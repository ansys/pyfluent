//
// Copyright 1987-2022 ANSYS, Inc. All Rights Reserved.
//

syntax = "proto3";

package grpcRemoting;

import "common.proto";

service FieldData {
  /* Get fields e.g. scalar, vector, surfaces etc in a single request.*/
  rpc GetFields(GetFieldsRequest) returns (stream GetFieldsResponse);

  /* Get scalar field range.*/
  rpc GetRange(GetRangeRequest) returns (GetRangeResponse) {}

  /* Get surfaces info.*/
  rpc GetSurfacesInfo(GetSurfacesInfoRequest) returns (GetSurfacesInfoResponse) {}

  /* Get vector fields info.*/
  rpc GetVectorFieldsInfo(GetVectorFieldsInfoRequest) returns (GetVectorFieldsInfoResponse) {}

  /* Get scalar fields info.*/
  rpc GetFieldsInfo(GetFieldsInfoRequest) returns (GetFieldsInfoResponse) {}

  /* Get surfaces data.*/
  rpc GetSurfaces(GetSurfacesRequest) returns (stream GetSurfacesResponse) {}

  /* Get scalar field data.*/
  rpc GetScalarField(GetScalarFieldRequest) returns (stream GetScalarFieldResponse) {}

  /* Get vector field data.*/
  rpc GetVectorField(GetVectorFieldRequest) returns (stream GetVectorFieldResponse) {}

  /* Get pathlines field data.*/
  rpc GetPathlinesField(GetPathlinesFieldRequest) returns (stream GetPathlinesFieldResponse) {}

  /* Get particle tracks field data.*/
  rpc GetParticleTracksField(GetParticleTracksFieldRequest) returns (stream GetParticleTracksFieldResponse) {}

  /*Check if boundary values are on.*/
  rpc IsBoundaryValuesOn(IsBoundaryValuesOnRequest) returns (IsBoundaryValuesOnResponse) {}
}

message DoublePayload {
  repeated double payload = 1;
}

message FloatPayload {
  repeated float payload = 1;
}

message IntPayload {
  repeated sint32 payload = 1;
}

message LongPayload {
  repeated sint64 payload = 1;
}

/**
 * Field Type
 */
enum FieldType {
  INT_ARRAY = 0;     // Integer array.
  LONG_ARRAY = 1;    // Long array.
  FLOAT_ARRAY = 2;   // Float array.
  DOUBLE_ARRAY = 3;  // Double array.
}

/**
 * Information about payload
 */
message PayloadInfo {
  uint64 surfaceId = 1;     // Surface id corresponding to field data.
  string fieldName = 2;     // Field name e.g. vertices, faces, temperature, vector etc.
  FieldType fieldType = 3;  // Field type.
  uint64 fieldSize = 4;     // Field size. For bytes it will be number of bytes otherwise array size.
}

/**
 * GetFieldsResponse can be either bytePayload or one of double/float/long/int payload.
 * Whether data is sent as bytes or as arrays of double/float/long/int depends upon value
 * of provideBytesStream in GetFieldsRequest. During streaming first payloadInfo is
 * streamed and then corresponding data is streamed.
 */
message GetFieldsResponse {
  oneof chunk {
    bytes bytePayload = 1;            // Bytes payload.
    DoublePayload doublePayload = 2;  // Double payload.
    FloatPayload floatPayload = 3;    // Float payload.
    LongPayload longPayload = 4;      // Long payload.
    IntPayload intPayload = 5;        // Int payload.
    PayloadInfo payloadInfo = 6;      // Payload info.
  }
}

/**
 * Request for surface data.
 * Surface data consists of information about vertices and faces.
 */
message SurfaceRequest {
  uint64 surfaceId = 1;           // Surface id.
  bool oversetMesh = 2;           // Provide overset mesh.
  bool provideVertices = 3;       // Provide vectices.
  bool provideFaces = 4;          // Provide face to vertex connectivity.
  bool provideFacesCentroid = 5;  // Provide face centroids.
  bool provideFacesNormal = 6;    // Provide face normals.
}

enum DataLocation {
  Nodes = 0;
  Elements = 1;
}

/**
 * Request for scalar field data
 */
message ScalarFieldRequest {
  uint64 surfaceId = 1;            // Surface id for scalar field.
  string scalarFieldName = 2;      // Scalar field name.
  DataLocation dataLocation = 3;   // Scalar Field location (Nodes/Elements).
  bool provideBoundaryValues = 4;  // Provide boundary values.
}

/**
 * Request for vector field data.
 */
message VectorFieldRequest {
  uint64 surfaceId = 1;        // Surface id for vector field.
  string vectorFieldName = 2;  // Vector field name.
}

/**
 * Request for fields.
 * - Default chunk size is 256kb. Minimum chunk size is 8b and Maximum is 4Mb.
 * - If true chunks of bytes will be streamed. Otherwise chunks of int/long/float or double array will be streamed.
 */
message GetFieldsRequest {
  uint32 chunkSize = 1;                                // Chunk size.
  bool provideBytesStream = 2;                         // Bytes are streamed if true
  repeated SurfaceRequest surfaceRequest = 3;          // Surface request.
  repeated ScalarFieldRequest scalarFieldRequest = 4;  // Scalar field request.
  repeated VectorFieldRequest vectorFieldRequest = 5;  // Vector field request.
}

enum DataStampingType {
  IterationIndex = 0;
  TimeStepIndex = 1;
  FlowTime = 2;
  SolidTime = 3;
  CaseID = 4;
  MeshID = 5;
  DataID = 6;
}

message DataStamping {
  DataStampingType datastampingtype = 1;
  oneof as {
    double doublevalue = 2;
    sint64 intvalue = 3;
  }
}

message UnitInfo {
  string name = 1;
  string unit = 2;
  double factor = 3;
  double offset = 4;
  string label = 5;
}

message DataStampingInfo {
  repeated DataStamping datastamping = 1;
}

message SurfaceId {
  sint64 id = 1;
}

message GetSurfacesRequest {
  repeated SurfaceId surfaceid = 1;
  bool oversetMesh = 2;
  DataStampingInfo datastampinginfo = 3;
  repeated SurfaceId availablesurfaces = 4;
}

message SurfaceMetaData {
  DataStampingInfo datastampinginfo = 1;
  UnitInfo lengthunit = 2;
}

message Coordinate {
  double x = 1;
  double y = 2;
  double z = 3;
}

message Facet {
  repeated sint32 node = 1;
}

message SurfaceInfo {
  repeated SurfaceId surfaceId = 1;
  SurfaceId zoneId = 2;
  string surfaceName = 3;
  string zoneType = 4;
  string type = 5;
}

message SurfaceData {
  SurfaceId surfaceid = 1;
  repeated Coordinate point = 2;
  repeated Facet facet = 3;
  oneof as {
    Empty empty_state = 5;
    SurfaceMetaData surfacemetadata = 6;
  }
}

message GetSurfacesResponse {
  SurfaceData surfacedata = 1;
}

message GetRangeRequest {
  string fieldName = 1;
  repeated SurfaceId surfaceid = 2;
  bool nodeValue = 3;
}

message GetRangeResponse {
  double minimum = 1;
  double maximum = 2;
}

message FieldInfo {
  string displayName = 1;
  string solverName = 2;
  string section = 3;
  string domain = 4;
}

message GetFieldsInfoRequest {
}

message GetFieldsInfoResponse {
  repeated FieldInfo fieldInfo = 1;
}

message GetVectorFieldsInfoRequest {
}
message VectorFieldInfo {
  string displayName = 1;
  string xComponent = 2;
  string yComponent = 3;
  string zComponent = 4;
}

message GetVectorFieldsInfoResponse {
  repeated VectorFieldInfo vectorFieldInfo = 1;
}

message GetSurfacesInfoRequest {
}
message GetSurfacesInfoResponse {
  repeated SurfaceInfo surfaceInfo = 1;
}

message GetScalarFieldRequest {
  repeated SurfaceId surfaceid = 1;
  string scalarfield = 2;
  bool nodevalue = 3;
  bool boundaryvalues = 7;
  DataStampingInfo datastampinginfo = 4;
  repeated SurfaceId availablesurfaces = 5;
  repeated SurfaceId availablescalarfield = 6;
}

message GlobalRange {
  double globalmin = 1;
  double globalmax = 2;
}

message ScalarFieldMetaData {
  DataStampingInfo datastampinginfo = 1;
  UnitInfo lengthunit = 2;
  GlobalRange scalarFieldrange = 3;
  UnitInfo scalarfieldunit = 4;
}

message VectorComponents {
  double x = 1;
  double y = 2;
  double z = 3;
}

message ScalarField {
  repeated double data = 1;
}

message VectorField {
  repeated VectorComponents vectorComponents = 1;
}

message ActiveField {
  repeated sint64 active = 1;
}

message ScalarFieldData {
  SurfaceId surfaceid = 1;
  SurfaceData surfacedata = 2;
  ScalarField scalarfield = 3;
  ActiveField activefield = 4;

  oneof as {
    Empty empty_state = 5;
    ScalarFieldMetaData scalarfieldmetadata = 6;
  }
}

message GetScalarFieldResponse {
  ScalarFieldData scalarfielddata = 1;
}

message GetVectorFieldRequest {
  repeated SurfaceId surfaceid = 1;
  string scalarfield = 2;
  bool nodevalue = 3;
  string vectorfield = 4;

  DataStampingInfo datastampinginfo = 6;
  repeated SurfaceId availablesurfaces = 7;
  repeated SurfaceId availablescalarfield = 8;
  repeated SurfaceId availablevectorfield = 9;
}

message VectorFieldMetaData {
  DataStampingInfo datastampinginfo = 1;
  UnitInfo lengthunit = 2;
  GlobalRange scalarFieldrange = 3;
  UnitInfo scalarfieldunit = 4;
}

message VectorScale {
  double data = 1;
}

message VectorFieldData {
  SurfaceId surfaceid = 1;
  SurfaceData surfacedata = 2;
  ScalarField scalarfield = 3;
  ActiveField activefield = 4;
  oneof as {
    Empty empty_state = 5;
    VectorFieldMetaData vectorfieldmetadata = 6;
  }
  VectorField base = 7;
  VectorField vector = 8;
  VectorField normal = 9;
  VectorScale vectorscale = 10;
}

message GetVectorFieldResponse {
  VectorFieldData vectorfielddata = 1;
}

message GetPathlinesFieldRequest {
  repeated SurfaceId releaseFrom = 1;
  string field1 = 2;
  string field2 = 3;
  bool nodeValue = 4;
  sint32 steps = 5;
  double stepSize = 6;
  sint32 skip = 8;
  bool reverse = 9;
  bool accuracyControlOn = 10;
  double tolerance = 11;
  sint32 coarsen = 12;
  string zone = 13 [deprecated = true];
  string velocityDomain = 14;
  DataStampingInfo dataStampingInfo = 15;
  repeated string zones = 16;
}

message PathlineMetaData {
  DataStampingInfo dataStampingInfo = 1;
  UnitInfo lengthUnit = 2;
  GlobalRange scalarFieldRange = 3;
  UnitInfo scalarFieldUnit = 4;
  GlobalRange twistRange = 5;
  UnitInfo timeUnit = 6;
}

message PathlineFieldData {
  sint64 particleId = 1;
  repeated double particlePositions = 2;
  repeated double particleTime = 3;
  repeated double field1 = 4;
  repeated double field2 = 5;
  sint64 beginStep = 6;
  sint64 endStep = 7;
}

message PathlineData {
  oneof as {
    PathlineFieldData pathlineFieldData = 1;
    PathlineMetaData pathlineMetaData = 2;
  }
}

message GetPathlinesFieldResponse {
  PathlineData pathlineData = 1;
}

message ParticleTracksFilter {
  string field = 1;
  GlobalRange filterRange = 2;
  bool insideRange = 3;
}

message GetParticleTracksFieldRequest {
  repeated string releaseFrom = 1;
  string field1 = 2;     // to color
  string field2 = 3;     // either spehere[only particle variable] or ribbon[non particle]
  string field3 = 4;     // vector
  string vectorsOf = 5;  // vector
  bool nodeValue = 6;
  sint32 skip = 7;
  sint32 singleStreamId = 8;  // if < 0 all stream will tracked. Otherwise single stream will be tracked
  sint32 coarsen = 9;
  bool freeStreamParticles = 10;
  bool wallFilmParticles = 11;
  bool pdfParticles = 12;
  ParticleTracksFilter filter = 13;
  DataStampingInfo dataStampingInfo = 14;
}

message ParticleTrackMetaData {
  DataStampingInfo dataStampingInfo = 1;
  UnitInfo lengthUnit = 2;
  GlobalRange scalarFieldRange = 3;
  UnitInfo scalarFieldUnit = 4;
  GlobalRange twistRange = 5;
  UnitInfo timeUnit = 6;
}

message ParticleTrackFieldData {
  sint64 particleId = 1;
  ScalarField particlePosition = 2;
  ScalarField particleTime = 3;
  ScalarField field1 = 4;
  ScalarField field2 = 5;
  ScalarField field3 = 6;
  VectorField particleVelocity = 7;
  double particleStartTime = 8;
  double particleEndTime = 9;
}

message ParticleTrackData {
  oneof as {
    ParticleTrackFieldData particleTrackFieldData = 1;
    ParticleTrackMetaData particleTrackMetaData = 2;
  }
}

message GetParticleTracksFieldResponse {
  ParticleTrackData particleTrackData = 1;
}

message IsBoundaryValuesOnRequest {
}

message IsBoundaryValuesOnResponse {
  bool isboundaryvalueson = 1;
}