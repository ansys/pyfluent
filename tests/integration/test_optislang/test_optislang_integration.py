import os
from pathlib import Path
import shutil

import pytest
from util.meshing_workflow import mixing_elbow_geometry  # noqa: F401

import ansys.fluent.core as pyfluent


@pytest.mark.optislang
@pytest.mark.integration
def test_simple_solve(load_mixing_elbow_param_case_dat):

    """
    Use case 1: This optiSLang integration test performs these steps

    - Reads a case file with and without data file
    - Gets input and output parameters and creates dictionary
    - Sets a variation on input parameters
    - Solve
    - Reread data

    This test queries the following using PyTest:
    - Session health
    - Input parameters
    - Output parameters
    """

    # Step 1: Setup logging
    pyfluent.set_log_level("ERROR")
    pyfluent.enable_logging_to_stdout()

    # Step 2: Launch fluent session and read case file with and without data file
    solver_session = load_mixing_elbow_param_case_dat
    assert solver_session.health_check_service.is_serving
    case_path = str(Path(pyfluent.EXAMPLES_PATH) / "elbow_param.cas.h5")
    solver_session.tui.file.read_case_data(case_path)

    # Step 3: Get input and output parameters and create a dictionary
    from ansys.fluent.core.filereader.casereader import CaseReader 
    reader = CaseReader(case_filepath=case_path) 

    input_parameters = {}
    for p in reader.input_parameters():
       input_parameters[p.name] = (p.value, p.number, p.units)
    output_parameters = {}
    for o in reader.output_parameters():
        output_parameters[o.name] = (0, o.units)
    solver_session.tui.file.read_case(case_path)

    # Step 4: Set a variation on these input parameters
    # variations/designs are generated by optiSLang based on
    # algorithm selected
    from ansys.fluent.parametric.parameters import InputParameters 
    inputs_table = InputParameters(solver_session)
    if 'inlet2_temp' in input_parameters.keys(): 
        inputs_table['inlet2_temp'] = 500 
    solver_session.tui.file.write_case("design_elbow_param.cas.h5")

    # Step 5: Solve
    solver_session.tui.solve.initialize.initialize_flow()

    # check if solution is steady or transient
    workflow = solver_session.scheme_eval.string_eval("(rp-unsteady?)")

    # iterate workflow
    if workflow == "#t":
        solver_session.tui.solve.dual_time_iterate()
    else:
        solver_session.tui.solve.iterate()

    convergence = solver_session.scheme_eval.string_eval(
        "(rpgetvar 'solution/converged?)"
    )

    # solution output (test conditional statement)
    if convergence == "#f":  # -> let user know
        print("Failed to converge")
    else:
        print("Solution is converged")

    assert convergence == "#t", "Solution failed to converge"

    # Step 6: Read the data again from the case and data file
    solver_session.tui.file.read_case_data(case_path)
    from ansys.fluent.parametric.parameters import InputParameters, OutputParameters
    inputs_table = InputParameters(solver_session)
    outputs_table = OutputParameters(solver_session) 

    output_units = outputs_table["outlet_temp-op"].split(' ')[1].strip('[]')
    assert input_parameters["inlet2_temp"][0] == inputs_table["inlet2_temp"]
    assert output_parameters["outlet_temp-op"][1] == output_units
    solver_session.exit()


@pytest.mark.optislang
@pytest.mark.integration
def test_generate_read_mesh(with_launching_container, mixing_elbow_geometry):

    """
    Use case 2: This optiSLang integration test performs these steps

    - Launch Fluent in Meshing Mode
    - Generate mesh with default workflow settings
    - Read created mesh file
    - Switch to solution and write case file

    This test queries the following using PyTest:
    - Session health
    """

    # Step 1: Setup logging
    pyfluent.set_log_level("ERROR")
    pyfluent.enable_logging_to_stdout()

    # Step 2: Launch fluent session in meshing mode
    meshing = pyfluent.launch_fluent(
        mode="meshing", precision="double", processor_count=2
    )
    assert meshing.health_check_service.is_serving
    temporary_resource_path = os.path.join(
        pyfluent.EXAMPLES_PATH, "test_generate_read_mesh_resources"
    )
    if os.path.exists(temporary_resource_path):
        shutil.rmtree(temporary_resource_path, ignore_errors=True)
    if not os.path.exists(temporary_resource_path):
        os.mkdir(temporary_resource_path)

    # TODO: Remove the if condition after a stable version of 23.1 is available and update the commands as required.
    if float(meshing.get_fluent_version()[:-2]) < 23.0:
        # Step 3 Generate mesh from geometry with default workflow settings
        meshing.workflow.InitializeWorkflow(WorkflowType="Watertight Geometry")
        meshing.workflow.TaskObject["Import Geometry"].Arguments = dict(
            FileName=mixing_elbow_geometry
        )
        meshing.workflow.TaskObject["Import Geometry"].Execute()
        meshing.workflow.TaskObject["Generate the Volume Mesh"].Execute()
        meshing.tui.mesh.check_mesh()
        gz_path = str(Path(temporary_resource_path) / "default_mesh.msh.gz")
        h5_path = str(Path(temporary_resource_path) / "default_mesh.msh.h5")
        meshing.tui.file.write_mesh(gz_path)
        meshing.tui.file.write_mesh(h5_path)
        assert (Path(temporary_resource_path) / "default_mesh.msh.gz").exists() == True
        assert (Path(temporary_resource_path) / "default_mesh.msh.h5").exists() == True

        # Step 4: use created mesh file - .msh.gz/.msh.h5
        meshing.tui.file.read_mesh(gz_path, "ok")
        meshing.tui.file.read_mesh(h5_path, "ok")

        # Step 5: Switch to solution and Write case file
        solver = meshing.switch_to_solver()
        solver.tui.solve.initialize.hyb_initialization()
        gz_path = str(Path(temporary_resource_path) / "default_case.cas.gz")
        h5_path = str(Path(temporary_resource_path) / "default_case.cas.h5")
        solver.tui.file.write_case(gz_path)
        solver.tui.file.write_case(h5_path)
        assert (Path(temporary_resource_path) / "default_case.cas.gz").exists() == True
        assert (Path(temporary_resource_path) / "default_case.cas.h5").exists() == True
        solver.exit()
        shutil.rmtree(temporary_resource_path, ignore_errors=True)
