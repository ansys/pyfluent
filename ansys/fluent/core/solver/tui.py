"""Fluent Solver TUI Commands"""
#
# This is an auto-generated file.  DO NOT EDIT!
#
# pylint: disable=line-too-long

from ansys.fluent.core.meta import PyMenuMeta, PyNamedObjectMeta
from ansys.fluent.core.services.datamodel_tui import PyMenu


class main_menu(metaclass=PyMenuMeta):
    """
    Fluent solver main menu.
    """
    def __init__(self, path, service):
        self.path = path
        self.service = service
        self.adjoint = self.__class__.adjoint(path + [("adjoint", None)], service)
        self.display = self.__class__.display(path + [("display", None)], service)
        self.define = self.__class__.define(path + [("define", None)], service)
        self.file = self.__class__.file(path + [("file", None)], service)
        self.icing = self.__class__.icing(path + [("icing", None)], service)
        self.mesh = self.__class__.mesh(path + [("mesh", None)], service)
        self.parameters__and__customization = self.__class__.parameters__and__customization(path + [("parameters__and__customization", None)], service)
        self.parallel = self.__class__.parallel(path + [("parallel", None)], service)
        self.plot = self.__class__.plot(path + [("plot", None)], service)
        self.preferences = self.__class__.preferences(path + [("preferences", None)], service)
        self.report = self.__class__.report(path + [("report", None)], service)
        self.results = self.__class__.results(path + [("results", None)], service)
        self.solution = self.__class__.solution(path + [("solution", None)], service)
        self.solve = self.__class__.solve(path + [("solve", None)], service)
        self.setup = self.__class__.setup(path + [("setup", None)], service)
        self.surface = self.__class__.surface(path + [("surface", None)], service)
        self.simulation_reports = self.__class__.simulation_reports(path + [("simulation_reports", None)], service)
        self.server = self.__class__.server(path + [("server", None)], service)
        self.turbo_post = self.__class__.turbo_post(path + [("turbo_post", None)], service)
        self.views = self.__class__.views(path + [("views", None)], service)
        self.parametric_study = self.__class__.parametric_study(path + [("parametric_study", None)], service)
        self.turbo_workflow = self.__class__.turbo_workflow(path + [("turbo_workflow", None)], service)
    def close_fluent(self, *args, **kwargs):
        """
        Exit program.
        """
        return PyMenu(self.service, "/close_fluent").execute(*args, **kwargs)
    def exit(self, *args, **kwargs):
        """
        Exit program.
        """
        return PyMenu(self.service, "/exit").execute(*args, **kwargs)
    def switch_to_meshing_mode(self, *args, **kwargs):
        """
        Switch to meshing mode.
        """
        return PyMenu(self.service, "/switch_to_meshing_mode").execute(*args, **kwargs)
    def print_license_usage(self, *args, **kwargs):
        """
        Print license usage information.
        """
        return PyMenu(self.service, "/print_license_usage").execute(*args, **kwargs)

    class adjoint(metaclass=PyMenuMeta):
        """
        Adjoint.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
        def observable(self, *args, **kwargs):
            """
            Observable menu.
            """
            return PyMenu(self.service, "/adjoint/observable").execute(*args, **kwargs)
        def methods(self, *args, **kwargs):
            """
            Methods menu.
            """
            return PyMenu(self.service, "/adjoint/methods").execute(*args, **kwargs)
        def controls(self, *args, **kwargs):
            """
            Controls menu.
            """
            return PyMenu(self.service, "/adjoint/controls").execute(*args, **kwargs)
        def monitors(self, *args, **kwargs):
            """
            Monitors menu.
            """
            return PyMenu(self.service, "/adjoint/monitors").execute(*args, **kwargs)
        def expert(self, *args, **kwargs):
            """
            Expert menu.
            """
            return PyMenu(self.service, "/adjoint/expert").execute(*args, **kwargs)
        def run(self, *args, **kwargs):
            """
            Run menu.
            """
            return PyMenu(self.service, "/adjoint/run").execute(*args, **kwargs)
        def reporting(self, *args, **kwargs):
            """
            Reporting.
            """
            return PyMenu(self.service, "/adjoint/reporting").execute(*args, **kwargs)
        def postprocess_options(self, *args, **kwargs):
            """
            Postprocess options.
            """
            return PyMenu(self.service, "/adjoint/postprocess_options").execute(*args, **kwargs)
        def morphing(self, *args, **kwargs):
            """
            Morphing menu.
            """
            return PyMenu(self.service, "/adjoint/morphing").execute(*args, **kwargs)
        def multi_objective(self, *args, **kwargs):
            """
            Multi-Objective menu.
            """
            return PyMenu(self.service, "/adjoint/multi_objective").execute(*args, **kwargs)
        def design_tool(self, *args, **kwargs):
            """
            Design tool menu.
            """
            return PyMenu(self.service, "/adjoint/design_tool").execute(*args, **kwargs)
        def optimizer(self, *args, **kwargs):
            """
            Optimizer menu.
            """
            return PyMenu(self.service, "/adjoint/optimizer").execute(*args, **kwargs)
        def utilities(self, *args, **kwargs):
            """
            Utilities menu.
            """
            return PyMenu(self.service, "/adjoint/utilities").execute(*args, **kwargs)

    class display(metaclass=PyMenuMeta):
        """
        Enter the display menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
            self.embedded_windows = self.__class__.embedded_windows(path + [("embedded_windows", None)], service)
            self.objects = self.__class__.objects(path + [("objects", None)], service)
            self.flamelet_data = self.__class__.flamelet_data(path + [("flamelet_data", None)], service)
            self.particle_tracks = self.__class__.particle_tracks(path + [("particle_tracks", None)], service)
            self.path_lines = self.__class__.path_lines(path + [("path_lines", None)], service)
            self.pdf_data = self.__class__.pdf_data(path + [("pdf_data", None)], service)
            self.set = self.__class__.set(path + [("set", None)], service)
            self.surface = self.__class__.surface(path + [("surface", None)], service)
            self.views = self.__class__.views(path + [("views", None)], service)
            self.display_states = self.__class__.display_states(path + [("display_states", None)], service)
            self.view_sync = self.__class__.view_sync(path + [("view_sync", None)], service)
            self.update_scene = self.__class__.update_scene(path + [("update_scene", None)], service)
            self.inverse_dft = self.__class__.inverse_dft(path + [("inverse_dft", None)], service)
        def add_custom_vector(self, *args, **kwargs):
            """
            Add new custom vector definition.
            """
            return PyMenu(self.service, "/display/add_custom_vector").execute(*args, **kwargs)
        def annotate(self, *args, **kwargs):
            """
            Add a text annotation string to the active graphics window.
            """
            return PyMenu(self.service, "/display/annotate").execute(*args, **kwargs)
        def clear_annotations(self, *args, **kwargs):
            """
            Delete all annotation text.
            """
            return PyMenu(self.service, "/display/clear_annotations").execute(*args, **kwargs)
        def close_window(self, *args, **kwargs):
            """
            Close a user graphics window.
            """
            return PyMenu(self.service, "/display/close_window").execute(*args, **kwargs)
        def close_window_by_name(self, *args, **kwargs):
            """
            Close a reserved graphics window by its name.
            """
            return PyMenu(self.service, "/display/close_window_by_name").execute(*args, **kwargs)
        def contour(self, *args, **kwargs):
            """
            Display contours of a flow variable.
            """
            return PyMenu(self.service, "/display/contour").execute(*args, **kwargs)
        def display_custom_vector(self, *args, **kwargs):
            """
            Display custom vector.
            """
            return PyMenu(self.service, "/display/display_custom_vector").execute(*args, **kwargs)
        def mesh(self, *args, **kwargs):
            """
            Display the mesh.
            """
            return PyMenu(self.service, "/display/mesh").execute(*args, **kwargs)
        def mesh_outline(self, *args, **kwargs):
            """
            Display the mesh boundaries.
            """
            return PyMenu(self.service, "/display/mesh_outline").execute(*args, **kwargs)
        def hsf_file(self, *args, **kwargs):
            """
            Display hoops stream file data to active graphics window.
            """
            return PyMenu(self.service, "/display/hsf_file").execute(*args, **kwargs)
        def mesh_partition_boundary(self, *args, **kwargs):
            """
            Display mesh partition boundaries.
            """
            return PyMenu(self.service, "/display/mesh_partition_boundary").execute(*args, **kwargs)
        def save_picture(self, *args, **kwargs):
            """
            Generate a "hardcopy" of the active window.
            """
            return PyMenu(self.service, "/display/save_picture").execute(*args, **kwargs)
        def multigrid_coarsening(self, *args, **kwargs):
            """
            Display a coarse mesh level from the last multigrid coarsening.
            """
            return PyMenu(self.service, "/display/multigrid_coarsening").execute(*args, **kwargs)
        def open_window(self, *args, **kwargs):
            """
            Open a user graphics window.
            """
            return PyMenu(self.service, "/display/open_window").execute(*args, **kwargs)
        def graphics_window_layout(self, *args, **kwargs):
            """
            Arrange the graphics window layout.
            """
            return PyMenu(self.service, "/display/graphics_window_layout").execute(*args, **kwargs)
        def reacting_channel_curves(self, *args, **kwargs):
            """
            Plot/Report the reacting channel variables.
            """
            return PyMenu(self.service, "/display/reacting_channel_curves").execute(*args, **kwargs)
        def profile(self, *args, **kwargs):
            """
            Display profiles of a flow variable.
            """
            return PyMenu(self.service, "/display/profile").execute(*args, **kwargs)
        def re_render(self, *args, **kwargs):
            """
            Re-render the last contour, profile, or velocity vector plot
            with updated surfaces, meshes, lights, colormap, rendering options, etc.,
            without recalculating the contour data.
            """
            return PyMenu(self.service, "/display/re_render").execute(*args, **kwargs)
        def re_scale(self, *args, **kwargs):
            """
            Re-render the last contour, profile, or velocity vector plot
            with updated scale, surfaces, meshes, lights, colormap, rendering options, etc.,
            without recalculating the field data.
            """
            return PyMenu(self.service, "/display/re_scale").execute(*args, **kwargs)
        def set_window(self, *args, **kwargs):
            """
            Set a user graphics window to be the active window.
            """
            return PyMenu(self.service, "/display/set_window").execute(*args, **kwargs)
        def set_window_by_name(self, *args, **kwargs):
            """
            Set a reserved graphics window to be the active window by its name.
            """
            return PyMenu(self.service, "/display/set_window_by_name").execute(*args, **kwargs)
        def surface_cells(self, *args, **kwargs):
            """
            Draw the cells on the specified surfaces.
            """
            return PyMenu(self.service, "/display/surface_cells").execute(*args, **kwargs)
        def surface_mesh(self, *args, **kwargs):
            """
            Draw the mesh defined by the specified surfaces.
            """
            return PyMenu(self.service, "/display/surface_mesh").execute(*args, **kwargs)
        def vector(self, *args, **kwargs):
            """
            Display space vectors.
            """
            return PyMenu(self.service, "/display/vector").execute(*args, **kwargs)
        def velocity_vector(self, *args, **kwargs):
            """
            Display velocity vectors.
            """
            return PyMenu(self.service, "/display/velocity_vector").execute(*args, **kwargs)
        def zone_mesh(self, *args, **kwargs):
            """
            Draw the mesh defined by specified face zones.
            """
            return PyMenu(self.service, "/display/zone_mesh").execute(*args, **kwargs)
        def set_list_tree_separator(self, *args, **kwargs):
            """
            Set the separator character for list tree.
            """
            return PyMenu(self.service, "/display/set_list_tree_separator").execute(*args, **kwargs)
        def update_layout(self, *args, **kwargs):
            """
            Update the fluent layout.
            """
            return PyMenu(self.service, "/display/update_layout").execute(*args, **kwargs)
        def switch_to_post_processing_volume(self, *args, **kwargs):
            """
            Switch to post processing volume.
            """
            return PyMenu(self.service, "/display/switch_to_post_processing_volume").execute(*args, **kwargs)
        def switch_to_primary_volume(self, *args, **kwargs):
            """
            Switch to primary volume.
            """
            return PyMenu(self.service, "/display/switch_to_primary_volume").execute(*args, **kwargs)

        class embedded_windows(metaclass=PyMenuMeta):
            """
            Enter to embed, close, move-out embedded windows.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def close(self, *args, **kwargs):
                """
                Close an embedded window.
                """
                return PyMenu(self.service, "/display/embedded_windows/close").execute(*args, **kwargs)
            def close_all(self, *args, **kwargs):
                """
                Close all embedded windows for given parent window.
                """
                return PyMenu(self.service, "/display/embedded_windows/close_all").execute(*args, **kwargs)
            def embed_in(self, *args, **kwargs):
                """
                Embed Window into another window.
                """
                return PyMenu(self.service, "/display/embedded_windows/embed_in").execute(*args, **kwargs)
            def move_out(self, *args, **kwargs):
                """
                Move out an embedded window.
                """
                return PyMenu(self.service, "/display/embedded_windows/move_out").execute(*args, **kwargs)
            def move_out_all(self, *args, **kwargs):
                """
                Move out all embedded windows for given parent window.
                """
                return PyMenu(self.service, "/display/embedded_windows/move_out_all").execute(*args, **kwargs)

        class objects(metaclass=PyMenuMeta):
            """
            Enter to add, edit, delete or display graphics objects.
            """
            is_extended_tui = True
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.xy_plot = self.__class__.xy_plot(path + [("xy_plot", None)], None, service)
                self.mesh = self.__class__.mesh(path + [("mesh", None)], None, service)
                self.contour = self.__class__.contour(path + [("contour", None)], None, service)
                self.vector = self.__class__.vector(path + [("vector", None)], None, service)
                self.pathlines = self.__class__.pathlines(path + [("pathlines", None)], None, service)
                self.particle_tracks = self.__class__.particle_tracks(path + [("particle_tracks", None)], None, service)
                self.scene = self.__class__.scene(path + [("scene", None)], None, service)
            def create(self, *args, **kwargs):
                """
                Create new graphics object.
                """
                return PyMenu(self.service, "/display/objects/create").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit graphics object.
                """
                return PyMenu(self.service, "/display/objects/edit").execute(*args, **kwargs)
            def copy(self, *args, **kwargs):
                """
                Copy graphics object.
                """
                return PyMenu(self.service, "/display/objects/copy").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete graphics object.
                """
                return PyMenu(self.service, "/display/objects/delete").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                Display graphics object.
                """
                return PyMenu(self.service, "/display/objects/display").execute(*args, **kwargs)
            def add_to_graphics(self, *args, **kwargs):
                """
                Add graphics object to existing graphics.
                """
                return PyMenu(self.service, "/display/objects/add_to_graphics").execute(*args, **kwargs)

            class xy_plot(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.name = self.__class__.name(path + [("name", None)], service)
                    self.uid = self.__class__.uid(path + [("uid", None)], service)
                    self.options = self.__class__.options(path + [("options", None)], service)
                    self.plot_direction = self.__class__.plot_direction(path + [("plot_direction", None)], service)
                    self.x_axis_function = self.__class__.x_axis_function(path + [("x_axis_function", None)], service)
                    self.y_axis_function = self.__class__.y_axis_function(path + [("y_axis_function", None)], service)
                    self.surfaces_list = self.__class__.surfaces_list(path + [("surfaces_list", None)], service)
                    self.physics = self.__class__.physics(path + [("physics", None)], service)
                    self.geometry = self.__class__.geometry(path + [("geometry", None)], service)
                    self.surfaces = self.__class__.surfaces(path + [("surfaces", None)], service)

                class name(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uid(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class options(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.node_values = self.__class__.node_values(path + [("node_values", None)], service)
                        self.position_on_x_axis = self.__class__.position_on_x_axis(path + [("position_on_x_axis", None)], service)
                        self.position_on_y_axis = self.__class__.position_on_y_axis(path + [("position_on_y_axis", None)], service)

                    class node_values(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class position_on_x_axis(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class position_on_y_axis(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class plot_direction(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.direction_vector = self.__class__.direction_vector(path + [("direction_vector", None)], service)
                        self.curve_length = self.__class__.curve_length(path + [("curve_length", None)], service)

                    class direction_vector(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.x_component = self.__class__.x_component(path + [("x_component", None)], service)
                            self.y_component = self.__class__.y_component(path + [("y_component", None)], service)
                            self.z_component = self.__class__.z_component(path + [("z_component", None)], service)

                        class x_component(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class y_component(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class z_component(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class curve_length(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.default = self.__class__.default(path + [("default", None)], service)
                            self.reverse = self.__class__.reverse(path + [("reverse", None)], service)

                        class default(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class reverse(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                class x_axis_function(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class y_axis_function(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class surfaces_list(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class physics(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geometry(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class surfaces(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

            class mesh(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.name = self.__class__.name(path + [("name", None)], service)
                    self.options = self.__class__.options(path + [("options", None)], service)
                    self.edge_type = self.__class__.edge_type(path + [("edge_type", None)], service)
                    self.shrink_factor = self.__class__.shrink_factor(path + [("shrink_factor", None)], service)
                    self.surfaces_list = self.__class__.surfaces_list(path + [("surfaces_list", None)], service)
                    self.coloring = self.__class__.coloring(path + [("coloring", None)], service)
                    self.display_state_name = self.__class__.display_state_name(path + [("display_state_name", None)], service)
                    self.physics = self.__class__.physics(path + [("physics", None)], service)
                    self.geometry = self.__class__.geometry(path + [("geometry", None)], service)
                    self.surfaces = self.__class__.surfaces(path + [("surfaces", None)], service)

                class name(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class options(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.nodes = self.__class__.nodes(path + [("nodes", None)], service)
                        self.edges = self.__class__.edges(path + [("edges", None)], service)
                        self.faces = self.__class__.faces(path + [("faces", None)], service)
                        self.partitions = self.__class__.partitions(path + [("partitions", None)], service)
                        self.overset = self.__class__.overset(path + [("overset", None)], service)
                        self.gap = self.__class__.gap(path + [("gap", None)], service)

                    class nodes(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class edges(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class faces(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class partitions(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class overset(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class gap(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class edge_type(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.all = self.__class__.all(path + [("all", None)], service)
                        self.feature = self.__class__.feature(path + [("feature", None)], service)
                        self.outline = self.__class__.outline(path + [("outline", None)], service)

                    class all(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class feature(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.feature_angle = self.__class__.feature_angle(path + [("feature_angle", None)], service)

                        class feature_angle(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class outline(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class shrink_factor(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class surfaces_list(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class coloring(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.automatic = self.__class__.automatic(path + [("automatic", None)], service)
                        self.manual = self.__class__.manual(path + [("manual", None)], service)

                    class automatic(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.type = self.__class__.type(path + [("type", None)], service)
                            self.id = self.__class__.id(path + [("id", None)], service)
                            self.normal = self.__class__.normal(path + [("normal", None)], service)
                            self.partition = self.__class__.partition(path + [("partition", None)], service)

                        class type(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class id(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class normal(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class partition(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class manual(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.faces = self.__class__.faces(path + [("faces", None)], service)
                            self.edges = self.__class__.edges(path + [("edges", None)], service)
                            self.nodes = self.__class__.nodes(path + [("nodes", None)], service)
                            self.material_color = self.__class__.material_color(path + [("material_color", None)], service)

                        class faces(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class edges(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class nodes(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class material_color(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                class display_state_name(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class physics(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geometry(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class surfaces(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

            class contour(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.name = self.__class__.name(path + [("name", None)], service)
                    self.field = self.__class__.field(path + [("field", None)], service)
                    self.filled = self.__class__.filled(path + [("filled", None)], service)
                    self.boundary_values = self.__class__.boundary_values(path + [("boundary_values", None)], service)
                    self.contour_lines = self.__class__.contour_lines(path + [("contour_lines", None)], service)
                    self.node_values = self.__class__.node_values(path + [("node_values", None)], service)
                    self.surfaces_list = self.__class__.surfaces_list(path + [("surfaces_list", None)], service)
                    self.range_option = self.__class__.range_option(path + [("range_option", None)], service)
                    self.coloring = self.__class__.coloring(path + [("coloring", None)], service)
                    self.color_map = self.__class__.color_map(path + [("color_map", None)], service)
                    self.draw_mesh = self.__class__.draw_mesh(path + [("draw_mesh", None)], service)
                    self.mesh_object = self.__class__.mesh_object(path + [("mesh_object", None)], service)
                    self.display_state_name = self.__class__.display_state_name(path + [("display_state_name", None)], service)
                    self.physics = self.__class__.physics(path + [("physics", None)], service)
                    self.geometry = self.__class__.geometry(path + [("geometry", None)], service)
                    self.surfaces = self.__class__.surfaces(path + [("surfaces", None)], service)

                class name(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class field(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class filled(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class boundary_values(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class contour_lines(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class node_values(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class surfaces_list(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class range_option(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.auto_range_on = self.__class__.auto_range_on(path + [("auto_range_on", None)], service)
                        self.auto_range_off = self.__class__.auto_range_off(path + [("auto_range_off", None)], service)

                    class auto_range_on(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.global_range = self.__class__.global_range(path + [("global_range", None)], service)

                        class global_range(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class auto_range_off(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.clip_to_range = self.__class__.clip_to_range(path + [("clip_to_range", None)], service)
                            self.minimum = self.__class__.minimum(path + [("minimum", None)], service)
                            self.maximum = self.__class__.maximum(path + [("maximum", None)], service)

                        class clip_to_range(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class minimum(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class maximum(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                class coloring(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.smooth = self.__class__.smooth(path + [("smooth", None)], service)
                        self.banded = self.__class__.banded(path + [("banded", None)], service)

                    class smooth(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class banded(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class color_map(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.visible = self.__class__.visible(path + [("visible", None)], service)
                        self.size = self.__class__.size(path + [("size", None)], service)
                        self.color = self.__class__.color(path + [("color", None)], service)
                        self.log_scale = self.__class__.log_scale(path + [("log_scale", None)], service)
                        self.format = self.__class__.format(path + [("format", None)], service)
                        self.user_skip = self.__class__.user_skip(path + [("user_skip", None)], service)
                        self.show_all = self.__class__.show_all(path + [("show_all", None)], service)
                        self.position = self.__class__.position(path + [("position", None)], service)
                        self.font_name = self.__class__.font_name(path + [("font_name", None)], service)
                        self.font_automatic = self.__class__.font_automatic(path + [("font_automatic", None)], service)
                        self.font_size = self.__class__.font_size(path + [("font_size", None)], service)
                        self.length = self.__class__.length(path + [("length", None)], service)
                        self.width = self.__class__.width(path + [("width", None)], service)

                    class visible(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class size(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class color(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class log_scale(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class format(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class user_skip(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class show_all(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class position(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class font_name(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class font_automatic(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class font_size(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class length(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class width(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class draw_mesh(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class mesh_object(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class display_state_name(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class physics(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geometry(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class surfaces(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

            class vector(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.name = self.__class__.name(path + [("name", None)], service)
                    self.field = self.__class__.field(path + [("field", None)], service)
                    self.vector_field = self.__class__.vector_field(path + [("vector_field", None)], service)
                    self.surfaces_list = self.__class__.surfaces_list(path + [("surfaces_list", None)], service)
                    self.scale = self.__class__.scale(path + [("scale", None)], service)
                    self.style = self.__class__.style(path + [("style", None)], service)
                    self.skip = self.__class__.skip(path + [("skip", None)], service)
                    self.vector_opt = self.__class__.vector_opt(path + [("vector_opt", None)], service)
                    self.range_option = self.__class__.range_option(path + [("range_option", None)], service)
                    self.color_map = self.__class__.color_map(path + [("color_map", None)], service)
                    self.draw_mesh = self.__class__.draw_mesh(path + [("draw_mesh", None)], service)
                    self.mesh_object = self.__class__.mesh_object(path + [("mesh_object", None)], service)
                    self.display_state_name = self.__class__.display_state_name(path + [("display_state_name", None)], service)
                    self.physics = self.__class__.physics(path + [("physics", None)], service)
                    self.geometry = self.__class__.geometry(path + [("geometry", None)], service)
                    self.surfaces = self.__class__.surfaces(path + [("surfaces", None)], service)

                class name(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class field(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vector_field(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class surfaces_list(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class scale(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.auto_scale = self.__class__.auto_scale(path + [("auto_scale", None)], service)
                        self.scale_f = self.__class__.scale_f(path + [("scale_f", None)], service)

                    class auto_scale(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class scale_f(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class style(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class skip(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vector_opt(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.in_plane = self.__class__.in_plane(path + [("in_plane", None)], service)
                        self.fixed_length = self.__class__.fixed_length(path + [("fixed_length", None)], service)
                        self.x_comp = self.__class__.x_comp(path + [("x_comp", None)], service)
                        self.y_comp = self.__class__.y_comp(path + [("y_comp", None)], service)
                        self.z_comp = self.__class__.z_comp(path + [("z_comp", None)], service)
                        self.scale_head = self.__class__.scale_head(path + [("scale_head", None)], service)
                        self.color = self.__class__.color(path + [("color", None)], service)

                    class in_plane(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class fixed_length(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class x_comp(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class y_comp(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class z_comp(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class scale_head(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class color(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class range_option(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.auto_range_on = self.__class__.auto_range_on(path + [("auto_range_on", None)], service)
                        self.auto_range_off = self.__class__.auto_range_off(path + [("auto_range_off", None)], service)

                    class auto_range_on(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.global_range = self.__class__.global_range(path + [("global_range", None)], service)

                        class global_range(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class auto_range_off(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.clip_to_range = self.__class__.clip_to_range(path + [("clip_to_range", None)], service)
                            self.minimum = self.__class__.minimum(path + [("minimum", None)], service)
                            self.maximum = self.__class__.maximum(path + [("maximum", None)], service)

                        class clip_to_range(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class minimum(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class maximum(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                class color_map(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.visible = self.__class__.visible(path + [("visible", None)], service)
                        self.size = self.__class__.size(path + [("size", None)], service)
                        self.color = self.__class__.color(path + [("color", None)], service)
                        self.log_scale = self.__class__.log_scale(path + [("log_scale", None)], service)
                        self.format = self.__class__.format(path + [("format", None)], service)
                        self.user_skip = self.__class__.user_skip(path + [("user_skip", None)], service)
                        self.show_all = self.__class__.show_all(path + [("show_all", None)], service)
                        self.position = self.__class__.position(path + [("position", None)], service)
                        self.font_name = self.__class__.font_name(path + [("font_name", None)], service)
                        self.font_automatic = self.__class__.font_automatic(path + [("font_automatic", None)], service)
                        self.font_size = self.__class__.font_size(path + [("font_size", None)], service)
                        self.length = self.__class__.length(path + [("length", None)], service)
                        self.width = self.__class__.width(path + [("width", None)], service)

                    class visible(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class size(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class color(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class log_scale(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class format(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class user_skip(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class show_all(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class position(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class font_name(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class font_automatic(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class font_size(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class length(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class width(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class draw_mesh(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class mesh_object(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class display_state_name(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class physics(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geometry(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class surfaces(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

            class pathlines(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.name = self.__class__.name(path + [("name", None)], service)
                    self.uid = self.__class__.uid(path + [("uid", None)], service)
                    self.options = self.__class__.options(path + [("options", None)], service)
                    self.range = self.__class__.range(path + [("range", None)], service)
                    self.style_attribute = self.__class__.style_attribute(path + [("style_attribute", None)], service)
                    self.accuracy_control = self.__class__.accuracy_control(path + [("accuracy_control", None)], service)
                    self.plot = self.__class__.plot(path + [("plot", None)], service)
                    self.step = self.__class__.step(path + [("step", None)], service)
                    self.skip = self.__class__.skip(path + [("skip", None)], service)
                    self.coarsen = self.__class__.coarsen(path + [("coarsen", None)], service)
                    self.onzone = self.__class__.onzone(path + [("onzone", None)], service)
                    self.field = self.__class__.field(path + [("field", None)], service)
                    self.surfaces_list = self.__class__.surfaces_list(path + [("surfaces_list", None)], service)
                    self.velocity_domain = self.__class__.velocity_domain(path + [("velocity_domain", None)], service)
                    self.color_map = self.__class__.color_map(path + [("color_map", None)], service)
                    self.draw_mesh = self.__class__.draw_mesh(path + [("draw_mesh", None)], service)
                    self.mesh_object = self.__class__.mesh_object(path + [("mesh_object", None)], service)
                    self.display_state_name = self.__class__.display_state_name(path + [("display_state_name", None)], service)
                    self.physics = self.__class__.physics(path + [("physics", None)], service)
                    self.geometry = self.__class__.geometry(path + [("geometry", None)], service)
                    self.surfaces = self.__class__.surfaces(path + [("surfaces", None)], service)

                class name(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uid(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class options(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.oil_flow = self.__class__.oil_flow(path + [("oil_flow", None)], service)
                        self.reverse = self.__class__.reverse(path + [("reverse", None)], service)
                        self.node_values = self.__class__.node_values(path + [("node_values", None)], service)
                        self.relative = self.__class__.relative(path + [("relative", None)], service)

                    class oil_flow(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class reverse(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class node_values(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class relative(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class range(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.auto_range = self.__class__.auto_range(path + [("auto_range", None)], service)
                        self.clip_to_range = self.__class__.clip_to_range(path + [("clip_to_range", None)], service)

                    class auto_range(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class clip_to_range(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.min_value = self.__class__.min_value(path + [("min_value", None)], service)
                            self.max_value = self.__class__.max_value(path + [("max_value", None)], service)

                        class min_value(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class max_value(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                class style_attribute(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.style = self.__class__.style(path + [("style", None)], service)
                        self.line_width = self.__class__.line_width(path + [("line_width", None)], service)
                        self.arrow_space = self.__class__.arrow_space(path + [("arrow_space", None)], service)
                        self.arrow_scale = self.__class__.arrow_scale(path + [("arrow_scale", None)], service)
                        self.marker_size = self.__class__.marker_size(path + [("marker_size", None)], service)
                        self.sphere_size = self.__class__.sphere_size(path + [("sphere_size", None)], service)
                        self.sphere_lod = self.__class__.sphere_lod(path + [("sphere_lod", None)], service)
                        self.radius = self.__class__.radius(path + [("radius", None)], service)
                        self.ribbon = self.__class__.ribbon(path + [("ribbon", None)], service)

                    class style(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class line_width(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class arrow_space(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class arrow_scale(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class marker_size(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class sphere_size(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class sphere_lod(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class radius(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class ribbon(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.field = self.__class__.field(path + [("field", None)], service)
                            self.scalefactor = self.__class__.scalefactor(path + [("scalefactor", None)], service)

                        class field(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class scalefactor(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                class accuracy_control(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.step_size = self.__class__.step_size(path + [("step_size", None)], service)
                        self.tolerance = self.__class__.tolerance(path + [("tolerance", None)], service)

                    class step_size(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class tolerance(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class plot(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.x_axis_function = self.__class__.x_axis_function(path + [("x_axis_function", None)], service)
                        self.enabled = self.__class__.enabled(path + [("enabled", None)], service)

                    class x_axis_function(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class enabled(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class step(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class skip(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class coarsen(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class onzone(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class field(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class surfaces_list(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class velocity_domain(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class color_map(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.visible = self.__class__.visible(path + [("visible", None)], service)
                        self.size = self.__class__.size(path + [("size", None)], service)
                        self.color = self.__class__.color(path + [("color", None)], service)
                        self.log_scale = self.__class__.log_scale(path + [("log_scale", None)], service)
                        self.format = self.__class__.format(path + [("format", None)], service)
                        self.user_skip = self.__class__.user_skip(path + [("user_skip", None)], service)
                        self.show_all = self.__class__.show_all(path + [("show_all", None)], service)
                        self.position = self.__class__.position(path + [("position", None)], service)
                        self.font_name = self.__class__.font_name(path + [("font_name", None)], service)
                        self.font_automatic = self.__class__.font_automatic(path + [("font_automatic", None)], service)
                        self.font_size = self.__class__.font_size(path + [("font_size", None)], service)
                        self.length = self.__class__.length(path + [("length", None)], service)
                        self.width = self.__class__.width(path + [("width", None)], service)

                    class visible(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class size(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class color(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class log_scale(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class format(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class user_skip(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class show_all(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class position(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class font_name(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class font_automatic(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class font_size(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class length(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class width(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class draw_mesh(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class mesh_object(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class display_state_name(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class physics(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geometry(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class surfaces(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

            class particle_tracks(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.name = self.__class__.name(path + [("name", None)], service)
                    self.uid = self.__class__.uid(path + [("uid", None)], service)
                    self.options = self.__class__.options(path + [("options", None)], service)
                    self.filter_settings = self.__class__.filter_settings(path + [("filter_settings", None)], service)
                    self.range = self.__class__.range(path + [("range", None)], service)
                    self.style_attribute = self.__class__.style_attribute(path + [("style_attribute", None)], service)
                    self.vector_settings = self.__class__.vector_settings(path + [("vector_settings", None)], service)
                    self.plot = self.__class__.plot(path + [("plot", None)], service)
                    self.track_single_particle_stream = self.__class__.track_single_particle_stream(path + [("track_single_particle_stream", None)], service)
                    self.skip = self.__class__.skip(path + [("skip", None)], service)
                    self.coarsen = self.__class__.coarsen(path + [("coarsen", None)], service)
                    self.field = self.__class__.field(path + [("field", None)], service)
                    self.injections_list = self.__class__.injections_list(path + [("injections_list", None)], service)
                    self.free_stream_particles = self.__class__.free_stream_particles(path + [("free_stream_particles", None)], service)
                    self.wall_film_particles = self.__class__.wall_film_particles(path + [("wall_film_particles", None)], service)
                    self.track_pdf_particles = self.__class__.track_pdf_particles(path + [("track_pdf_particles", None)], service)
                    self.color_map = self.__class__.color_map(path + [("color_map", None)], service)
                    self.draw_mesh = self.__class__.draw_mesh(path + [("draw_mesh", None)], service)
                    self.mesh_object = self.__class__.mesh_object(path + [("mesh_object", None)], service)
                    self.display_state_name = self.__class__.display_state_name(path + [("display_state_name", None)], service)

                class name(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uid(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class options(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.node_values = self.__class__.node_values(path + [("node_values", None)], service)

                    class node_values(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class filter_settings(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.field = self.__class__.field(path + [("field", None)], service)
                        self.options = self.__class__.options(path + [("options", None)], service)
                        self.enabled = self.__class__.enabled(path + [("enabled", None)], service)
                        self.filter_minimum = self.__class__.filter_minimum(path + [("filter_minimum", None)], service)
                        self.filter_maximum = self.__class__.filter_maximum(path + [("filter_maximum", None)], service)

                    class field(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class options(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.inside = self.__class__.inside(path + [("inside", None)], service)
                            self.outside = self.__class__.outside(path + [("outside", None)], service)

                        class inside(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class outside(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class enabled(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class filter_minimum(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class filter_maximum(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class range(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.auto_range = self.__class__.auto_range(path + [("auto_range", None)], service)
                        self.clip_to_range = self.__class__.clip_to_range(path + [("clip_to_range", None)], service)

                    class auto_range(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class clip_to_range(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.min_value = self.__class__.min_value(path + [("min_value", None)], service)
                            self.max_value = self.__class__.max_value(path + [("max_value", None)], service)

                        class min_value(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class max_value(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                class style_attribute(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.style = self.__class__.style(path + [("style", None)], service)
                        self.line_width = self.__class__.line_width(path + [("line_width", None)], service)
                        self.arrow_space = self.__class__.arrow_space(path + [("arrow_space", None)], service)
                        self.arrow_scale = self.__class__.arrow_scale(path + [("arrow_scale", None)], service)
                        self.marker_size = self.__class__.marker_size(path + [("marker_size", None)], service)
                        self.sphere_size = self.__class__.sphere_size(path + [("sphere_size", None)], service)
                        self.sphere_lod = self.__class__.sphere_lod(path + [("sphere_lod", None)], service)
                        self.radius = self.__class__.radius(path + [("radius", None)], service)
                        self.ribbon_settings = self.__class__.ribbon_settings(path + [("ribbon_settings", None)], service)
                        self.sphere_settings = self.__class__.sphere_settings(path + [("sphere_settings", None)], service)

                    class style(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class line_width(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class arrow_space(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class arrow_scale(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class marker_size(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class sphere_size(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class sphere_lod(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class radius(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class ribbon_settings(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.field = self.__class__.field(path + [("field", None)], service)
                            self.scalefactor = self.__class__.scalefactor(path + [("scalefactor", None)], service)

                        class field(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class scalefactor(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class sphere_settings(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.scale = self.__class__.scale(path + [("scale", None)], service)
                            self.sphere_lod = self.__class__.sphere_lod(path + [("sphere_lod", None)], service)
                            self.options = self.__class__.options(path + [("options", None)], service)

                        class scale(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class sphere_lod(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class options(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.constant = self.__class__.constant(path + [("constant", None)], service)
                                self.variable = self.__class__.variable(path + [("variable", None)], service)

                            class constant(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service
                                    self.diameter = self.__class__.diameter(path + [("diameter", None)], service)

                                class diameter(metaclass=PyMenuMeta):
                                    """
                                    """
                                    is_extended_tui = True
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service

                            class variable(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service
                                    self.size_by = self.__class__.size_by(path + [("size_by", None)], service)
                                    self.range = self.__class__.range(path + [("range", None)], service)

                                class size_by(metaclass=PyMenuMeta):
                                    """
                                    """
                                    is_extended_tui = True
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service

                                class range(metaclass=PyMenuMeta):
                                    """
                                    """
                                    is_extended_tui = True
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                        self.auto_range = self.__class__.auto_range(path + [("auto_range", None)], service)
                                        self.clip_to_range = self.__class__.clip_to_range(path + [("clip_to_range", None)], service)

                                    class auto_range(metaclass=PyMenuMeta):
                                        """
                                        """
                                        is_extended_tui = True
                                        def __init__(self, path, service):
                                            self.path = path
                                            self.service = service

                                    class clip_to_range(metaclass=PyMenuMeta):
                                        """
                                        """
                                        is_extended_tui = True
                                        def __init__(self, path, service):
                                            self.path = path
                                            self.service = service
                                            self.min_value = self.__class__.min_value(path + [("min_value", None)], service)
                                            self.max_value = self.__class__.max_value(path + [("max_value", None)], service)

                                        class min_value(metaclass=PyMenuMeta):
                                            """
                                            """
                                            is_extended_tui = True
                                            def __init__(self, path, service):
                                                self.path = path
                                                self.service = service

                                        class max_value(metaclass=PyMenuMeta):
                                            """
                                            """
                                            is_extended_tui = True
                                            def __init__(self, path, service):
                                                self.path = path
                                                self.service = service

                class vector_settings(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.style = self.__class__.style(path + [("style", None)], service)
                        self.vector_length = self.__class__.vector_length(path + [("vector_length", None)], service)
                        self.constant_color = self.__class__.constant_color(path + [("constant_color", None)], service)
                        self.vector_of = self.__class__.vector_of(path + [("vector_of", None)], service)
                        self.scale = self.__class__.scale(path + [("scale", None)], service)
                        self.length_to_head_ratio = self.__class__.length_to_head_ratio(path + [("length_to_head_ratio", None)], service)

                    class style(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class vector_length(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.constant_length = self.__class__.constant_length(path + [("constant_length", None)], service)
                            self.variable_length = self.__class__.variable_length(path + [("variable_length", None)], service)

                        class constant_length(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class variable_length(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class constant_color(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.enabled = self.__class__.enabled(path + [("enabled", None)], service)
                            self.color = self.__class__.color(path + [("color", None)], service)

                        class enabled(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class color(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class vector_of(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class scale(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class length_to_head_ratio(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class plot(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.x_axis_function = self.__class__.x_axis_function(path + [("x_axis_function", None)], service)
                        self.enabled = self.__class__.enabled(path + [("enabled", None)], service)

                    class x_axis_function(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class enabled(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class track_single_particle_stream(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.enabled = self.__class__.enabled(path + [("enabled", None)], service)
                        self.stream_id = self.__class__.stream_id(path + [("stream_id", None)], service)

                    class enabled(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class stream_id(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class skip(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class coarsen(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class field(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class injections_list(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class free_stream_particles(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wall_film_particles(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class track_pdf_particles(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class color_map(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.visible = self.__class__.visible(path + [("visible", None)], service)
                        self.size = self.__class__.size(path + [("size", None)], service)
                        self.color = self.__class__.color(path + [("color", None)], service)
                        self.log_scale = self.__class__.log_scale(path + [("log_scale", None)], service)
                        self.format = self.__class__.format(path + [("format", None)], service)
                        self.user_skip = self.__class__.user_skip(path + [("user_skip", None)], service)
                        self.show_all = self.__class__.show_all(path + [("show_all", None)], service)
                        self.position = self.__class__.position(path + [("position", None)], service)
                        self.font_name = self.__class__.font_name(path + [("font_name", None)], service)
                        self.font_automatic = self.__class__.font_automatic(path + [("font_automatic", None)], service)
                        self.font_size = self.__class__.font_size(path + [("font_size", None)], service)
                        self.length = self.__class__.length(path + [("length", None)], service)
                        self.width = self.__class__.width(path + [("width", None)], service)

                    class visible(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class size(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class color(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class log_scale(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class format(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class user_skip(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class show_all(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class position(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class font_name(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class font_automatic(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class font_size(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class length(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class width(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class draw_mesh(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class mesh_object(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class display_state_name(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

            class scene(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.name = self.__class__.name(path + [("name", None)], service)
                    self.title = self.__class__.title(path + [("title", None)], service)
                    self.temporary = self.__class__.temporary(path + [("temporary", None)], service)
                    self.display_state_name = self.__class__.display_state_name(path + [("display_state_name", None)], service)

                class name(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class title(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class temporary(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class display_state_name(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

        class flamelet_data(metaclass=PyMenuMeta):
            """
            Display flamelet data.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def draw_number_box(self, *args, **kwargs):
                """
                Enable/disable display of the numbers box.
                """
                return PyMenu(self.service, "/display/flamelet_data/draw_number_box").execute(*args, **kwargs)
            def plot_1d_slice(self, *args, **kwargs):
                """
                Enable/disable plot of the 1D-slice.
                """
                return PyMenu(self.service, "/display/flamelet_data/plot_1d_slice").execute(*args, **kwargs)
            def write_to_file(self, *args, **kwargs):
                """
                Enable/disable writing the 1D-slice to file instead of plot.
                """
                return PyMenu(self.service, "/display/flamelet_data/write_to_file").execute(*args, **kwargs)
            def carpet_plot(self, *args, **kwargs):
                """
                Enable/disable display of carpet plot of a property.
                """
                return PyMenu(self.service, "/display/flamelet_data/carpet_plot").execute(*args, **kwargs)

        class particle_tracks(metaclass=PyMenuMeta):
            """
            Enter the particle tracks menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def particle_tracks(self, *args, **kwargs):
                """
                Calculate and display particle tracks from defined injections.
                """
                return PyMenu(self.service, "/display/particle_tracks/particle_tracks").execute(*args, **kwargs)
            def plot_write_xy_plot(self, *args, **kwargs):
                """
                Plot or write XY plot of particle tracks.
                """
                return PyMenu(self.service, "/display/particle_tracks/plot_write_xy_plot").execute(*args, **kwargs)

        class path_lines(metaclass=PyMenuMeta):
            """
            Enter the pathlines menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def path_lines(self, *args, **kwargs):
                """
                Display pathlines from a surface.
                """
                return PyMenu(self.service, "/display/path_lines/path_lines").execute(*args, **kwargs)
            def plot_write_xy_plot(self, *args, **kwargs):
                """
                Plot or write XY plot of pathline.
                """
                return PyMenu(self.service, "/display/path_lines/plot_write_xy_plot").execute(*args, **kwargs)
            def write_to_files(self, *args, **kwargs):
                """
                Write Pathlines to a File.
                """
                return PyMenu(self.service, "/display/path_lines/write_to_files").execute(*args, **kwargs)

        class pdf_data(metaclass=PyMenuMeta):
            """
            Enter the PDF data menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def draw_number_box(self, *args, **kwargs):
                """
                Enable/disable the display of the numbers box.
                """
                return PyMenu(self.service, "/display/pdf_data/draw_number_box").execute(*args, **kwargs)
            def plot_1d_slice(self, *args, **kwargs):
                """
                Enable/disable a plot of the 1D-slice.
                """
                return PyMenu(self.service, "/display/pdf_data/plot_1d_slice").execute(*args, **kwargs)
            def write_to_file(self, *args, **kwargs):
                """
                Enable/disable writing the 1D-slice to file instead of plot.
                """
                return PyMenu(self.service, "/display/pdf_data/write_to_file").execute(*args, **kwargs)
            def carpet_plot(self, *args, **kwargs):
                """
                Enable/disable the display of a carpet plot of a property.
                """
                return PyMenu(self.service, "/display/pdf_data/carpet_plot").execute(*args, **kwargs)

        class set(metaclass=PyMenuMeta):
            """
            Enter the set menu to set display parameters.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.colors = self.__class__.colors(path + [("colors", None)], service)
                self.contours = self.__class__.contours(path + [("contours", None)], service)
                self.picture = self.__class__.picture(path + [("picture", None)], service)
                self.lights = self.__class__.lights(path + [("lights", None)], service)
                self.particle_tracks = self.__class__.particle_tracks(path + [("particle_tracks", None)], service)
                self.path_lines = self.__class__.path_lines(path + [("path_lines", None)], service)
                self.rendering_options = self.__class__.rendering_options(path + [("rendering_options", None)], service)
                self.titles = self.__class__.titles(path + [("titles", None)], service)
                self.velocity_vectors = self.__class__.velocity_vectors(path + [("velocity_vectors", None)], service)
                self.windows = self.__class__.windows(path + [("windows", None)], service)
            def color_map(self, *args, **kwargs):
                """
                Enter the color-map menu.
                """
                return PyMenu(self.service, "/display/set/color_map").execute(*args, **kwargs)
            def element_shrink(self, *args, **kwargs):
                """
                Set percentage to shrink elements.
                """
                return PyMenu(self.service, "/display/set/element_shrink").execute(*args, **kwargs)
            def filled_mesh(self, *args, **kwargs):
                """
                Enable/disable the filled mesh option.
                """
                return PyMenu(self.service, "/display/set/filled_mesh").execute(*args, **kwargs)
            def mesh_level(self, *args, **kwargs):
                """
                Set coarse mesh level to be drawn.
                """
                return PyMenu(self.service, "/display/set/mesh_level").execute(*args, **kwargs)
            def mesh_partitions(self, *args, **kwargs):
                """
                Enable/disable drawing of the mesh partition boundaries.
                """
                return PyMenu(self.service, "/display/set/mesh_partitions").execute(*args, **kwargs)
            def mesh_surfaces(self, *args, **kwargs):
                """
                Set surface IDs to be drawn as mesh.
                """
                return PyMenu(self.service, "/display/set/mesh_surfaces").execute(*args, **kwargs)
            def mesh_zones(self, *args, **kwargs):
                """
                Set zone IDs to be drawn as mesh.
                """
                return PyMenu(self.service, "/display/set/mesh_zones").execute(*args, **kwargs)
            def line_weight(self, *args, **kwargs):
                """
                Set the line-weight factor for the window.
                """
                return PyMenu(self.service, "/display/set/line_weight").execute(*args, **kwargs)
            def marker_size(self, *args, **kwargs):
                """
                Set the size of markers used to represent points.
                """
                return PyMenu(self.service, "/display/set/marker_size").execute(*args, **kwargs)
            def marker_symbol(self, *args, **kwargs):
                """
                Set the type of markers used to represent points.
                """
                return PyMenu(self.service, "/display/set/marker_symbol").execute(*args, **kwargs)
            def mesh_display_configuration(self, *args, **kwargs):
                """
                Set mesh display configuration.
                """
                return PyMenu(self.service, "/display/set/mesh_display_configuration").execute(*args, **kwargs)
            def mirror_zones(self, *args, **kwargs):
                """
                Set zones to mirror the domain about.
                """
                return PyMenu(self.service, "/display/set/mirror_zones").execute(*args, **kwargs)
            def n_stream_func(self, *args, **kwargs):
                """
                Set the number of iterations used in computing stream function.
                """
                return PyMenu(self.service, "/display/set/n_stream_func").execute(*args, **kwargs)
            def nodewt_based_interp(self, *args, **kwargs):
                """
                Use more accurate node-weight based interpolation for postprocessing.
                """
                return PyMenu(self.service, "/display/set/nodewt_based_interp").execute(*args, **kwargs)
            def overlays(self, *args, **kwargs):
                """
                Enable/disable overlays.
                """
                return PyMenu(self.service, "/display/set/overlays").execute(*args, **kwargs)
            def periodic_instancing(self, *args, **kwargs):
                """
                Set periodic instancing.
                """
                return PyMenu(self.service, "/display/set/periodic_instancing").execute(*args, **kwargs)
            def proximity_zones(self, *args, **kwargs):
                """
                Set zones to be used for boundary cell distance and boundary proximity.
                """
                return PyMenu(self.service, "/display/set/proximity_zones").execute(*args, **kwargs)
            def render_mesh(self, *args, **kwargs):
                """
                Enable/disable rendering the mesh on top of contours, vectors, etc.
                """
                return PyMenu(self.service, "/display/set/render_mesh").execute(*args, **kwargs)
            def reset_graphics(self, *args, **kwargs):
                """
                Reset the graphics system.
                """
                return PyMenu(self.service, "/display/set/reset_graphics").execute(*args, **kwargs)
            def zero_angle_dir(self, *args, **kwargs):
                """
                Set the vector having zero angular coordinates.
                """
                return PyMenu(self.service, "/display/set/zero_angle_dir").execute(*args, **kwargs)
            def duplicate_node_display(self, *args, **kwargs):
                """
                Set flag to remove duplicate nodes in mesh display.
                """
                return PyMenu(self.service, "/display/set/duplicate_node_display").execute(*args, **kwargs)

            class colors(metaclass=PyMenuMeta):
                """
                Enter the color options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.by_type = self.__class__.by_type(path + [("by_type", None)], service)
                    self.by_surface = self.__class__.by_surface(path + [("by_surface", None)], service)
                def background(self, *args, **kwargs):
                    """
                    Set the background (window) color.
                    """
                    return PyMenu(self.service, "/display/set/colors/background").execute(*args, **kwargs)
                def color_by_type(self, *args, **kwargs):
                    """
                    Determine whether to color meshes by type or by surface (ID).
                    """
                    return PyMenu(self.service, "/display/set/colors/color_by_type").execute(*args, **kwargs)
                def foreground(self, *args, **kwargs):
                    """
                    Set the foreground (text and window frame) color.
                    """
                    return PyMenu(self.service, "/display/set/colors/foreground").execute(*args, **kwargs)
                def far_field_faces(self, *args, **kwargs):
                    """
                    Set the color of far field faces.
                    """
                    return PyMenu(self.service, "/display/set/colors/far_field_faces").execute(*args, **kwargs)
                def inlet_faces(self, *args, **kwargs):
                    """
                    Set the color of inlet faces.
                    """
                    return PyMenu(self.service, "/display/set/colors/inlet_faces").execute(*args, **kwargs)
                def interior_faces(self, *args, **kwargs):
                    """
                    Set the color of interior faces.
                    """
                    return PyMenu(self.service, "/display/set/colors/interior_faces").execute(*args, **kwargs)
                def internal_faces(self, *args, **kwargs):
                    """
                    Set the color of internal interface faces.
                    """
                    return PyMenu(self.service, "/display/set/colors/internal_faces").execute(*args, **kwargs)
                def outlet_faces(self, *args, **kwargs):
                    """
                    Set the color of outlet faces.
                    """
                    return PyMenu(self.service, "/display/set/colors/outlet_faces").execute(*args, **kwargs)
                def overset_faces(self, *args, **kwargs):
                    """
                    Set the color of overset faces.
                    """
                    return PyMenu(self.service, "/display/set/colors/overset_faces").execute(*args, **kwargs)
                def periodic_faces(self, *args, **kwargs):
                    """
                    Set the color of periodic faces.
                    """
                    return PyMenu(self.service, "/display/set/colors/periodic_faces").execute(*args, **kwargs)
                def rans_les_interface_faces(self, *args, **kwargs):
                    """
                    Set the color of RANS/LES interface faces.
                    """
                    return PyMenu(self.service, "/display/set/colors/rans_les_interface_faces").execute(*args, **kwargs)
                def reset_user_colors(self, *args, **kwargs):
                    """
                    Reset all user colors.
                    """
                    return PyMenu(self.service, "/display/set/colors/reset_user_colors").execute(*args, **kwargs)
                def show_user_colors(self, *args, **kwargs):
                    """
                    List currently defined user colors.
                    """
                    return PyMenu(self.service, "/display/set/colors/show_user_colors").execute(*args, **kwargs)
                def symmetry_faces(self, *args, **kwargs):
                    """
                    Set the color of symmetric faces.
                    """
                    return PyMenu(self.service, "/display/set/colors/symmetry_faces").execute(*args, **kwargs)
                def axis_faces(self, *args, **kwargs):
                    """
                    Set the color of axisymmetric faces.
                    """
                    return PyMenu(self.service, "/display/set/colors/axis_faces").execute(*args, **kwargs)
                def free_surface_faces(self, *args, **kwargs):
                    """
                    Set the color of free-surface faces.
                    """
                    return PyMenu(self.service, "/display/set/colors/free_surface_faces").execute(*args, **kwargs)
                def traction_faces(self, *args, **kwargs):
                    """
                    Set the color of traction faces.
                    """
                    return PyMenu(self.service, "/display/set/colors/traction_faces").execute(*args, **kwargs)
                def user_color(self, *args, **kwargs):
                    """
                    Explicitly set color of display zone.
                    """
                    return PyMenu(self.service, "/display/set/colors/user_color").execute(*args, **kwargs)
                def wall_faces(self, *args, **kwargs):
                    """
                    Set the color of wall faces.
                    """
                    return PyMenu(self.service, "/display/set/colors/wall_faces").execute(*args, **kwargs)
                def interface_faces(self, *args, **kwargs):
                    """
                    Set the color of mesh Interfaces.
                    """
                    return PyMenu(self.service, "/display/set/colors/interface_faces").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    List available colors.
                    """
                    return PyMenu(self.service, "/display/set/colors/list").execute(*args, **kwargs)
                def reset_colors(self, *args, **kwargs):
                    """
                    Reset individual mesh surface colors to the defaults.
                    """
                    return PyMenu(self.service, "/display/set/colors/reset_colors").execute(*args, **kwargs)
                def surface(self, *args, **kwargs):
                    """
                    Set the color of surfaces.
                    """
                    return PyMenu(self.service, "/display/set/colors/surface").execute(*args, **kwargs)
                def skip_label(self, *args, **kwargs):
                    """
                    Set the number of labels to be skipped in the colopmap scale.
                    """
                    return PyMenu(self.service, "/display/set/colors/skip_label").execute(*args, **kwargs)
                def automatic_skip(self, *args, **kwargs):
                    """
                    Determine whether to skip labels in the colopmap scale automatically.
                    """
                    return PyMenu(self.service, "/display/set/colors/automatic_skip").execute(*args, **kwargs)
                def graphics_color_theme(self, *args, **kwargs):
                    """
                    Enter the graphics color theme menu.
                    """
                    return PyMenu(self.service, "/display/set/colors/graphics_color_theme").execute(*args, **kwargs)

                class by_type(metaclass=PyMenuMeta):
                    """
                    Enter the zone type color and material assignment menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.type_name = self.__class__.type_name(path + [("type_name", None)], service)
                    def only_list_case_boundaries(self, *args, **kwargs):
                        """
                        Only list the boundary types that are assigned in this case.
                        """
                        return PyMenu(self.service, "/display/set/colors/by_type/only_list_case_boundaries").execute(*args, **kwargs)
                    def use_inherent_material_color(self, *args, **kwargs):
                        """
                        Use inherent material color for boundary zones.
                        """
                        return PyMenu(self.service, "/display/set/colors/by_type/use_inherent_material_color").execute(*args, **kwargs)
                    def reset(self, *args, **kwargs):
                        """
                        To reset colors and/or materials to the defaults.
                        """
                        return PyMenu(self.service, "/display/set/colors/by_type/reset").execute(*args, **kwargs)

                    class type_name(metaclass=PyMenuMeta):
                        """
                        Select the boundary type to specify colors and/or materials.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.axis = self.__class__.axis(path + [("axis", None)], service)
                            self.far_field = self.__class__.far_field(path + [("far_field", None)], service)
                            self.free_surface = self.__class__.free_surface(path + [("free_surface", None)], service)
                            self.inlet = self.__class__.inlet(path + [("inlet", None)], service)
                            self.interface = self.__class__.interface(path + [("interface", None)], service)
                            self.interior = self.__class__.interior(path + [("interior", None)], service)
                            self.internal = self.__class__.internal(path + [("internal", None)], service)
                            self.outlet = self.__class__.outlet(path + [("outlet", None)], service)
                            self.overset = self.__class__.overset(path + [("overset", None)], service)
                            self.periodic = self.__class__.periodic(path + [("periodic", None)], service)
                            self.rans_les_interface = self.__class__.rans_les_interface(path + [("rans_les_interface", None)], service)
                            self.surface = self.__class__.surface(path + [("surface", None)], service)
                            self.symmetry = self.__class__.symmetry(path + [("symmetry", None)], service)
                            self.traction = self.__class__.traction(path + [("traction", None)], service)
                            self.wall = self.__class__.wall(path + [("wall", None)], service)

                        class axis(metaclass=PyMenuMeta):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def color(self, *args, **kwargs):
                                """
                                Set a color for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/axis/color").execute(*args, **kwargs)
                            def material(self, *args, **kwargs):
                                """
                                Set a material for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/axis/material").execute(*args, **kwargs)

                        class far_field(metaclass=PyMenuMeta):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def color(self, *args, **kwargs):
                                """
                                Set a color for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/far_field/color").execute(*args, **kwargs)
                            def material(self, *args, **kwargs):
                                """
                                Set a material for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/far_field/material").execute(*args, **kwargs)

                        class free_surface(metaclass=PyMenuMeta):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def color(self, *args, **kwargs):
                                """
                                Set a color for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/free_surface/color").execute(*args, **kwargs)
                            def material(self, *args, **kwargs):
                                """
                                Set a material for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/free_surface/material").execute(*args, **kwargs)

                        class inlet(metaclass=PyMenuMeta):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def color(self, *args, **kwargs):
                                """
                                Set a color for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/inlet/color").execute(*args, **kwargs)
                            def material(self, *args, **kwargs):
                                """
                                Set a material for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/inlet/material").execute(*args, **kwargs)

                        class interface(metaclass=PyMenuMeta):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def color(self, *args, **kwargs):
                                """
                                Set a color for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/interface/color").execute(*args, **kwargs)
                            def material(self, *args, **kwargs):
                                """
                                Set a material for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/interface/material").execute(*args, **kwargs)

                        class interior(metaclass=PyMenuMeta):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def color(self, *args, **kwargs):
                                """
                                Set a color for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/interior/color").execute(*args, **kwargs)
                            def material(self, *args, **kwargs):
                                """
                                Set a material for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/interior/material").execute(*args, **kwargs)

                        class internal(metaclass=PyMenuMeta):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def color(self, *args, **kwargs):
                                """
                                Set a color for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/internal/color").execute(*args, **kwargs)
                            def material(self, *args, **kwargs):
                                """
                                Set a material for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/internal/material").execute(*args, **kwargs)

                        class outlet(metaclass=PyMenuMeta):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def color(self, *args, **kwargs):
                                """
                                Set a color for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/outlet/color").execute(*args, **kwargs)
                            def material(self, *args, **kwargs):
                                """
                                Set a material for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/outlet/material").execute(*args, **kwargs)

                        class overset(metaclass=PyMenuMeta):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def color(self, *args, **kwargs):
                                """
                                Set a color for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/overset/color").execute(*args, **kwargs)
                            def material(self, *args, **kwargs):
                                """
                                Set a material for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/overset/material").execute(*args, **kwargs)

                        class periodic(metaclass=PyMenuMeta):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def color(self, *args, **kwargs):
                                """
                                Set a color for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/periodic/color").execute(*args, **kwargs)
                            def material(self, *args, **kwargs):
                                """
                                Set a material for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/periodic/material").execute(*args, **kwargs)

                        class rans_les_interface(metaclass=PyMenuMeta):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def color(self, *args, **kwargs):
                                """
                                Set a color for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/rans_les_interface/color").execute(*args, **kwargs)
                            def material(self, *args, **kwargs):
                                """
                                Set a material for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/rans_les_interface/material").execute(*args, **kwargs)

                        class surface(metaclass=PyMenuMeta):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def color(self, *args, **kwargs):
                                """
                                Set a color for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/surface/color").execute(*args, **kwargs)
                            def material(self, *args, **kwargs):
                                """
                                Set a material for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/surface/material").execute(*args, **kwargs)

                        class symmetry(metaclass=PyMenuMeta):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def color(self, *args, **kwargs):
                                """
                                Set a color for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/symmetry/color").execute(*args, **kwargs)
                            def material(self, *args, **kwargs):
                                """
                                Set a material for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/symmetry/material").execute(*args, **kwargs)

                        class traction(metaclass=PyMenuMeta):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def color(self, *args, **kwargs):
                                """
                                Set a color for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/traction/color").execute(*args, **kwargs)
                            def material(self, *args, **kwargs):
                                """
                                Set a material for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/traction/material").execute(*args, **kwargs)

                        class wall(metaclass=PyMenuMeta):
                            """
                            Set the material and/or color for the selected boundary type.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def color(self, *args, **kwargs):
                                """
                                Set a color for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/wall/color").execute(*args, **kwargs)
                            def material(self, *args, **kwargs):
                                """
                                Set a material for the selected boundary type.
                                """
                                return PyMenu(self.service, "/display/set/colors/by_type/type_name/wall/material").execute(*args, **kwargs)

                class by_surface(metaclass=PyMenuMeta):
                    """
                    Enter the surface(s) color and material assignment menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def surfaces(self, *args, **kwargs):
                        """
                        Select the surface(s) to specify colors and/or materials.
                        """
                        return PyMenu(self.service, "/display/set/colors/by_surface/surfaces").execute(*args, **kwargs)
                    def use_inherent_material_color(self, *args, **kwargs):
                        """
                        Use inherent material color for surfaces.
                        """
                        return PyMenu(self.service, "/display/set/colors/by_surface/use_inherent_material_color").execute(*args, **kwargs)
                    def reset(self, *args, **kwargs):
                        """
                        To reset colors and/or materials to the defaults.
                        """
                        return PyMenu(self.service, "/display/set/colors/by_surface/reset").execute(*args, **kwargs)
                    def list_surfaces_by_color(self, *args, **kwargs):
                        """
                        To list the surfaces by its color.
                        """
                        return PyMenu(self.service, "/display/set/colors/by_surface/list_surfaces_by_color").execute(*args, **kwargs)
                    def list_surfaces_by_material(self, *args, **kwargs):
                        """
                        To list the surfaces by its material.
                        """
                        return PyMenu(self.service, "/display/set/colors/by_surface/list_surfaces_by_material").execute(*args, **kwargs)

            class contours(metaclass=PyMenuMeta):
                """
                Enter the contour options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def auto_range(self, *args, **kwargs):
                    """
                    Enable/disable auto-computation of range for contours.
                    """
                    return PyMenu(self.service, "/display/set/contours/auto_range").execute(*args, **kwargs)
                def clip_to_range(self, *args, **kwargs):
                    """
                    Enable/disable the clip to range option for filled contours.
                    """
                    return PyMenu(self.service, "/display/set/contours/clip_to_range").execute(*args, **kwargs)
                def surfaces(self, *args, **kwargs):
                    """
                    Set surfaces to be contoured.
                    """
                    return PyMenu(self.service, "/display/set/contours/surfaces").execute(*args, **kwargs)
                def filled_contours(self, *args, **kwargs):
                    """
                    Enable/disable the filled contour option.
                    """
                    return PyMenu(self.service, "/display/set/contours/filled_contours").execute(*args, **kwargs)
                def global_range(self, *args, **kwargs):
                    """
                    Enable/disable the global range for contours option.
                    """
                    return PyMenu(self.service, "/display/set/contours/global_range").execute(*args, **kwargs)
                def line_contours(self, *args, **kwargs):
                    """
                    Enable/disable the filled contour option.
                    """
                    return PyMenu(self.service, "/display/set/contours/line_contours").execute(*args, **kwargs)
                def log_scale(self, *args, **kwargs):
                    """
                    Enable/disable the use of a log scale.
                    """
                    return PyMenu(self.service, "/display/set/contours/log_scale").execute(*args, **kwargs)
                def n_contour(self, *args, **kwargs):
                    """
                    Set the number of contour levels.
                    """
                    return PyMenu(self.service, "/display/set/contours/n_contour").execute(*args, **kwargs)
                def node_values(self, *args, **kwargs):
                    """
                    Enable/disable the plot of node values.
                    """
                    return PyMenu(self.service, "/display/set/contours/node_values").execute(*args, **kwargs)
                def render_mesh(self, *args, **kwargs):
                    """
                    Determine whether or not to render the mesh on top of contours, vectors, etc.
                    """
                    return PyMenu(self.service, "/display/set/contours/render_mesh").execute(*args, **kwargs)
                def coloring(self, *args, **kwargs):
                    """
                    Select coloring option.
                    """
                    return PyMenu(self.service, "/display/set/contours/coloring").execute(*args, **kwargs)

            class picture(metaclass=PyMenuMeta):
                """
                Enter the hardcopy/save-picture options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.color_mode = self.__class__.color_mode(path + [("color_mode", None)], service)
                    self.driver = self.__class__.driver(path + [("driver", None)], service)
                def invert_background(self, *args, **kwargs):
                    """
                    Use a white background when the picture is saved.
                    """
                    return PyMenu(self.service, "/display/set/picture/invert_background").execute(*args, **kwargs)
                def landscape(self, *args, **kwargs):
                    """
                    Plot hardcopies in landscape or portrait orientation.
                    """
                    return PyMenu(self.service, "/display/set/picture/landscape").execute(*args, **kwargs)
                def preview(self, *args, **kwargs):
                    """
                    Display a preview image of a hardcopy.
                    """
                    return PyMenu(self.service, "/display/set/picture/preview").execute(*args, **kwargs)
                def x_resolution(self, *args, **kwargs):
                    """
                    Set the width of raster-formatted images in pixels (0 implies current window size).
                    """
                    return PyMenu(self.service, "/display/set/picture/x_resolution").execute(*args, **kwargs)
                def y_resolution(self, *args, **kwargs):
                    """
                    Set the height of raster-formatted images in pixels (0 implies current window size).
                    """
                    return PyMenu(self.service, "/display/set/picture/y_resolution").execute(*args, **kwargs)
                def dpi(self, *args, **kwargs):
                    """
                    Set the DPI for EPS and Postscript files, specifies the resolution in dots per inch (DPI) instead of setting the width and height.
                    """
                    return PyMenu(self.service, "/display/set/picture/dpi").execute(*args, **kwargs)
                def use_window_resolution(self, *args, **kwargs):
                    """
                    Use the currently active window's resolution for hardcopy (ignores the x-resolution and y-resolution in this case).
                    """
                    return PyMenu(self.service, "/display/set/picture/use_window_resolution").execute(*args, **kwargs)
                def set_standard_resolution(self, *args, **kwargs):
                    """
                    Select from pre-defined resolution list.
                    """
                    return PyMenu(self.service, "/display/set/picture/set_standard_resolution").execute(*args, **kwargs)
                def jpeg_hardcopy_quality(self, *args, **kwargs):
                    """
                    To set jpeg hardcopy quality.
                    """
                    return PyMenu(self.service, "/display/set/picture/jpeg_hardcopy_quality").execute(*args, **kwargs)

                class color_mode(metaclass=PyMenuMeta):
                    """
                    Enter the hardcopy color mode menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def color(self, *args, **kwargs):
                        """
                        Plot hardcopies in color.
                        """
                        return PyMenu(self.service, "/display/set/picture/color_mode/color").execute(*args, **kwargs)
                    def gray_scale(self, *args, **kwargs):
                        """
                        Convert color to grayscale for hardcopy.
                        """
                        return PyMenu(self.service, "/display/set/picture/color_mode/gray_scale").execute(*args, **kwargs)
                    def mono_chrome(self, *args, **kwargs):
                        """
                        Convert color to monochrome (black and white) for hardcopy.
                        """
                        return PyMenu(self.service, "/display/set/picture/color_mode/mono_chrome").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        Display the current hardcopy color mode.
                        """
                        return PyMenu(self.service, "/display/set/picture/color_mode/list").execute(*args, **kwargs)

                class driver(metaclass=PyMenuMeta):
                    """
                    Enter the set hardcopy driver menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.post_format = self.__class__.post_format(path + [("post_format", None)], service)
                    def dump_window(self, *args, **kwargs):
                        """
                        Set the command used to dump the graphics window to a file.
                        """
                        return PyMenu(self.service, "/display/set/picture/driver/dump_window").execute(*args, **kwargs)
                    def eps(self, *args, **kwargs):
                        """
                        Produce encapsulated PostScript (EPS) output for hardcopies.
                        """
                        return PyMenu(self.service, "/display/set/picture/driver/eps").execute(*args, **kwargs)
                    def jpeg(self, *args, **kwargs):
                        """
                        Produce JPEG output for hardcopies.
                        """
                        return PyMenu(self.service, "/display/set/picture/driver/jpeg").execute(*args, **kwargs)
                    def post_script(self, *args, **kwargs):
                        """
                        Produce PostScript output for hardcopies.
                        """
                        return PyMenu(self.service, "/display/set/picture/driver/post_script").execute(*args, **kwargs)
                    def ppm(self, *args, **kwargs):
                        """
                        Produce PPM output for hardcopies.
                        """
                        return PyMenu(self.service, "/display/set/picture/driver/ppm").execute(*args, **kwargs)
                    def tiff(self, *args, **kwargs):
                        """
                        Use TIFF output for hardcopies.
                        """
                        return PyMenu(self.service, "/display/set/picture/driver/tiff").execute(*args, **kwargs)
                    def png(self, *args, **kwargs):
                        """
                        Use PNG output for hardcopies.
                        """
                        return PyMenu(self.service, "/display/set/picture/driver/png").execute(*args, **kwargs)
                    def hsf(self, *args, **kwargs):
                        """
                        Use HSF output for hardcopies.
                        """
                        return PyMenu(self.service, "/display/set/picture/driver/hsf").execute(*args, **kwargs)
                    def avz(self, *args, **kwargs):
                        """
                        Use AVZ output for hardcopies.
                        """
                        return PyMenu(self.service, "/display/set/picture/driver/avz").execute(*args, **kwargs)
                    def glb(self, *args, **kwargs):
                        """
                        Use GLB output for hardcopies.
                        """
                        return PyMenu(self.service, "/display/set/picture/driver/glb").execute(*args, **kwargs)
                    def vrml(self, *args, **kwargs):
                        """
                        Use VRML output for hardcopies.
                        """
                        return PyMenu(self.service, "/display/set/picture/driver/vrml").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        List the current hardcopy driver.
                        """
                        return PyMenu(self.service, "/display/set/picture/driver/list").execute(*args, **kwargs)
                    def options(self, *args, **kwargs):
                        """
                        Set the hardcopy options. Available options are:
                        \\n               	"no gamma correction", disables gamma correction of colors,
                        \\n               	"physical size = (width,height)", where width and height
                                  are the actual measurements of the printable area of the page
                                  in centimeters.
                        \\n               	"subscreen = (left,right,bottom,top)", where left,right,
                                  bottom, and top are numbers in [-1,1] describing a subwindow on
                                  the page in which to place the hardcopy.
                        
                        \\n          The options may be combined by separating them with commas.
                        """
                        return PyMenu(self.service, "/display/set/picture/driver/options").execute(*args, **kwargs)

                    class post_format(metaclass=PyMenuMeta):
                        """
                        Enter the PostScript driver format menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def fast_raster(self, *args, **kwargs):
                            """
                            Use the new raster format.
                            """
                            return PyMenu(self.service, "/display/set/picture/driver/post_format/fast_raster").execute(*args, **kwargs)
                        def raster(self, *args, **kwargs):
                            """
                            Use the original raster format.
                            """
                            return PyMenu(self.service, "/display/set/picture/driver/post_format/raster").execute(*args, **kwargs)
                        def rle_raster(self, *args, **kwargs):
                            """
                            Use the run-length encoded raster format.
                            """
                            return PyMenu(self.service, "/display/set/picture/driver/post_format/rle_raster").execute(*args, **kwargs)
                        def vector(self, *args, **kwargs):
                            """
                            Use vector format.
                            """
                            return PyMenu(self.service, "/display/set/picture/driver/post_format/vector").execute(*args, **kwargs)

            class lights(metaclass=PyMenuMeta):
                """
                Enter the lights menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.lighting_interpolation = self.__class__.lighting_interpolation(path + [("lighting_interpolation", None)], service)
                def lights_on(self, *args, **kwargs):
                    """
                    Turn all active lighting on/off.
                    """
                    return PyMenu(self.service, "/display/set/lights/lights_on").execute(*args, **kwargs)
                def set_ambient_color(self, *args, **kwargs):
                    """
                    Set the ambient light color for the scene.
                    """
                    return PyMenu(self.service, "/display/set/lights/set_ambient_color").execute(*args, **kwargs)
                def set_light(self, *args, **kwargs):
                    """
                    Add or modify a directional, colored light.
                    """
                    return PyMenu(self.service, "/display/set/lights/set_light").execute(*args, **kwargs)
                def headlight_on(self, *args, **kwargs):
                    """
                    Turn the light that moves with the camera on or off.
                    """
                    return PyMenu(self.service, "/display/set/lights/headlight_on").execute(*args, **kwargs)

                class lighting_interpolation(metaclass=PyMenuMeta):
                    """
                    Set lighting interpolation method.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def automatic(self, *args, **kwargs):
                        """
                        Choose Automatic to automatically select the best lighting method for a given graphics object.
                        """
                        return PyMenu(self.service, "/display/set/lights/lighting_interpolation/automatic").execute(*args, **kwargs)
                    def flat(self, *args, **kwargs):
                        """
                        Use flat shading for meshes and polygons.
                        """
                        return PyMenu(self.service, "/display/set/lights/lighting_interpolation/flat").execute(*args, **kwargs)
                    def gouraud(self, *args, **kwargs):
                        """
                        Use Gouraud shading to calculate the color at each vertex of a polygon and interpolate it in the interior.
                        """
                        return PyMenu(self.service, "/display/set/lights/lighting_interpolation/gouraud").execute(*args, **kwargs)
                    def phong(self, *args, **kwargs):
                        """
                        Use Phong shading to interpolate the normals for each pixel of a polygon and compute a color at every pixel.
                        """
                        return PyMenu(self.service, "/display/set/lights/lighting_interpolation/phong").execute(*args, **kwargs)

            class particle_tracks(metaclass=PyMenuMeta):
                """
                Enter the particle-tracks menu to set parameters for display of particle tracks.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.sphere_settings = self.__class__.sphere_settings(path + [("sphere_settings", None)], service)
                    self.vector_settings = self.__class__.vector_settings(path + [("vector_settings", None)], service)
                    self.filter_settings = self.__class__.filter_settings(path + [("filter_settings", None)], service)
                def display(self, *args, **kwargs):
                    """
                    Determine whether particle tracks will be displayed or only tracked.
                    """
                    return PyMenu(self.service, "/display/set/particle_tracks/display").execute(*args, **kwargs)
                def history_filename(self, *args, **kwargs):
                    """
                    Specify the name of the particle history file.
                    """
                    return PyMenu(self.service, "/display/set/particle_tracks/history_filename").execute(*args, **kwargs)
                def report_to(self, *args, **kwargs):
                    """
                    Specify the destination for the report (console, file, none).
                    """
                    return PyMenu(self.service, "/display/set/particle_tracks/report_to").execute(*args, **kwargs)
                def report_type(self, *args, **kwargs):
                    """
                    Set the report type for particle tracks.
                    """
                    return PyMenu(self.service, "/display/set/particle_tracks/report_type").execute(*args, **kwargs)
                def report_variables(self, *args, **kwargs):
                    """
                    Set the report variables.
                    """
                    return PyMenu(self.service, "/display/set/particle_tracks/report_variables").execute(*args, **kwargs)
                def report_default_variables(self, *args, **kwargs):
                    """
                    Set the report variables to default.
                    """
                    return PyMenu(self.service, "/display/set/particle_tracks/report_default_variables").execute(*args, **kwargs)
                def track_single_particle_stream(self, *args, **kwargs):
                    """
                    Specify the stream ID to be tracked.
                    """
                    return PyMenu(self.service, "/display/set/particle_tracks/track_single_particle_stream").execute(*args, **kwargs)
                def arrow_scale(self, *args, **kwargs):
                    """
                    Set the scale factor for arrows drawn on particle tracks.
                    """
                    return PyMenu(self.service, "/display/set/particle_tracks/arrow_scale").execute(*args, **kwargs)
                def arrow_space(self, *args, **kwargs):
                    """
                    Set the spacing factor for arrows drawn on particle tracks.
                    """
                    return PyMenu(self.service, "/display/set/particle_tracks/arrow_space").execute(*args, **kwargs)
                def coarsen_factor(self, *args, **kwargs):
                    """
                    Set the particle tracks coarsening factor.
                    """
                    return PyMenu(self.service, "/display/set/particle_tracks/coarsen_factor").execute(*args, **kwargs)
                def line_width(self, *args, **kwargs):
                    """
                    Set the width for particle track.
                    """
                    return PyMenu(self.service, "/display/set/particle_tracks/line_width").execute(*args, **kwargs)
                def marker_size(self, *args, **kwargs):
                    """
                    Set the marker size for particle drawing.
                    """
                    return PyMenu(self.service, "/display/set/particle_tracks/marker_size").execute(*args, **kwargs)
                def radius(self, *args, **kwargs):
                    """
                    Set the radius for particle track (ribbons/cylinder only) cross-section.
                    """
                    return PyMenu(self.service, "/display/set/particle_tracks/radius").execute(*args, **kwargs)
                def style(self, *args, **kwargs):
                    """
                    Set the display style for particle track (line/ribbon/cylinder/sphere).
                    """
                    return PyMenu(self.service, "/display/set/particle_tracks/style").execute(*args, **kwargs)
                def twist_factor(self, *args, **kwargs):
                    """
                    Set the scale factor for twisting (ribbons only).
                    """
                    return PyMenu(self.service, "/display/set/particle_tracks/twist_factor").execute(*args, **kwargs)
                def sphere_attrib(self, *args, **kwargs):
                    """
                    Specify size and number of slices to be used in drawing spheres.
                    """
                    return PyMenu(self.service, "/display/set/particle_tracks/sphere_attrib").execute(*args, **kwargs)
                def particle_skip(self, *args, **kwargs):
                    """
                    Specify how many particle tracks should be displayed.
                    """
                    return PyMenu(self.service, "/display/set/particle_tracks/particle_skip").execute(*args, **kwargs)

                class sphere_settings(metaclass=PyMenuMeta):
                    """
                    Provide sphere specific input.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def vary_diameter(self, *args, **kwargs):
                        """
                        Specify whether the spheres can vary with another variable.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/sphere_settings/vary_diameter").execute(*args, **kwargs)
                    def diameter(self, *args, **kwargs):
                        """
                        Diameter of the spheres when vary-diameter? is disabled.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/sphere_settings/diameter").execute(*args, **kwargs)
                    def auto_range(self, *args, **kwargs):
                        """
                        Specify whether displayed spheres should include auto range of variable to size spheres.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/sphere_settings/auto_range").execute(*args, **kwargs)
                    def minimum(self, *args, **kwargs):
                        """
                        Set the minimum value of the sphere to be displayed.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/sphere_settings/minimum").execute(*args, **kwargs)
                    def maximum(self, *args, **kwargs):
                        """
                        Set the maximum value of the sphere to be displayed.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/sphere_settings/maximum").execute(*args, **kwargs)
                    def smooth_parameter(self, *args, **kwargs):
                        """
                        Specify number of slices to be used in drawing spheres.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/sphere_settings/smooth_parameter").execute(*args, **kwargs)
                    def scale_factor(self, *args, **kwargs):
                        """
                        Specify a scale factor to enlarge/reduce the size of spheres.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/sphere_settings/scale_factor").execute(*args, **kwargs)
                    def size_variable(self, *args, **kwargs):
                        """
                        Select a particle variable to size the spheres.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/sphere_settings/size_variable").execute(*args, **kwargs)

                class vector_settings(metaclass=PyMenuMeta):
                    """
                    Set vector specific input.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def style(self, *args, **kwargs):
                        """
                        Enable and set the display style for particle vectors (none/vector/centered-vector/centered-cylinder).
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/vector_settings/style").execute(*args, **kwargs)
                    def vector_length(self, *args, **kwargs):
                        """
                        Specify the length of constant vectors.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/vector_settings/vector_length").execute(*args, **kwargs)
                    def vector_length_variable(self, *args, **kwargs):
                        """
                        Select a particle variable to specify the length of vectors.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/vector_settings/vector_length_variable").execute(*args, **kwargs)
                    def scale_factor(self, *args, **kwargs):
                        """
                        Specify a scale factor to enlarge/reduce the length of vectors.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/vector_settings/scale_factor").execute(*args, **kwargs)
                    def length_variable(self, *args, **kwargs):
                        """
                        Specify whether the displayed vectors have length varying with another variable.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/vector_settings/length_variable").execute(*args, **kwargs)
                    def length_to_head_ratio(self, *args, **kwargs):
                        """
                        Specify ratio of length to head for vectors and length to diameter for cylinders.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/vector_settings/length_to_head_ratio").execute(*args, **kwargs)
                    def constant_color(self, *args, **kwargs):
                        """
                        Specify a constant color for the vectors.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/vector_settings/constant_color").execute(*args, **kwargs)
                    def color_variable(self, *args, **kwargs):
                        """
                        Specify whether the vectors should be colored by variable specified in /display/particle-track/particle-track (if false use a constant color).
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/vector_settings/color_variable").execute(*args, **kwargs)
                    def vector_variable(self, *args, **kwargs):
                        """
                        Select a particle vector function to specify vector direction.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/vector_settings/vector_variable").execute(*args, **kwargs)

                class filter_settings(metaclass=PyMenuMeta):
                    """
                    Set filter for particle display.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def enable_filtering(self, *args, **kwargs):
                        """
                        Specify whether particle display is filtered.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/filter_settings/enable_filtering").execute(*args, **kwargs)
                    def inside(self, *args, **kwargs):
                        """
                        Specify whether filter variable needs to be inside min/max to be displayed (else outside min/max).
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/filter_settings/inside").execute(*args, **kwargs)
                    def filter_variable(self, *args, **kwargs):
                        """
                        Select a variable used for filtering of particles.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/filter_settings/filter_variable").execute(*args, **kwargs)
                    def minimum(self, *args, **kwargs):
                        """
                        Specify the lower bound for the filter variable.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/filter_settings/minimum").execute(*args, **kwargs)
                    def maximum(self, *args, **kwargs):
                        """
                        Specify the upper bound for the filter variable.
                        """
                        return PyMenu(self.service, "/display/set/particle_tracks/filter_settings/maximum").execute(*args, **kwargs)

            class path_lines(metaclass=PyMenuMeta):
                """
                Enter the path-lines menu to set parameters for the display of pathlines.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def arrow_scale(self, *args, **kwargs):
                    """
                    Set the scale factor for arrows drawn on pathlines.
                    """
                    return PyMenu(self.service, "/display/set/path_lines/arrow_scale").execute(*args, **kwargs)
                def arrow_space(self, *args, **kwargs):
                    """
                    Set the spacing factor for arrows drawn on pathlines.
                    """
                    return PyMenu(self.service, "/display/set/path_lines/arrow_space").execute(*args, **kwargs)
                def display_steps(self, *args, **kwargs):
                    """
                    Set the display stepping for pathlines.
                    """
                    return PyMenu(self.service, "/display/set/path_lines/display_steps").execute(*args, **kwargs)
                def error_control(self, *args, **kwargs):
                    """
                    Set error control during pathline computation.
                    """
                    return PyMenu(self.service, "/display/set/path_lines/error_control").execute(*args, **kwargs)
                def line_width(self, *args, **kwargs):
                    """
                    Set the width for pathlines.
                    """
                    return PyMenu(self.service, "/display/set/path_lines/line_width").execute(*args, **kwargs)
                def marker_size(self, *args, **kwargs):
                    """
                    Set the marker size for particle drawing.
                    """
                    return PyMenu(self.service, "/display/set/path_lines/marker_size").execute(*args, **kwargs)
                def maximum_steps(self, *args, **kwargs):
                    """
                    Set the maximum number of steps to take for pathlines.
                    """
                    return PyMenu(self.service, "/display/set/path_lines/maximum_steps").execute(*args, **kwargs)
                def maximum_error(self, *args, **kwargs):
                    """
                    Set the maximum error allowed while computing the pathlines.
                    """
                    return PyMenu(self.service, "/display/set/path_lines/maximum_error").execute(*args, **kwargs)
                def radius(self, *args, **kwargs):
                    """
                    Set the radius for pathline (ribbons/cylinder only) cross-section.
                    """
                    return PyMenu(self.service, "/display/set/path_lines/radius").execute(*args, **kwargs)
                def relative_pathlines(self, *args, **kwargs):
                    """
                    Enable/disable the tracking of pathlines in a relative coordinate system.
                    """
                    return PyMenu(self.service, "/display/set/path_lines/relative_pathlines").execute(*args, **kwargs)
                def style(self, *args, **kwargs):
                    """
                    Set display style for pathlines (line/ribbon/cylinder).
                    """
                    return PyMenu(self.service, "/display/set/path_lines/style").execute(*args, **kwargs)
                def twist_factor(self, *args, **kwargs):
                    """
                    Set the scale factor for twisting (ribbons only).
                    """
                    return PyMenu(self.service, "/display/set/path_lines/twist_factor").execute(*args, **kwargs)
                def step_size(self, *args, **kwargs):
                    """
                    Set the step length between particle positions for path-lines.
                    """
                    return PyMenu(self.service, "/display/set/path_lines/step_size").execute(*args, **kwargs)
                def reverse(self, *args, **kwargs):
                    """
                    Enable/disable the direction of path tracking.
                    """
                    return PyMenu(self.service, "/display/set/path_lines/reverse").execute(*args, **kwargs)
                def sphere_attrib(self, *args, **kwargs):
                    """
                    Specify size and no. of slices to be used in drawing sphere for sphere-style.
                    """
                    return PyMenu(self.service, "/display/set/path_lines/sphere_attrib").execute(*args, **kwargs)
                def track_in_phase(self, *args, **kwargs):
                    """
                    Assign phase to display pathlines in.
                    """
                    return PyMenu(self.service, "/display/set/path_lines/track_in_phase").execute(*args, **kwargs)

            class rendering_options(metaclass=PyMenuMeta):
                """
                Enter the rendering options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def auto_spin(self, *args, **kwargs):
                    """
                    Enable/disable mouse view rotations to continue to spin the display after the button is released.
                    """
                    return PyMenu(self.service, "/display/set/rendering_options/auto_spin").execute(*args, **kwargs)
                def device_info(self, *args, **kwargs):
                    """
                    List information for the graphics device.
                    """
                    return PyMenu(self.service, "/display/set/rendering_options/device_info").execute(*args, **kwargs)
                def double_buffering(self, *args, **kwargs):
                    """
                    Enable/disable double-buffering.
                    """
                    return PyMenu(self.service, "/display/set/rendering_options/double_buffering").execute(*args, **kwargs)
                def driver(self, *args, **kwargs):
                    """
                    Change the current graphics driver.
                    """
                    return PyMenu(self.service, "/display/set/rendering_options/driver").execute(*args, **kwargs)
                def hidden_surfaces(self, *args, **kwargs):
                    """
                    Enable/disable hidden surface removal.
                    """
                    return PyMenu(self.service, "/display/set/rendering_options/hidden_surfaces").execute(*args, **kwargs)
                def hidden_surface_method(self, *args, **kwargs):
                    """
                    Specify the method to perform hidden line and hidden surface rendering.
                    """
                    return PyMenu(self.service, "/display/set/rendering_options/hidden_surface_method").execute(*args, **kwargs)
                def outer_face_cull(self, *args, **kwargs):
                    """
                    Enable/disable discarding outer faces during display.
                    """
                    return PyMenu(self.service, "/display/set/rendering_options/outer_face_cull").execute(*args, **kwargs)
                def surface_edge_visibility(self, *args, **kwargs):
                    """
                    Set edge visibility flags for surfaces.
                    """
                    return PyMenu(self.service, "/display/set/rendering_options/surface_edge_visibility").execute(*args, **kwargs)
                def animation_option(self, *args, **kwargs):
                    """
                    Using Wireframe / All option during animation.
                    """
                    return PyMenu(self.service, "/display/set/rendering_options/animation_option").execute(*args, **kwargs)
                def color_map_alignment(self, *args, **kwargs):
                    """
                    Set the color bar alignment.
                    """
                    return PyMenu(self.service, "/display/set/rendering_options/color_map_alignment").execute(*args, **kwargs)
                def help_text_color(self, *args, **kwargs):
                    """
                    Set the color of screen help text.
                    """
                    return PyMenu(self.service, "/display/set/rendering_options/help_text_color").execute(*args, **kwargs)
                def face_displacement(self, *args, **kwargs):
                    """
                    Set face displacement value in Z-buffer units along the Camera Z-axis.
                    """
                    return PyMenu(self.service, "/display/set/rendering_options/face_displacement").execute(*args, **kwargs)
                def set_rendering_options(self, *args, **kwargs):
                    """
                    Set the rendering options.
                    """
                    return PyMenu(self.service, "/display/set/rendering_options/set_rendering_options").execute(*args, **kwargs)
                def show_colormap(self, *args, **kwargs):
                    """
                    Enable/Disable colormap.
                    """
                    return PyMenu(self.service, "/display/set/rendering_options/show_colormap").execute(*args, **kwargs)

            class titles(metaclass=PyMenuMeta):
                """
                Set problem title.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def left_top(self, *args, **kwargs):
                    """
                    Set the title text for left top in title segment.
                    """
                    return PyMenu(self.service, "/display/set/titles/left_top").execute(*args, **kwargs)
                def left_bottom(self, *args, **kwargs):
                    """
                    Set the title text for left bottom in title segment.
                    """
                    return PyMenu(self.service, "/display/set/titles/left_bottom").execute(*args, **kwargs)
                def right_top(self, *args, **kwargs):
                    """
                    Set the title text for right top in title segment.
                    """
                    return PyMenu(self.service, "/display/set/titles/right_top").execute(*args, **kwargs)
                def right_middle(self, *args, **kwargs):
                    """
                    Set the title text for right middle in title segment.
                    """
                    return PyMenu(self.service, "/display/set/titles/right_middle").execute(*args, **kwargs)
                def right_bottom(self, *args, **kwargs):
                    """
                    Set the title text for right bottom in title segment.
                    """
                    return PyMenu(self.service, "/display/set/titles/right_bottom").execute(*args, **kwargs)

            class velocity_vectors(metaclass=PyMenuMeta):
                """
                Enter the menu to set parameters for display of velocity vectors.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def auto_scale(self, *args, **kwargs):
                    """
                    Enable/disable auto-scale of all vectors so that vector overlap is minimal.
                    """
                    return PyMenu(self.service, "/display/set/velocity_vectors/auto_scale").execute(*args, **kwargs)
                def color(self, *args, **kwargs):
                    """
                    Set the color used for all vectors. Set color to the null string to use the color map.
                    """
                    return PyMenu(self.service, "/display/set/velocity_vectors/color").execute(*args, **kwargs)
                def component_x(self, *args, **kwargs):
                    """
                    Enable/disable use of x-component of vectors.
                    """
                    return PyMenu(self.service, "/display/set/velocity_vectors/component_x").execute(*args, **kwargs)
                def component_y(self, *args, **kwargs):
                    """
                    Enable/disable use of y-component of vectors.
                    """
                    return PyMenu(self.service, "/display/set/velocity_vectors/component_y").execute(*args, **kwargs)
                def component_z(self, *args, **kwargs):
                    """
                    Enable/disable use of z-component of vectors.
                    """
                    return PyMenu(self.service, "/display/set/velocity_vectors/component_z").execute(*args, **kwargs)
                def constant_length(self, *args, **kwargs):
                    """
                    Enable/disable setting all vectors to have the same length.
                    """
                    return PyMenu(self.service, "/display/set/velocity_vectors/constant_length").execute(*args, **kwargs)
                def color_levels(self, *args, **kwargs):
                    """
                    Set the number of colors used from the color map.
                    """
                    return PyMenu(self.service, "/display/set/velocity_vectors/color_levels").execute(*args, **kwargs)
                def global_range(self, *args, **kwargs):
                    """
                    Enable/disable the global range for vectors option.
                    """
                    return PyMenu(self.service, "/display/set/velocity_vectors/global_range").execute(*args, **kwargs)
                def in_plane(self, *args, **kwargs):
                    """
                    Toggle the display of in-plane velocity vectors.
                    """
                    return PyMenu(self.service, "/display/set/velocity_vectors/in_plane").execute(*args, **kwargs)
                def log_scale(self, *args, **kwargs):
                    """
                    Enable/disable the use of a log scale.
                    """
                    return PyMenu(self.service, "/display/set/velocity_vectors/log_scale").execute(*args, **kwargs)
                def node_values(self, *args, **kwargs):
                    """
                    Enable/disable plotting node values. Cell values will be plotted if "no".
                    """
                    return PyMenu(self.service, "/display/set/velocity_vectors/node_values").execute(*args, **kwargs)
                def relative(self, *args, **kwargs):
                    """
                    Enable/disable the display of relative velocity vectors.
                    """
                    return PyMenu(self.service, "/display/set/velocity_vectors/relative").execute(*args, **kwargs)
                def render_mesh(self, *args, **kwargs):
                    """
                    Enable/disable rendering the mseh on top of contours, vectors, etc.
                    """
                    return PyMenu(self.service, "/display/set/velocity_vectors/render_mesh").execute(*args, **kwargs)
                def scale(self, *args, **kwargs):
                    """
                    Set the value by which the vector length will be scaled.
                    """
                    return PyMenu(self.service, "/display/set/velocity_vectors/scale").execute(*args, **kwargs)
                def scale_head(self, *args, **kwargs):
                    """
                    Set the value by which the vector head will be scaled.
                    """
                    return PyMenu(self.service, "/display/set/velocity_vectors/scale_head").execute(*args, **kwargs)
                def style(self, *args, **kwargs):
                    """
                    Set the style with which the vectors will be drawn.
                    """
                    return PyMenu(self.service, "/display/set/velocity_vectors/style").execute(*args, **kwargs)
                def surfaces(self, *args, **kwargs):
                    """
                    Set surfaces on which vectors are drawn.
                    """
                    return PyMenu(self.service, "/display/set/velocity_vectors/surfaces").execute(*args, **kwargs)

            class windows(metaclass=PyMenuMeta):
                """
                Enter the window options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.axes = self.__class__.axes(path + [("axes", None)], service)
                    self.main = self.__class__.main(path + [("main", None)], service)
                    self.scale = self.__class__.scale(path + [("scale", None)], service)
                    self.text = self.__class__.text(path + [("text", None)], service)
                    self.video = self.__class__.video(path + [("video", None)], service)
                    self.xy = self.__class__.xy(path + [("xy", None)], service)
                def aspect_ratio(self, *args, **kwargs):
                    """
                    Set the aspect ratio of the active window.
                    """
                    return PyMenu(self.service, "/display/set/windows/aspect_ratio").execute(*args, **kwargs)
                def logo(self, *args, **kwargs):
                    """
                    Enable/disable visibility of the logo in graphics window.
                    """
                    return PyMenu(self.service, "/display/set/windows/logo").execute(*args, **kwargs)
                def ruler(self, *args, **kwargs):
                    """
                    Enable/disable ruler visibility.
                    """
                    return PyMenu(self.service, "/display/set/windows/ruler").execute(*args, **kwargs)
                def logo_color(self, *args, **kwargs):
                    """
                    Set logo color to white/black.
                    """
                    return PyMenu(self.service, "/display/set/windows/logo_color").execute(*args, **kwargs)

                class axes(metaclass=PyMenuMeta):
                    """
                    Enter the axes window options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def border(self, *args, **kwargs):
                        """
                        Enable/disable drawing of a border around the axes window.
                        """
                        return PyMenu(self.service, "/display/set/windows/axes/border").execute(*args, **kwargs)
                    def bottom(self, *args, **kwargs):
                        """
                        Set the bottom boundary of the axes window.
                        """
                        return PyMenu(self.service, "/display/set/windows/axes/bottom").execute(*args, **kwargs)
                    def clear(self, *args, **kwargs):
                        """
                        Set the transparency of the axes window.
                        """
                        return PyMenu(self.service, "/display/set/windows/axes/clear").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        Set the right boundary of the axes window.
                        """
                        return PyMenu(self.service, "/display/set/windows/axes/right").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        Enable/disable axes visibility.
                        """
                        return PyMenu(self.service, "/display/set/windows/axes/visible").execute(*args, **kwargs)

                class main(metaclass=PyMenuMeta):
                    """
                    Enter the main view window options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def border(self, *args, **kwargs):
                        """
                        Enable/disable drawing of borders around the main viewing window.
                        """
                        return PyMenu(self.service, "/display/set/windows/main/border").execute(*args, **kwargs)
                    def bottom(self, *args, **kwargs):
                        """
                        Set the bottom boundary of the main viewing window.
                        """
                        return PyMenu(self.service, "/display/set/windows/main/bottom").execute(*args, **kwargs)
                    def left(self, *args, **kwargs):
                        """
                        Set the left boundary of the main viewing window.
                        """
                        return PyMenu(self.service, "/display/set/windows/main/left").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        Set the right boundary of the main viewing window.
                        """
                        return PyMenu(self.service, "/display/set/windows/main/right").execute(*args, **kwargs)
                    def top(self, *args, **kwargs):
                        """
                        Set the top boundary of the main viewing window.
                        """
                        return PyMenu(self.service, "/display/set/windows/main/top").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        Enable/disable visibility of the main viewing window.
                        """
                        return PyMenu(self.service, "/display/set/windows/main/visible").execute(*args, **kwargs)

                class scale(metaclass=PyMenuMeta):
                    """
                    Enter the color scale window options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def border(self, *args, **kwargs):
                        """
                        Enable/disable drawing of borders around the color scale window.
                        """
                        return PyMenu(self.service, "/display/set/windows/scale/border").execute(*args, **kwargs)
                    def bottom(self, *args, **kwargs):
                        """
                        Set the bottom boundary of the color scale window.
                        """
                        return PyMenu(self.service, "/display/set/windows/scale/bottom").execute(*args, **kwargs)
                    def clear(self, *args, **kwargs):
                        """
                        Set the transparency of the scale window.
                        """
                        return PyMenu(self.service, "/display/set/windows/scale/clear").execute(*args, **kwargs)
                    def format(self, *args, **kwargs):
                        """
                        Set the number format of the color scale window (e.g. %0.2e).
                        """
                        return PyMenu(self.service, "/display/set/windows/scale/format").execute(*args, **kwargs)
                    def font_size(self, *args, **kwargs):
                        """
                        Set the font size of the color scale window.
                        """
                        return PyMenu(self.service, "/display/set/windows/scale/font_size").execute(*args, **kwargs)
                    def left(self, *args, **kwargs):
                        """
                        Set the left boundary of the color scale window.
                        """
                        return PyMenu(self.service, "/display/set/windows/scale/left").execute(*args, **kwargs)
                    def margin(self, *args, **kwargs):
                        """
                        Set the margin of the color scale window.
                        """
                        return PyMenu(self.service, "/display/set/windows/scale/margin").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        Set the right boundary of the color scale window.
                        """
                        return PyMenu(self.service, "/display/set/windows/scale/right").execute(*args, **kwargs)
                    def top(self, *args, **kwargs):
                        """
                        Set the top boundary of the color scale window.
                        """
                        return PyMenu(self.service, "/display/set/windows/scale/top").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        Enable/disable visibility of the color scale window.
                        """
                        return PyMenu(self.service, "/display/set/windows/scale/visible").execute(*args, **kwargs)
                    def alignment(self, *args, **kwargs):
                        """
                        Set colormap to bottom/left/top/right.
                        """
                        return PyMenu(self.service, "/display/set/windows/scale/alignment").execute(*args, **kwargs)

                class text(metaclass=PyMenuMeta):
                    """
                    Enter the text window options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def application(self, *args, **kwargs):
                        """
                        Enable/disable the application name in the picture.
                        """
                        return PyMenu(self.service, "/display/set/windows/text/application").execute(*args, **kwargs)
                    def border(self, *args, **kwargs):
                        """
                        Enable/disable drawing of borders around the text window.
                        """
                        return PyMenu(self.service, "/display/set/windows/text/border").execute(*args, **kwargs)
                    def bottom(self, *args, **kwargs):
                        """
                        Set the bottom boundary of the text window.
                        """
                        return PyMenu(self.service, "/display/set/windows/text/bottom").execute(*args, **kwargs)
                    def clear(self, *args, **kwargs):
                        """
                        Enable/disable text window transparency.
                        """
                        return PyMenu(self.service, "/display/set/windows/text/clear").execute(*args, **kwargs)
                    def company(self, *args, **kwargs):
                        """
                        Enable/disable the company name in the picture.
                        """
                        return PyMenu(self.service, "/display/set/windows/text/company").execute(*args, **kwargs)
                    def date(self, *args, **kwargs):
                        """
                        Enable/disable the date in the picture.
                        """
                        return PyMenu(self.service, "/display/set/windows/text/date").execute(*args, **kwargs)
                    def left(self, *args, **kwargs):
                        """
                        Set the left boundary of the text window.
                        """
                        return PyMenu(self.service, "/display/set/windows/text/left").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        Set the right boundary of the text window.
                        """
                        return PyMenu(self.service, "/display/set/windows/text/right").execute(*args, **kwargs)
                    def top(self, *args, **kwargs):
                        """
                        Set the top boundary of the text window.
                        """
                        return PyMenu(self.service, "/display/set/windows/text/top").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        Enable/disable text window transparency.
                        """
                        return PyMenu(self.service, "/display/set/windows/text/visible").execute(*args, **kwargs)

                class video(metaclass=PyMenuMeta):
                    """
                    Enter the video window options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def background(self, *args, **kwargs):
                        """
                        Set the background color in the video picture.
                        """
                        return PyMenu(self.service, "/display/set/windows/video/background").execute(*args, **kwargs)
                    def color_filter(self, *args, **kwargs):
                        """
                        Set the color filter options for the picture.
                        """
                        return PyMenu(self.service, "/display/set/windows/video/color_filter").execute(*args, **kwargs)
                    def foreground(self, *args, **kwargs):
                        """
                        Set the foreground color in the video picture.
                        """
                        return PyMenu(self.service, "/display/set/windows/video/foreground").execute(*args, **kwargs)
                    def on(self, *args, **kwargs):
                        """
                        Enable/disable video picture settings.
                        """
                        return PyMenu(self.service, "/display/set/windows/video/on").execute(*args, **kwargs)
                    def pixel_size(self, *args, **kwargs):
                        """
                        Set the window size in pixels.
                        """
                        return PyMenu(self.service, "/display/set/windows/video/pixel_size").execute(*args, **kwargs)

                class xy(metaclass=PyMenuMeta):
                    """
                    Enter the X-Y plot window options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def border(self, *args, **kwargs):
                        """
                        Enable/disable drawing of a border around the X-Y plotter window.
                        """
                        return PyMenu(self.service, "/display/set/windows/xy/border").execute(*args, **kwargs)
                    def bottom(self, *args, **kwargs):
                        """
                        Set the bottom boundary of the X-Y plotter window.
                        """
                        return PyMenu(self.service, "/display/set/windows/xy/bottom").execute(*args, **kwargs)
                    def left(self, *args, **kwargs):
                        """
                        Set the left boundary of the X-Y plotter window.
                        """
                        return PyMenu(self.service, "/display/set/windows/xy/left").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        Set the right boundary of the X-Y plotter window.
                        """
                        return PyMenu(self.service, "/display/set/windows/xy/right").execute(*args, **kwargs)
                    def top(self, *args, **kwargs):
                        """
                        Set the top boundary of the X-Y plotter window.
                        """
                        return PyMenu(self.service, "/display/set/windows/xy/top").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        Enable/disable X-Y plotter window visibility.
                        """
                        return PyMenu(self.service, "/display/set/windows/xy/visible").execute(*args, **kwargs)

        class surface(metaclass=PyMenuMeta):
            """
            Enter the data surface manipulation menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.post_processing_volume = self.__class__.post_processing_volume(path + [("post_processing_volume", None)], service)
                self.query = self.__class__.query(path + [("query", None)], service)
            def circle_slice(self, *args, **kwargs):
                """
                Extract a circular slice.
                """
                return PyMenu(self.service, "/display/surface/circle_slice").execute(*args, **kwargs)
            def delete_surface(self, *args, **kwargs):
                """
                Remove a defined data surface.
                """
                return PyMenu(self.service, "/display/surface/delete_surface").execute(*args, **kwargs)
            def group_surfaces(self, *args, **kwargs):
                """
                Group a set of surfaces.
                """
                return PyMenu(self.service, "/display/surface/group_surfaces").execute(*args, **kwargs)
            def ungroup_surface(self, *args, **kwargs):
                """
                Ungroup the surface(if grouped).
                """
                return PyMenu(self.service, "/display/surface/ungroup_surface").execute(*args, **kwargs)
            def iso_clip(self, *args, **kwargs):
                """
                Clip a data surface (surface, curve, or point) between two iso-values.
                """
                return PyMenu(self.service, "/display/surface/iso_clip").execute(*args, **kwargs)
            def iso_surface(self, *args, **kwargs):
                """
                Extract an iso-surface (surface, curve, or point) from the curent data field.
                """
                return PyMenu(self.service, "/display/surface/iso_surface").execute(*args, **kwargs)
            def expression_volume(self, *args, **kwargs):
                """
                Create volume with boolean expression.
                """
                return PyMenu(self.service, "/display/surface/expression_volume").execute(*args, **kwargs)
            def multiple_iso_surfaces(self, *args, **kwargs):
                """
                Create multiple iso-surfaces from the data field at specified spacing.
                """
                return PyMenu(self.service, "/display/surface/multiple_iso_surfaces").execute(*args, **kwargs)
            def line_slice(self, *args, **kwargs):
                """
                Extract a linear slice.
                """
                return PyMenu(self.service, "/display/surface/line_slice").execute(*args, **kwargs)
            def line_surface(self, *args, **kwargs):
                """
                Define a "line" surface by specifying the two endpoint coordinates.
                """
                return PyMenu(self.service, "/display/surface/line_surface").execute(*args, **kwargs)
            def list_surfaces(self, *args, **kwargs):
                """
                List the number of facets in the defined surfaces.
                """
                return PyMenu(self.service, "/display/surface/list_surfaces").execute(*args, **kwargs)
            def mouse_line(self, *args, **kwargs):
                """
                Define a line surface using the mouse to select two points.
                """
                return PyMenu(self.service, "/display/surface/mouse_line").execute(*args, **kwargs)
            def mouse_plane(self, *args, **kwargs):
                """
                Define a plane surface using the mouse to select three points.
                """
                return PyMenu(self.service, "/display/surface/mouse_plane").execute(*args, **kwargs)
            def mouse_rake(self, *args, **kwargs):
                """
                Define a "rake" surface using the mouse to select the end points.
                """
                return PyMenu(self.service, "/display/surface/mouse_rake").execute(*args, **kwargs)
            def partition_surface(self, *args, **kwargs):
                """
                Define a data surface on mesh faces on the partition boundary.
                """
                return PyMenu(self.service, "/display/surface/partition_surface").execute(*args, **kwargs)
            def plane(self, *args, **kwargs):
                """
                Create a plane given 3 points bounded by the domain.
                """
                return PyMenu(self.service, "/display/surface/plane").execute(*args, **kwargs)
            def plane_surface(self, *args, **kwargs):
                """
                Create a plane from a coordinate plane, point and normal, or three points.
                """
                return PyMenu(self.service, "/display/surface/plane_surface").execute(*args, **kwargs)
            def multiple_plane_surfaces(self, *args, **kwargs):
                """
                Create multiple plane surfaces at specified spacing.
                """
                return PyMenu(self.service, "/display/surface/multiple_plane_surfaces").execute(*args, **kwargs)
            def plane_slice(self, *args, **kwargs):
                """
                Extract a planar slice.
                """
                return PyMenu(self.service, "/display/surface/plane_slice").execute(*args, **kwargs)
            def point_array(self, *args, **kwargs):
                """
                Extract a rectangular array of data points.
                """
                return PyMenu(self.service, "/display/surface/point_array").execute(*args, **kwargs)
            def point_surface(self, *args, **kwargs):
                """
                Define a "point" surface by specifying the coordinates.
                """
                return PyMenu(self.service, "/display/surface/point_surface").execute(*args, **kwargs)
            def structural_point_surface(self, *args, **kwargs):
                """
                Define a "structural point" surface by specifying the coordinates.
                """
                return PyMenu(self.service, "/display/surface/structural_point_surface").execute(*args, **kwargs)
            def quadric_slice(self, *args, **kwargs):
                """
                Extract a quadric slice.
                """
                return PyMenu(self.service, "/display/surface/quadric_slice").execute(*args, **kwargs)
            def rake_surface(self, *args, **kwargs):
                """
                Define a "rake" surface by specifying the end points.
                """
                return PyMenu(self.service, "/display/surface/rake_surface").execute(*args, **kwargs)
            def rename_surface(self, *args, **kwargs):
                """
                Rename a defined data surface.
                """
                return PyMenu(self.service, "/display/surface/rename_surface").execute(*args, **kwargs)
            def sphere_slice(self, *args, **kwargs):
                """
                Extract a spherical slice.
                """
                return PyMenu(self.service, "/display/surface/sphere_slice").execute(*args, **kwargs)
            def ellipsoid_slice(self, *args, **kwargs):
                """
                Extract a ellipsoid slice.
                """
                return PyMenu(self.service, "/display/surface/ellipsoid_slice").execute(*args, **kwargs)
            def cone_slice(self, *args, **kwargs):
                """
                Extract a cone slice.
                """
                return PyMenu(self.service, "/display/surface/cone_slice").execute(*args, **kwargs)
            def surface_cells(self, *args, **kwargs):
                """
                Extract all cells intersected by a data surface.
                """
                return PyMenu(self.service, "/display/surface/surface_cells").execute(*args, **kwargs)
            def transform_surface(self, *args, **kwargs):
                """
                Transform surface.
                """
                return PyMenu(self.service, "/display/surface/transform_surface").execute(*args, **kwargs)
            def create_imprint_surface(self, *args, **kwargs):
                """
                Imprint surface.
                """
                return PyMenu(self.service, "/display/surface/create_imprint_surface").execute(*args, **kwargs)
            def zone_surface(self, *args, **kwargs):
                """
                Define a data surface on a mesh zone.
                """
                return PyMenu(self.service, "/display/surface/zone_surface").execute(*args, **kwargs)
            def reset_zone_surfaces(self, *args, **kwargs):
                """
                Reset case surface list.
                """
                return PyMenu(self.service, "/display/surface/reset_zone_surfaces").execute(*args, **kwargs)
            def multiple_zone_surfaces(self, *args, **kwargs):
                """
                Create multiple data surfaces at a time.
                """
                return PyMenu(self.service, "/display/surface/multiple_zone_surfaces").execute(*args, **kwargs)
            def edit_surface(self, *args, **kwargs):
                """
                Edit a defined data surface.
                """
                return PyMenu(self.service, "/display/surface/edit_surface").execute(*args, **kwargs)

            class post_processing_volume(metaclass=PyMenuMeta):
                """
                Enter post-processing volume menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def create_from_file(self, *args, **kwargs):
                    """
                    Read post-processing mesh from file.
                    """
                    return PyMenu(self.service, "/display/surface/post_processing_volume/create_from_file").execute(*args, **kwargs)
                def create_octree(self, *args, **kwargs):
                    """
                    Create post-processing octree mesh based on current case.
                    """
                    return PyMenu(self.service, "/display/surface/post_processing_volume/create_octree").execute(*args, **kwargs)

            class query(metaclass=PyMenuMeta):
                """
                Enter surface query menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def delete_query(self, *args, **kwargs):
                    """
                    Delete saved query.
                    """
                    return PyMenu(self.service, "/display/surface/query/delete_query").execute(*args, **kwargs)
                def list_surfaces(self, *args, **kwargs):
                    """
                    List surfaces.
                    """
                    return PyMenu(self.service, "/display/surface/query/list_surfaces").execute(*args, **kwargs)
                def named_surface_list(self, *args, **kwargs):
                    """
                    Create named list of surfaces.
                    """
                    return PyMenu(self.service, "/display/surface/query/named_surface_list").execute(*args, **kwargs)
                def list_named_selection(self, *args, **kwargs):
                    """
                    List named selection of surface type.
                    """
                    return PyMenu(self.service, "/display/surface/query/list_named_selection").execute(*args, **kwargs)
                def list_queries(self, *args, **kwargs):
                    """
                    List all saved queries.
                    """
                    return PyMenu(self.service, "/display/surface/query/list_queries").execute(*args, **kwargs)

        class views(metaclass=PyMenuMeta):
            """
            Enter the view manipulation menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.camera = self.__class__.camera(path + [("camera", None)], service)
            def auto_scale(self, *args, **kwargs):
                """
                Scale and center the current scene.
                """
                return PyMenu(self.service, "/display/views/auto_scale").execute(*args, **kwargs)
            def default_view(self, *args, **kwargs):
                """
                Reset view to front and center.
                """
                return PyMenu(self.service, "/display/views/default_view").execute(*args, **kwargs)
            def delete_view(self, *args, **kwargs):
                """
                Remove a view from the list.
                """
                return PyMenu(self.service, "/display/views/delete_view").execute(*args, **kwargs)
            def last_view(self, *args, **kwargs):
                """
                Return to the camera position before the last manipulation.
                """
                return PyMenu(self.service, "/display/views/last_view").execute(*args, **kwargs)
            def next_view(self, *args, **kwargs):
                """
                Return to the camera position after the current position in the stack.
                """
                return PyMenu(self.service, "/display/views/next_view").execute(*args, **kwargs)
            def list_views(self, *args, **kwargs):
                """
                List predefined and saved views.
                """
                return PyMenu(self.service, "/display/views/list_views").execute(*args, **kwargs)
            def restore_view(self, *args, **kwargs):
                """
                Use a saved view.
                """
                return PyMenu(self.service, "/display/views/restore_view").execute(*args, **kwargs)
            def read_views(self, *args, **kwargs):
                """
                Read views from a view file.
                """
                return PyMenu(self.service, "/display/views/read_views").execute(*args, **kwargs)
            def save_view(self, *args, **kwargs):
                """
                Save the current view to the view list.
                """
                return PyMenu(self.service, "/display/views/save_view").execute(*args, **kwargs)
            def write_views(self, *args, **kwargs):
                """
                Write selected views to a view file.
                """
                return PyMenu(self.service, "/display/views/write_views").execute(*args, **kwargs)

            class camera(metaclass=PyMenuMeta):
                """
                Enter the camera menu to modify the current viewing parameters.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def dolly_camera(self, *args, **kwargs):
                    """
                    Adjust the camera position and target.
                    """
                    return PyMenu(self.service, "/display/views/camera/dolly_camera").execute(*args, **kwargs)
                def field(self, *args, **kwargs):
                    """
                    Set the field of view (width and height).
                    """
                    return PyMenu(self.service, "/display/views/camera/field").execute(*args, **kwargs)
                def orbit_camera(self, *args, **kwargs):
                    """
                    Adjust the camera position without modifying the target.
                    """
                    return PyMenu(self.service, "/display/views/camera/orbit_camera").execute(*args, **kwargs)
                def pan_camera(self, *args, **kwargs):
                    """
                    Adjust the camera target without modifying the position.
                    """
                    return PyMenu(self.service, "/display/views/camera/pan_camera").execute(*args, **kwargs)
                def position(self, *args, **kwargs):
                    """
                    Set the camera position.
                    """
                    return PyMenu(self.service, "/display/views/camera/position").execute(*args, **kwargs)
                def projection(self, *args, **kwargs):
                    """
                    Set the camera projection type.
                    """
                    return PyMenu(self.service, "/display/views/camera/projection").execute(*args, **kwargs)
                def roll_camera(self, *args, **kwargs):
                    """
                    Adjust the camera up-vector.
                    """
                    return PyMenu(self.service, "/display/views/camera/roll_camera").execute(*args, **kwargs)
                def target(self, *args, **kwargs):
                    """
                    Set the point to be the center of the camera view.
                    """
                    return PyMenu(self.service, "/display/views/camera/target").execute(*args, **kwargs)
                def up_vector(self, *args, **kwargs):
                    """
                    Set the camera up-vector.
                    """
                    return PyMenu(self.service, "/display/views/camera/up_vector").execute(*args, **kwargs)
                def zoom_camera(self, *args, **kwargs):
                    """
                    Adjust the camera field of view.
                    """
                    return PyMenu(self.service, "/display/views/camera/zoom_camera").execute(*args, **kwargs)

        class display_states(metaclass=PyMenuMeta):
            """
            Enter the display state manipulation menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def list(self, *args, **kwargs):
                """
                Print the names of the available display states to the console.
                """
                return PyMenu(self.service, "/display/display_states/list").execute(*args, **kwargs)
            def apply(self, *args, **kwargs):
                """
                Apply a display state to the active window.
                """
                return PyMenu(self.service, "/display/display_states/apply").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete a display state.
                """
                return PyMenu(self.service, "/display/display_states/delete").execute(*args, **kwargs)
            def use_active(self, *args, **kwargs):
                """
                Update an existing display state's settings to match those of the active graphics window.
                """
                return PyMenu(self.service, "/display/display_states/use_active").execute(*args, **kwargs)
            def copy(self, *args, **kwargs):
                """
                Create a new display state with settings copied from an existing display state.
                """
                return PyMenu(self.service, "/display/display_states/copy").execute(*args, **kwargs)
            def read(self, *args, **kwargs):
                """
                Read display states from a file.
                """
                return PyMenu(self.service, "/display/display_states/read").execute(*args, **kwargs)
            def write(self, *args, **kwargs):
                """
                Write display states to a file.
                """
                return PyMenu(self.service, "/display/display_states/write").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit a particular display state setting.
                """
                return PyMenu(self.service, "/display/display_states/edit").execute(*args, **kwargs)
            def create(self, *args, **kwargs):
                """
                Create a new display state.
                """
                return PyMenu(self.service, "/display/display_states/create").execute(*args, **kwargs)

        class view_sync(metaclass=PyMenuMeta):
            """
            Synchronize window views.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def list(self, *args, **kwargs):
                """
                Print window ids of open windows.
                """
                return PyMenu(self.service, "/display/view_sync/list").execute(*args, **kwargs)
            def start(self, *args, **kwargs):
                """
                Start view synchronization.
                """
                return PyMenu(self.service, "/display/view_sync/start").execute(*args, **kwargs)
            def stop(self, *args, **kwargs):
                """
                Stop view synchronization.
                """
                return PyMenu(self.service, "/display/view_sync/stop").execute(*args, **kwargs)
            def remove_all(self, *args, **kwargs):
                """
                Unsynchronize all windows.
                """
                return PyMenu(self.service, "/display/view_sync/remove_all").execute(*args, **kwargs)
            def add_all(self, *args, **kwargs):
                """
                Synchronize all windows.
                """
                return PyMenu(self.service, "/display/view_sync/add_all").execute(*args, **kwargs)
            def add(self, *args, **kwargs):
                """
                Add list of window ids for synchronization.
                """
                return PyMenu(self.service, "/display/view_sync/add").execute(*args, **kwargs)
            def remove(self, *args, **kwargs):
                """
                Remove list of window ids from synchronization.
                """
                return PyMenu(self.service, "/display/view_sync/remove").execute(*args, **kwargs)

        class update_scene(metaclass=PyMenuMeta):
            """
            Enter the scene options menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def select_geometry(self, *args, **kwargs):
                """
                Select geometry to be updated.
                """
                return PyMenu(self.service, "/display/update_scene/select_geometry").execute(*args, **kwargs)
            def overlays(self, *args, **kwargs):
                """
                Enable/disable the overlays option.
                """
                return PyMenu(self.service, "/display/update_scene/overlays").execute(*args, **kwargs)
            def draw_frame(self, *args, **kwargs):
                """
                Enable/disable drawing of the bounding frame.
                """
                return PyMenu(self.service, "/display/update_scene/draw_frame").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete selected geometries.
                """
                return PyMenu(self.service, "/display/update_scene/delete").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                Display selected geometries.
                """
                return PyMenu(self.service, "/display/update_scene/display").execute(*args, **kwargs)
            def transform(self, *args, **kwargs):
                """
                Apply transformation matrix on selected geometries.
                """
                return PyMenu(self.service, "/display/update_scene/transform").execute(*args, **kwargs)
            def pathline(self, *args, **kwargs):
                """
                Change pathline attributes.
                """
                return PyMenu(self.service, "/display/update_scene/pathline").execute(*args, **kwargs)
            def iso_sweep(self, *args, **kwargs):
                """
                Change iso-sweep values.
                """
                return PyMenu(self.service, "/display/update_scene/iso_sweep").execute(*args, **kwargs)
            def time(self, *args, **kwargs):
                """
                Change time-step value.
                """
                return PyMenu(self.service, "/display/update_scene/time").execute(*args, **kwargs)
            def set_frame(self, *args, **kwargs):
                """
                Change frame options.
                """
                return PyMenu(self.service, "/display/update_scene/set_frame").execute(*args, **kwargs)

        class inverse_dft(metaclass=PyMenuMeta):
            """
            Reconstruct DFT signal.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def set(self, *args, **kwargs):
                """
                Set reconstruction parameters.
                """
                return PyMenu(self.service, "/display/inverse_dft/set").execute(*args, **kwargs)
            def reconstruct(self, *args, **kwargs):
                """
                Make inverse DFT recontruction.
                """
                return PyMenu(self.service, "/display/inverse_dft/reconstruct").execute(*args, **kwargs)

    class define(metaclass=PyMenuMeta):
        """
        Enter the define menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
            self.boundary_conditions = self.__class__.boundary_conditions(path + [("boundary_conditions", None)], service)
            self.spectral = self.__class__.spectral(path + [("spectral", None)], service)
            self.custom_field_functions = self.__class__.custom_field_functions(path + [("custom_field_functions", None)], service)
            self.dynamic_mesh = self.__class__.dynamic_mesh(path + [("dynamic_mesh", None)], service)
            self.mesh_interfaces = self.__class__.mesh_interfaces(path + [("mesh_interfaces", None)], service)
            self.gap_model = self.__class__.gap_model(path + [("gap_model", None)], service)
            self.materials = self.__class__.materials(path + [("materials", None)], service)
            self.mixing_planes = self.__class__.mixing_planes(path + [("mixing_planes", None)], service)
            self.models = self.__class__.models(path + [("models", None)], service)
            self.overset_interfaces = self.__class__.overset_interfaces(path + [("overset_interfaces", None)], service)
            self.operating_conditions = self.__class__.operating_conditions(path + [("operating_conditions", None)], service)
            self.parameters = self.__class__.parameters(path + [("parameters", None)], service)
            self.periodic_conditions = self.__class__.periodic_conditions(path + [("periodic_conditions", None)], service)
            self.turbo_model = self.__class__.turbo_model(path + [("turbo_model", None)], service)
            self.phases = self.__class__.phases(path + [("phases", None)], service)
            self.profiles = self.__class__.profiles(path + [("profiles", None)], service)
            self.solution_strategy = self.__class__.solution_strategy(path + [("solution_strategy", None)], service)
            self.reference_frames = self.__class__.reference_frames(path + [("reference_frames", None)], service)
            self.user_defined = self.__class__.user_defined(path + [("user_defined", None)], service)
            self.named_expressions = self.__class__.named_expressions(path + [("named_expressions", None)], service)
            self.virtual_boundary = self.__class__.virtual_boundary(path + [("virtual_boundary", None)], service)
            self.curvilinear_coordinate_system = self.__class__.curvilinear_coordinate_system(path + [("curvilinear_coordinate_system", None)], service)
        def beta_feature_access(self, *args, **kwargs):
            """
            Enable access to beta features in the interface.
            """
            return PyMenu(self.service, "/define/beta_feature_access").execute(*args, **kwargs)
        def physics(self, *args, **kwargs):
            """
            Manage Physics-regions.
            """
            return PyMenu(self.service, "/define/physics").execute(*args, **kwargs)
        def injections(self, *args, **kwargs):
            """
            Enter the injections menu.
            """
            return PyMenu(self.service, "/define/injections").execute(*args, **kwargs)
        def enable_mesh_morpher_optimizer(self, *args, **kwargs):
            """
            Enable use of mesh morpher/optimizer.
            """
            return PyMenu(self.service, "/define/enable_mesh_morpher_optimizer").execute(*args, **kwargs)
        def units(self, *args, **kwargs):
            """
            Set unit conversion factors.
            """
            return PyMenu(self.service, "/define/units").execute(*args, **kwargs)
        def set_unit_system(self, *args, **kwargs):
            """
            To apply standard set of units to all quantities.
            """
            return PyMenu(self.service, "/define/set_unit_system").execute(*args, **kwargs)

        class boundary_conditions(metaclass=PyMenuMeta):
            """
            Enter the boundary conditions menu.
            """
            is_extended_tui = True
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.mass_flow_inlet = self.__class__.mass_flow_inlet(path + [("mass_flow_inlet", None)], None, service)
                self.modify_zones = self.__class__.modify_zones(path + [("modify_zones", None)], service)
                self.periodic = self.__class__.periodic(path + [("periodic", None)], None, service)
                self.pressure_far_field = self.__class__.pressure_far_field(path + [("pressure_far_field", None)], None, service)
                self.pressure_inlet = self.__class__.pressure_inlet(path + [("pressure_inlet", None)], None, service)
                self.pressure_outlet = self.__class__.pressure_outlet(path + [("pressure_outlet", None)], None, service)
                self.symmetry = self.__class__.symmetry(path + [("symmetry", None)], None, service)
                self.velocity_inlet = self.__class__.velocity_inlet(path + [("velocity_inlet", None)], None, service)
                self.wall = self.__class__.wall(path + [("wall", None)], None, service)
                self.non_reflecting_bc = self.__class__.non_reflecting_bc(path + [("non_reflecting_bc", None)], service)
                self.rename_zone = self.__class__.rename_zone(path + [("rename_zone", None)], service)
                self.bc_settings = self.__class__.bc_settings(path + [("bc_settings", None)], service)
                self.perforated_walls = self.__class__.perforated_walls(path + [("perforated_walls", None)], service)
                self.set = self.__class__.set(path + [("set", None)], service)
                self.impedance_data_fitting = self.__class__.impedance_data_fitting(path + [("impedance_data_fitting", None)], service)
            def axis(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/axis").execute(*args, **kwargs)
            def copy_bc(self, *args, **kwargs):
                """
                Copy boundary conditions to another zone.
                """
                return PyMenu(self.service, "/define/boundary_conditions/copy_bc").execute(*args, **kwargs)
            def degassing(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/degassing").execute(*args, **kwargs)
            def exhaust_fan(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/exhaust_fan").execute(*args, **kwargs)
            def fan(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/fan").execute(*args, **kwargs)
            def fluid(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/fluid").execute(*args, **kwargs)
            def geometry(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/geometry").execute(*args, **kwargs)
            def inlet_vent(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/inlet_vent").execute(*args, **kwargs)
            def intake_fan(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/intake_fan").execute(*args, **kwargs)
            def interface(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/interface").execute(*args, **kwargs)
            def interior(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/interior").execute(*args, **kwargs)
            def list_zones(self, *args, **kwargs):
                """
                List zone IDs, types, kinds, and names.
                """
                return PyMenu(self.service, "/define/boundary_conditions/list_zones").execute(*args, **kwargs)
            def mass_flow_outlet(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/mass_flow_outlet").execute(*args, **kwargs)
            def network(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/network").execute(*args, **kwargs)
            def network_end(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/network_end").execute(*args, **kwargs)
            def openchannel_threads(self, *args, **kwargs):
                """
                List open channel group IDs, names, types, and variables.
                """
                return PyMenu(self.service, "/define/boundary_conditions/openchannel_threads").execute(*args, **kwargs)
            def open_channel_wave_settings(self, *args, **kwargs):
                """
                Open channel wave input analysis.
                """
                return PyMenu(self.service, "/define/boundary_conditions/open_channel_wave_settings").execute(*args, **kwargs)
            def outflow(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/outflow").execute(*args, **kwargs)
            def outlet_vent(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/outlet_vent").execute(*args, **kwargs)
            def overset(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/overset").execute(*args, **kwargs)
            def porous_jump(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/porous_jump").execute(*args, **kwargs)
            def radiator(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/radiator").execute(*args, **kwargs)
            def rans_les_interface(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/rans_les_interface").execute(*args, **kwargs)
            def recirculation_inlet(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/recirculation_inlet").execute(*args, **kwargs)
            def recirculation_outlet(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/recirculation_outlet").execute(*args, **kwargs)
            def shadow(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/shadow").execute(*args, **kwargs)
            def solid(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/solid").execute(*args, **kwargs)
            def zone_name(self, *args, **kwargs):
                """
                Give a zone a new name.
                """
                return PyMenu(self.service, "/define/boundary_conditions/zone_name").execute(*args, **kwargs)
            def zone_type(self, *args, **kwargs):
                """
                Set a zone's type.
                """
                return PyMenu(self.service, "/define/boundary_conditions/zone_type").execute(*args, **kwargs)
            def target_mass_flow_rate_settings(self, *args, **kwargs):
                """
                Enter the targeted mass flow rate setting menu.
                """
                return PyMenu(self.service, "/define/boundary_conditions/target_mass_flow_rate_settings").execute(*args, **kwargs)
            def non_overlapping_zone_name(self, *args, **kwargs):
                """
                Get non-overlapping zone name from the associated interface zone.
                """
                return PyMenu(self.service, "/define/boundary_conditions/non_overlapping_zone_name").execute(*args, **kwargs)
            def knudsen_number_calculator(self, *args, **kwargs):
                """
                Utility to compute Kudsen number based on characteristic length and boundary information.
                """
                return PyMenu(self.service, "/define/boundary_conditions/knudsen_number_calculator").execute(*args, **kwargs)

            class mass_flow_inlet(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.flow_spec = self.__class__.flow_spec(path + [("flow_spec", None)], service)
                    self.mass_flow = self.__class__.mass_flow(path + [("mass_flow", None)], service)
                    self.ec_mass_flow = self.__class__.ec_mass_flow(path + [("ec_mass_flow", None)], service)
                    self.mass_flux = self.__class__.mass_flux(path + [("mass_flux", None)], service)
                    self.mass_flux_ave = self.__class__.mass_flux_ave(path + [("mass_flux_ave", None)], service)
                    self.tref = self.__class__.tref(path + [("tref", None)], service)
                    self.pref = self.__class__.pref(path + [("pref", None)], service)
                    self.p = self.__class__.p(path + [("p", None)], service)
                    self.direction_spec = self.__class__.direction_spec(path + [("direction_spec", None)], service)
                    self.impedance_0 = self.__class__.impedance_0(path + [("impedance_0", None)], service)
                    self.frame_of_reference = self.__class__.frame_of_reference(path + [("frame_of_reference", None)], service)
                    self.coordinate_system = self.__class__.coordinate_system(path + [("coordinate_system", None)], service)
                    self.ni = self.__class__.ni(path + [("ni", None)], service)
                    self.nj = self.__class__.nj(path + [("nj", None)], service)
                    self.nk = self.__class__.nk(path + [("nk", None)], service)
                    self.ni2 = self.__class__.ni2(path + [("ni2", None)], service)
                    self.nj2 = self.__class__.nj2(path + [("nj2", None)], service)
                    self.nk2 = self.__class__.nk2(path + [("nk2", None)], service)
                    self.ai = self.__class__.ai(path + [("ai", None)], service)
                    self.aj = self.__class__.aj(path + [("aj", None)], service)
                    self.ak = self.__class__.ak(path + [("ak", None)], service)
                    self.x_origin = self.__class__.x_origin(path + [("x_origin", None)], service)
                    self.y_origin = self.__class__.y_origin(path + [("y_origin", None)], service)
                    self.z_origin = self.__class__.z_origin(path + [("z_origin", None)], service)
                    self.ke_spec = self.__class__.ke_spec(path + [("ke_spec", None)], service)
                    self.nut = self.__class__.nut(path + [("nut", None)], service)
                    self.kl = self.__class__.kl(path + [("kl", None)], service)
                    self.intermit = self.__class__.intermit(path + [("intermit", None)], service)
                    self.k = self.__class__.k(path + [("k", None)], service)
                    self.e = self.__class__.e(path + [("e", None)], service)
                    self.o = self.__class__.o(path + [("o", None)], service)
                    self.v2 = self.__class__.v2(path + [("v2", None)], service)
                    self.turb_intensity = self.__class__.turb_intensity(path + [("turb_intensity", None)], service)
                    self.turb_length_scale = self.__class__.turb_length_scale(path + [("turb_length_scale", None)], service)
                    self.turb_hydraulic_diam = self.__class__.turb_hydraulic_diam(path + [("turb_hydraulic_diam", None)], service)
                    self.turb_viscosity_ratio = self.__class__.turb_viscosity_ratio(path + [("turb_viscosity_ratio", None)], service)
                    self.turb_viscosity_ratio_profile = self.__class__.turb_viscosity_ratio_profile(path + [("turb_viscosity_ratio_profile", None)], service)
                    self.rst_spec = self.__class__.rst_spec(path + [("rst_spec", None)], service)
                    self.uu = self.__class__.uu(path + [("uu", None)], service)
                    self.vv = self.__class__.vv(path + [("vv", None)], service)
                    self.ww = self.__class__.ww(path + [("ww", None)], service)
                    self.uv = self.__class__.uv(path + [("uv", None)], service)
                    self.vw = self.__class__.vw(path + [("vw", None)], service)
                    self.uw = self.__class__.uw(path + [("uw", None)], service)
                    self.ksgs_spec = self.__class__.ksgs_spec(path + [("ksgs_spec", None)], service)
                    self.ksgs = self.__class__.ksgs(path + [("ksgs", None)], service)
                    self.sgs_turb_intensity = self.__class__.sgs_turb_intensity(path + [("sgs_turb_intensity", None)], service)
                    self.swirl_model = self.__class__.swirl_model(path + [("swirl_model", None)], service)
                    self.swirl_factor = self.__class__.swirl_factor(path + [("swirl_factor", None)], service)
                    self.x_fan_origin = self.__class__.x_fan_origin(path + [("x_fan_origin", None)], service)
                    self.y_fan_origin = self.__class__.y_fan_origin(path + [("y_fan_origin", None)], service)
                    self.z_fan_origin = self.__class__.z_fan_origin(path + [("z_fan_origin", None)], service)
                    self.wsf = self.__class__.wsf(path + [("wsf", None)], service)
                    self.wsb = self.__class__.wsb(path + [("wsb", None)], service)
                    self.wsn = self.__class__.wsn(path + [("wsn", None)], service)
                    self.slip_velocity = self.__class__.slip_velocity(path + [("slip_velocity", None)], service)
                    self.velocity_ratio = self.__class__.velocity_ratio(path + [("velocity_ratio", None)], service)
                    self.volume_frac = self.__class__.volume_frac(path + [("volume_frac", None)], service)
                    self.granular_temperature = self.__class__.granular_temperature(path + [("granular_temperature", None)], service)
                    self.ac_options = self.__class__.ac_options(path + [("ac_options", None)], service)
                    self.ac_wave = self.__class__.ac_wave(path + [("ac_wave", None)], service)
                    self.t0 = self.__class__.t0(path + [("t0", None)], service)

                class flow_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class mass_flow(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ec_mass_flow(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class mass_flux(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class mass_flux_ave(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class tref(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class pref(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class p(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class direction_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class impedance_0(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class frame_of_reference(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class coordinate_system(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ni(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nk(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ni2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nj2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nk2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ai(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class aj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ak(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class x_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class y_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class z_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ke_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nut(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class kl(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class intermit(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class k(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class e(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class o(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class v2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_length_scale(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_hydraulic_diam(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio_profile(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class rst_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uu(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ww(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class sgs_turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class swirl_model(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class swirl_factor(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class x_fan_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class y_fan_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class z_fan_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wsf(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wsb(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wsn(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class slip_velocity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class velocity_ratio(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class volume_frac(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class granular_temperature(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ac_options(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ac_wave(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class t0(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

            class modify_zones(metaclass=PyMenuMeta):
                """
                Enter the modify zones menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def activate_cell_zone(self, *args, **kwargs):
                    """
                    Activate a cell thread.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/activate_cell_zone").execute(*args, **kwargs)
                def append_mesh(self, *args, **kwargs):
                    """
                    Append new mesh.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/append_mesh").execute(*args, **kwargs)
                def append_mesh_data(self, *args, **kwargs):
                    """
                    Append new mesh with data.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/append_mesh_data").execute(*args, **kwargs)
                def copy_move_cell_zone(self, *args, **kwargs):
                    """
                    Copy and translate or rotate a cell zone.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/copy_move_cell_zone").execute(*args, **kwargs)
                def create_all_shell_threads(self, *args, **kwargs):
                    """
                    Mark all finite thickness wall for shell creation. Shell zones will be created at the start of iterations.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/create_all_shell_threads").execute(*args, **kwargs)
                def deactivate_cell_zone(self, *args, **kwargs):
                    """
                    Deactivate cell thread.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/deactivate_cell_zone").execute(*args, **kwargs)
                def recreate_all_shells(self, *args, **kwargs):
                    """
                    Create shell on all the walls where which were deleted using the command delete-all-shells.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/recreate_all_shells").execute(*args, **kwargs)
                def delete_all_shells(self, *args, **kwargs):
                    """
                    Delete all shell zones and switch off shell conduction on all the walls. These zones can be recreated using the command recreate-all-shells.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/delete_all_shells").execute(*args, **kwargs)
                def delete_cell_zone(self, *args, **kwargs):
                    """
                    Delete a cell thread.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/delete_cell_zone").execute(*args, **kwargs)
                def extrude_face_zone_delta(self, *args, **kwargs):
                    """
                    Extrude a face thread a specified distance based on a list of deltas.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/extrude_face_zone_delta").execute(*args, **kwargs)
                def extrude_face_zone_para(self, *args, **kwargs):
                    """
                    Extrude a face thread a specified distance based on a distance and a list of parametric locations between 0 and 1 (eg. 0 0.2 0.4 0.8 1.0).
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/extrude_face_zone_para").execute(*args, **kwargs)
                def fuse_face_zones(self, *args, **kwargs):
                    """
                    Attempt to fuse zones by removing duplicate faces and nodes.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/fuse_face_zones").execute(*args, **kwargs)
                def list_zones(self, *args, **kwargs):
                    """
                    List zone IDs, types, kinds, and names.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/list_zones").execute(*args, **kwargs)
                def make_periodic(self, *args, **kwargs):
                    """
                    Attempt to establish periodic/shadow face zone connectivity.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/make_periodic").execute(*args, **kwargs)
                def create_periodic_interface(self, *args, **kwargs):
                    """
                    Create a conformal or non-conformal periodic interface.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/create_periodic_interface").execute(*args, **kwargs)
                def scale_zone(self, *args, **kwargs):
                    """
                    Scale nodal coordinates of input cell zones.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/scale_zone").execute(*args, **kwargs)
                def rotate_zone(self, *args, **kwargs):
                    """
                    Rotate nodal coordinates of input cell zones.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/rotate_zone").execute(*args, **kwargs)
                def translate_zone(self, *args, **kwargs):
                    """
                    Translate nodal coordinates of input cell zones.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/translate_zone").execute(*args, **kwargs)
                def matching_tolerance(self, *args, **kwargs):
                    """
                    Set the normalized tolerance used for finding coincident nodes.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/matching_tolerance").execute(*args, **kwargs)
                def merge_zones(self, *args, **kwargs):
                    """
                    Merge zones of the same type and condition into one.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/merge_zones").execute(*args, **kwargs)
                def mrf_to_sliding_mesh(self, *args, **kwargs):
                    """
                    Change motion specification from MRF to moving mesh.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/mrf_to_sliding_mesh").execute(*args, **kwargs)
                def convert_all_solid_mrf_to_solid_motion(self, *args, **kwargs):
                    """
                    Change all solid zones motion specification from MRF to solid motion.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/convert_all_solid_mrf_to_solid_motion").execute(*args, **kwargs)
                def orient_face_zone(self, *args, **kwargs):
                    """
                    Orient the face zone.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/orient_face_zone").execute(*args, **kwargs)
                def replace_zone(self, *args, **kwargs):
                    """
                    Replace a cell zone.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/replace_zone").execute(*args, **kwargs)
                def sep_cell_zone_mark(self, *args, **kwargs):
                    """
                    Separate a cell zone based on cell marking.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/sep_cell_zone_mark").execute(*args, **kwargs)
                def sep_cell_zone_region(self, *args, **kwargs):
                    """
                    Separate a cell zone based on contiguous regions.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/sep_cell_zone_region").execute(*args, **kwargs)
                def sep_face_zone_angle(self, *args, **kwargs):
                    """
                    Separate a face zone based on significant angle.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/sep_face_zone_angle").execute(*args, **kwargs)
                def sep_face_zone_face(self, *args, **kwargs):
                    """
                    Separate each face in a zone into unique zone.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/sep_face_zone_face").execute(*args, **kwargs)
                def sep_face_zone_mark(self, *args, **kwargs):
                    """
                    Separate a face zone based on cell marking.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/sep_face_zone_mark").execute(*args, **kwargs)
                def sep_face_zone_region(self, *args, **kwargs):
                    """
                    Separate a face zone based on contiguous regions.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/sep_face_zone_region").execute(*args, **kwargs)
                def slit_periodic(self, *args, **kwargs):
                    """
                    Slit a periodic zone into two symmetry zones.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/slit_periodic").execute(*args, **kwargs)
                def slit_face_zone(self, *args, **kwargs):
                    """
                    Slit a two-sided wall into two connected wall zones.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/slit_face_zone").execute(*args, **kwargs)
                def slit_interior_between_diff_solids(self, *args, **kwargs):
                    """
                    Slit interior created between different solids into coupled walls.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/slit_interior_between_diff_solids").execute(*args, **kwargs)
                def zone_name(self, *args, **kwargs):
                    """
                    Give a zone a new name.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/zone_name").execute(*args, **kwargs)
                def zone_type(self, *args, **kwargs):
                    """
                    Set a zone's type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/zone_type").execute(*args, **kwargs)
                def copy_mrf_to_mesh_motion(self, *args, **kwargs):
                    """
                    Copy motion variable values for origin, axis and velocities from Frame Motion to Mesh Motion.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/copy_mrf_to_mesh_motion").execute(*args, **kwargs)
                def copy_mesh_to_mrf_motion(self, *args, **kwargs):
                    """
                    Copy motion variable values for origin, axis and velocities from Mesh Motion to Frame Motion.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/copy_mesh_to_mrf_motion").execute(*args, **kwargs)
                def change_zone_state(self, *args, **kwargs):
                    """
                    Change the realgas material state for a zone.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/change_zone_state").execute(*args, **kwargs)
                def change_zone_phase(self, *args, **kwargs):
                    """
                    Change the realgas phase for a zone.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/modify_zones/change_zone_phase").execute(*args, **kwargs)

            class periodic(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service

            class pressure_far_field(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.p = self.__class__.p(path + [("p", None)], service)
                    self.m = self.__class__.m(path + [("m", None)], service)
                    self.coordinate_system = self.__class__.coordinate_system(path + [("coordinate_system", None)], service)
                    self.ni = self.__class__.ni(path + [("ni", None)], service)
                    self.nj = self.__class__.nj(path + [("nj", None)], service)
                    self.nk = self.__class__.nk(path + [("nk", None)], service)
                    self.ai = self.__class__.ai(path + [("ai", None)], service)
                    self.aj = self.__class__.aj(path + [("aj", None)], service)
                    self.ak = self.__class__.ak(path + [("ak", None)], service)
                    self.x_origin = self.__class__.x_origin(path + [("x_origin", None)], service)
                    self.y_origin = self.__class__.y_origin(path + [("y_origin", None)], service)
                    self.z_origin = self.__class__.z_origin(path + [("z_origin", None)], service)
                    self.ke_spec = self.__class__.ke_spec(path + [("ke_spec", None)], service)
                    self.nut = self.__class__.nut(path + [("nut", None)], service)
                    self.kl = self.__class__.kl(path + [("kl", None)], service)
                    self.intermit = self.__class__.intermit(path + [("intermit", None)], service)
                    self.k = self.__class__.k(path + [("k", None)], service)
                    self.e = self.__class__.e(path + [("e", None)], service)
                    self.o = self.__class__.o(path + [("o", None)], service)
                    self.v2 = self.__class__.v2(path + [("v2", None)], service)
                    self.turb_intensity = self.__class__.turb_intensity(path + [("turb_intensity", None)], service)
                    self.turb_length_scale = self.__class__.turb_length_scale(path + [("turb_length_scale", None)], service)
                    self.turb_hydraulic_diam = self.__class__.turb_hydraulic_diam(path + [("turb_hydraulic_diam", None)], service)
                    self.turb_viscosity_ratio = self.__class__.turb_viscosity_ratio(path + [("turb_viscosity_ratio", None)], service)
                    self.turb_viscosity_ratio_profile = self.__class__.turb_viscosity_ratio_profile(path + [("turb_viscosity_ratio_profile", None)], service)
                    self.rst_spec = self.__class__.rst_spec(path + [("rst_spec", None)], service)
                    self.uu = self.__class__.uu(path + [("uu", None)], service)
                    self.vv = self.__class__.vv(path + [("vv", None)], service)
                    self.ww = self.__class__.ww(path + [("ww", None)], service)
                    self.uv = self.__class__.uv(path + [("uv", None)], service)
                    self.vw = self.__class__.vw(path + [("vw", None)], service)
                    self.uw = self.__class__.uw(path + [("uw", None)], service)
                    self.ksgs_spec = self.__class__.ksgs_spec(path + [("ksgs_spec", None)], service)
                    self.ksgs = self.__class__.ksgs(path + [("ksgs", None)], service)
                    self.sgs_turb_intensity = self.__class__.sgs_turb_intensity(path + [("sgs_turb_intensity", None)], service)
                    self.geom_disable = self.__class__.geom_disable(path + [("geom_disable", None)], service)
                    self.geom_dir_spec = self.__class__.geom_dir_spec(path + [("geom_dir_spec", None)], service)
                    self.geom_dir_x = self.__class__.geom_dir_x(path + [("geom_dir_x", None)], service)
                    self.geom_dir_y = self.__class__.geom_dir_y(path + [("geom_dir_y", None)], service)
                    self.geom_dir_z = self.__class__.geom_dir_z(path + [("geom_dir_z", None)], service)
                    self.geom_levels = self.__class__.geom_levels(path + [("geom_levels", None)], service)
                    self.geom_bgthread = self.__class__.geom_bgthread(path + [("geom_bgthread", None)], service)
                    self.t = self.__class__.t(path + [("t", None)], service)
                    self.non_equil_boundary = self.__class__.non_equil_boundary(path + [("non_equil_boundary", None)], service)
                    self.tve = self.__class__.tve(path + [("tve", None)], service)

                class p(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class m(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class coordinate_system(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ni(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nk(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ai(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class aj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ak(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class x_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class y_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class z_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ke_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nut(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class kl(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class intermit(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class k(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class e(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class o(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class v2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_length_scale(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_hydraulic_diam(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio_profile(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class rst_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uu(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ww(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class sgs_turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geom_disable(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geom_dir_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geom_dir_x(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geom_dir_y(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geom_dir_z(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geom_levels(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geom_bgthread(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class t(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class non_equil_boundary(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class tve(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

            class pressure_inlet(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.frame_of_reference = self.__class__.frame_of_reference(path + [("frame_of_reference", None)], service)
                    self.p0 = self.__class__.p0(path + [("p0", None)], service)
                    self.p = self.__class__.p(path + [("p", None)], service)
                    self.direction_spec = self.__class__.direction_spec(path + [("direction_spec", None)], service)
                    self.coordinate_system = self.__class__.coordinate_system(path + [("coordinate_system", None)], service)
                    self.ni = self.__class__.ni(path + [("ni", None)], service)
                    self.nj = self.__class__.nj(path + [("nj", None)], service)
                    self.nk = self.__class__.nk(path + [("nk", None)], service)
                    self.ni2 = self.__class__.ni2(path + [("ni2", None)], service)
                    self.nj2 = self.__class__.nj2(path + [("nj2", None)], service)
                    self.nk2 = self.__class__.nk2(path + [("nk2", None)], service)
                    self.ai = self.__class__.ai(path + [("ai", None)], service)
                    self.aj = self.__class__.aj(path + [("aj", None)], service)
                    self.ak = self.__class__.ak(path + [("ak", None)], service)
                    self.x_origin = self.__class__.x_origin(path + [("x_origin", None)], service)
                    self.y_origin = self.__class__.y_origin(path + [("y_origin", None)], service)
                    self.z_origin = self.__class__.z_origin(path + [("z_origin", None)], service)
                    self.vm_number_of_vortices = self.__class__.vm_number_of_vortices(path + [("vm_number_of_vortices", None)], service)
                    self.vm_streamwise_fluct = self.__class__.vm_streamwise_fluct(path + [("vm_streamwise_fluct", None)], service)
                    self.vm_mass_conservation = self.__class__.vm_mass_conservation(path + [("vm_mass_conservation", None)], service)
                    self.volumetric_synthetic_turbulence_generator = self.__class__.volumetric_synthetic_turbulence_generator(path + [("volumetric_synthetic_turbulence_generator", None)], service)
                    self.volumetric_synthetic_turbulence_generator_option = self.__class__.volumetric_synthetic_turbulence_generator_option(path + [("volumetric_synthetic_turbulence_generator_option", None)], service)
                    self.volumetric_synthetic_turbulence_generator_option_thickness = self.__class__.volumetric_synthetic_turbulence_generator_option_thickness(path + [("volumetric_synthetic_turbulence_generator_option_thickness", None)], service)
                    self.prevent_reverse_flow = self.__class__.prevent_reverse_flow(path + [("prevent_reverse_flow", None)], service)
                    self.ke_spec = self.__class__.ke_spec(path + [("ke_spec", None)], service)
                    self.nut = self.__class__.nut(path + [("nut", None)], service)
                    self.kl = self.__class__.kl(path + [("kl", None)], service)
                    self.intermit = self.__class__.intermit(path + [("intermit", None)], service)
                    self.k = self.__class__.k(path + [("k", None)], service)
                    self.e = self.__class__.e(path + [("e", None)], service)
                    self.o = self.__class__.o(path + [("o", None)], service)
                    self.v2 = self.__class__.v2(path + [("v2", None)], service)
                    self.turb_intensity = self.__class__.turb_intensity(path + [("turb_intensity", None)], service)
                    self.turb_length_scale = self.__class__.turb_length_scale(path + [("turb_length_scale", None)], service)
                    self.turb_hydraulic_diam = self.__class__.turb_hydraulic_diam(path + [("turb_hydraulic_diam", None)], service)
                    self.turb_viscosity_ratio = self.__class__.turb_viscosity_ratio(path + [("turb_viscosity_ratio", None)], service)
                    self.turb_viscosity_ratio_profile = self.__class__.turb_viscosity_ratio_profile(path + [("turb_viscosity_ratio_profile", None)], service)
                    self.rst_spec = self.__class__.rst_spec(path + [("rst_spec", None)], service)
                    self.uu = self.__class__.uu(path + [("uu", None)], service)
                    self.vv = self.__class__.vv(path + [("vv", None)], service)
                    self.ww = self.__class__.ww(path + [("ww", None)], service)
                    self.uv = self.__class__.uv(path + [("uv", None)], service)
                    self.vw = self.__class__.vw(path + [("vw", None)], service)
                    self.uw = self.__class__.uw(path + [("uw", None)], service)
                    self.ksgs_spec = self.__class__.ksgs_spec(path + [("ksgs_spec", None)], service)
                    self.ksgs = self.__class__.ksgs(path + [("ksgs", None)], service)
                    self.sgs_turb_intensity = self.__class__.sgs_turb_intensity(path + [("sgs_turb_intensity", None)], service)
                    self.les_spec_name = self.__class__.les_spec_name(path + [("les_spec_name", None)], service)
                    self.wsf = self.__class__.wsf(path + [("wsf", None)], service)
                    self.wsb = self.__class__.wsb(path + [("wsb", None)], service)
                    self.wsn = self.__class__.wsn(path + [("wsn", None)], service)
                    self.ac_options = self.__class__.ac_options(path + [("ac_options", None)], service)
                    self.ac_wave = self.__class__.ac_wave(path + [("ac_wave", None)], service)
                    self.impedance_0 = self.__class__.impedance_0(path + [("impedance_0", None)], service)
                    self.t0 = self.__class__.t0(path + [("t0", None)], service)

                class frame_of_reference(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class p0(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class p(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class direction_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class coordinate_system(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ni(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nk(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ni2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nj2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nk2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ai(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class aj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ak(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class x_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class y_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class z_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vm_number_of_vortices(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vm_streamwise_fluct(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vm_mass_conservation(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class volumetric_synthetic_turbulence_generator(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class volumetric_synthetic_turbulence_generator_option(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class volumetric_synthetic_turbulence_generator_option_thickness(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class prevent_reverse_flow(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ke_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nut(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class kl(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class intermit(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class k(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class e(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class o(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class v2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_length_scale(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_hydraulic_diam(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio_profile(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class rst_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uu(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ww(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class sgs_turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class les_spec_name(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wsf(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wsb(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wsn(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ac_options(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ac_wave(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class impedance_0(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class t0(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

            class pressure_outlet(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.prevent_reverse_flow = self.__class__.prevent_reverse_flow(path + [("prevent_reverse_flow", None)], service)
                    self.radial = self.__class__.radial(path + [("radial", None)], service)
                    self.gen_nrbc_spec = self.__class__.gen_nrbc_spec(path + [("gen_nrbc_spec", None)], service)
                    self.avg_press_spec = self.__class__.avg_press_spec(path + [("avg_press_spec", None)], service)
                    self.avg_option = self.__class__.avg_option(path + [("avg_option", None)], service)
                    self.targeted_mf_boundary = self.__class__.targeted_mf_boundary(path + [("targeted_mf_boundary", None)], service)
                    self.targeted_mf = self.__class__.targeted_mf(path + [("targeted_mf", None)], service)
                    self.targeted_mf_pmax = self.__class__.targeted_mf_pmax(path + [("targeted_mf_pmax", None)], service)
                    self.targeted_mf_pmin = self.__class__.targeted_mf_pmin(path + [("targeted_mf_pmin", None)], service)
                    self.press_spec_gen = self.__class__.press_spec_gen(path + [("press_spec_gen", None)], service)
                    self.p_backflow_spec = self.__class__.p_backflow_spec(path + [("p_backflow_spec", None)], service)
                    self.p_backflow_spec_gen = self.__class__.p_backflow_spec_gen(path + [("p_backflow_spec_gen", None)], service)
                    self.ac_options = self.__class__.ac_options(path + [("ac_options", None)], service)
                    self.ac_wave = self.__class__.ac_wave(path + [("ac_wave", None)], service)
                    self.impedance_0 = self.__class__.impedance_0(path + [("impedance_0", None)], service)
                    self.p = self.__class__.p(path + [("p", None)], service)
                    self.p_profile_multiplier = self.__class__.p_profile_multiplier(path + [("p_profile_multiplier", None)], service)
                    self.direction_spec = self.__class__.direction_spec(path + [("direction_spec", None)], service)
                    self.frame_of_reference = self.__class__.frame_of_reference(path + [("frame_of_reference", None)], service)
                    self.coordinate_system = self.__class__.coordinate_system(path + [("coordinate_system", None)], service)
                    self.ni = self.__class__.ni(path + [("ni", None)], service)
                    self.nj = self.__class__.nj(path + [("nj", None)], service)
                    self.nk = self.__class__.nk(path + [("nk", None)], service)
                    self.ai = self.__class__.ai(path + [("ai", None)], service)
                    self.aj = self.__class__.aj(path + [("aj", None)], service)
                    self.ak = self.__class__.ak(path + [("ak", None)], service)
                    self.x_origin = self.__class__.x_origin(path + [("x_origin", None)], service)
                    self.y_origin = self.__class__.y_origin(path + [("y_origin", None)], service)
                    self.z_origin = self.__class__.z_origin(path + [("z_origin", None)], service)
                    self.ke_spec = self.__class__.ke_spec(path + [("ke_spec", None)], service)
                    self.nut = self.__class__.nut(path + [("nut", None)], service)
                    self.kl = self.__class__.kl(path + [("kl", None)], service)
                    self.intermit = self.__class__.intermit(path + [("intermit", None)], service)
                    self.k = self.__class__.k(path + [("k", None)], service)
                    self.e = self.__class__.e(path + [("e", None)], service)
                    self.o = self.__class__.o(path + [("o", None)], service)
                    self.v2 = self.__class__.v2(path + [("v2", None)], service)
                    self.turb_intensity = self.__class__.turb_intensity(path + [("turb_intensity", None)], service)
                    self.turb_length_scale = self.__class__.turb_length_scale(path + [("turb_length_scale", None)], service)
                    self.turb_hydraulic_diam = self.__class__.turb_hydraulic_diam(path + [("turb_hydraulic_diam", None)], service)
                    self.turb_viscosity_ratio = self.__class__.turb_viscosity_ratio(path + [("turb_viscosity_ratio", None)], service)
                    self.turb_viscosity_ratio_profile = self.__class__.turb_viscosity_ratio_profile(path + [("turb_viscosity_ratio_profile", None)], service)
                    self.rst_spec = self.__class__.rst_spec(path + [("rst_spec", None)], service)
                    self.uu = self.__class__.uu(path + [("uu", None)], service)
                    self.vv = self.__class__.vv(path + [("vv", None)], service)
                    self.ww = self.__class__.ww(path + [("ww", None)], service)
                    self.uv = self.__class__.uv(path + [("uv", None)], service)
                    self.vw = self.__class__.vw(path + [("vw", None)], service)
                    self.uw = self.__class__.uw(path + [("uw", None)], service)
                    self.ksgs_spec = self.__class__.ksgs_spec(path + [("ksgs_spec", None)], service)
                    self.ksgs = self.__class__.ksgs(path + [("ksgs", None)], service)
                    self.sgs_turb_intensity = self.__class__.sgs_turb_intensity(path + [("sgs_turb_intensity", None)], service)
                    self.wsf = self.__class__.wsf(path + [("wsf", None)], service)
                    self.wsb = self.__class__.wsb(path + [("wsb", None)], service)
                    self.wsn = self.__class__.wsn(path + [("wsn", None)], service)
                    self.t0 = self.__class__.t0(path + [("t0", None)], service)

                class prevent_reverse_flow(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class radial(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class gen_nrbc_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class avg_press_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class avg_option(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class targeted_mf_boundary(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class targeted_mf(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class targeted_mf_pmax(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class targeted_mf_pmin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class press_spec_gen(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class p_backflow_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class p_backflow_spec_gen(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ac_options(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ac_wave(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class impedance_0(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class p(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class p_profile_multiplier(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class direction_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class frame_of_reference(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class coordinate_system(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ni(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nk(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ai(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class aj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ak(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class x_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class y_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class z_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ke_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nut(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class kl(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class intermit(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class k(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class e(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class o(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class v2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_length_scale(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_hydraulic_diam(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio_profile(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class rst_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uu(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ww(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class sgs_turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wsf(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wsb(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wsn(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class t0(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

            class symmetry(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service

            class velocity_inlet(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.vmag = self.__class__.vmag(path + [("vmag", None)], service)
                    self.p_sup = self.__class__.p_sup(path + [("p_sup", None)], service)
                    self.velocity_spec = self.__class__.velocity_spec(path + [("velocity_spec", None)], service)
                    self.wave_velocity_spec = self.__class__.wave_velocity_spec(path + [("wave_velocity_spec", None)], service)
                    self.wave_vmag = self.__class__.wave_vmag(path + [("wave_vmag", None)], service)
                    self.wave_u = self.__class__.wave_u(path + [("wave_u", None)], service)
                    self.wave_v = self.__class__.wave_v(path + [("wave_v", None)], service)
                    self.wave_w = self.__class__.wave_w(path + [("wave_w", None)], service)
                    self.ocw_ship_vel_spec = self.__class__.ocw_ship_vel_spec(path + [("ocw_ship_vel_spec", None)], service)
                    self.ocw_ship_vmag = self.__class__.ocw_ship_vmag(path + [("ocw_ship_vmag", None)], service)
                    self.ocw_ship_ni = self.__class__.ocw_ship_ni(path + [("ocw_ship_ni", None)], service)
                    self.ocw_ship_nj = self.__class__.ocw_ship_nj(path + [("ocw_ship_nj", None)], service)
                    self.ocw_ship_nk = self.__class__.ocw_ship_nk(path + [("ocw_ship_nk", None)], service)
                    self.ocw_sp_vel_spec = self.__class__.ocw_sp_vel_spec(path + [("ocw_sp_vel_spec", None)], service)
                    self.ocw_sp_vmag = self.__class__.ocw_sp_vmag(path + [("ocw_sp_vmag", None)], service)
                    self.ocw_sp_ni = self.__class__.ocw_sp_ni(path + [("ocw_sp_ni", None)], service)
                    self.ocw_sp_nj = self.__class__.ocw_sp_nj(path + [("ocw_sp_nj", None)], service)
                    self.ocw_sp_nk = self.__class__.ocw_sp_nk(path + [("ocw_sp_nk", None)], service)
                    self.ocw_pp_vel_spec = self.__class__.ocw_pp_vel_spec(path + [("ocw_pp_vel_spec", None)], service)
                    self.ocw_pp_vmag = self.__class__.ocw_pp_vmag(path + [("ocw_pp_vmag", None)], service)
                    self.ocw_pp_vmag_ref = self.__class__.ocw_pp_vmag_ref(path + [("ocw_pp_vmag_ref", None)], service)
                    self.ocw_pp_ref_ht = self.__class__.ocw_pp_ref_ht(path + [("ocw_pp_ref_ht", None)], service)
                    self.ocw_pp_power_coeff = self.__class__.ocw_pp_power_coeff(path + [("ocw_pp_power_coeff", None)], service)
                    self.ocw_pp_ni = self.__class__.ocw_pp_ni(path + [("ocw_pp_ni", None)], service)
                    self.ocw_pp_nj = self.__class__.ocw_pp_nj(path + [("ocw_pp_nj", None)], service)
                    self.ocw_pp_nk = self.__class__.ocw_pp_nk(path + [("ocw_pp_nk", None)], service)
                    self.p = self.__class__.p(path + [("p", None)], service)
                    self.omega_swirl = self.__class__.omega_swirl(path + [("omega_swirl", None)], service)
                    self.turb_intensity = self.__class__.turb_intensity(path + [("turb_intensity", None)], service)
                    self.turb_length_scale = self.__class__.turb_length_scale(path + [("turb_length_scale", None)], service)
                    self.turb_hydraulic_diam = self.__class__.turb_hydraulic_diam(path + [("turb_hydraulic_diam", None)], service)
                    self.turb_viscosity_ratio = self.__class__.turb_viscosity_ratio(path + [("turb_viscosity_ratio", None)], service)
                    self.turb_viscosity_ratio_profile = self.__class__.turb_viscosity_ratio_profile(path + [("turb_viscosity_ratio_profile", None)], service)
                    self.frame_of_reference = self.__class__.frame_of_reference(path + [("frame_of_reference", None)], service)
                    self.coordinate_system = self.__class__.coordinate_system(path + [("coordinate_system", None)], service)
                    self.ni = self.__class__.ni(path + [("ni", None)], service)
                    self.nj = self.__class__.nj(path + [("nj", None)], service)
                    self.nk = self.__class__.nk(path + [("nk", None)], service)
                    self.u = self.__class__.u(path + [("u", None)], service)
                    self.v = self.__class__.v(path + [("v", None)], service)
                    self.w = self.__class__.w(path + [("w", None)], service)
                    self.ai = self.__class__.ai(path + [("ai", None)], service)
                    self.aj = self.__class__.aj(path + [("aj", None)], service)
                    self.ak = self.__class__.ak(path + [("ak", None)], service)
                    self.x_origin = self.__class__.x_origin(path + [("x_origin", None)], service)
                    self.y_origin = self.__class__.y_origin(path + [("y_origin", None)], service)
                    self.z_origin = self.__class__.z_origin(path + [("z_origin", None)], service)
                    self.vm_number_of_vortices = self.__class__.vm_number_of_vortices(path + [("vm_number_of_vortices", None)], service)
                    self.vm_streamwise_fluct = self.__class__.vm_streamwise_fluct(path + [("vm_streamwise_fluct", None)], service)
                    self.vm_mass_conservation = self.__class__.vm_mass_conservation(path + [("vm_mass_conservation", None)], service)
                    self.volumetric_synthetic_turbulence_generator = self.__class__.volumetric_synthetic_turbulence_generator(path + [("volumetric_synthetic_turbulence_generator", None)], service)
                    self.volumetric_synthetic_turbulence_generator_option = self.__class__.volumetric_synthetic_turbulence_generator_option(path + [("volumetric_synthetic_turbulence_generator_option", None)], service)
                    self.volumetric_synthetic_turbulence_generator_option_thickness = self.__class__.volumetric_synthetic_turbulence_generator_option_thickness(path + [("volumetric_synthetic_turbulence_generator_option_thickness", None)], service)
                    self.ke_spec = self.__class__.ke_spec(path + [("ke_spec", None)], service)
                    self.nut = self.__class__.nut(path + [("nut", None)], service)
                    self.kl = self.__class__.kl(path + [("kl", None)], service)
                    self.intermit = self.__class__.intermit(path + [("intermit", None)], service)
                    self.k = self.__class__.k(path + [("k", None)], service)
                    self.e = self.__class__.e(path + [("e", None)], service)
                    self.o = self.__class__.o(path + [("o", None)], service)
                    self.v2 = self.__class__.v2(path + [("v2", None)], service)
                    self.rst_spec = self.__class__.rst_spec(path + [("rst_spec", None)], service)
                    self.uu = self.__class__.uu(path + [("uu", None)], service)
                    self.vv = self.__class__.vv(path + [("vv", None)], service)
                    self.ww = self.__class__.ww(path + [("ww", None)], service)
                    self.uv = self.__class__.uv(path + [("uv", None)], service)
                    self.vw = self.__class__.vw(path + [("vw", None)], service)
                    self.uw = self.__class__.uw(path + [("uw", None)], service)
                    self.ksgs_spec = self.__class__.ksgs_spec(path + [("ksgs_spec", None)], service)
                    self.ksgs = self.__class__.ksgs(path + [("ksgs", None)], service)
                    self.sgs_turb_intensity = self.__class__.sgs_turb_intensity(path + [("sgs_turb_intensity", None)], service)
                    self.les_spec_name = self.__class__.les_spec_name(path + [("les_spec_name", None)], service)
                    self.granular_temperature = self.__class__.granular_temperature(path + [("granular_temperature", None)], service)
                    self.ac_options = self.__class__.ac_options(path + [("ac_options", None)], service)
                    self.ac_wave = self.__class__.ac_wave(path + [("ac_wave", None)], service)
                    self.impedance_0 = self.__class__.impedance_0(path + [("impedance_0", None)], service)
                    self.t = self.__class__.t(path + [("t", None)], service)
                    self.non_equil_boundary = self.__class__.non_equil_boundary(path + [("non_equil_boundary", None)], service)
                    self.tve = self.__class__.tve(path + [("tve", None)], service)

                class vmag(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class p_sup(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class velocity_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wave_velocity_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wave_vmag(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wave_u(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wave_v(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wave_w(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_ship_vel_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_ship_vmag(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_ship_ni(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_ship_nj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_ship_nk(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_sp_vel_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_sp_vmag(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_sp_ni(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_sp_nj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_sp_nk(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_pp_vel_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_pp_vmag(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_pp_vmag_ref(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_pp_ref_ht(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_pp_power_coeff(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_pp_ni(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_pp_nj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_pp_nk(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class p(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class omega_swirl(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_length_scale(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_hydraulic_diam(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio_profile(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class frame_of_reference(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class coordinate_system(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ni(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nk(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class u(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class v(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class w(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ai(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class aj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ak(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class x_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class y_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class z_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vm_number_of_vortices(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vm_streamwise_fluct(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vm_mass_conservation(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class volumetric_synthetic_turbulence_generator(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class volumetric_synthetic_turbulence_generator_option(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class volumetric_synthetic_turbulence_generator_option_thickness(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ke_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nut(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class kl(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class intermit(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class k(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class e(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class o(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class v2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class rst_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uu(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ww(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class sgs_turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class les_spec_name(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class granular_temperature(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ac_options(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ac_wave(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class impedance_0(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class t(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class non_equil_boundary(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class tve(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

            class wall(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service

            class non_reflecting_bc(metaclass=PyMenuMeta):
                """
                Enter the non-reflecting b.c. menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.general_nrbc = self.__class__.general_nrbc(path + [("general_nrbc", None)], service)
                    self.turbo_specific_nrbc = self.__class__.turbo_specific_nrbc(path + [("turbo_specific_nrbc", None)], service)

                class general_nrbc(metaclass=PyMenuMeta):
                    """
                    Enter the menu for setting general non-reflecting boundary conditions.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.set = self.__class__.set(path + [("set", None)], service)

                    class set(metaclass=PyMenuMeta):
                        """
                        Enter the general non-reflecting b.c. menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def sigma(self, *args, **kwargs):
                            """
                            Set nrbc sigma factor (default value 0.15).
                            """
                            return PyMenu(self.service, "/define/boundary_conditions/non_reflecting_bc/general_nrbc/set/sigma").execute(*args, **kwargs)
                        def sigma2(self, *args, **kwargs):
                            """
                            Set nrbc sigma2 factor (default value 5.0).
                            """
                            return PyMenu(self.service, "/define/boundary_conditions/non_reflecting_bc/general_nrbc/set/sigma2").execute(*args, **kwargs)
                        def relax(self, *args, **kwargs):
                            """
                            Set NRBC relaxation factor (default value 0.5).
                            """
                            return PyMenu(self.service, "/define/boundary_conditions/non_reflecting_bc/general_nrbc/set/relax").execute(*args, **kwargs)
                        def tangential_source(self, *args, **kwargs):
                            """
                            Include or not NRBC tangential source (default value #t).
                            """
                            return PyMenu(self.service, "/define/boundary_conditions/non_reflecting_bc/general_nrbc/set/tangential_source").execute(*args, **kwargs)
                        def verbosity(self, *args, **kwargs):
                            """
                            Print boundary equations convergence info.
                            """
                            return PyMenu(self.service, "/define/boundary_conditions/non_reflecting_bc/general_nrbc/set/verbosity").execute(*args, **kwargs)

                class turbo_specific_nrbc(metaclass=PyMenuMeta):
                    """
                    Enter the turbo-specific n.r.b.c. menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.set = self.__class__.set(path + [("set", None)], service)
                    def enable(self, *args, **kwargs):
                        """
                        Enable/disable turbo-specific non-reflecting b.c.'s.
                        """
                        return PyMenu(self.service, "/define/boundary_conditions/non_reflecting_bc/turbo_specific_nrbc/enable").execute(*args, **kwargs)
                    def initialize(self, *args, **kwargs):
                        """
                        Initialize turbo-specific non-reflecting b.c.'s.
                        """
                        return PyMenu(self.service, "/define/boundary_conditions/non_reflecting_bc/turbo_specific_nrbc/initialize").execute(*args, **kwargs)
                    def show_status(self, *args, **kwargs):
                        """
                        Show current status of turbo-specific non-reflecting b.c.'s.
                        """
                        return PyMenu(self.service, "/define/boundary_conditions/non_reflecting_bc/turbo_specific_nrbc/show_status").execute(*args, **kwargs)

                    class set(metaclass=PyMenuMeta):
                        """
                        Enter the set menu for turbo-specific non-reflecting b.c. parameters.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def discretization(self, *args, **kwargs):
                            """
                            Enable use of higher-order reconstruction at boundaries if available.
                            """
                            return PyMenu(self.service, "/define/boundary_conditions/non_reflecting_bc/turbo_specific_nrbc/set/discretization").execute(*args, **kwargs)
                        def under_relaxation(self, *args, **kwargs):
                            """
                            Set turbo-specific non-reflecting b.c. under-relaxation factor.
                             specify < 0 => use P/a_ave
                             specify = 0 => use 1/N    
                             specify > 0 => use specified.
                            """
                            return PyMenu(self.service, "/define/boundary_conditions/non_reflecting_bc/turbo_specific_nrbc/set/under_relaxation").execute(*args, **kwargs)
                        def verbosity(self, *args, **kwargs):
                            """
                            Set turbo-specific non-reflecting b.c. verbosity level.
                             0 : silent
                             1 : basic info. default 
                             2 : detailed info. for debugging 
                            .
                            """
                            return PyMenu(self.service, "/define/boundary_conditions/non_reflecting_bc/turbo_specific_nrbc/set/verbosity").execute(*args, **kwargs)

            class rename_zone(metaclass=PyMenuMeta):
                """
                Enter zone rename menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def rename_by_adjacency(self, *args, **kwargs):
                    """
                    Rename zone to adjacent zones.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/rename_zone/rename_by_adjacency").execute(*args, **kwargs)
                def rename_to_default(self, *args, **kwargs):
                    """
                    Rename zone to default name.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/rename_zone/rename_to_default").execute(*args, **kwargs)
                def add_suffix_or_prefix(self, *args, **kwargs):
                    """
                    Add suffix or prefix to zone name.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/rename_zone/add_suffix_or_prefix").execute(*args, **kwargs)

            class bc_settings(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.pressure_far_field = self.__class__.pressure_far_field(path + [("pressure_far_field", None)], service)
                def mass_flow(self, *args, **kwargs):
                    """
                    Select method for setting the mass flow rate.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/bc_settings/mass_flow").execute(*args, **kwargs)
                def pressure_outlet(self, *args, **kwargs):
                    """
                    Select pressure specification method on pressure-outlet boundaries.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/bc_settings/pressure_outlet").execute(*args, **kwargs)

                class pressure_far_field(metaclass=PyMenuMeta):
                    """
                    Select presure-far-field boundary-condition options.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def riemann_invariants_tangency_correction(self, *args, **kwargs):
                        """
                        Apply a local correction where the flow is tangential to the boundary.
                        """
                        return PyMenu(self.service, "/define/boundary_conditions/bc_settings/pressure_far_field/riemann_invariants_tangency_correction").execute(*args, **kwargs)
                    def type_flag(self, *args, **kwargs):
                        """
                        Choose pressure-far-field boundary-condition type.
                        """
                        return PyMenu(self.service, "/define/boundary_conditions/bc_settings/pressure_far_field/type_flag").execute(*args, **kwargs)

            class perforated_walls(metaclass=PyMenuMeta):
                """
                Enter the perforated walls setting menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def read_input_file(self, *args, **kwargs):
                    """
                    Read an input file.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/perforated_walls/read_input_file").execute(*args, **kwargs)
                def model_setup(self, *args, **kwargs):
                    """
                    Set up perforated walls.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/perforated_walls/model_setup").execute(*args, **kwargs)

            class set(metaclass=PyMenuMeta):
                """
                Enter the set boundary conditions menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def axis(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/axis").execute(*args, **kwargs)
                def degassing(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/degassing").execute(*args, **kwargs)
                def exhaust_fan(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/exhaust_fan").execute(*args, **kwargs)
                def fan(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/fan").execute(*args, **kwargs)
                def fluid(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/fluid").execute(*args, **kwargs)
                def geometry(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/geometry").execute(*args, **kwargs)
                def inlet_vent(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/inlet_vent").execute(*args, **kwargs)
                def intake_fan(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/intake_fan").execute(*args, **kwargs)
                def interface(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/interface").execute(*args, **kwargs)
                def interior(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/interior").execute(*args, **kwargs)
                def mass_flow_inlet(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/mass_flow_inlet").execute(*args, **kwargs)
                def mass_flow_outlet(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/mass_flow_outlet").execute(*args, **kwargs)
                def network(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/network").execute(*args, **kwargs)
                def network_end(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/network_end").execute(*args, **kwargs)
                def outflow(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/outflow").execute(*args, **kwargs)
                def outlet_vent(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/outlet_vent").execute(*args, **kwargs)
                def overset(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/overset").execute(*args, **kwargs)
                def periodic(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/periodic").execute(*args, **kwargs)
                def porous_jump(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/porous_jump").execute(*args, **kwargs)
                def pressure_far_field(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/pressure_far_field").execute(*args, **kwargs)
                def pressure_inlet(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/pressure_inlet").execute(*args, **kwargs)
                def pressure_outlet(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/pressure_outlet").execute(*args, **kwargs)
                def radiator(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/radiator").execute(*args, **kwargs)
                def rans_les_interface(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/rans_les_interface").execute(*args, **kwargs)
                def recirculation_inlet(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/recirculation_inlet").execute(*args, **kwargs)
                def recirculation_outlet(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/recirculation_outlet").execute(*args, **kwargs)
                def shadow(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/shadow").execute(*args, **kwargs)
                def solid(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/solid").execute(*args, **kwargs)
                def symmetry(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/symmetry").execute(*args, **kwargs)
                def velocity_inlet(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/velocity_inlet").execute(*args, **kwargs)
                def wall(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/set/wall").execute(*args, **kwargs)

            class impedance_data_fitting(metaclass=PyMenuMeta):
                """
                Enter the impedance data fitting menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def impedance_data(self, *args, **kwargs):
                    """
                    Read experimental impedance data and output impedance parameters for a boundary condition.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/impedance_data_fitting/impedance_data").execute(*args, **kwargs)
                def reflection_data(self, *args, **kwargs):
                    """
                    Read experimental reflection coefficient data and output impedance parameters for a boundary condition.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/impedance_data_fitting/reflection_data").execute(*args, **kwargs)
                def absorption_data(self, *args, **kwargs):
                    """
                    Read experimental absorption coefficient data and output impedance parameters for a boundary condition.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/impedance_data_fitting/absorption_data").execute(*args, **kwargs)
                def iterations(self, *args, **kwargs):
                    """
                    Set the number of iterations for the fitting algorithm.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/impedance_data_fitting/iterations").execute(*args, **kwargs)
                def convergence_tolerance(self, *args, **kwargs):
                    """
                    Set the convergence tolerance for the fitting algorithm.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/impedance_data_fitting/convergence_tolerance").execute(*args, **kwargs)
                def residue_tolerance(self, *args, **kwargs):
                    """
                    Set the residue tolerance for the fitting algorithm.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/impedance_data_fitting/residue_tolerance").execute(*args, **kwargs)
                def verbosity(self, *args, **kwargs):
                    """
                    Set verbosity level [0, 1] for fitting algorithm.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/impedance_data_fitting/verbosity").execute(*args, **kwargs)
                def import_parameters(self, *args, **kwargs):
                    """
                    Import impedance parameters into boundary condition.
                    """
                    return PyMenu(self.service, "/define/boundary_conditions/impedance_data_fitting/import_parameters").execute(*args, **kwargs)

        class spectral(metaclass=PyMenuMeta):
            """
            Enter the Spectral menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def calculate_fourier_coefficients(self, *args, **kwargs):
                """
                Calculates Fourier coefficient data.
                """
                return PyMenu(self.service, "/define/spectral/calculate_fourier_coefficients").execute(*args, **kwargs)
            def delete_fourier_coefficients(self, *args, **kwargs):
                """
                Deletes Fourier coefficient data.
                """
                return PyMenu(self.service, "/define/spectral/delete_fourier_coefficients").execute(*args, **kwargs)
            def calculate_harmonic_exports(self, *args, **kwargs):
                """
                Calculates Harmonic Export data.
                """
                return PyMenu(self.service, "/define/spectral/calculate_harmonic_exports").execute(*args, **kwargs)
            def delete_harmonic_exports(self, *args, **kwargs):
                """
                Deletes Harmonic Export data.
                """
                return PyMenu(self.service, "/define/spectral/delete_harmonic_exports").execute(*args, **kwargs)

        class custom_field_functions(metaclass=PyMenuMeta):
            """
            Enter the custom field functions menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def define(self, *args, **kwargs):
                """
                Define a custom field function.
                """
                return PyMenu(self.service, "/define/custom_field_functions/define").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete a custom field function.
                """
                return PyMenu(self.service, "/define/custom_field_functions/delete").execute(*args, **kwargs)
            def save(self, *args, **kwargs):
                """
                Save a custom field function.
                """
                return PyMenu(self.service, "/define/custom_field_functions/save").execute(*args, **kwargs)
            def load(self, *args, **kwargs):
                """
                Load a custom field function.
                """
                return PyMenu(self.service, "/define/custom_field_functions/load").execute(*args, **kwargs)
            def list_valid_cell_function_names(self, *args, **kwargs):
                """
                List the names of cell functions that can be used in a custom field function.
                """
                return PyMenu(self.service, "/define/custom_field_functions/list_valid_cell_function_names").execute(*args, **kwargs)
            def example_cff_definitions(self, *args, **kwargs):
                """
                List example custom field functions.
                """
                return PyMenu(self.service, "/define/custom_field_functions/example_cff_definitions").execute(*args, **kwargs)

        class dynamic_mesh(metaclass=PyMenuMeta):
            """
            Enter the dynamic mesh menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.controls = self.__class__.controls(path + [("controls", None)], service)
                self.events = self.__class__.events(path + [("events", None)], service)
                self.zones = self.__class__.zones(path + [("zones", None)], service)
                self.actions = self.__class__.actions(path + [("actions", None)], service)
                self.transient_settings = self.__class__.transient_settings(path + [("transient_settings", None)], service)
            def dynamic_mesh(self, *args, **kwargs):
                """
                Enable/disable the dynamic mesh solver and options.
                """
                return PyMenu(self.service, "/define/dynamic_mesh/dynamic_mesh").execute(*args, **kwargs)

            class controls(metaclass=PyMenuMeta):
                """
                Enter the dynamic mesh control menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.smoothing_parameters = self.__class__.smoothing_parameters(path + [("smoothing_parameters", None)], service)
                    self.layering_parameters = self.__class__.layering_parameters(path + [("layering_parameters", None)], service)
                    self.remeshing_parameters = self.__class__.remeshing_parameters(path + [("remeshing_parameters", None)], service)
                    self.in_cylinder_parameters = self.__class__.in_cylinder_parameters(path + [("in_cylinder_parameters", None)], service)
                    self.implicit_update_parameters = self.__class__.implicit_update_parameters(path + [("implicit_update_parameters", None)], service)
                    self.six_dof_parameters = self.__class__.six_dof_parameters(path + [("six_dof_parameters", None)], service)
                    self.periodic_displacement_parameters = self.__class__.periodic_displacement_parameters(path + [("periodic_displacement_parameters", None)], service)
                    self.contact_parameters = self.__class__.contact_parameters(path + [("contact_parameters", None)], service)
                def in_cylinder_output(self, *args, **kwargs):
                    """
                    Enable/disable in-cylinder output.
                    """
                    return PyMenu(self.service, "/define/dynamic_mesh/controls/in_cylinder_output").execute(*args, **kwargs)
                def smoothing(self, *args, **kwargs):
                    """
                    Enable/disable dynamic mesh smoothing.
                    """
                    return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing").execute(*args, **kwargs)
                def layering(self, *args, **kwargs):
                    """
                    Enable/disable dynamic-layering in quad/hex cell zones.
                    """
                    return PyMenu(self.service, "/define/dynamic_mesh/controls/layering").execute(*args, **kwargs)
                def remeshing(self, *args, **kwargs):
                    """
                    Enable/disable local remeshing in tri/tet and mixed cell zones.
                    """
                    return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing").execute(*args, **kwargs)
                def steady_pseudo_time_control(self, *args, **kwargs):
                    """
                    Enable/disable pseudo time step control in user interface.
                    """
                    return PyMenu(self.service, "/define/dynamic_mesh/controls/steady_pseudo_time_control").execute(*args, **kwargs)

                class smoothing_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the dynamic mesh smoothing menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def smoothing_method(self, *args, **kwargs):
                        """
                        Specify the smoothing method used by the dynamic mesh model.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/smoothing_method").execute(*args, **kwargs)
                    def constant_factor(self, *args, **kwargs):
                        """
                        Set the spring constant relaxation factor.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/constant_factor").execute(*args, **kwargs)
                    def bnd_node_relaxation(self, *args, **kwargs):
                        """
                        Set the spring boundary node relaxation factor.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/bnd_node_relaxation").execute(*args, **kwargs)
                    def bnd_stiffness_factor(self, *args, **kwargs):
                        """
                        Set the stiffness factor for springs connected to boundary nodes.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/bnd_stiffness_factor").execute(*args, **kwargs)
                    def convergence_tolerance(self, *args, **kwargs):
                        """
                        Set the convergence tolerance for spring-based solver.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/convergence_tolerance").execute(*args, **kwargs)
                    def max_iter(self, *args, **kwargs):
                        """
                        Set the maximum number of iterations for spring-based solver.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/max_iter").execute(*args, **kwargs)
                    def spring_on_all_elements(self, *args, **kwargs):
                        """
                        Enable/disable spring-based smoothing for all cell shapes.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/spring_on_all_elements").execute(*args, **kwargs)
                    def spring_on_simplex_elements(self, *args, **kwargs):
                        """
                        Enable/disable spring-based smoothing for tri/tet elements in mixed element zones.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/spring_on_simplex_elements").execute(*args, **kwargs)
                    def skew_smooth_niter(self, *args, **kwargs):
                        """
                        Set the number of skewness-based smoothing cycles.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/skew_smooth_niter").execute(*args, **kwargs)
                    def skew_smooth_cell_skew_max(self, *args, **kwargs):
                        """
                        Set the cell skewness threshold above which cells will be smoothed 
                        using the skewness method.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/skew_smooth_cell_skew_max").execute(*args, **kwargs)
                    def skew_smooth_face_skew_max(self, *args, **kwargs):
                        """
                        Set the face skewness threshold above which deforming boundary faces 
                        will be smoothed using the skewness method.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/skew_smooth_face_skew_max").execute(*args, **kwargs)
                    def skew_smooth_all_deforming_boundaries(self, *args, **kwargs):
                        """
                        Enable/disable skewness smoothing for all deforming 
                        dynamic boundary zones. If disabled, only the deforming dynamic boundary zones are 
                        smoothed which have smoothing explicitly enabled or use local face remeshing.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/skew_smooth_all_deforming_boundaries").execute(*args, **kwargs)
                    def laplace_node_relaxation(self, *args, **kwargs):
                        """
                        Set the Laplace boundary node relaxation factor.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/laplace_node_relaxation").execute(*args, **kwargs)
                    def diffusion_coeff_function(self, *args, **kwargs):
                        """
                        Specify whether the diffusion coefficient is based on the 
                        boundary distance or the cell volume.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/diffusion_coeff_function").execute(*args, **kwargs)
                    def diffusion_coeff_parameter(self, *args, **kwargs):
                        """
                        Set the diffusion coefficient parameter used for diffusion-based smoothing.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/diffusion_coeff_parameter").execute(*args, **kwargs)
                    def diffusion_fvm(self, *args, **kwargs):
                        """
                        Set the numerical method used for diffusion-based smoothing.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/diffusion_fvm").execute(*args, **kwargs)
                    def poisson_ratio(self, *args, **kwargs):
                        """
                        Set the Poisson's ratio used by the linearly elastic solid model.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/poisson_ratio").execute(*args, **kwargs)
                    def smooth_from_reference_position(self, *args, **kwargs):
                        """
                        Enable smoothing from reference position.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/smooth_from_reference_position").execute(*args, **kwargs)
                    def relative_convergence_tolerance(self, *args, **kwargs):
                        """
                        Set the relative residual convergence tolerance for diffusion-based (FVM) smoothing.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/relative_convergence_tolerance").execute(*args, **kwargs)
                    def amg_stabilization(self, *args, **kwargs):
                        """
                        Set the AMG stabilization method for mesh smoothing (FEM).
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/amg_stabilization").execute(*args, **kwargs)
                    def verbosity(self, *args, **kwargs):
                        """
                        Set the verbosity for spring smoothing.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/verbosity").execute(*args, **kwargs)
                    def boundary_distance_method(self, *args, **kwargs):
                        """
                        Set the method used to evaluate the boundary distance for the 
                        diffusion coefficient calculation.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/smoothing_parameters/boundary_distance_method").execute(*args, **kwargs)

                class layering_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the dynamic mesh layering menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def split_factor(self, *args, **kwargs):
                        """
                        Set the factor determining when to split dynamic layers.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/layering_parameters/split_factor").execute(*args, **kwargs)
                    def collapse_factor(self, *args, **kwargs):
                        """
                        Set the factor determining when to collapse dynamic layers.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/layering_parameters/collapse_factor").execute(*args, **kwargs)
                    def constant_height(self, *args, **kwargs):
                        """
                        Enable/disable layering based on constant height, else layering based on constant ratio.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/layering_parameters/constant_height").execute(*args, **kwargs)

                class remeshing_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the dynamic mesh remeshing menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.prism_controls = self.__class__.prism_controls(path + [("prism_controls", None)], service)
                        self.sizing_controls = self.__class__.sizing_controls(path + [("sizing_controls", None)], service)
                        self.prism_layer_parameters = self.__class__.prism_layer_parameters(path + [("prism_layer_parameters", None)], service)
                    def unified_remeshing(self, *args, **kwargs):
                        """
                        Enable/disable unified remeshing.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/unified_remeshing").execute(*args, **kwargs)
                    def retain_size_distribution(self, *args, **kwargs):
                        """
                        Enable/disable retaining of size distribution.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/retain_size_distribution").execute(*args, **kwargs)
                    def poly_remeshing(self, *args, **kwargs):
                        """
                        Enable/disable poly remeshing.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/poly_remeshing").execute(*args, **kwargs)
                    def remeshing_methods(self, *args, **kwargs):
                        """
                        Enable/disable remeshing methods.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/remeshing_methods").execute(*args, **kwargs)
                    def zone_remeshing(self, *args, **kwargs):
                        """
                        Enable/disable cell zone remeshing method.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/zone_remeshing").execute(*args, **kwargs)
                    def length_min(self, *args, **kwargs):
                        """
                        Set the length threshold below which cells will be remeshed.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/length_min").execute(*args, **kwargs)
                    def length_max(self, *args, **kwargs):
                        """
                        Set the length threshold above which cells will be remeshed.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/length_max").execute(*args, **kwargs)
                    def cell_skew_max(self, *args, **kwargs):
                        """
                        Set the cell skewness threshold above which cells will be remeshed.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/cell_skew_max").execute(*args, **kwargs)
                    def face_skew_max(self, *args, **kwargs):
                        """
                        Set the face skewness threshold above which faces will be remeshed.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/face_skew_max").execute(*args, **kwargs)
                    def size_remesh_interval(self, *args, **kwargs):
                        """
                        Set the interval (in time steps) when remeshing based on size is done.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/size_remesh_interval").execute(*args, **kwargs)
                    def sizing_function(self, *args, **kwargs):
                        """
                        Enable/disable sizing function to control size based remeshing.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_function").execute(*args, **kwargs)
                    def sizing_funct_defaults(self, *args, **kwargs):
                        """
                        Set sizing function defaults.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_funct_defaults").execute(*args, **kwargs)
                    def sizing_funct_resolution(self, *args, **kwargs):
                        """
                        Set the sizing function resolution with respect to shortest boundary.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_funct_resolution").execute(*args, **kwargs)
                    def sizing_funct_variation(self, *args, **kwargs):
                        """
                        Set the maximum sizing function increase/decrease in the interior.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_funct_variation").execute(*args, **kwargs)
                    def sizing_funct_rate(self, *args, **kwargs):
                        """
                        Determine how far from the boundary the increase/decrease happens.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_funct_rate").execute(*args, **kwargs)
                    def parallel_remeshing(self, *args, **kwargs):
                        """
                        Enable/disable parallel remeshing for zone remeshing.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/parallel_remeshing").execute(*args, **kwargs)
                    def remeshing_after_moving(self, *args, **kwargs):
                        """
                        Enable/disable optional remeshing after mesh motion to meet skewness threshold.
                        Steady state dynamic mesh only.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/remeshing_after_moving").execute(*args, **kwargs)

                    class prism_controls(metaclass=PyMenuMeta):
                        """
                        Specify optional prism controls.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def add(self, *args, **kwargs):
                            """
                            Add a new object.
                            """
                            return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/prism_controls/add").execute(*args, **kwargs)
                        def edit(self, *args, **kwargs):
                            """
                            Edit an object.
                            """
                            return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/prism_controls/edit").execute(*args, **kwargs)
                        def delete(self, *args, **kwargs):
                            """
                            Delete an object.
                            """
                            return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/prism_controls/delete").execute(*args, **kwargs)
                        def list(self, *args, **kwargs):
                            """
                            List objects.
                            """
                            return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/prism_controls/list").execute(*args, **kwargs)
                        def list_properties(self, *args, **kwargs):
                            """
                            List properties of an object.
                            """
                            return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/prism_controls/list_properties").execute(*args, **kwargs)

                    class sizing_controls(metaclass=PyMenuMeta):
                        """
                        Specify optional sizing controls.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def add(self, *args, **kwargs):
                            """
                            Add a new object.
                            """
                            return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_controls/add").execute(*args, **kwargs)
                        def edit(self, *args, **kwargs):
                            """
                            Edit an object.
                            """
                            return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_controls/edit").execute(*args, **kwargs)
                        def delete(self, *args, **kwargs):
                            """
                            Delete an object.
                            """
                            return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_controls/delete").execute(*args, **kwargs)
                        def list(self, *args, **kwargs):
                            """
                            List objects.
                            """
                            return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_controls/list").execute(*args, **kwargs)
                        def list_properties(self, *args, **kwargs):
                            """
                            List properties of an object.
                            """
                            return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/sizing_controls/list_properties").execute(*args, **kwargs)

                    class prism_layer_parameters(metaclass=PyMenuMeta):
                        """
                        Enter the dynamic mesh prism remeshing menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def first_height(self, *args, **kwargs):
                            """
                            Set first cell height in the prism layer.
                            """
                            return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/prism_layer_parameters/first_height").execute(*args, **kwargs)
                        def growth_rate(self, *args, **kwargs):
                            """
                            Set the geometric growth rate of the prism layer.
                            """
                            return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/prism_layer_parameters/growth_rate").execute(*args, **kwargs)
                        def number_of_layers(self, *args, **kwargs):
                            """
                            Set the number of elements in the prism layer.
                            """
                            return PyMenu(self.service, "/define/dynamic_mesh/controls/remeshing_parameters/prism_layer_parameters/number_of_layers").execute(*args, **kwargs)

                class in_cylinder_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the dynamic mesh in-cylinder menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def starting_crank_angle(self, *args, **kwargs):
                        """
                        Specify the starting crank angle.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/in_cylinder_parameters/starting_crank_angle").execute(*args, **kwargs)
                    def crank_angle_step(self, *args, **kwargs):
                        """
                        Specify the crank angle step size.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/in_cylinder_parameters/crank_angle_step").execute(*args, **kwargs)
                    def crank_period(self, *args, **kwargs):
                        """
                        Specify the crank period.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/in_cylinder_parameters/crank_period").execute(*args, **kwargs)
                    def max_crank_angle_step(self, *args, **kwargs):
                        """
                        Specify the maximum crank angle step size.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/in_cylinder_parameters/max_crank_angle_step").execute(*args, **kwargs)
                    def piston_data(self, *args, **kwargs):
                        """
                        Specify the crank radius, connecting rod length, and piston pin offset.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/in_cylinder_parameters/piston_data").execute(*args, **kwargs)
                    def piston_stroke_cutoff(self, *args, **kwargs):
                        """
                        Specify the cut off point for in-cylinder piston.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/in_cylinder_parameters/piston_stroke_cutoff").execute(*args, **kwargs)
                    def minimum_lift(self, *args, **kwargs):
                        """
                        Specify the minimum lift for in-cylinder valves.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/in_cylinder_parameters/minimum_lift").execute(*args, **kwargs)
                    def print_plot_lift(self, *args, **kwargs):
                        """
                        Print or plot valve lift curve.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/in_cylinder_parameters/print_plot_lift").execute(*args, **kwargs)
                    def modify_lift(self, *args, **kwargs):
                        """
                        Modify the lift curve (shift or scale).
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/in_cylinder_parameters/modify_lift").execute(*args, **kwargs)
                    def position_starting_mesh(self, *args, **kwargs):
                        """
                        Move mesh from top dead center to starting crank angle.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/in_cylinder_parameters/position_starting_mesh").execute(*args, **kwargs)

                class implicit_update_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the dynamic mesh implicit update menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def update_interval(self, *args, **kwargs):
                        """
                        Specify update interval of implicit update.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/implicit_update_parameters/update_interval").execute(*args, **kwargs)
                    def motion_relaxation(self, *args, **kwargs):
                        """
                        Specify motion relaxation of implicit update.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/implicit_update_parameters/motion_relaxation").execute(*args, **kwargs)
                    def residual_criteria(self, *args, **kwargs):
                        """
                        Specify residual criteria of implicit update.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/implicit_update_parameters/residual_criteria").execute(*args, **kwargs)

                class six_dof_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the dynamic mesh six-dof menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def create_properties(self, *args, **kwargs):
                        """
                        Create a set of Six DOF Properties.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/six_dof_parameters/create_properties").execute(*args, **kwargs)
                    def delete_properties(self, *args, **kwargs):
                        """
                        Delete a set of Six DOF Properties.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/six_dof_parameters/delete_properties").execute(*args, **kwargs)
                    def list_properties(self, *args, **kwargs):
                        """
                        List Six DOF Properties.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/six_dof_parameters/list_properties").execute(*args, **kwargs)
                    def x_component_of_gravity(self, *args, **kwargs):
                        """
                        Specify x-component-of-gravity.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/six_dof_parameters/x_component_of_gravity").execute(*args, **kwargs)
                    def y_component_of_gravity(self, *args, **kwargs):
                        """
                        Specify y-component-of-gravity.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/six_dof_parameters/y_component_of_gravity").execute(*args, **kwargs)
                    def z_component_of_gravity(self, *args, **kwargs):
                        """
                        Specify z-component-of-gravity.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/six_dof_parameters/z_component_of_gravity").execute(*args, **kwargs)
                    def second_order(self, *args, **kwargs):
                        """
                        Enable/disable second order six DOF solver.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/six_dof_parameters/second_order").execute(*args, **kwargs)
                    def motion_history(self, *args, **kwargs):
                        """
                        Enable/disable writing position/orientation of six DOF zones to file.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/six_dof_parameters/motion_history").execute(*args, **kwargs)
                    def motion_history_file_name(self, *args, **kwargs):
                        """
                        Location of six DOF motion history file.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/six_dof_parameters/motion_history_file_name").execute(*args, **kwargs)

                class periodic_displacement_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the dynamic mesh periodic displacement menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def list_displacements(self, *args, **kwargs):
                        """
                        List Periodic Displacements.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/periodic_displacement_parameters/list_displacements").execute(*args, **kwargs)
                    def create_displacement(self, *args, **kwargs):
                        """
                        Create Periodic Displacement.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/periodic_displacement_parameters/create_displacement").execute(*args, **kwargs)
                    def edit_displacement(self, *args, **kwargs):
                        """
                        Edit Periodic Displacement.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/periodic_displacement_parameters/edit_displacement").execute(*args, **kwargs)
                    def copy_displacement(self, *args, **kwargs):
                        """
                        Copy Periodic Displacement.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/periodic_displacement_parameters/copy_displacement").execute(*args, **kwargs)
                    def delete_displacement(self, *args, **kwargs):
                        """
                        Delete Periodic Displacement.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/periodic_displacement_parameters/delete_displacement").execute(*args, **kwargs)
                    def delete_all_displacements(self, *args, **kwargs):
                        """
                        Delete All Periodic Displacements.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/periodic_displacement_parameters/delete_all_displacements").execute(*args, **kwargs)
                    def create_group(self, *args, **kwargs):
                        """
                        Create Periodic Displacement Group.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/periodic_displacement_parameters/create_group").execute(*args, **kwargs)
                    def list_groups(self, *args, **kwargs):
                        """
                        List Periodic Displacement Groups.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/periodic_displacement_parameters/list_groups").execute(*args, **kwargs)
                    def edit_group(self, *args, **kwargs):
                        """
                        Edit Periodic Displacement Group.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/periodic_displacement_parameters/edit_group").execute(*args, **kwargs)
                    def delete_group(self, *args, **kwargs):
                        """
                        Delete Periodic Displacement Group.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/periodic_displacement_parameters/delete_group").execute(*args, **kwargs)
                    def delete_all_groups(self, *args, **kwargs):
                        """
                        Delete All Periodic Displacement Groups.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/periodic_displacement_parameters/delete_all_groups").execute(*args, **kwargs)
                    def set_active_displacement(self, *args, **kwargs):
                        """
                        Set Active Periodic Displacement in Group.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/periodic_displacement_parameters/set_active_displacement").execute(*args, **kwargs)

                class contact_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the dynamic mesh contact detection menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.flow_control_parameters = self.__class__.flow_control_parameters(path + [("flow_control_parameters", None)], service)
                    def contact_face_zones(self, *args, **kwargs):
                        """
                        Select face zones involved in contact detection.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/contact_parameters/contact_face_zones").execute(*args, **kwargs)
                    def contact_udf(self, *args, **kwargs):
                        """
                        Select UDF to be invoked when contact is detected.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/contact_parameters/contact_udf").execute(*args, **kwargs)
                    def contact_threshold(self, *args, **kwargs):
                        """
                        Specify threshold distance for contact detection.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/contact_parameters/contact_threshold").execute(*args, **kwargs)
                    def update_contact_marks(self, *args, **kwargs):
                        """
                        Update which cells are marked in order to block flow in the contact region.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/contact_parameters/update_contact_marks").execute(*args, **kwargs)
                    def flow_control(self, *args, **kwargs):
                        """
                        Enable/disable flow control.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/contact_parameters/flow_control").execute(*args, **kwargs)
                    def contact_method(self, *args, **kwargs):
                        """
                        Select the method used for flow control in the contact region.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/contact_parameters/contact_method").execute(*args, **kwargs)
                    def render_contact_cells(self, *args, **kwargs):
                        """
                        Set the option to include contact-cells in post-processing.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/contact_parameters/render_contact_cells").execute(*args, **kwargs)
                    def verbosity(self, *args, **kwargs):
                        """
                        Set the verbosity for contact-detection.
                        """
                        return PyMenu(self.service, "/define/dynamic_mesh/controls/contact_parameters/verbosity").execute(*args, **kwargs)

                    class flow_control_parameters(metaclass=PyMenuMeta):
                        """
                        Enter the flow control menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def solution_stabilization(self, *args, **kwargs):
                            """
                            Enable/disable the performance of additional iterations per time step and 
                                the application of solution controls to improve the stability of the solver.
                            """
                            return PyMenu(self.service, "/define/dynamic_mesh/controls/contact_parameters/flow_control_parameters/solution_stabilization").execute(*args, **kwargs)
                        def create_flow_control_zone(self, *args, **kwargs):
                            """
                            Create a flow control zone.
                            """
                            return PyMenu(self.service, "/define/dynamic_mesh/controls/contact_parameters/flow_control_parameters/create_flow_control_zone").execute(*args, **kwargs)
                        def delete_flow_control_zone(self, *args, **kwargs):
                            """
                            Delete a flow control zone.
                            """
                            return PyMenu(self.service, "/define/dynamic_mesh/controls/contact_parameters/flow_control_parameters/delete_flow_control_zone").execute(*args, **kwargs)

            class events(metaclass=PyMenuMeta):
                """
                Enter the dynamic mesh events menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def import_event_file(self, *args, **kwargs):
                    """
                    Import dynamic mesh event file.
                    """
                    return PyMenu(self.service, "/define/dynamic_mesh/events/import_event_file").execute(*args, **kwargs)
                def export_event_file(self, *args, **kwargs):
                    """
                    Export dynamic mesh events to file.
                    """
                    return PyMenu(self.service, "/define/dynamic_mesh/events/export_event_file").execute(*args, **kwargs)

            class zones(metaclass=PyMenuMeta):
                """
                Enter the dynamic mesh zones menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def create(self, *args, **kwargs):
                    """
                    Create dynamic zone.
                    """
                    return PyMenu(self.service, "/define/dynamic_mesh/zones/create").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete dynamic zone.
                    """
                    return PyMenu(self.service, "/define/dynamic_mesh/zones/delete").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    List dynamic zones.
                    """
                    return PyMenu(self.service, "/define/dynamic_mesh/zones/list").execute(*args, **kwargs)
                def insert_boundary_layer(self, *args, **kwargs):
                    """
                    Insert new cell zone.
                    """
                    return PyMenu(self.service, "/define/dynamic_mesh/zones/insert_boundary_layer").execute(*args, **kwargs)
                def remove_boundary_layer(self, *args, **kwargs):
                    """
                    Remove cell zone.
                    """
                    return PyMenu(self.service, "/define/dynamic_mesh/zones/remove_boundary_layer").execute(*args, **kwargs)
                def insert_interior_layer(self, *args, **kwargs):
                    """
                    Insert new layer cell zone at specified location.
                    """
                    return PyMenu(self.service, "/define/dynamic_mesh/zones/insert_interior_layer").execute(*args, **kwargs)
                def remove_interior_layer(self, *args, **kwargs):
                    """
                    Remove interior layer cell zone.
                    """
                    return PyMenu(self.service, "/define/dynamic_mesh/zones/remove_interior_layer").execute(*args, **kwargs)

            class actions(metaclass=PyMenuMeta):
                """
                Enter the dynamic mesh actions menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def remesh_cell_zone(self, *args, **kwargs):
                    """
                    Manually remesh cell zone with option to remesh adjacent dynamic face zones.
                    """
                    return PyMenu(self.service, "/define/dynamic_mesh/actions/remesh_cell_zone").execute(*args, **kwargs)

            class transient_settings(metaclass=PyMenuMeta):
                """
                Enter the dynamic mesh transient settings menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def verbosity(self, *args, **kwargs):
                    """
                    Enable/disable transient scheme verbosity for dynamic mesh cases.
                    """
                    return PyMenu(self.service, "/define/dynamic_mesh/transient_settings/verbosity").execute(*args, **kwargs)
                def allow_second_order(self, *args, **kwargs):
                    """
                    Enable/disable 2nd order transient scheme for dynamic mesh cases.
                    """
                    return PyMenu(self.service, "/define/dynamic_mesh/transient_settings/allow_second_order").execute(*args, **kwargs)

        class mesh_interfaces(metaclass=PyMenuMeta):
            """
            Enter the mesh-interfaces menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.non_conformal_interface_numerics = self.__class__.non_conformal_interface_numerics(path + [("non_conformal_interface_numerics", None)], service)
                self.mapped_interface_options = self.__class__.mapped_interface_options(path + [("mapped_interface_options", None)], service)
                self.auto_options = self.__class__.auto_options(path + [("auto_options", None)], service)
            def create(self, *args, **kwargs):
                """
                Create a mesh interface.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/create").execute(*args, **kwargs)
            def turbo_create(self, *args, **kwargs):
                """
                Create a general turbo interface.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/turbo_create").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit a mesh interface.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete a mesh interface.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/delete").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                Display specified mesh interface zone.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/display").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List all mesh-interfaces.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/list").execute(*args, **kwargs)
            def make_periodic(self, *args, **kwargs):
                """
                Make interface zones periodic.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/make_periodic").execute(*args, **kwargs)
            def make_phaselag_from_boundaries(self, *args, **kwargs):
                """
                Make interface zones phase lagged.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/make_phaselag_from_boundaries").execute(*args, **kwargs)
            def make_phaselag_from_periodic(self, *args, **kwargs):
                """
                Convert periodic interface to phase lagged.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/make_phaselag_from_periodic").execute(*args, **kwargs)
            def delete_all(self, *args, **kwargs):
                """
                Delete all mesh interfaces.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/delete_all").execute(*args, **kwargs)
            def enforce_continuity_after_bc(self, *args, **kwargs):
                """
                Across the interface, enforces continuity over boundary condition.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/enforce_continuity_after_bc").execute(*args, **kwargs)
            def verbosity(self, *args, **kwargs):
                """
                Set mesh interface verbosity.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/verbosity").execute(*args, **kwargs)
            def enable_si_with_nodes(self, *args, **kwargs):
                """
                Enable sliding interfaces with nodes.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/enable_si_with_nodes").execute(*args, **kwargs)
            def enforce_coupled_wall_between_solids(self, *args, **kwargs):
                """
                Create coupled wall interface between solids.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/enforce_coupled_wall_between_solids").execute(*args, **kwargs)
            def improve_quality(self, *args, **kwargs):
                """
                Improve mesh interface quality.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/improve_quality").execute(*args, **kwargs)
            def one_to_one_pairing(self, *args, **kwargs):
                """
                Use the default one-to-one interface creation method?.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/one_to_one_pairing").execute(*args, **kwargs)
            def auto_pairing(self, *args, **kwargs):
                """
                Automatically pair and create mesh interfaces for some or all interface zones.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/auto_pairing").execute(*args, **kwargs)
            def enable_visualization_of_interfaces(self, *args, **kwargs):
                """
                Display facets on mesh interfaces.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/enable_visualization_of_interfaces").execute(*args, **kwargs)
            def transfer_motion_across_interfaces(self, *args, **kwargs):
                """
                Transfer motion from one side of the interface to the other when only one side undergoes user-defined or system-coupling motion.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/transfer_motion_across_interfaces").execute(*args, **kwargs)
            def non_overlapping_zone_name(self, *args, **kwargs):
                """
                Get non-overlapping zone name from the associated interface zone.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/non_overlapping_zone_name").execute(*args, **kwargs)
            def remove_left_handed_interface_faces(self, *args, **kwargs):
                """
                Remove left-handed faces during mesh interface creation.
                """
                return PyMenu(self.service, "/define/mesh_interfaces/remove_left_handed_interface_faces").execute(*args, **kwargs)

            class non_conformal_interface_numerics(metaclass=PyMenuMeta):
                """
                Setting non-conformal numerics options.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def change_numerics(self, *args, **kwargs):
                    """
                    Enable modified non-conformal interface numerics.
                    """
                    return PyMenu(self.service, "/define/mesh_interfaces/non_conformal_interface_numerics/change_numerics").execute(*args, **kwargs)

            class mapped_interface_options(metaclass=PyMenuMeta):
                """
                Enter the mapped-interface-options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def solution_controls(self, *args, **kwargs):
                    """
                    Specification of mapped frequency and under-relaxation factor for mapped interfaces.
                    """
                    return PyMenu(self.service, "/define/mesh_interfaces/mapped_interface_options/solution_controls").execute(*args, **kwargs)
                def tolerance(self, *args, **kwargs):
                    """
                    Specification of mapped interface tolerance.
                    """
                    return PyMenu(self.service, "/define/mesh_interfaces/mapped_interface_options/tolerance").execute(*args, **kwargs)
                def convert_to_mapped_interface(self, *args, **kwargs):
                    """
                    Convert non-conformal mesh interface to mapped mesh interfaces.
                    """
                    return PyMenu(self.service, "/define/mesh_interfaces/mapped_interface_options/convert_to_mapped_interface").execute(*args, **kwargs)

            class auto_options(metaclass=PyMenuMeta):
                """
                Enter auto-options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def proximity_tolerance(self, *args, **kwargs):
                    """
                    Specification of auto pairing tolerance.
                    """
                    return PyMenu(self.service, "/define/mesh_interfaces/auto_options/proximity_tolerance").execute(*args, **kwargs)
                def naming_option(self, *args, **kwargs):
                    """
                    Specify whether or not to include an informative suffix to the mesh interface name.
                    """
                    return PyMenu(self.service, "/define/mesh_interfaces/auto_options/naming_option").execute(*args, **kwargs)
                def set_default_name_prefix(self, *args, **kwargs):
                    """
                    Specification of auto pairing default name prefix.
                    """
                    return PyMenu(self.service, "/define/mesh_interfaces/auto_options/set_default_name_prefix").execute(*args, **kwargs)
                def set_one_to_one_pairing_tolerance(self, *args, **kwargs):
                    """
                    Enable/disable one-to-one auto pairing tolerance.
                    """
                    return PyMenu(self.service, "/define/mesh_interfaces/auto_options/set_one_to_one_pairing_tolerance").execute(*args, **kwargs)
                def pairing_between_different_cell_zones_only(self, *args, **kwargs):
                    """
                    Pairing between interface zones from different cell zones only.
                    """
                    return PyMenu(self.service, "/define/mesh_interfaces/auto_options/pairing_between_different_cell_zones_only").execute(*args, **kwargs)
                def pairing_between_interface_zones_only(self, *args, **kwargs):
                    """
                    Pairing between interface zones only.
                    """
                    return PyMenu(self.service, "/define/mesh_interfaces/auto_options/pairing_between_interface_zones_only").execute(*args, **kwargs)
                def keep_empty_interface(self, *args, **kwargs):
                    """
                    Keep empty interfaces during one-to-one mesh interface creation.
                    """
                    return PyMenu(self.service, "/define/mesh_interfaces/auto_options/keep_empty_interface").execute(*args, **kwargs)

        class gap_model(metaclass=PyMenuMeta):
            """
            Enter the narrow-gaps menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.advanced_options = self.__class__.advanced_options(path + [("advanced_options", None)], service)
            def enable(self, *args, **kwargs):
                """
                Enable/Disable gap model.
                """
                return PyMenu(self.service, "/define/gap_model/enable").execute(*args, **kwargs)
            def create(self, *args, **kwargs):
                """
                Create a gap object.
                """
                return PyMenu(self.service, "/define/gap_model/create").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an exiting gap object.
                """
                return PyMenu(self.service, "/define/gap_model/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an exiting gap object.
                """
                return PyMenu(self.service, "/define/gap_model/delete").execute(*args, **kwargs)
            def delete_all(self, *args, **kwargs):
                """
                Delete all of the exiting gap objects.
                """
                return PyMenu(self.service, "/define/gap_model/delete_all").execute(*args, **kwargs)
            def list_gap_regions(self, *args, **kwargs):
                """
                List gap regions.
                """
                return PyMenu(self.service, "/define/gap_model/list_gap_regions").execute(*args, **kwargs)
            def list_gap_face_zones(self, *args, **kwargs):
                """
                List name of the gap face zones that can be used for gaps creation.
                """
                return PyMenu(self.service, "/define/gap_model/list_gap_face_zones").execute(*args, **kwargs)
            def list_gap_cell_zones(self, *args, **kwargs):
                """
                List name of the gap cells zones that can be used as exclided cell zones in gaps creation.
                """
                return PyMenu(self.service, "/define/gap_model/list_gap_cell_zones").execute(*args, **kwargs)
            def render_gap_regions(self, *args, **kwargs):
                """
                Update gap regions for postprocessing.
                """
                return PyMenu(self.service, "/define/gap_model/render_gap_regions").execute(*args, **kwargs)

            class advanced_options(metaclass=PyMenuMeta):
                """
                Show options.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def expert(self, *args, **kwargs):
                    """
                    Enable expert options for gap model.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/expert").execute(*args, **kwargs)
                def alternative_marking(self, *args, **kwargs):
                    """
                    Mark gap regions using an alternative marking algorithm.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/alternative_marking").execute(*args, **kwargs)
                def cell_check_distance_factor(self, *args, **kwargs):
                    """
                    Enter value of the cell distance factor.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/cell_check_distance_factor").execute(*args, **kwargs)
                def flow_blocking_stabilization_parameters(self, *args, **kwargs):
                    """
                    Adjust stabilization settings for the sponge layer used for blocked gap regions.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/flow_blocking_stabilization_parameters").execute(*args, **kwargs)
                def update_gap_regions(self, *args, **kwargs):
                    """
                    Update gap regions and gap model solution information.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/update_gap_regions").execute(*args, **kwargs)
                def clear_gap_regions(self, *args, **kwargs):
                    """
                    Clear gap model solution information and marks.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/clear_gap_regions").execute(*args, **kwargs)
                def precise_gap_marking(self, *args, **kwargs):
                    """
                    Mark cells in gap regions using more accurate search algorithm.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/precise_gap_marking").execute(*args, **kwargs)
                def render_flow_modeling_gaps(self, *args, **kwargs):
                    """
                    Render solution inside flow modeling gap cells.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/render_flow_modeling_gaps").execute(*args, **kwargs)
                def reduce_gap_regions(self, *args, **kwargs):
                    """
                    Using a more restrictive algorithm for marking cells in gap regions.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/reduce_gap_regions").execute(*args, **kwargs)
                def fill_data_in_gap_regions(self, *args, **kwargs):
                    """
                    Interpolate solution data into the whole gap regions.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/fill_data_in_gap_regions").execute(*args, **kwargs)
                def enhanced_data_interpolation(self, *args, **kwargs):
                    """
                    Use enhanced data interpolation for updating information in gap regions.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/enhanced_data_interpolation").execute(*args, **kwargs)
                def sponge_layer(self, *args, **kwargs):
                    """
                    Set advanced settings for gap sponge layer.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/sponge_layer").execute(*args, **kwargs)
                def solution_stabilization(self, *args, **kwargs):
                    """
                    Set solution stabilization level for gap model.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/solution_stabilization").execute(*args, **kwargs)
                def include_coupled_walls(self, *args, **kwargs):
                    """
                    Include coupled walls in gap face zones.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/include_coupled_walls").execute(*args, **kwargs)
                def check_cfl_condition(self, *args, **kwargs):
                    """
                    Check time step size for better convergence.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/check_cfl_condition").execute(*args, **kwargs)
                def extend_gap_regions(self, *args, **kwargs):
                    """
                    Extend gap regions for better convergence.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/extend_gap_regions").execute(*args, **kwargs)
                def revert_controls_to_default(self, *args, **kwargs):
                    """
                    Revert gap stabilization and any related solver settings to default.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/revert_controls_to_default").execute(*args, **kwargs)
                def verbosity(self, *args, **kwargs):
                    """
                    Set the verbosity for gap model.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/verbosity").execute(*args, **kwargs)
                def render_gap_interface(self, *args, **kwargs):
                    """
                    Render gap interface.
                    """
                    return PyMenu(self.service, "/define/gap_model/advanced_options/render_gap_interface").execute(*args, **kwargs)

        class materials(metaclass=PyMenuMeta):
            """
            Enter the materials menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.data_base = self.__class__.data_base(path + [("data_base", None)], service)
            def change_create(self, *args, **kwargs):
                """
                Change the properties of a locally-stored material or create a new material.
                """
                return PyMenu(self.service, "/define/materials/change_create").execute(*args, **kwargs)
            def copy(self, *args, **kwargs):
                """
                Copy a material from the database.
                """
                return PyMenu(self.service, "/define/materials/copy").execute(*args, **kwargs)
            def copy_by_formula(self, *args, **kwargs):
                """
                Copy a material from the database by formula.
                """
                return PyMenu(self.service, "/define/materials/copy_by_formula").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete a material from local storage.
                """
                return PyMenu(self.service, "/define/materials/delete").execute(*args, **kwargs)
            def list_materials(self, *args, **kwargs):
                """
                List all locally-stored materials.
                """
                return PyMenu(self.service, "/define/materials/list_materials").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                List the properties of a locally-stored material.
                """
                return PyMenu(self.service, "/define/materials/list_properties").execute(*args, **kwargs)

            class data_base(metaclass=PyMenuMeta):
                """
                Enter the database menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def database_type(self, *args, **kwargs):
                    """
                    Set the database type.
                    """
                    return PyMenu(self.service, "/define/materials/data_base/database_type").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit a material.
                    """
                    return PyMenu(self.service, "/define/materials/data_base/edit").execute(*args, **kwargs)
                def list_materials(self, *args, **kwargs):
                    """
                    List all materials in the database.
                    """
                    return PyMenu(self.service, "/define/materials/data_base/list_materials").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    List the properties of a material in the database.
                    """
                    return PyMenu(self.service, "/define/materials/data_base/list_properties").execute(*args, **kwargs)
                def new(self, *args, **kwargs):
                    """
                    Define a new material.
                    """
                    return PyMenu(self.service, "/define/materials/data_base/new").execute(*args, **kwargs)
                def save(self, *args, **kwargs):
                    """
                    Save user-defined database.
                    """
                    return PyMenu(self.service, "/define/materials/data_base/save").execute(*args, **kwargs)

        class mixing_planes(metaclass=PyMenuMeta):
            """
            Enter the mixing planes menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.set = self.__class__.set(path + [("set", None)], service)
            def create(self, *args, **kwargs):
                """
                Create a mixing plane.
                """
                return PyMenu(self.service, "/define/mixing_planes/create").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete a mixing plane.
                """
                return PyMenu(self.service, "/define/mixing_planes/delete").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List defined mixing plane(s).
                """
                return PyMenu(self.service, "/define/mixing_planes/list").execute(*args, **kwargs)

            class set(metaclass=PyMenuMeta):
                """
                Enter the mixing plane set menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.conserve_swirl = self.__class__.conserve_swirl(path + [("conserve_swirl", None)], service)
                    self.conserve_total_enthalpy = self.__class__.conserve_total_enthalpy(path + [("conserve_total_enthalpy", None)], service)
                def under_relaxation(self, *args, **kwargs):
                    """
                    Set mixing plane under-relaxation factor.
                    """
                    return PyMenu(self.service, "/define/mixing_planes/set/under_relaxation").execute(*args, **kwargs)
                def averaging_method(self, *args, **kwargs):
                    """
                    Set mixing plane profile averaging method.
                    """
                    return PyMenu(self.service, "/define/mixing_planes/set/averaging_method").execute(*args, **kwargs)
                def fix_pressure_level(self, *args, **kwargs):
                    """
                    Set fix pressure level using define/reference-pressure-location.
                    """
                    return PyMenu(self.service, "/define/mixing_planes/set/fix_pressure_level").execute(*args, **kwargs)

                class conserve_swirl(metaclass=PyMenuMeta):
                    """
                    Enter the mixing plane conserve-swirl menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def enable(self, *args, **kwargs):
                        """
                        Enable/disable swirl conservation in mixing plane.
                        """
                        return PyMenu(self.service, "/define/mixing_planes/set/conserve_swirl/enable").execute(*args, **kwargs)
                    def verbosity(self, *args, **kwargs):
                        """
                        Enable/disable verbosity in swirl conservation calculations.
                        """
                        return PyMenu(self.service, "/define/mixing_planes/set/conserve_swirl/verbosity").execute(*args, **kwargs)
                    def report_swirl_integration(self, *args, **kwargs):
                        """
                        Report swirl integration (torque) on inflow and outflow zones.
                        """
                        return PyMenu(self.service, "/define/mixing_planes/set/conserve_swirl/report_swirl_integration").execute(*args, **kwargs)

                class conserve_total_enthalpy(metaclass=PyMenuMeta):
                    """
                    Enter the menu to set total enthalpy conservation in mixing plane menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def enable(self, *args, **kwargs):
                        """
                        Enable/disable total enthalpy conservation in mixing plane.
                        """
                        return PyMenu(self.service, "/define/mixing_planes/set/conserve_total_enthalpy/enable").execute(*args, **kwargs)
                    def verbosity(self, *args, **kwargs):
                        """
                        Enable/disable verbosity in total-enthalpy conservation calculations.
                        """
                        return PyMenu(self.service, "/define/mixing_planes/set/conserve_total_enthalpy/verbosity").execute(*args, **kwargs)

        class models(metaclass=PyMenuMeta):
            """
            Enter the models menu to configure the solver.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.acoustics = self.__class__.acoustics(path + [("acoustics", None)], service)
                self.optics = self.__class__.optics(path + [("optics", None)], service)
                self.eulerian_wallfilm = self.__class__.eulerian_wallfilm(path + [("eulerian_wallfilm", None)], service)
                self.dpm = self.__class__.dpm(path + [("dpm", None)], service)
                self.shell_conduction = self.__class__.shell_conduction(path + [("shell_conduction", None)], service)
                self.system_coupling_settings = self.__class__.system_coupling_settings(path + [("system_coupling_settings", None)], service)
                self.cht = self.__class__.cht(path + [("cht", None)], service)
                self.two_temperature = self.__class__.two_temperature(path + [("two_temperature", None)], service)
                self.multiphase = self.__class__.multiphase(path + [("multiphase", None)], service)
                self.nox_parameters = self.__class__.nox_parameters(path + [("nox_parameters", None)], service)
                self.soot_parameters = self.__class__.soot_parameters(path + [("soot_parameters", None)], service)
                self.radiation = self.__class__.radiation(path + [("radiation", None)], service)
                self.solver = self.__class__.solver(path + [("solver", None)], service)
                self.species = self.__class__.species(path + [("species", None)], service)
                self.viscous = self.__class__.viscous(path + [("viscous", None)], service)
                self.structure = self.__class__.structure(path + [("structure", None)], service)
                self.heat_exchanger = self.__class__.heat_exchanger(path + [("heat_exchanger", None)], service)
                self.electrolysis_setup = self.__class__.electrolysis_setup(path + [("electrolysis_setup", None)], service)
            def addon_module(self, *args, **kwargs):
                """
                Load addon module.
                """
                return PyMenu(self.service, "/define/models/addon_module").execute(*args, **kwargs)
            def axisymmetric(self, *args, **kwargs):
                """
                Enable/disable the axisymmetric model.
                """
                return PyMenu(self.service, "/define/models/axisymmetric").execute(*args, **kwargs)
            def solidification_melting(self, *args, **kwargs):
                """
                Enable/disable the solidification and melting model.
                """
                return PyMenu(self.service, "/define/models/solidification_melting").execute(*args, **kwargs)
            def crevice_model(self, *args, **kwargs):
                """
                Enable/disable the crevice model.
                """
                return PyMenu(self.service, "/define/models/crevice_model").execute(*args, **kwargs)
            def crevice_model_controls(self, *args, **kwargs):
                """
                Enter the crevice model controls menu.
                """
                return PyMenu(self.service, "/define/models/crevice_model_controls").execute(*args, **kwargs)
            def energy(self, *args, **kwargs):
                """
                Enable/disable the energy model.
                """
                return PyMenu(self.service, "/define/models/energy").execute(*args, **kwargs)
            def noniterative_time_advance(self, *args, **kwargs):
                """
                Enable/disable the noniterative time advancement scheme.
                """
                return PyMenu(self.service, "/define/models/noniterative_time_advance").execute(*args, **kwargs)
            def nox(self, *args, **kwargs):
                """
                Enable/disable the NOx model.
                """
                return PyMenu(self.service, "/define/models/nox").execute(*args, **kwargs)
            def soot(self, *args, **kwargs):
                """
                Enable/disable the soot model.
                """
                return PyMenu(self.service, "/define/models/soot").execute(*args, **kwargs)
            def steady(self, *args, **kwargs):
                """
                Enable/disable the steady solution model.
                """
                return PyMenu(self.service, "/define/models/steady").execute(*args, **kwargs)
            def swirl(self, *args, **kwargs):
                """
                Enable/disable axisymmetric swirl velocity.
                """
                return PyMenu(self.service, "/define/models/swirl").execute(*args, **kwargs)
            def unsteady_1st_order(self, *args, **kwargs):
                """
                Enable/disable first-order unsteady solution model.
                """
                return PyMenu(self.service, "/define/models/unsteady_1st_order").execute(*args, **kwargs)
            def frozen_flux(self, *args, **kwargs):
                """
                Enable/disable frozen flux formulation for transient flows.
                """
                return PyMenu(self.service, "/define/models/frozen_flux").execute(*args, **kwargs)
            def unsteady_2nd_order(self, *args, **kwargs):
                """
                Enable/disable the second-order unsteady solution model.
                """
                return PyMenu(self.service, "/define/models/unsteady_2nd_order").execute(*args, **kwargs)
            def unsteady_2nd_order_bounded(self, *args, **kwargs):
                """
                Enable/disable bounded second-order unsteady formulation.
                """
                return PyMenu(self.service, "/define/models/unsteady_2nd_order_bounded").execute(*args, **kwargs)
            def unsteady_global_time(self, *args, **kwargs):
                """
                Enable/disable the unsteady global-time-step solution model.
                """
                return PyMenu(self.service, "/define/models/unsteady_global_time").execute(*args, **kwargs)
            def unsteady_structure_newmark(self, *args, **kwargs):
                """
                Enable/disable Newmark unsteady solution model.
                """
                return PyMenu(self.service, "/define/models/unsteady_structure_newmark").execute(*args, **kwargs)
            def unsteady_structure_euler(self, *args, **kwargs):
                """
                Enable/disable Backward Euler unsteady solution model.
                """
                return PyMenu(self.service, "/define/models/unsteady_structure_euler").execute(*args, **kwargs)
            def battery_model(self, *args, **kwargs):
                """
                Enter battery model menu.
                """
                return PyMenu(self.service, "/define/models/battery_model").execute(*args, **kwargs)
            def ablation(self, *args, **kwargs):
                """
                Enable/disable ablation model.
                """
                return PyMenu(self.service, "/define/models/ablation").execute(*args, **kwargs)
            def potential_and_li_ion_battery(self, *args, **kwargs):
                """
                Enable/disable the electric-potential model.
                """
                return PyMenu(self.service, "/define/models/potential_and_li_ion_battery").execute(*args, **kwargs)

            class acoustics(metaclass=PyMenuMeta):
                """
                Enter the acoustics model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.far_field_parameters = self.__class__.far_field_parameters(path + [("far_field_parameters", None)], service)
                    self.wave_equation_options = self.__class__.wave_equation_options(path + [("wave_equation_options", None)], service)
                    self.sources_fft = self.__class__.sources_fft(path + [("sources_fft", None)], service)
                    self.sponge_layers = self.__class__.sponge_layers(path + [("sponge_layers", None)], service)
                def off(self, *args, **kwargs):
                    """
                    Enable/disable the acoustics model.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/off").execute(*args, **kwargs)
                def ffowcs_williams(self, *args, **kwargs):
                    """
                    Enable/disable the Ffowcs-Williams-and-Hawkings model.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/ffowcs_williams").execute(*args, **kwargs)
                def broad_band_noise(self, *args, **kwargs):
                    """
                    Enable/disable the broadband noise model.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/broad_band_noise").execute(*args, **kwargs)
                def modal_analysis(self, *args, **kwargs):
                    """
                    Enable/disable the modal analysis model.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/modal_analysis").execute(*args, **kwargs)
                def wave_equation(self, *args, **kwargs):
                    """
                    Enable/disable the wave equation model.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/wave_equation").execute(*args, **kwargs)
                def receivers(self, *args, **kwargs):
                    """
                    Set acoustic receivers.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/receivers").execute(*args, **kwargs)
                def export_source_data(self, *args, **kwargs):
                    """
                    Enable export acoustic source data in ASD format during the wave equation model run.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/export_source_data").execute(*args, **kwargs)
                def export_source_data_cgns(self, *args, **kwargs):
                    """
                    Export acoustic source data in CGNS format.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/export_source_data_cgns").execute(*args, **kwargs)
                def sources(self, *args, **kwargs):
                    """
                    Set acoustic sources.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/sources").execute(*args, **kwargs)
                def read_compute_write(self, *args, **kwargs):
                    """
                    Read acoustic source data files and compute sound pressure.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/read_compute_write").execute(*args, **kwargs)
                def write_acoustic_signals(self, *args, **kwargs):
                    """
                    Write on-the-fly sound pressure.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/write_acoustic_signals").execute(*args, **kwargs)
                def compute_write(self, *args, **kwargs):
                    """
                    Compute sound pressure.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/compute_write").execute(*args, **kwargs)
                def write_centroid_info(self, *args, **kwargs):
                    """
                    Write centroid info.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/write_centroid_info").execute(*args, **kwargs)
                def acoustic_modal_analysis(self, *args, **kwargs):
                    """
                    Iterate linear acoustic solver to compute the resonance frequencies and the acoustic modes.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/acoustic_modal_analysis").execute(*args, **kwargs)
                def export_volumetric_sources(self, *args, **kwargs):
                    """
                    Enable/disable the export of fluid zones.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/export_volumetric_sources").execute(*args, **kwargs)
                def export_volumetric_sources_cgns(self, *args, **kwargs):
                    """
                    Enable/disable the export of fluid zones.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/export_volumetric_sources_cgns").execute(*args, **kwargs)
                def display_flow_time(self, *args, **kwargs):
                    """
                    Enable/disable the display of flow time during read-and-compute.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/display_flow_time").execute(*args, **kwargs)
                def cylindrical_export(self, *args, **kwargs):
                    """
                    Enable/disable the export data in cylindrical coordinates.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/cylindrical_export").execute(*args, **kwargs)
                def auto_prune(self, *args, **kwargs):
                    """
                    Enable/disable auto prune of the receiver signal(s) during read-and-compute.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/auto_prune").execute(*args, **kwargs)
                def moving_receiver(self, *args, **kwargs):
                    """
                    Enable/disable moving receiver option.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/moving_receiver").execute(*args, **kwargs)
                def convective_effects(self, *args, **kwargs):
                    """
                    Enable/disable convective effects option.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/convective_effects").execute(*args, **kwargs)
                def display_frequencies(self, *args, **kwargs):
                    """
                    Display resonance frequencies.
                    """
                    return PyMenu(self.service, "/define/models/acoustics/display_frequencies").execute(*args, **kwargs)

                class far_field_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the far field parameters menu for the wave equation model.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def far_field_density(self, *args, **kwargs):
                        """
                        Specify far field density.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/far_field_parameters/far_field_density").execute(*args, **kwargs)
                    def far_field_sound_speed(self, *args, **kwargs):
                        """
                        Specify far field speed of sound.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/far_field_parameters/far_field_sound_speed").execute(*args, **kwargs)

                class wave_equation_options(metaclass=PyMenuMeta):
                    """
                    Enter the options menu for the wave equation model.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.basic_shapes = self.__class__.basic_shapes(path + [("basic_shapes", None)], service)
                        self.remote_receivers_options = self.__class__.remote_receivers_options(path + [("remote_receivers_options", None)], service)
                    def time_filter_source(self, *args, **kwargs):
                        """
                        Activate time-filtering of sound sources.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/wave_equation_options/time_filter_source").execute(*args, **kwargs)
                    def sponge_layer_factor(self, *args, **kwargs):
                        """
                        Specify artificial viscosity factor for sponge layer.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/wave_equation_options/sponge_layer_factor").execute(*args, **kwargs)
                    def sponge_layer_base_level(self, *args, **kwargs):
                        """
                        Specify artificial viscosity base level applied everywhere.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/wave_equation_options/sponge_layer_base_level").execute(*args, **kwargs)
                    def source_mask_udf(self, *args, **kwargs):
                        """
                        Select user-defined function for sound source masking.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/wave_equation_options/source_mask_udf").execute(*args, **kwargs)
                    def sponge_layer_udf(self, *args, **kwargs):
                        """
                        Select user-defined function for sponge layer.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/wave_equation_options/sponge_layer_udf").execute(*args, **kwargs)
                    def remote_receivers(self, *args, **kwargs):
                        """
                        Activate the Kirchhoff's integral method for remote receivers.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/wave_equation_options/remote_receivers").execute(*args, **kwargs)

                    class basic_shapes(metaclass=PyMenuMeta):
                        """
                        Enter the basic shapes menu to build source mask and sponge layer
                        geometry shapes using cell registers.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def list_region_registers(self, *args, **kwargs):
                            """
                            List all available region registers (hex/cylinder/sphere).
                            """
                            return PyMenu(self.service, "/define/models/acoustics/wave_equation_options/basic_shapes/list_region_registers").execute(*args, **kwargs)
                        def list_source_mask_shapes(self, *args, **kwargs):
                            """
                            List all active source mask registers.
                            """
                            return PyMenu(self.service, "/define/models/acoustics/wave_equation_options/basic_shapes/list_source_mask_shapes").execute(*args, **kwargs)
                        def list_sponge_layer_shapes(self, *args, **kwargs):
                            """
                            List all active sponge layer registers.
                            """
                            return PyMenu(self.service, "/define/models/acoustics/wave_equation_options/basic_shapes/list_sponge_layer_shapes").execute(*args, **kwargs)
                        def add_source_mask_shape(self, *args, **kwargs):
                            """
                            Add a region register for the source mask.
                            """
                            return PyMenu(self.service, "/define/models/acoustics/wave_equation_options/basic_shapes/add_source_mask_shape").execute(*args, **kwargs)
                        def add_sponge_layer_shape(self, *args, **kwargs):
                            """
                            Add a region register for the sponge layer.
                            """
                            return PyMenu(self.service, "/define/models/acoustics/wave_equation_options/basic_shapes/add_sponge_layer_shape").execute(*args, **kwargs)
                        def remove_source_mask_shape(self, *args, **kwargs):
                            """
                            Remove a region register from the source mask.
                            """
                            return PyMenu(self.service, "/define/models/acoustics/wave_equation_options/basic_shapes/remove_source_mask_shape").execute(*args, **kwargs)
                        def remove_sponge_layer_shape(self, *args, **kwargs):
                            """
                            Remove a region register from the sponge layer.
                            """
                            return PyMenu(self.service, "/define/models/acoustics/wave_equation_options/basic_shapes/remove_sponge_layer_shape").execute(*args, **kwargs)

                    class remote_receivers_options(metaclass=PyMenuMeta):
                        """
                        Enter the menu to set up the Kirchhoff's integral method and output its results.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def integration_surface(self, *args, **kwargs):
                            """
                            Select Kirchhoff's integration surface.
                            """
                            return PyMenu(self.service, "/define/models/acoustics/wave_equation_options/remote_receivers_options/integration_surface").execute(*args, **kwargs)
                        def write_signals(self, *args, **kwargs):
                            """
                            Write signals calculated at receiver locations.
                            """
                            return PyMenu(self.service, "/define/models/acoustics/wave_equation_options/remote_receivers_options/write_signals").execute(*args, **kwargs)

                class sources_fft(metaclass=PyMenuMeta):
                    """
                    Enter the acoustic sources FFT menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.fft_surface_variables = self.__class__.fft_surface_variables(path + [("fft_surface_variables", None)], service)
                    def read_asd_files(self, *args, **kwargs):
                        """
                        Read ASD files.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/sources_fft/read_asd_files").execute(*args, **kwargs)
                    def compute_fft_fields(self, *args, **kwargs):
                        """
                        Compute FFT fields.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/sources_fft/compute_fft_fields").execute(*args, **kwargs)
                    def write_cgns_files(self, *args, **kwargs):
                        """
                        Write CGNS files.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/sources_fft/write_cgns_files").execute(*args, **kwargs)
                    def clean_up_storage_area(self, *args, **kwargs):
                        """
                        Clean up storage area.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/sources_fft/clean_up_storage_area").execute(*args, **kwargs)

                    class fft_surface_variables(metaclass=PyMenuMeta):
                        """
                        Enter the FFT surface variables menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def create_octave_bands(self, *args, **kwargs):
                            """
                            Create octave bands.
                            """
                            return PyMenu(self.service, "/define/models/acoustics/sources_fft/fft_surface_variables/create_octave_bands").execute(*args, **kwargs)
                        def create_third_bands(self, *args, **kwargs):
                            """
                            Create third bands.
                            """
                            return PyMenu(self.service, "/define/models/acoustics/sources_fft/fft_surface_variables/create_third_bands").execute(*args, **kwargs)
                        def create_constant_width_bands(self, *args, **kwargs):
                            """
                            Create constant-width bands.
                            """
                            return PyMenu(self.service, "/define/models/acoustics/sources_fft/fft_surface_variables/create_constant_width_bands").execute(*args, **kwargs)
                        def create_set_of_modes(self, *args, **kwargs):
                            """
                            Create set of modes.
                            """
                            return PyMenu(self.service, "/define/models/acoustics/sources_fft/fft_surface_variables/create_set_of_modes").execute(*args, **kwargs)
                        def remove_variables(self, *args, **kwargs):
                            """
                            Remove variables.
                            """
                            return PyMenu(self.service, "/define/models/acoustics/sources_fft/fft_surface_variables/remove_variables").execute(*args, **kwargs)

                class sponge_layers(metaclass=PyMenuMeta):
                    """
                    Manage sponge layers where density is blended to eliminate reflections from boundary zones.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def activate(self, *args, **kwargs):
                        """
                        Activate a sponge object.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/sponge_layers/activate").execute(*args, **kwargs)
                    def add(self, *args, **kwargs):
                        """
                        Add a new sponge layer definition.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/sponge_layers/add").execute(*args, **kwargs)
                    def deactivate(self, *args, **kwargs):
                        """
                        Deactivate a sponge layer definition.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/sponge_layers/deactivate").execute(*args, **kwargs)
                    def edit(self, *args, **kwargs):
                        """
                        Edit a sponge layer definition.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/sponge_layers/edit").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete a sponge layer definition.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/sponge_layers/delete").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        List the names of the sponge layer definitions.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/sponge_layers/list").execute(*args, **kwargs)
                    def list_active(self, *args, **kwargs):
                        """
                        List the names of the active sponge layer definitions.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/sponge_layers/list_active").execute(*args, **kwargs)
                    def list_properties(self, *args, **kwargs):
                        """
                        List the properties of a sponge layer definition.
                        """
                        return PyMenu(self.service, "/define/models/acoustics/sponge_layers/list_properties").execute(*args, **kwargs)

            class optics(metaclass=PyMenuMeta):
                """
                Enter the optics model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.set = self.__class__.set(path + [("set", None)], service)
                def enable(self, *args, **kwargs):
                    """
                    Enable/disable optics model.
                    """
                    return PyMenu(self.service, "/define/models/optics/enable").execute(*args, **kwargs)
                def add_beam(self, *args, **kwargs):
                    """
                    Add optical beam grid.
                    """
                    return PyMenu(self.service, "/define/models/optics/add_beam").execute(*args, **kwargs)

                class set(metaclass=PyMenuMeta):
                    """
                    Enter the set menu for optics model.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def sampling(self, *args, **kwargs):
                        """
                        Specify when the fluid density field is sampled.
                        """
                        return PyMenu(self.service, "/define/models/optics/set/sampling").execute(*args, **kwargs)
                    def index_of_refraction(self, *args, **kwargs):
                        """
                        Specify the model parameters of index of refraction.
                        """
                        return PyMenu(self.service, "/define/models/optics/set/index_of_refraction").execute(*args, **kwargs)
                    def running_average(self, *args, **kwargs):
                        """
                        Setup the running average of the collected density field.
                        """
                        return PyMenu(self.service, "/define/models/optics/set/running_average").execute(*args, **kwargs)

            class eulerian_wallfilm(metaclass=PyMenuMeta):
                """
                Enter the Eulerian wall film model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.coupled_solution = self.__class__.coupled_solution(path + [("coupled_solution", None)], service)
                    self.implicit_options = self.__class__.implicit_options(path + [("implicit_options", None)], service)
                def enable_wallfilm_model(self, *args, **kwargs):
                    """
                    Enable Eulerian wall film model.
                    """
                    return PyMenu(self.service, "/define/models/eulerian_wallfilm/enable_wallfilm_model").execute(*args, **kwargs)
                def initialize_wallfilm_model(self, *args, **kwargs):
                    """
                    Initialize Eulerian wall film model.
                    """
                    return PyMenu(self.service, "/define/models/eulerian_wallfilm/initialize_wallfilm_model").execute(*args, **kwargs)
                def solve_wallfilm_equation(self, *args, **kwargs):
                    """
                    Activate Eulerian wall film equations.
                    """
                    return PyMenu(self.service, "/define/models/eulerian_wallfilm/solve_wallfilm_equation").execute(*args, **kwargs)
                def model_options(self, *args, **kwargs):
                    """
                    Set Eulerian wall film model options.
                    """
                    return PyMenu(self.service, "/define/models/eulerian_wallfilm/model_options").execute(*args, **kwargs)
                def film_material(self, *args, **kwargs):
                    """
                    Set film material and properties.
                    """
                    return PyMenu(self.service, "/define/models/eulerian_wallfilm/film_material").execute(*args, **kwargs)
                def solution_options(self, *args, **kwargs):
                    """
                    Set Eulerian wall film model solution options.
                    """
                    return PyMenu(self.service, "/define/models/eulerian_wallfilm/solution_options").execute(*args, **kwargs)

                class coupled_solution(metaclass=PyMenuMeta):
                    """
                    Enter Eulerian wall film coupled solution menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def enable_coupled_solution(self, *args, **kwargs):
                        """
                        Enable Eulerian wall film coupled solution.
                        """
                        return PyMenu(self.service, "/define/models/eulerian_wallfilm/coupled_solution/enable_coupled_solution").execute(*args, **kwargs)
                    def enable_curvature_smoothing(self, *args, **kwargs):
                        """
                        Enable Eulerian wall film curvature smoothing.
                        """
                        return PyMenu(self.service, "/define/models/eulerian_wallfilm/coupled_solution/enable_curvature_smoothing").execute(*args, **kwargs)

                class implicit_options(metaclass=PyMenuMeta):
                    """
                    Enter Implicit Scheme Option (beta).
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def new_implicit_scheme(self, *args, **kwargs):
                        """
                        Enable alternative implicit scheme.
                        """
                        return PyMenu(self.service, "/define/models/eulerian_wallfilm/implicit_options/new_implicit_scheme").execute(*args, **kwargs)
                    def relative_error_residual(self, *args, **kwargs):
                        """
                        Enable relative error residual.
                        """
                        return PyMenu(self.service, "/define/models/eulerian_wallfilm/implicit_options/relative_error_residual").execute(*args, **kwargs)

            class dpm(metaclass=PyMenuMeta):
                """
                Enter the dispersed phase model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.collisions = self.__class__.collisions(path + [("collisions", None)], service)
                    self.erosion_dynamic_mesh = self.__class__.erosion_dynamic_mesh(path + [("erosion_dynamic_mesh", None)], service)
                    self.interaction = self.__class__.interaction(path + [("interaction", None)], service)
                    self.numerics = self.__class__.numerics(path + [("numerics", None)], service)
                    self.options = self.__class__.options(path + [("options", None)], service)
                    self.parallel = self.__class__.parallel(path + [("parallel", None)], service)
                    self.splash_options = self.__class__.splash_options(path + [("splash_options", None)], service)
                    self.stripping_options = self.__class__.stripping_options(path + [("stripping_options", None)], service)
                def clear_particles_from_domain(self, *args, **kwargs):
                    """
                    Remove/keep all particles currently in the domain.
                    """
                    return PyMenu(self.service, "/define/models/dpm/clear_particles_from_domain").execute(*args, **kwargs)
                def fill_injection_material_sources(self, *args, **kwargs):
                    """
                    Initialize the DPM sources corresponding to each material.
                    """
                    return PyMenu(self.service, "/define/models/dpm/fill_injection_material_sources").execute(*args, **kwargs)
                def injections(self, *args, **kwargs):
                    """
                    Enter the injections menu.
                    """
                    return PyMenu(self.service, "/define/models/dpm/injections").execute(*args, **kwargs)
                def unsteady_tracking(self, *args, **kwargs):
                    """
                    Enable/disable unsteady particle tracking.
                    """
                    return PyMenu(self.service, "/define/models/dpm/unsteady_tracking").execute(*args, **kwargs)
                def spray_model(self, *args, **kwargs):
                    """
                    Enter the spray model menu.
                    """
                    return PyMenu(self.service, "/define/models/dpm/spray_model").execute(*args, **kwargs)
                def user_defined(self, *args, **kwargs):
                    """
                    Set DPM user-defined functions.
                    """
                    return PyMenu(self.service, "/define/models/dpm/user_defined").execute(*args, **kwargs)

                class collisions(metaclass=PyMenuMeta):
                    """
                    Enter the DEM collisions menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.collision_partners = self.__class__.collision_partners(path + [("collision_partners", None)], service)
                    def collision_pair_settings(self, *args, **kwargs):
                        """
                        Supply settings for collisions to a pair of collision partners.
                        """
                        return PyMenu(self.service, "/define/models/dpm/collisions/collision_pair_settings").execute(*args, **kwargs)
                    def list_all_pair_settings(self, *args, **kwargs):
                        """
                        For each pair of collision partners, lists the collision laws and their parameters.
                        """
                        return PyMenu(self.service, "/define/models/dpm/collisions/list_all_pair_settings").execute(*args, **kwargs)
                    def dem_collisions(self, *args, **kwargs):
                        """
                        Enable/disable the DEM collision model.
                        """
                        return PyMenu(self.service, "/define/models/dpm/collisions/dem_collisions").execute(*args, **kwargs)
                    def collision_mesh(self, *args, **kwargs):
                        """
                        Input for the collision mesh.
                        """
                        return PyMenu(self.service, "/define/models/dpm/collisions/collision_mesh").execute(*args, **kwargs)
                    def max_particle_velocity(self, *args, **kwargs):
                        """
                        Set the maximum particle velocity that may arise from collisions.
                        """
                        return PyMenu(self.service, "/define/models/dpm/collisions/max_particle_velocity").execute(*args, **kwargs)

                    class collision_partners(metaclass=PyMenuMeta):
                        """
                        Manage collision partners.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def create(self, *args, **kwargs):
                            """
                            Create a collision partner.
                            """
                            return PyMenu(self.service, "/define/models/dpm/collisions/collision_partners/create").execute(*args, **kwargs)
                        def delete(self, *args, **kwargs):
                            """
                            Delete a collision partner.
                            """
                            return PyMenu(self.service, "/define/models/dpm/collisions/collision_partners/delete").execute(*args, **kwargs)
                        def copy(self, *args, **kwargs):
                            """
                            Copy a collision partner.
                            """
                            return PyMenu(self.service, "/define/models/dpm/collisions/collision_partners/copy").execute(*args, **kwargs)
                        def rename(self, *args, **kwargs):
                            """
                            Rename a collision partner.
                            """
                            return PyMenu(self.service, "/define/models/dpm/collisions/collision_partners/rename").execute(*args, **kwargs)
                        def list(self, *args, **kwargs):
                            """
                            Lists all known collision partners.
                            """
                            return PyMenu(self.service, "/define/models/dpm/collisions/collision_partners/list").execute(*args, **kwargs)

                class erosion_dynamic_mesh(metaclass=PyMenuMeta):
                    """
                    Enter the erosion-dynamic mesh interactions menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.general_parameters = self.__class__.general_parameters(path + [("general_parameters", None)], service)
                        self.run_parameters = self.__class__.run_parameters(path + [("run_parameters", None)], service)
                    def enable_erosion_dynamic_mesh_coupling(self, *args, **kwargs):
                        """
                        Enable mesh deformation due to wall erosion.
                        """
                        return PyMenu(self.service, "/define/models/dpm/erosion_dynamic_mesh/enable_erosion_dynamic_mesh_coupling").execute(*args, **kwargs)
                    def run_simulation(self, *args, **kwargs):
                        """
                        Perform coupled erosion-dynamic mesh simulation.
                        """
                        return PyMenu(self.service, "/define/models/dpm/erosion_dynamic_mesh/run_simulation").execute(*args, **kwargs)

                    class general_parameters(metaclass=PyMenuMeta):
                        """
                        Enter the erosion-dynamic mesh setup menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def erosion_settings(self, *args, **kwargs):
                            """
                            Set erosion modelling specific settings.
                            """
                            return PyMenu(self.service, "/define/models/dpm/erosion_dynamic_mesh/general_parameters/erosion_settings").execute(*args, **kwargs)
                        def dynamic_mesh_settings(self, *args, **kwargs):
                            """
                            Perform dynamic mesh related setup.
                            """
                            return PyMenu(self.service, "/define/models/dpm/erosion_dynamic_mesh/general_parameters/dynamic_mesh_settings").execute(*args, **kwargs)
                        def participating_walls(self, *args, **kwargs):
                            """
                            Specify all participating walls.
                            """
                            return PyMenu(self.service, "/define/models/dpm/erosion_dynamic_mesh/general_parameters/participating_walls").execute(*args, **kwargs)

                    class run_parameters(metaclass=PyMenuMeta):
                        """
                        Enter the erosion-dynamic mesh run menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def mesh_motion_time_step(self, *args, **kwargs):
                            """
                            Set the mesh motion time stepping parameters and method.
                            """
                            return PyMenu(self.service, "/define/models/dpm/erosion_dynamic_mesh/run_parameters/mesh_motion_time_step").execute(*args, **kwargs)
                        def simulation_termination(self, *args, **kwargs):
                            """
                            Set total time of erosion.
                            """
                            return PyMenu(self.service, "/define/models/dpm/erosion_dynamic_mesh/run_parameters/simulation_termination").execute(*args, **kwargs)
                        def flow_simulation_control(self, *args, **kwargs):
                            """
                            Set number of iterations per flow simulation step.
                            """
                            return PyMenu(self.service, "/define/models/dpm/erosion_dynamic_mesh/run_parameters/flow_simulation_control").execute(*args, **kwargs)
                        def autosave_files(self, *args, **kwargs):
                            """
                            Set the iteration increment to save data files.
                            """
                            return PyMenu(self.service, "/define/models/dpm/erosion_dynamic_mesh/run_parameters/autosave_files").execute(*args, **kwargs)
                        def autosave_graphics(self, *args, **kwargs):
                            """
                            Set the iteration increment to save graphics files.
                            """
                            return PyMenu(self.service, "/define/models/dpm/erosion_dynamic_mesh/run_parameters/autosave_graphics").execute(*args, **kwargs)

                class interaction(metaclass=PyMenuMeta):
                    """
                    Enter the interaction menu to set parameters for coupled discrete phase calculations.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def choice_of_eulerian_phase_for_interaction(self, *args, **kwargs):
                        """
                        Enable/disable the option to choose for every injection the Eulerian phase for the DPM continuous phase interaction.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/choice_of_eulerian_phase_for_interaction").execute(*args, **kwargs)
                    def coupled_calculations(self, *args, **kwargs):
                        """
                        Enable/disable coupling of continuous and discrete phase calculations.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/coupled_calculations").execute(*args, **kwargs)
                    def dpm_iteration_interval(self, *args, **kwargs):
                        """
                        Set the number of continuous phase iterations per DPM iteration.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/dpm_iteration_interval").execute(*args, **kwargs)
                    def underrelaxation_factor(self, *args, **kwargs):
                        """
                        Set the under-relaxation factor.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/underrelaxation_factor").execute(*args, **kwargs)
                    def implicit_momentum_coupling(self, *args, **kwargs):
                        """
                        Enable/disable implicit treatment for the DPM momentum source terms.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/implicit_momentum_coupling").execute(*args, **kwargs)
                    def implicit_source_term_coupling(self, *args, **kwargs):
                        """
                        Enable/disable implicit treatment for all DPM source terms.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/implicit_source_term_coupling").execute(*args, **kwargs)
                    def linearized_dpm_source_terms(self, *args, **kwargs):
                        """
                        Perform a linearization of all DPM source terms to increase numerical robustness.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/linearized_dpm_source_terms").execute(*args, **kwargs)
                    def replace_dpm_mass_source_by_mixture_fraction(self, *args, **kwargs):
                        """
                        Recalculate the mixture fraction source terms as function of the primary mixture fraction?.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/replace_dpm_mass_source_by_mixture_fraction").execute(*args, **kwargs)
                    def linearized_dpm_mixture_fraction_source_terms(self, *args, **kwargs):
                        """
                        Perform a linearization of mixture fraction source terms.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/linearized_dpm_mixture_fraction_source_terms").execute(*args, **kwargs)
                    def linearized_dpm_species_source_terms(self, *args, **kwargs):
                        """
                        Perform linearization of species source terms.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/linearized_dpm_species_source_terms").execute(*args, **kwargs)
                    def keep_linearized_dpm_source_terms_constant(self, *args, **kwargs):
                        """
                        Keep linearized DPM source terms constant until the next DPM Update.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/keep_linearized_dpm_source_terms_constant").execute(*args, **kwargs)
                    def linearized_dpm_source_terms_limiter(self, *args, **kwargs):
                        """
                        Relative limit for DPM source linear coefficient with respect to fluid linear Ap coefficient.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/linearized_dpm_source_terms_limiter").execute(*args, **kwargs)
                    def update_dpm_sources_every_flow_iteration(self, *args, **kwargs):
                        """
                        Enable/disable the update of DPM source terms every flow iteration. 
                        
                              (if not, the terms will be updated every DPM iteration).
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/update_dpm_sources_every_flow_iteration").execute(*args, **kwargs)
                    def linear_growth_of_dpm_source_term(self, *args, **kwargs):
                        """
                        Enable/disable the linear growth of DPM source terms every DPM iteration. 
                        .
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/linear_growth_of_dpm_source_term").execute(*args, **kwargs)
                    def reset_sources_at_timestep_flag(self, *args, **kwargs):
                        """
                        Enable/disable flush of DPM source terms at beginning of every time step.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/reset_sources_at_timestep_flag").execute(*args, **kwargs)
                    def enable_flow_blocking_by_particles_flag(self, *args, **kwargs):
                        """
                        Enable/disable inclusion of DPM volume fraction in continuous flow.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/enable_flow_blocking_by_particles_flag").execute(*args, **kwargs)
                    def enable_source_scaling_due_to_flow_blocking_flag(self, *args, **kwargs):
                        """
                        Enable/disable scaling of DPM source terms due to inclusion of DPM volume fraction in continuous flow.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/enable_source_scaling_due_to_flow_blocking_flag").execute(*args, **kwargs)
                    def enable_drag_scaling_due_to_flow_blocking_flag(self, *args, **kwargs):
                        """
                        Enable/disable scaling of DPM drag coefficient due to inclusion of DPM volume fraction in continuous flow.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/enable_drag_scaling_due_to_flow_blocking_flag").execute(*args, **kwargs)
                    def max_vf_allowed_for_blocking(self, *args, **kwargs):
                        """
                        Maximum DPM volume fraction used in continuous flow.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/max_vf_allowed_for_blocking").execute(*args, **kwargs)
                    def min_vf_threshold_for_dpm_src_scaling(self, *args, **kwargs):
                        """
                        Minimum DPM volume fraction below which no DPM source scaling is applied.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/min_vf_threshold_for_dpm_src_scaling").execute(*args, **kwargs)
                    def ddpm_iad_particle(self, *args, **kwargs):
                        """
                        Enable/disable the non-default interfacial area method IA-particle.
                        """
                        return PyMenu(self.service, "/define/models/dpm/interaction/ddpm_iad_particle").execute(*args, **kwargs)

                class numerics(metaclass=PyMenuMeta):
                    """
                    Enter the numerics menu to set numerical solution parameters.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.high_resolution_tracking = self.__class__.high_resolution_tracking(path + [("high_resolution_tracking", None)], service)
                    def coupled_heat_mass_update(self, *args, **kwargs):
                        """
                        Enable/disable coupled heat and mass update.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/coupled_heat_mass_update").execute(*args, **kwargs)
                    def minimum_liquid_fraction(self, *args, **kwargs):
                        """
                        Evaporate droplet completely when the remaining mass is below this fraction of initial mass.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/minimum_liquid_fraction").execute(*args, **kwargs)
                    def underrelax_film_height(self, *args, **kwargs):
                        """
                        Define underrelaxation factor for film height.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/underrelax_film_height").execute(*args, **kwargs)
                    def vaporization_limiting_factors(self, *args, **kwargs):
                        """
                        Set Vaporization Fractional Change Limits.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/vaporization_limiting_factors").execute(*args, **kwargs)
                    def tracking_parameters(self, *args, **kwargs):
                        """
                        Set parameters for the (initial) tracking step length.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/tracking_parameters").execute(*args, **kwargs)
                    def tracking_scheme(self, *args, **kwargs):
                        """
                        Specify a tracking scheme.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/tracking_scheme").execute(*args, **kwargs)
                    def tracking_statistics(self, *args, **kwargs):
                        """
                        Control the format of the one-line tracking statistics printed after every DPM tracking pass.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/tracking_statistics").execute(*args, **kwargs)
                    def verbosity(self, *args, **kwargs):
                        """
                        Adjust the DPM tracker's verbosity level.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/verbosity").execute(*args, **kwargs)
                    def error_control(self, *args, **kwargs):
                        """
                        Set the adapt integration step length based on a maximum error.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/error_control").execute(*args, **kwargs)
                    def automated_scheme_selection(self, *args, **kwargs):
                        """
                        Enable/disable the adaptation of integration step length based on a maximum error.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/automated_scheme_selection").execute(*args, **kwargs)
                    def drag_law(self, *args, **kwargs):
                        """
                        Set the drag law.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/drag_law").execute(*args, **kwargs)
                    def enable_node_based_averaging(self, *args, **kwargs):
                        """
                        Enable node based averaging of DPM variables.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/enable_node_based_averaging").execute(*args, **kwargs)
                    def average_source_terms(self, *args, **kwargs):
                        """
                        Average DPM source terms on nodes.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/average_source_terms").execute(*args, **kwargs)
                    def average_DDPM_variables(self, *args, **kwargs):
                        """
                        Average DDPM specific variables like volume fractions and velocities on nodes.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/average_DDPM_variables").execute(*args, **kwargs)
                    def average_each_step(self, *args, **kwargs):
                        """
                        Do the averaging after each integration step for higher accuracy at a higher cost.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/average_each_step").execute(*args, **kwargs)
                    def average_kernel(self, *args, **kwargs):
                        """
                        Specify a kernel for the averaging.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/average_kernel").execute(*args, **kwargs)
                    def gaussian_factor(self, *args, **kwargs):
                        """
                        Set a factor for the gaussian kernel for node-based averaging.~%Large values give small size, small values give large size of kernel.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/gaussian_factor").execute(*args, **kwargs)
                    def mppic_settings(self, *args, **kwargs):
                        """
                        Enable PIC and MPPIC to compute DPM and DDPM source terms.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/mppic_settings").execute(*args, **kwargs)
                    def enhanced_packing_limit_numerics(self, *args, **kwargs):
                        """
                        Enable enhanced packing limit numerics to avoid exceeding of packing limit for granular phases.
                        """
                        return PyMenu(self.service, "/define/models/dpm/numerics/enhanced_packing_limit_numerics").execute(*args, **kwargs)

                    class high_resolution_tracking(metaclass=PyMenuMeta):
                        """
                        Enter the high resolution tracking menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.barycentric_interpolation = self.__class__.barycentric_interpolation(path + [("barycentric_interpolation", None)], service)
                            self.particle_relocation = self.__class__.particle_relocation(path + [("particle_relocation", None)], service)
                        def enable_high_resolution_tracking(self, *args, **kwargs):
                            """
                            Enable high resolution tracking.
                            """
                            return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/enable_high_resolution_tracking").execute(*args, **kwargs)
                        def enable_barycentric_intersections(self, *args, **kwargs):
                            """
                            Use barycentric coordinates for intersection calculations.
                            """
                            return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/enable_barycentric_intersections").execute(*args, **kwargs)
                        def use_barycentric_sampling(self, *args, **kwargs):
                            """
                            Use barycentric coordinates when sampling at planes.
                            """
                            return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/use_barycentric_sampling").execute(*args, **kwargs)
                        def use_velocity_based_error_control(self, *args, **kwargs):
                            """
                            Use adaptive time stepping based upon the particle velocity.
                            """
                            return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/use_velocity_based_error_control").execute(*args, **kwargs)
                        def use_quad_face_centroid(self, *args, **kwargs):
                            """
                            Use quad face centroids when creating subtets.
                            """
                            return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/use_quad_face_centroid").execute(*args, **kwargs)
                        def check_subtet_validity(self, *args, **kwargs):
                            """
                            Test for inverted subtets due to warped cells.
                            """
                            return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/check_subtet_validity").execute(*args, **kwargs)
                        def always_use_face_centroid_with_periodics(self, *args, **kwargs):
                            """
                            Use quad face centroids when creating subtets if the case contains periodic boundaries.
                            """
                            return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/always_use_face_centroid_with_periodics").execute(*args, **kwargs)
                        def boundary_layer_tracking(self, *args, **kwargs):
                            """
                            Adjust the particle timestep to account for high aspect ratio cells.
                            """
                            return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/boundary_layer_tracking").execute(*args, **kwargs)
                        def sliding_interface_crossover_fraction(self, *args, **kwargs):
                            """
                            Move the particle a fraction of the distance to the subtet center when crossing a sliding interface.
                            """
                            return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/sliding_interface_crossover_fraction").execute(*args, **kwargs)
                        def project_wall_film_particles_to_film(self, *args, **kwargs):
                            """
                            Project existing particles to film to track using high resolution tracking?.
                            """
                            return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/project_wall_film_particles_to_film").execute(*args, **kwargs)
                        def use_particle_timestep_for_intersection_tolerance(self, *args, **kwargs):
                            """
                            Use the particle timestep for the axisymmetric subtet intersection tolerance.
                            """
                            return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/use_particle_timestep_for_intersection_tolerance").execute(*args, **kwargs)
                        def enable_automatic_intersection_tolerance(self, *args, **kwargs):
                            """
                            Enable automatic scaling of subtet intersection tolerance.
                            """
                            return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/enable_automatic_intersection_tolerance").execute(*args, **kwargs)
                        def set_film_spreading_parameter(self, *args, **kwargs):
                            """
                            Set the spreading parameter for Lagrangian wallfilm particles.
                            """
                            return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/set_film_spreading_parameter").execute(*args, **kwargs)
                        def set_subtet_intersection_tolerance(self, *args, **kwargs):
                            """
                            Set the tolerance for subtet intersection calculations.
                            """
                            return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/set_subtet_intersection_tolerance").execute(*args, **kwargs)

                        class barycentric_interpolation(metaclass=PyMenuMeta):
                            """
                            Enter the barycentric interpolation menu.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def interpolate_flow_solution_gradients(self, *args, **kwargs):
                                """
                                Enable interpolation of flow solution gradients.
                                """
                                return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/interpolate_flow_solution_gradients").execute(*args, **kwargs)
                            def interpolate_temperature(self, *args, **kwargs):
                                """
                                Enable interpolation of temperature to the particle position.
                                """
                                return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/interpolate_temperature").execute(*args, **kwargs)
                            def interpolate_flow_density(self, *args, **kwargs):
                                """
                                Enable interpolation of flow density to the particle position.
                                """
                                return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/interpolate_flow_density").execute(*args, **kwargs)
                            def interpolate_flow_cp(self, *args, **kwargs):
                                """
                                Enable interpolation of flow specific heat to the particle position.
                                """
                                return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/interpolate_flow_cp").execute(*args, **kwargs)
                            def interpolate_flow_viscosity(self, *args, **kwargs):
                                """
                                Enable interpolation of flow viscosity to the particle position.
                                """
                                return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/interpolate_flow_viscosity").execute(*args, **kwargs)
                            def interpolate_wallfilm_properties(self, *args, **kwargs):
                                """
                                Enable interpolation of wallfilm properties to the particle position.
                                """
                                return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/interpolate_wallfilm_properties").execute(*args, **kwargs)
                            def precompute_pdf_species(self, *args, **kwargs):
                                """
                                Precompute cell values of PDF species mass fractions prior to particle tracking.
                                """
                                return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/precompute_pdf_species").execute(*args, **kwargs)
                            def zero_nodal_velocity_on_walls(self, *args, **kwargs):
                                """
                                Set the nodal velocity on all walls to zero.
                                """
                                return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/zero_nodal_velocity_on_walls").execute(*args, **kwargs)
                            def enable_transient_variable_interpolation(self, *args, **kwargs):
                                """
                                Enable transient variable interpolation.
                                """
                                return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/enable_transient_variable_interpolation").execute(*args, **kwargs)
                            def nodal_reconstruction_frequency(self, *args, **kwargs):
                                """
                                Update nodal reconstruction every N'th DPM iteration.
                                """
                                return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/nodal_reconstruction_frequency").execute(*args, **kwargs)
                            def user_interpolation_function(self, *args, **kwargs):
                                """
                                Enter user interpolation function.
                                """
                                return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/user_interpolation_function").execute(*args, **kwargs)

                        class particle_relocation(metaclass=PyMenuMeta):
                            """
                            Enter the particle relocation menu.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def wallfilm_relocation_tolerance_scale_factor(self, *args, **kwargs):
                                """
                                Set the relocation tolerance scaling factor for wallfilm particles after remeshing.
                                """
                                return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/particle_relocation/wallfilm_relocation_tolerance_scale_factor").execute(*args, **kwargs)
                            def use_legacy_particle_location_method(self, *args, **kwargs):
                                """
                                Enable legacy method of locating particles in cells.
                                """
                                return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/particle_relocation/use_legacy_particle_location_method").execute(*args, **kwargs)
                            def load_legacy_particles(self, *args, **kwargs):
                                """
                                Load particles that were tracked without high-resolution tracking enabled.
                                """
                                return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/particle_relocation/load_legacy_particles").execute(*args, **kwargs)
                            def enhanced_cell_relocation_method(self, *args, **kwargs):
                                """
                                Enable enhanced method of locating particles in cells.
                                """
                                return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/particle_relocation/enhanced_cell_relocation_method").execute(*args, **kwargs)
                            def overset_relocation_robustness_level(self, *args, **kwargs):
                                """
                                Set the robustness level for particle relocation in overset meshes.
                                """
                                return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/particle_relocation/overset_relocation_robustness_level").execute(*args, **kwargs)
                            def enhanced_wallfilm_location_method(self, *args, **kwargs):
                                """
                                Enable enhanced method of locating film particles on faces.
                                """
                                return PyMenu(self.service, "/define/models/dpm/numerics/high_resolution_tracking/particle_relocation/enhanced_wallfilm_location_method").execute(*args, **kwargs)

                class options(metaclass=PyMenuMeta):
                    """
                    Enter the options menu to set optional DPM models.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def enable_contour_plots(self, *args, **kwargs):
                        """
                        Enable contour and vector plots of particle data.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/enable_contour_plots").execute(*args, **kwargs)
                    def ensemble_average(self, *args, **kwargs):
                        """
                        Set ensemble average cloud properties.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/ensemble_average").execute(*args, **kwargs)
                    def particle_radiation(self, *args, **kwargs):
                        """
                        Enable/disable particle radiation.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/particle_radiation").execute(*args, **kwargs)
                    def track_in_absolute_frame(self, *args, **kwargs):
                        """
                        Enable/disable tracking in absolute frame.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/track_in_absolute_frame").execute(*args, **kwargs)
                    def thermophoretic_force(self, *args, **kwargs):
                        """
                        Enable/disable thermophoretic force.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/thermophoretic_force").execute(*args, **kwargs)
                    def convective_film_heat_transfer(self, *args, **kwargs):
                        """
                        Enable/disable convection/conduction film to wall heat transfer model.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/convective_film_heat_transfer").execute(*args, **kwargs)
                    def saffman_lift_force(self, *args, **kwargs):
                        """
                        Enable/disable Saffman lift force.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/saffman_lift_force").execute(*args, **kwargs)
                    def pressure_gradient_force(self, *args, **kwargs):
                        """
                        Enable/disable pressure gradient force.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/pressure_gradient_force").execute(*args, **kwargs)
                    def virtual_mass_force(self, *args, **kwargs):
                        """
                        Enable/disable virtual mass force.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/virtual_mass_force").execute(*args, **kwargs)
                    def two_way_coupling(self, *args, **kwargs):
                        """
                        Enable/disable calculation of DPM sources in TKE equation.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/two_way_coupling").execute(*args, **kwargs)
                    def remove_wall_film_temperature_limiter(self, *args, **kwargs):
                        """
                        Remove the wall film temperature limiter.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/remove_wall_film_temperature_limiter").execute(*args, **kwargs)
                    def maximum_udf_species(self, *args, **kwargs):
                        """
                        Maximum number of species that can interact with particles in the DPM UDFs.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/maximum_udf_species").execute(*args, **kwargs)
                    def brownian_motion(self, *args, **kwargs):
                        """
                        Enable/disable Brownian motion of particles.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/brownian_motion").execute(*args, **kwargs)
                    def stagger_spatially_standard_injections(self, *args, **kwargs):
                        """
                        Spatially stagger non-atomizer injections?.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/stagger_spatially_standard_injections").execute(*args, **kwargs)
                    def stagger_spatially_atomizer_injections(self, *args, **kwargs):
                        """
                        Spatially stagger atomizer injections?.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/stagger_spatially_atomizer_injections").execute(*args, **kwargs)
                    def stagger_temporally(self, *args, **kwargs):
                        """
                        Stagger transient parcels for their first time step?.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/stagger_temporally").execute(*args, **kwargs)
                    def staggering_factor(self, *args, **kwargs):
                        """
                        Set the staggering factor between 0 and 1 to control the amount of staggering.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/staggering_factor").execute(*args, **kwargs)
                    def stagger_radius(self, *args, **kwargs):
                        """
                        Provide a stagger radius for non atomizer injections.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/stagger_radius").execute(*args, **kwargs)
                    def uniform_mass_distribution_for_injections(self, *args, **kwargs):
                        """
                        A uniform mass distribution will be enabled for all solid cone and atomizer injections.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/uniform_mass_distribution_for_injections").execute(*args, **kwargs)
                    def use_absolute_pressure_for_vaporization(self, *args, **kwargs):
                        """
                        Enable/disable using Absolute Pressure for Vaporization.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/use_absolute_pressure_for_vaporization").execute(*args, **kwargs)
                    def vaporization_options(self, *args, **kwargs):
                        """
                        Set Vaporization options.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/vaporization_options").execute(*args, **kwargs)
                    def vaporization_heat_transfer_averaging(self, *args, **kwargs):
                        """
                        Enable/disable correction for Vaporization heat transfer.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/vaporization_heat_transfer_averaging").execute(*args, **kwargs)
                    def allow_supercritical_pressure_vaporization(self, *args, **kwargs):
                        """
                        Skip the pressure dependent boiling point calculation to allow supercritical pressure conditions for vaporization.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/allow_supercritical_pressure_vaporization").execute(*args, **kwargs)
                    def treat_multicomponent_saturation_temperature_failure(self, *args, **kwargs):
                        """
                        Dump multicomponent particle mass if the saturation temperature cannot be determined.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/treat_multicomponent_saturation_temperature_failure").execute(*args, **kwargs)
                    def set_thermolysis_limit(self, *args, **kwargs):
                        """
                        Set the thermolysis limit.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/set_thermolysis_limit").execute(*args, **kwargs)
                    def lowest_volatiles_mass_fraction(self, *args, **kwargs):
                        """
                        Set the lowest volatiles mass fraction.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/lowest_volatiles_mass_fraction").execute(*args, **kwargs)
                    def erosion_accretion(self, *args, **kwargs):
                        """
                        Enable/disable erosion/accretion.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/erosion_accretion").execute(*args, **kwargs)
                    def init_erosion_accretion_rate(self, *args, **kwargs):
                        """
                        Initialize erosion/accretion rates with Zero.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/init_erosion_accretion_rate").execute(*args, **kwargs)
                    def step_report_sig_figures(self, *args, **kwargs):
                        """
                        Set significant figures in the step-by-step report.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/step_report_sig_figures").execute(*args, **kwargs)
                    def include_lwf_particles_in_dpm_concentration(self, *args, **kwargs):
                        """
                        Include LWF particle mass in DPM Concentration.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/include_lwf_particles_in_dpm_concentration").execute(*args, **kwargs)
                    def current_positions_in_sample_file_format(self, *args, **kwargs):
                        """
                        Write the current positions (step-by-step history report for unsteady tracking) in the sampling file format.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/current_positions_in_sample_file_format").execute(*args, **kwargs)
                    def scr_urea_deposition_risk_analysis(self, *args, **kwargs):
                        """
                        Options to activate and configure the SCR urea deposition risk analysis.
                        """
                        return PyMenu(self.service, "/define/models/dpm/options/scr_urea_deposition_risk_analysis").execute(*args, **kwargs)

                class parallel(metaclass=PyMenuMeta):
                    """
                    Enter the parallel menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.expert = self.__class__.expert(path + [("expert", None)], service)
                    def enable_workpile(self, *args, **kwargs):
                        """
                        Enable/disable the particle workpile algorithm.
                        """
                        return PyMenu(self.service, "/define/models/dpm/parallel/enable_workpile").execute(*args, **kwargs)
                    def n_threads(self, *args, **kwargs):
                        """
                        Set the number of processors to use for DPM.
                        """
                        return PyMenu(self.service, "/define/models/dpm/parallel/n_threads").execute(*args, **kwargs)
                    def report(self, *args, **kwargs):
                        """
                        Print particle workpile statistics.
                        """
                        return PyMenu(self.service, "/define/models/dpm/parallel/report").execute(*args, **kwargs)
                    def use_shared_memory(self, *args, **kwargs):
                        """
                        Set DPM parallel-mode to shared memory.
                        """
                        return PyMenu(self.service, "/define/models/dpm/parallel/use_shared_memory").execute(*args, **kwargs)
                    def use_message_passing(self, *args, **kwargs):
                        """
                        Set DPM parallel-mode to message passing.
                        """
                        return PyMenu(self.service, "/define/models/dpm/parallel/use_message_passing").execute(*args, **kwargs)
                    def use_hybrid(self, *args, **kwargs):
                        """
                        Set DPM parallel-mode to hybrid.
                        """
                        return PyMenu(self.service, "/define/models/dpm/parallel/use_hybrid").execute(*args, **kwargs)
                    def fix_source_term_accumulation_order(self, *args, **kwargs):
                        """
                        Enforce deterministic order of source term accumulation.
                        """
                        return PyMenu(self.service, "/define/models/dpm/parallel/fix_source_term_accumulation_order").execute(*args, **kwargs)
                    def hybrid_2domain(self, *args, **kwargs):
                        """
                        Use DPM domain to simulate particles.
                        """
                        return PyMenu(self.service, "/define/models/dpm/parallel/hybrid_2domain").execute(*args, **kwargs)
                    def hybrid_workpile(self, *args, **kwargs):
                        """
                        Optimize multi-thread load balancing within each partition in hybrid-parallel DPM tracking.
                        """
                        return PyMenu(self.service, "/define/models/dpm/parallel/hybrid_workpile").execute(*args, **kwargs)
                    def hybrid_collision_model(self, *args, **kwargs):
                        """
                        An EXPERIMENTAL feature to allow 'hybrid' DPM parallel tracking with the collision / coalescence model.
                        """
                        return PyMenu(self.service, "/define/models/dpm/parallel/hybrid_collision_model").execute(*args, **kwargs)
                    def hybrid_collision_unidirectional(self, *args, **kwargs):
                        """
                        A faster, yet potentially somewhat less accurate, modification to the beta feature
                        that allows 'hybrid' DPM parallel tracking with the collision / coalescence model.
                        """
                        return PyMenu(self.service, "/define/models/dpm/parallel/hybrid_collision_unidirectional").execute(*args, **kwargs)
                    def hybrid_collision_variant(self, *args, **kwargs):
                        """
                        Further reduce the residual risk of dead-locks in the experimental feature that
                        allows 'hybrid' DPM parallel tracking with the collision / coalescence model.
                        """
                        return PyMenu(self.service, "/define/models/dpm/parallel/hybrid_collision_variant").execute(*args, **kwargs)

                    class expert(metaclass=PyMenuMeta):
                        """
                        Enter the menu to set expert DPM parallel options.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def partition_method_hybrid_2domain(self, *args, **kwargs):
                            """
                            Set DPM Domain partition method.
                            """
                            return PyMenu(self.service, "/define/models/dpm/parallel/expert/partition_method_hybrid_2domain").execute(*args, **kwargs)

                class splash_options(metaclass=PyMenuMeta):
                    """
                    Enter the splash options menu to set optional parameters.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def orourke_splash_fraction(self, *args, **kwargs):
                        """
                        Select splash fraction method.
                        """
                        return PyMenu(self.service, "/define/models/dpm/splash_options/orourke_splash_fraction").execute(*args, **kwargs)
                    def splash_pdf_limiting(self, *args, **kwargs):
                        """
                        Select splash pdf limiting method.
                        """
                        return PyMenu(self.service, "/define/models/dpm/splash_options/splash_pdf_limiting").execute(*args, **kwargs)

                class stripping_options(metaclass=PyMenuMeta):
                    """
                    Enter the stripping options menu to set optional parameters.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def mass_coefficient(self, *args, **kwargs):
                        """
                        Set the stripping mass coefficient.
                        """
                        return PyMenu(self.service, "/define/models/dpm/stripping_options/mass_coefficient").execute(*args, **kwargs)
                    def diameter_coefficient(self, *args, **kwargs):
                        """
                        Set the stripping diameter coefficient.
                        """
                        return PyMenu(self.service, "/define/models/dpm/stripping_options/diameter_coefficient").execute(*args, **kwargs)

            class shell_conduction(metaclass=PyMenuMeta):
                """
                Enter the shell conduction model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def multi_layer_shell(self, *args, **kwargs):
                    """
                    Enable/disable multi layer shell conduction model.
                    """
                    return PyMenu(self.service, "/define/models/shell_conduction/multi_layer_shell").execute(*args, **kwargs)
                def enhanced_encapsulation(self, *args, **kwargs):
                    """
                    Enable/disable enhanced encapsulation for shell conduction and S2S models. This is not applicable if coupled sliding interface walls exists.
                    """
                    return PyMenu(self.service, "/define/models/shell_conduction/enhanced_encapsulation").execute(*args, **kwargs)
                def read_csv(self, *args, **kwargs):
                    """
                    Read shell conduction settings from a csv file.
                    """
                    return PyMenu(self.service, "/define/models/shell_conduction/read_csv").execute(*args, **kwargs)
                def write_csv(self, *args, **kwargs):
                    """
                    Write shell conduction settings to a csv file.
                    """
                    return PyMenu(self.service, "/define/models/shell_conduction/write_csv").execute(*args, **kwargs)
                def settings(self, *args, **kwargs):
                    """
                    Enter Multi-layer Shell Conduction data.
                    """
                    return PyMenu(self.service, "/define/models/shell_conduction/settings").execute(*args, **kwargs)
                def save_shell_zones(self, *args, **kwargs):
                    """
                    Enable/Disable saving shell zones to case file.
                    """
                    return PyMenu(self.service, "/define/models/shell_conduction/save_shell_zones").execute(*args, **kwargs)

            class system_coupling_settings(metaclass=PyMenuMeta):
                """
                Enter the system coupling model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.htc = self.__class__.htc(path + [("htc", None)], service)
                def use_face_or_element_based_data_transfer(self, *args, **kwargs):
                    """
                    Enable/disable face based data transfer.
                    """
                    return PyMenu(self.service, "/define/models/system_coupling_settings/use_face_or_element_based_data_transfer").execute(*args, **kwargs)
                def update_rigid_body_mesh_motion_before_mesh_transfer(self, *args, **kwargs):
                    """
                    SC Enable/disable mesh motion.
                    """
                    return PyMenu(self.service, "/define/models/system_coupling_settings/update_rigid_body_mesh_motion_before_mesh_transfer").execute(*args, **kwargs)
                def specify_system_coupling_volumetric_cell_zones(self, *args, **kwargs):
                    """
                    Enable/disable volumetric cell zones.
                    """
                    return PyMenu(self.service, "/define/models/system_coupling_settings/specify_system_coupling_volumetric_cell_zones").execute(*args, **kwargs)

                class htc(metaclass=PyMenuMeta):
                    """
                    Enter the heat transfer coeficient menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.unsteady_statistics = self.__class__.unsteady_statistics(path + [("unsteady_statistics", None)], service)
                        self.htc_calculation_method = self.__class__.htc_calculation_method(path + [("htc_calculation_method", None)], service)

                    class unsteady_statistics(metaclass=PyMenuMeta):
                        """
                        Enter the unsteady statistics menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def sc_enable_sub_stepping_option_per_coupling_step(self, *args, **kwargs):
                            """
                            Enable/disable sub stepping option per coupling step.
                            """
                            return PyMenu(self.service, "/define/models/system_coupling_settings/htc/unsteady_statistics/sc_enable_sub_stepping_option_per_coupling_step").execute(*args, **kwargs)

                    class htc_calculation_method(metaclass=PyMenuMeta):
                        """
                        Enter the htc calculation menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def use_tref_in_htc_calculation(self, *args, **kwargs):
                            """
                            Enable/disable tref in htc computation.
                            """
                            return PyMenu(self.service, "/define/models/system_coupling_settings/htc/htc_calculation_method/use_tref_in_htc_calculation").execute(*args, **kwargs)
                        def use_yplus_based_htc_calculation(self, *args, **kwargs):
                            """
                            Enable/disable yplus in htc computation.
                            """
                            return PyMenu(self.service, "/define/models/system_coupling_settings/htc/htc_calculation_method/use_yplus_based_htc_calculation").execute(*args, **kwargs)
                        def use_wall_function_based_htc(self, *args, **kwargs):
                            """
                            Enable/disable wall function based htc computation.
                            """
                            return PyMenu(self.service, "/define/models/system_coupling_settings/htc/htc_calculation_method/use_wall_function_based_htc").execute(*args, **kwargs)

            class cht(metaclass=PyMenuMeta):
                """
                Enter the mapped interface model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.explicit_time_averaged_coupling = self.__class__.explicit_time_averaged_coupling(path + [("explicit_time_averaged_coupling", None)], service)
                def read_mi_type_wall(self, *args, **kwargs):
                    """
                    Read mapped interface data settings from a csv file.
                    """
                    return PyMenu(self.service, "/define/models/cht/read_mi_type_wall").execute(*args, **kwargs)
                def write_mi_type_wall(self, *args, **kwargs):
                    """
                    Write mapped interface settings to a scv file.
                    """
                    return PyMenu(self.service, "/define/models/cht/write_mi_type_wall").execute(*args, **kwargs)
                def implicit_coupling(self, *args, **kwargs):
                    """
                    Enable/disable implicit coupling for mapped interface.
                    """
                    return PyMenu(self.service, "/define/models/cht/implicit_coupling").execute(*args, **kwargs)

                class explicit_time_averaged_coupling(metaclass=PyMenuMeta):
                    """
                    Enter the explcit time averaged thermal coupling menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def conformal_coupled_walls(self, *args, **kwargs):
                        """
                        Select fluid-solid coupled walls (without shell) for explicit coupling using time averaged thermal variables.
                        """
                        return PyMenu(self.service, "/define/models/cht/explicit_time_averaged_coupling/conformal_coupled_walls").execute(*args, **kwargs)
                    def mapped_interfaces(self, *args, **kwargs):
                        """
                        Select fluid-solid mapped interfaces for explicit coupling using time averaged thermal variables.
                        """
                        return PyMenu(self.service, "/define/models/cht/explicit_time_averaged_coupling/mapped_interfaces").execute(*args, **kwargs)
                    def coupling_controls(self, *args, **kwargs):
                        """
                        Specify explcit coupling controls.
                        """
                        return PyMenu(self.service, "/define/models/cht/explicit_time_averaged_coupling/coupling_controls").execute(*args, **kwargs)
                    def fuse_explicit_cht_zones(self, *args, **kwargs):
                        """
                        Fuse slitted conformal coupled walls marked for transient explicit thermal coupling.
                        """
                        return PyMenu(self.service, "/define/models/cht/explicit_time_averaged_coupling/fuse_explicit_cht_zones").execute(*args, **kwargs)

            class two_temperature(metaclass=PyMenuMeta):
                """
                Define two-temperature model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def enable(self, *args, **kwargs):
                    """
                    Enable/disable the two-temperature model.
                    """
                    return PyMenu(self.service, "/define/models/two_temperature/enable").execute(*args, **kwargs)
                def robustness_enhancement(self, *args, **kwargs):
                    """
                    Apply robustness enhancements in the two-temperature model.
                    """
                    return PyMenu(self.service, "/define/models/two_temperature/robustness_enhancement").execute(*args, **kwargs)
                def nasa9_enhancement(self, *args, **kwargs):
                    """
                    Apply nasa9 robustness enhancements in the two-temperature model.
                    """
                    return PyMenu(self.service, "/define/models/two_temperature/nasa9_enhancement").execute(*args, **kwargs)
                def set_verbosity(self, *args, **kwargs):
                    """
                    Set two-temperature model verbosity option.
                    """
                    return PyMenu(self.service, "/define/models/two_temperature/set_verbosity").execute(*args, **kwargs)

            class multiphase(metaclass=PyMenuMeta):
                """
                Define multiphase model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.phases = self.__class__.phases(path + [("phases", None)], service)
                    self.wet_steam = self.__class__.wet_steam(path + [("wet_steam", None)], service)
                    self.population_balance = self.__class__.population_balance(path + [("population_balance", None)], service)
                    self.explicit_expert_options = self.__class__.explicit_expert_options(path + [("explicit_expert_options", None)], service)
                def model(self, *args, **kwargs):
                    """
                    Specify multiphase model.
                    """
                    return PyMenu(self.service, "/define/models/multiphase/model").execute(*args, **kwargs)
                def number_of_phases(self, *args, **kwargs):
                    """
                    Specify the number of phases.
                    """
                    return PyMenu(self.service, "/define/models/multiphase/number_of_phases").execute(*args, **kwargs)
                def regime_transition_modeling(self, *args, **kwargs):
                    """
                    Regime-transition-modeling-options.
                    """
                    return PyMenu(self.service, "/define/models/multiphase/regime_transition_modeling").execute(*args, **kwargs)
                def eulerian_parameters(self, *args, **kwargs):
                    """
                    Eulerian parameters.
                    """
                    return PyMenu(self.service, "/define/models/multiphase/eulerian_parameters").execute(*args, **kwargs)
                def volume_fraction_parameters(self, *args, **kwargs):
                    """
                    Volume fraction parameters.
                    """
                    return PyMenu(self.service, "/define/models/multiphase/volume_fraction_parameters").execute(*args, **kwargs)
                def boiling_model_options(self, *args, **kwargs):
                    """
                    Boiling model options.
                    """
                    return PyMenu(self.service, "/define/models/multiphase/boiling_model_options").execute(*args, **kwargs)
                def mixture_parameters(self, *args, **kwargs):
                    """
                    Mixture parameters.
                    """
                    return PyMenu(self.service, "/define/models/multiphase/mixture_parameters").execute(*args, **kwargs)
                def body_force_formulation(self, *args, **kwargs):
                    """
                    Body force formulation.
                    """
                    return PyMenu(self.service, "/define/models/multiphase/body_force_formulation").execute(*args, **kwargs)
                def coupled_level_set(self, *args, **kwargs):
                    """
                    Coupled level set.
                    """
                    return PyMenu(self.service, "/define/models/multiphase/coupled_level_set").execute(*args, **kwargs)
                def vof_sub_models(self, *args, **kwargs):
                    """
                    VOF sub-models.
                    """
                    return PyMenu(self.service, "/define/models/multiphase/vof_sub_models").execute(*args, **kwargs)
                def interface_modeling_options(self, *args, **kwargs):
                    """
                    Interface Modeling Options.
                    """
                    return PyMenu(self.service, "/define/models/multiphase/interface_modeling_options").execute(*args, **kwargs)
                def expert_options(self, *args, **kwargs):
                    """
                    Expert Options.
                    """
                    return PyMenu(self.service, "/define/models/multiphase/expert_options").execute(*args, **kwargs)

                class phases(metaclass=PyMenuMeta):
                    """
                    Enter the phases menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.set_domain_properties = self.__class__.set_domain_properties(path + [("set_domain_properties", None)], service)
                        self.iac_expert = self.__class__.iac_expert(path + [("iac_expert", None)], service)

                    class set_domain_properties(metaclass=PyMenuMeta):
                        """
                        Enter the menu to set domain properties.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.interaction_domain = self.__class__.interaction_domain(path + [("interaction_domain", None)], service)
                        def change_phases_names(self, *args, **kwargs):
                            """
                            Change names for all defined phases?.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/change_phases_names").execute(*args, **kwargs)
                        def phase_domains(self, *args, **kwargs):
                            """
                            Enter the menu to select a specific phase domain.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/phase_domains").execute(*args, **kwargs)

                        class interaction_domain(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set the interaction domain properties.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.forces = self.__class__.forces(path + [("forces", None)], service)
                                self.heat_mass_reactions = self.__class__.heat_mass_reactions(path + [("heat_mass_reactions", None)], service)
                                self.interfacial_area = self.__class__.interfacial_area(path + [("interfacial_area", None)], service)
                                self.model_transition = self.__class__.model_transition(path + [("model_transition", None)], service)
                                self.numerics = self.__class__.numerics(path + [("numerics", None)], service)

                            class forces(metaclass=PyMenuMeta):
                                """
                                Enter the menu to set interfacial forces related models.
                                """
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service
                                    self.cavitation = self.__class__.cavitation(path + [("cavitation", None)], service)
                                    self.interphase_discretization = self.__class__.interphase_discretization(path + [("interphase_discretization", None)], service)
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(path + [("interphase_viscous_dissipation", None)], service)
                                    self.lift = self.__class__.lift(path + [("lift", None)], service)
                                    self.surface_tension = self.__class__.surface_tension(path + [("surface_tension", None)], service)
                                    self.virtual_mass = self.__class__.virtual_mass(path + [("virtual_mass", None)], service)
                                def drag(self, *args, **kwargs):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/drag").execute(*args, **kwargs)
                                def heat_coeff(self, *args, **kwargs):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/heat_coeff").execute(*args, **kwargs)
                                def interfacial_area(self, *args, **kwargs):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interfacial_area").execute(*args, **kwargs)
                                def mass_transfer(self, *args, **kwargs):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/mass_transfer").execute(*args, **kwargs)
                                def model_transition(self, *args, **kwargs):
                                    """
                                    Set the model transition mechanism.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/model_transition").execute(*args, **kwargs)
                                def reactions(self, *args, **kwargs):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/reactions").execute(*args, **kwargs)
                                def restitution(self, *args, **kwargs):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/restitution").execute(*args, **kwargs)
                                def slip_velocity(self, *args, **kwargs):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/slip_velocity").execute(*args, **kwargs)
                                def turbulence_interaction(self, *args, **kwargs):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/turbulence_interaction").execute(*args, **kwargs)
                                def turbulent_dispersion(self, *args, **kwargs):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/turbulent_dispersion").execute(*args, **kwargs)
                                def wall_lubrication(self, *args, **kwargs):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/wall_lubrication").execute(*args, **kwargs)

                                class cavitation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/wall_adhesion").execute(*args, **kwargs)

                                class interphase_discretization(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/wall_adhesion").execute(*args, **kwargs)

                                class interphase_viscous_dissipation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)

                                class lift(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/wall_adhesion").execute(*args, **kwargs)

                                class surface_tension(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/wall_adhesion").execute(*args, **kwargs)

                                class virtual_mass(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/wall_adhesion").execute(*args, **kwargs)

                            class heat_mass_reactions(metaclass=PyMenuMeta):
                                """
                                Enter the menu to set heat, mass-transfer, or reaction related models.
                                """
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service
                                    self.cavitation = self.__class__.cavitation(path + [("cavitation", None)], service)
                                    self.interphase_discretization = self.__class__.interphase_discretization(path + [("interphase_discretization", None)], service)
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(path + [("interphase_viscous_dissipation", None)], service)
                                    self.lift = self.__class__.lift(path + [("lift", None)], service)
                                    self.surface_tension = self.__class__.surface_tension(path + [("surface_tension", None)], service)
                                    self.virtual_mass = self.__class__.virtual_mass(path + [("virtual_mass", None)], service)
                                def drag(self, *args, **kwargs):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/drag").execute(*args, **kwargs)
                                def heat_coeff(self, *args, **kwargs):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/heat_coeff").execute(*args, **kwargs)
                                def interfacial_area(self, *args, **kwargs):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interfacial_area").execute(*args, **kwargs)
                                def mass_transfer(self, *args, **kwargs):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/mass_transfer").execute(*args, **kwargs)
                                def model_transition(self, *args, **kwargs):
                                    """
                                    Set the model transition mechanism.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/model_transition").execute(*args, **kwargs)
                                def reactions(self, *args, **kwargs):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/reactions").execute(*args, **kwargs)
                                def restitution(self, *args, **kwargs):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/restitution").execute(*args, **kwargs)
                                def slip_velocity(self, *args, **kwargs):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/slip_velocity").execute(*args, **kwargs)
                                def turbulence_interaction(self, *args, **kwargs):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/turbulence_interaction").execute(*args, **kwargs)
                                def turbulent_dispersion(self, *args, **kwargs):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/turbulent_dispersion").execute(*args, **kwargs)
                                def wall_lubrication(self, *args, **kwargs):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/wall_lubrication").execute(*args, **kwargs)

                                class cavitation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/wall_adhesion").execute(*args, **kwargs)

                                class interphase_discretization(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/wall_adhesion").execute(*args, **kwargs)

                                class interphase_viscous_dissipation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)

                                class lift(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/wall_adhesion").execute(*args, **kwargs)

                                class surface_tension(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/wall_adhesion").execute(*args, **kwargs)

                                class virtual_mass(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/wall_adhesion").execute(*args, **kwargs)

                            class interfacial_area(metaclass=PyMenuMeta):
                                """
                                Enter the menu to set interfacial area models.
                                """
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service
                                    self.cavitation = self.__class__.cavitation(path + [("cavitation", None)], service)
                                    self.interphase_discretization = self.__class__.interphase_discretization(path + [("interphase_discretization", None)], service)
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(path + [("interphase_viscous_dissipation", None)], service)
                                    self.lift = self.__class__.lift(path + [("lift", None)], service)
                                    self.surface_tension = self.__class__.surface_tension(path + [("surface_tension", None)], service)
                                    self.virtual_mass = self.__class__.virtual_mass(path + [("virtual_mass", None)], service)
                                def drag(self, *args, **kwargs):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/drag").execute(*args, **kwargs)
                                def heat_coeff(self, *args, **kwargs):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/heat_coeff").execute(*args, **kwargs)
                                def interfacial_area(self, *args, **kwargs):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interfacial_area").execute(*args, **kwargs)
                                def mass_transfer(self, *args, **kwargs):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/mass_transfer").execute(*args, **kwargs)
                                def model_transition(self, *args, **kwargs):
                                    """
                                    Set the model transition mechanism.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/model_transition").execute(*args, **kwargs)
                                def reactions(self, *args, **kwargs):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/reactions").execute(*args, **kwargs)
                                def restitution(self, *args, **kwargs):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/restitution").execute(*args, **kwargs)
                                def slip_velocity(self, *args, **kwargs):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/slip_velocity").execute(*args, **kwargs)
                                def turbulence_interaction(self, *args, **kwargs):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/turbulence_interaction").execute(*args, **kwargs)
                                def turbulent_dispersion(self, *args, **kwargs):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/turbulent_dispersion").execute(*args, **kwargs)
                                def wall_lubrication(self, *args, **kwargs):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/wall_lubrication").execute(*args, **kwargs)

                                class cavitation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/wall_adhesion").execute(*args, **kwargs)

                                class interphase_discretization(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/wall_adhesion").execute(*args, **kwargs)

                                class interphase_viscous_dissipation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)

                                class lift(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/wall_adhesion").execute(*args, **kwargs)

                                class surface_tension(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/wall_adhesion").execute(*args, **kwargs)

                                class virtual_mass(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/wall_adhesion").execute(*args, **kwargs)

                            class model_transition(metaclass=PyMenuMeta):
                                """
                                Enter the menu to set model transition mechanisms.
                                """
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service
                                    self.cavitation = self.__class__.cavitation(path + [("cavitation", None)], service)
                                    self.interphase_discretization = self.__class__.interphase_discretization(path + [("interphase_discretization", None)], service)
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(path + [("interphase_viscous_dissipation", None)], service)
                                    self.lift = self.__class__.lift(path + [("lift", None)], service)
                                    self.surface_tension = self.__class__.surface_tension(path + [("surface_tension", None)], service)
                                    self.virtual_mass = self.__class__.virtual_mass(path + [("virtual_mass", None)], service)
                                def drag(self, *args, **kwargs):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/drag").execute(*args, **kwargs)
                                def heat_coeff(self, *args, **kwargs):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/heat_coeff").execute(*args, **kwargs)
                                def interfacial_area(self, *args, **kwargs):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interfacial_area").execute(*args, **kwargs)
                                def mass_transfer(self, *args, **kwargs):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/mass_transfer").execute(*args, **kwargs)
                                def model_transition(self, *args, **kwargs):
                                    """
                                    Set the model transition mechanism.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/model_transition").execute(*args, **kwargs)
                                def reactions(self, *args, **kwargs):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/reactions").execute(*args, **kwargs)
                                def restitution(self, *args, **kwargs):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/restitution").execute(*args, **kwargs)
                                def slip_velocity(self, *args, **kwargs):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/slip_velocity").execute(*args, **kwargs)
                                def turbulence_interaction(self, *args, **kwargs):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/turbulence_interaction").execute(*args, **kwargs)
                                def turbulent_dispersion(self, *args, **kwargs):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/turbulent_dispersion").execute(*args, **kwargs)
                                def wall_lubrication(self, *args, **kwargs):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/wall_lubrication").execute(*args, **kwargs)

                                class cavitation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/wall_adhesion").execute(*args, **kwargs)

                                class interphase_discretization(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/wall_adhesion").execute(*args, **kwargs)

                                class interphase_viscous_dissipation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)

                                class lift(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/wall_adhesion").execute(*args, **kwargs)

                                class surface_tension(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/wall_adhesion").execute(*args, **kwargs)

                                class virtual_mass(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/wall_adhesion").execute(*args, **kwargs)

                            class numerics(metaclass=PyMenuMeta):
                                """
                                Enter the menu to set numerics models.
                                """
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service
                                    self.cavitation = self.__class__.cavitation(path + [("cavitation", None)], service)
                                    self.interphase_discretization = self.__class__.interphase_discretization(path + [("interphase_discretization", None)], service)
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(path + [("interphase_viscous_dissipation", None)], service)
                                    self.lift = self.__class__.lift(path + [("lift", None)], service)
                                    self.surface_tension = self.__class__.surface_tension(path + [("surface_tension", None)], service)
                                    self.virtual_mass = self.__class__.virtual_mass(path + [("virtual_mass", None)], service)
                                def drag(self, *args, **kwargs):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/drag").execute(*args, **kwargs)
                                def heat_coeff(self, *args, **kwargs):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/heat_coeff").execute(*args, **kwargs)
                                def interfacial_area(self, *args, **kwargs):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interfacial_area").execute(*args, **kwargs)
                                def mass_transfer(self, *args, **kwargs):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/mass_transfer").execute(*args, **kwargs)
                                def model_transition(self, *args, **kwargs):
                                    """
                                    Set the model transition mechanism.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/model_transition").execute(*args, **kwargs)
                                def reactions(self, *args, **kwargs):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/reactions").execute(*args, **kwargs)
                                def restitution(self, *args, **kwargs):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/restitution").execute(*args, **kwargs)
                                def slip_velocity(self, *args, **kwargs):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/slip_velocity").execute(*args, **kwargs)
                                def turbulence_interaction(self, *args, **kwargs):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/turbulence_interaction").execute(*args, **kwargs)
                                def turbulent_dispersion(self, *args, **kwargs):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/turbulent_dispersion").execute(*args, **kwargs)
                                def wall_lubrication(self, *args, **kwargs):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/wall_lubrication").execute(*args, **kwargs)

                                class cavitation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/wall_adhesion").execute(*args, **kwargs)

                                class interphase_discretization(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/wall_adhesion").execute(*args, **kwargs)

                                class interphase_viscous_dissipation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)

                                class lift(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/wall_adhesion").execute(*args, **kwargs)

                                class surface_tension(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/wall_adhesion").execute(*args, **kwargs)

                                class virtual_mass(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/define/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/wall_adhesion").execute(*args, **kwargs)

                    class iac_expert(metaclass=PyMenuMeta):
                        """
                        Enter the IAC expert setting menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def ishii_kim_model(self, *args, **kwargs):
                            """
                            Set ik model coefficients.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/phases/iac_expert/ishii_kim_model").execute(*args, **kwargs)
                        def hibiki_ishii_model(self, *args, **kwargs):
                            """
                            Set hi model coefficients.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/phases/iac_expert/hibiki_ishii_model").execute(*args, **kwargs)
                        def yao_morel_model(self, *args, **kwargs):
                            """
                            Set ym model coefficients.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/phases/iac_expert/yao_morel_model").execute(*args, **kwargs)
                        def iac_pseudo_time_step(self, *args, **kwargs):
                            """
                            Set iac pseudo-time.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/phases/iac_expert/iac_pseudo_time_step").execute(*args, **kwargs)

                class wet_steam(metaclass=PyMenuMeta):
                    """
                    Enter the wet steam model menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.set = self.__class__.set(path + [("set", None)], service)
                    def enable(self, *args, **kwargs):
                        """
                        Enable/disable the wet steam model.
                        """
                        return PyMenu(self.service, "/define/models/multiphase/wet_steam/enable").execute(*args, **kwargs)
                    def compile_user_defined_wetsteam_functions(self, *args, **kwargs):
                        """
                        Compile user-defined wet steam library.
                        """
                        return PyMenu(self.service, "/define/models/multiphase/wet_steam/compile_user_defined_wetsteam_functions").execute(*args, **kwargs)
                    def load_unload_user_defined_wetsteam_library(self, *args, **kwargs):
                        """
                        Load or unload user-defined wet steam library.
                        """
                        return PyMenu(self.service, "/define/models/multiphase/wet_steam/load_unload_user_defined_wetsteam_library").execute(*args, **kwargs)

                    class set(metaclass=PyMenuMeta):
                        """
                        Enter the set menu for setting wet steam model options.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def max_liquid_mass_fraction(self, *args, **kwargs):
                            """
                            Set the maximum limit on the condensed liquid-phase mass-fraction to prevent divergence.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/wet_steam/set/max_liquid_mass_fraction").execute(*args, **kwargs)
                        def droplet_growth_rate(self, *args, **kwargs):
                            """
                            Select the formula to model the droplet growth rate.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/wet_steam/set/droplet_growth_rate").execute(*args, **kwargs)
                        def virial_equation(self, *args, **kwargs):
                            """
                            Select the formulation of the virial equation of state and associated equations for thermodynamic properties of steam.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/wet_steam/set/virial_equation").execute(*args, **kwargs)
                        def rgp_tables(self, *args, **kwargs):
                            """
                            Select which properties to use: build-in or from RGP tables.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/wet_steam/set/rgp_tables").execute(*args, **kwargs)
                        def stagnation_conditions(self, *args, **kwargs):
                            """
                            If the gas phase is selected, zero wetness is assumed when evaluating total or static values of pressure and temperature.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/wet_steam/set/stagnation_conditions").execute(*args, **kwargs)

                class population_balance(metaclass=PyMenuMeta):
                    """
                    Enter the population balance model menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.phenomena = self.__class__.phenomena(path + [("phenomena", None)], service)
                        self.expert = self.__class__.expert(path + [("expert", None)], service)
                    def model(self, *args, **kwargs):
                        """
                        Select the population balance model.
                        """
                        return PyMenu(self.service, "/define/models/multiphase/population_balance/model").execute(*args, **kwargs)
                    def include_expansion(self, *args, **kwargs):
                        """
                        Set expansion.
                        """
                        return PyMenu(self.service, "/define/models/multiphase/population_balance/include_expansion").execute(*args, **kwargs)
                    def size_calculator(self, *args, **kwargs):
                        """
                        Calculate fluid particle diameters using different methods.
                        """
                        return PyMenu(self.service, "/define/models/multiphase/population_balance/size_calculator").execute(*args, **kwargs)

                    class phenomena(metaclass=PyMenuMeta):
                        """
                        Enter the phenomena menu for population balance.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def nucleation(self, *args, **kwargs):
                            """
                            Set the nucleantion rate.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/population_balance/phenomena/nucleation").execute(*args, **kwargs)
                        def growth(self, *args, **kwargs):
                            """
                            Set the growth rate.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/population_balance/phenomena/growth").execute(*args, **kwargs)
                        def aggregation(self, *args, **kwargs):
                            """
                            Set the aggregation kernel.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/population_balance/phenomena/aggregation").execute(*args, **kwargs)
                        def breakage(self, *args, **kwargs):
                            """
                            Set the breakage kernel.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/population_balance/phenomena/breakage").execute(*args, **kwargs)
                        def aggregation_factor(self, *args, **kwargs):
                            """
                            Set a factor which controls the intensity of the selected aggregation kernel.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/population_balance/phenomena/aggregation_factor").execute(*args, **kwargs)
                        def breakage_factor(self, *args, **kwargs):
                            """
                            Set a factor which controls the intensity of the selected breakage kernel.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/population_balance/phenomena/breakage_factor").execute(*args, **kwargs)
                        def breakage_aggregation_vof_cutoff(self, *args, **kwargs):
                            """
                            Control vof cut-off for breakage and aggregation.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/population_balance/phenomena/breakage_aggregation_vof_cutoff").execute(*args, **kwargs)

                    class expert(metaclass=PyMenuMeta):
                        """
                        Enter the expert menu for quadrature-based population balance method.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.qmom = self.__class__.qmom(path + [("qmom", None)], service)

                        class qmom(metaclass=PyMenuMeta):
                            """
                            .
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def retain_qmom_sources_for_low_vof(self, *args, **kwargs):
                                """
                                Retain qmom source calculation for low secondary phase vof.
                                """
                                return PyMenu(self.service, "/define/models/multiphase/population_balance/expert/qmom/retain_qmom_sources_for_low_vof").execute(*args, **kwargs)
                            def realizable_moments(self, *args, **kwargs):
                                """
                                Set the population balance model.
                                """
                                return PyMenu(self.service, "/define/models/multiphase/population_balance/expert/qmom/realizable_moments").execute(*args, **kwargs)
                            def print_realizable_moment_warning(self, *args, **kwargs):
                                """
                                Print the information for realizable moments in the population balance model.
                                """
                                return PyMenu(self.service, "/define/models/multiphase/population_balance/expert/qmom/print_realizable_moment_warning").execute(*args, **kwargs)
                            def inversion_algorithm(self, *args, **kwargs):
                                """
                                Select the inversion algorithm for quadrature-based population balance method.
                                """
                                return PyMenu(self.service, "/define/models/multiphase/population_balance/expert/qmom/inversion_algorithm").execute(*args, **kwargs)

                class explicit_expert_options(metaclass=PyMenuMeta):
                    """
                    Expert options for explicit formulation.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.volume_fraction_filtering = self.__class__.volume_fraction_filtering(path + [("volume_fraction_filtering", None)], service)
                    def sub_time_step_method(self, *args, **kwargs):
                        """
                        Select sub-time step method for the time integration in explicit formulation.
                        """
                        return PyMenu(self.service, "/define/models/multiphase/explicit_expert_options/sub_time_step_method").execute(*args, **kwargs)
                    def solve_vof_every_iter(self, *args, **kwargs):
                        """
                        Solve volume fraction equation every iteration for explicit formulation.
                        """
                        return PyMenu(self.service, "/define/models/multiphase/explicit_expert_options/solve_vof_every_iter").execute(*args, **kwargs)

                    class volume_fraction_filtering(metaclass=PyMenuMeta):
                        """
                        Advanced volume fraction filtering controls for explicit formulation.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def enable(self, *args, **kwargs):
                            """
                            Enable volume fraction filtering treatment.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/explicit_expert_options/volume_fraction_filtering/enable").execute(*args, **kwargs)
                        def filtering_options(self, *args, **kwargs):
                            """
                            Select volume fraction filtering method.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/explicit_expert_options/volume_fraction_filtering/filtering_options").execute(*args, **kwargs)
                        def vol_frac_cutoff(self, *args, **kwargs):
                            """
                            Enter node-averaged volume fraction cutoff.
                            """
                            return PyMenu(self.service, "/define/models/multiphase/explicit_expert_options/volume_fraction_filtering/vol_frac_cutoff").execute(*args, **kwargs)

            class nox_parameters(metaclass=PyMenuMeta):
                """
                Enter the NOx parameters menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def nox_chemistry(self, *args, **kwargs):
                    """
                    Select NOx chemistry model.
                    """
                    return PyMenu(self.service, "/define/models/nox_parameters/nox_chemistry").execute(*args, **kwargs)
                def nox_turbulence_interaction(self, *args, **kwargs):
                    """
                    Set NOx-turbulence interaction model.
                    """
                    return PyMenu(self.service, "/define/models/nox_parameters/nox_turbulence_interaction").execute(*args, **kwargs)
                def inlet_diffusion(self, *args, **kwargs):
                    """
                    Enable/disable inclusion of diffusion at inlets.
                    """
                    return PyMenu(self.service, "/define/models/nox_parameters/inlet_diffusion").execute(*args, **kwargs)
                def nox_expert(self, *args, **kwargs):
                    """
                    Select additional nox equations.
                    """
                    return PyMenu(self.service, "/define/models/nox_parameters/nox_expert").execute(*args, **kwargs)

            class soot_parameters(metaclass=PyMenuMeta):
                """
                Enter the soot parameters menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def soot_model_parameters(self, *args, **kwargs):
                    """
                    Enter the soot model parameters menu.
                    """
                    return PyMenu(self.service, "/define/models/soot_parameters/soot_model_parameters").execute(*args, **kwargs)
                def soot_process_parameters(self, *args, **kwargs):
                    """
                    Set soot process parameters.
                    """
                    return PyMenu(self.service, "/define/models/soot_parameters/soot_process_parameters").execute(*args, **kwargs)
                def soot_radiation_interaction(self, *args, **kwargs):
                    """
                    Enable/disable the soot-radiation interaction model.
                    """
                    return PyMenu(self.service, "/define/models/soot_parameters/soot_radiation_interaction").execute(*args, **kwargs)
                def soot_turbulence_interaction(self, *args, **kwargs):
                    """
                    Set Soot-turbulence interaction model.
                    """
                    return PyMenu(self.service, "/define/models/soot_parameters/soot_turbulence_interaction").execute(*args, **kwargs)
                def modify_schmidt_number(self, *args, **kwargs):
                    """
                    Change Turbulent Schmidt Number for Soot/Nuclei Equations.
                    """
                    return PyMenu(self.service, "/define/models/soot_parameters/modify_schmidt_number").execute(*args, **kwargs)
                def inlet_diffusion(self, *args, **kwargs):
                    """
                    Enable/disable inclusion of diffusion at inlets.
                    """
                    return PyMenu(self.service, "/define/models/soot_parameters/inlet_diffusion").execute(*args, **kwargs)
                def soot_model_udfs(self, *args, **kwargs):
                    """
                    User defined functions for soot model.
                    """
                    return PyMenu(self.service, "/define/models/soot_parameters/soot_model_udfs").execute(*args, **kwargs)

            class radiation(metaclass=PyMenuMeta):
                """
                Enter the radiation models menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.s2s_parameters = self.__class__.s2s_parameters(path + [("s2s_parameters", None)], service)
                    self.dtrm_parameters = self.__class__.dtrm_parameters(path + [("dtrm_parameters", None)], service)
                    self.solar_parameters = self.__class__.solar_parameters(path + [("solar_parameters", None)], service)
                def discrete_ordinates(self, *args, **kwargs):
                    """
                    Enable/disable the discrete ordinates radiation model.
                    """
                    return PyMenu(self.service, "/define/models/radiation/discrete_ordinates").execute(*args, **kwargs)
                def do_acceleration(self, *args, **kwargs):
                    """
                    Enable/disable acceleration of computation of DO model.
                    """
                    return PyMenu(self.service, "/define/models/radiation/do_acceleration").execute(*args, **kwargs)
                def non_gray_model_parameters(self, *args, **kwargs):
                    """
                    Set parameters for non-gray model.
                    """
                    return PyMenu(self.service, "/define/models/radiation/non_gray_model_parameters").execute(*args, **kwargs)
                def montecarlo(self, *args, **kwargs):
                    """
                    Enable/disable the Monte Carlo radiation model.
                    """
                    return PyMenu(self.service, "/define/models/radiation/montecarlo").execute(*args, **kwargs)
                def target_cells_per_volume_cluster(self, *args, **kwargs):
                    """
                    Enter cells per volume cluster for Monte Carlo radiation model.
                    """
                    return PyMenu(self.service, "/define/models/radiation/target_cells_per_volume_cluster").execute(*args, **kwargs)
                def s2s(self, *args, **kwargs):
                    """
                    Enable/disable the S2S radiation model.
                    """
                    return PyMenu(self.service, "/define/models/radiation/s2s").execute(*args, **kwargs)
                def discrete_transfer(self, *args, **kwargs):
                    """
                    Enable/disable discrete the transfer radiation model.
                    """
                    return PyMenu(self.service, "/define/models/radiation/discrete_transfer").execute(*args, **kwargs)
                def p1(self, *args, **kwargs):
                    """
                    Enable/disable the P1 radiation model.
                    """
                    return PyMenu(self.service, "/define/models/radiation/p1").execute(*args, **kwargs)
                def radiation_model_parameters(self, *args, **kwargs):
                    """
                    Set parameters for radiation models.
                    """
                    return PyMenu(self.service, "/define/models/radiation/radiation_model_parameters").execute(*args, **kwargs)
                def radiation_iteration_parameters(self, *args, **kwargs):
                    """
                    Set iteration parameters for radiation models.
                    """
                    return PyMenu(self.service, "/define/models/radiation/radiation_iteration_parameters").execute(*args, **kwargs)
                def mc_model_parameters(self, *args, **kwargs):
                    """
                    Set parameters for montecarlo radiation model.
                    """
                    return PyMenu(self.service, "/define/models/radiation/mc_model_parameters").execute(*args, **kwargs)
                def mc_under_relaxation(self, *args, **kwargs):
                    """
                    Set under-relaxation factor for montecarlo radiation sources used in the energy equation.
                    """
                    return PyMenu(self.service, "/define/models/radiation/mc_under_relaxation").execute(*args, **kwargs)
                def rosseland(self, *args, **kwargs):
                    """
                    Enable/disable the Rosseland radiation model.
                    """
                    return PyMenu(self.service, "/define/models/radiation/rosseland").execute(*args, **kwargs)
                def solar(self, *args, **kwargs):
                    """
                    Enable/disable the solar model.
                    """
                    return PyMenu(self.service, "/define/models/radiation/solar").execute(*args, **kwargs)
                def solar_irradiation(self, *args, **kwargs):
                    """
                    Enable/disable the Solar irradiation model.
                    """
                    return PyMenu(self.service, "/define/models/radiation/solar_irradiation").execute(*args, **kwargs)
                def solar_calculator(self, *args, **kwargs):
                    """
                    Calculate sun direction and intensity.
                    """
                    return PyMenu(self.service, "/define/models/radiation/solar_calculator").execute(*args, **kwargs)
                def apply_full_solar_irradiation(self, *args, **kwargs):
                    """
                    Enable/disable application of solar irradiation to first band with DO model.
                    """
                    return PyMenu(self.service, "/define/models/radiation/apply_full_solar_irradiation").execute(*args, **kwargs)
                def wsggm_cell_based(self, *args, **kwargs):
                    """
                    Enable/disable WSGGM cell based method.
                    """
                    return PyMenu(self.service, "/define/models/radiation/wsggm_cell_based").execute(*args, **kwargs)
                def fast_second_order_discrete_ordinate(self, *args, **kwargs):
                    """
                    Enable/disable the fast-second-order option for Discrete Ordinate Model.
                    """
                    return PyMenu(self.service, "/define/models/radiation/fast_second_order_discrete_ordinate").execute(*args, **kwargs)
                def do_coupling(self, *args, **kwargs):
                    """
                    Enabled DO Energy Coupling.
                    """
                    return PyMenu(self.service, "/define/models/radiation/do_coupling").execute(*args, **kwargs)
                def solution_method_for_do_coupling(self, *args, **kwargs):
                    """
                    Enable the solution method for DO/Energy  Coupling.
                    """
                    return PyMenu(self.service, "/define/models/radiation/solution_method_for_do_coupling").execute(*args, **kwargs)
                def beta_radiation_features(self, *args, **kwargs):
                    """
                    Enable Radiation Models with Non-Iterative Time Advancement (NITA) as Beta features in FL12.0.
                    """
                    return PyMenu(self.service, "/define/models/radiation/beta_radiation_features").execute(*args, **kwargs)
                def method_partially_specular_wall(self, *args, **kwargs):
                    """
                    Set method for partially specular wall with discrete ordinate model.
                    """
                    return PyMenu(self.service, "/define/models/radiation/method_partially_specular_wall").execute(*args, **kwargs)
                def blending_factor(self, *args, **kwargs):
                    """
                    Set numeric option for Discrete Ordinate model.
                    """
                    return PyMenu(self.service, "/define/models/radiation/blending_factor").execute(*args, **kwargs)

                class s2s_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the S2S parameters menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def compute_vf_only(self, *args, **kwargs):
                        """
                        Compute/write view factors only.
                        """
                        return PyMenu(self.service, "/define/models/radiation/s2s_parameters/compute_vf_only").execute(*args, **kwargs)
                    def compute_write_vf(self, *args, **kwargs):
                        """
                        Compute/write surface clusters and view factors for S2S radiation model.
                        """
                        return PyMenu(self.service, "/define/models/radiation/s2s_parameters/compute_write_vf").execute(*args, **kwargs)
                    def compute_vf_accelerated(self, *args, **kwargs):
                        """
                        Compute/Write view factors from existing surface clusters.
                        """
                        return PyMenu(self.service, "/define/models/radiation/s2s_parameters/compute_vf_accelerated").execute(*args, **kwargs)
                    def compute_clusters_and_vf_accelerated(self, *args, **kwargs):
                        """
                        Compute/Write surface cluster first and then view factors.
                        """
                        return PyMenu(self.service, "/define/models/radiation/s2s_parameters/compute_clusters_and_vf_accelerated").execute(*args, **kwargs)
                    def non_participating_boundary_zones_temperature(self, *args, **kwargs):
                        """
                        Set temperature for the non-participating boundary zones.
                        """
                        return PyMenu(self.service, "/define/models/radiation/s2s_parameters/non_participating_boundary_zones_temperature").execute(*args, **kwargs)
                    def read_vf_file(self, *args, **kwargs):
                        """
                        Read an S2S file.
                        """
                        return PyMenu(self.service, "/define/models/radiation/s2s_parameters/read_vf_file").execute(*args, **kwargs)
                    def set_vf_parameters(self, *args, **kwargs):
                        """
                        Set the parameters needed for the view factor calculations.
                        """
                        return PyMenu(self.service, "/define/models/radiation/s2s_parameters/set_vf_parameters").execute(*args, **kwargs)
                    def split_angle(self, *args, **kwargs):
                        """
                        Set the split angle for the clustering algorithm.
                        """
                        return PyMenu(self.service, "/define/models/radiation/s2s_parameters/split_angle").execute(*args, **kwargs)
                    def set_global_faces_per_surface_cluster(self, *args, **kwargs):
                        """
                        Set global value of faces per surface cluster for all boundary zones.
                        """
                        return PyMenu(self.service, "/define/models/radiation/s2s_parameters/set_global_faces_per_surface_cluster").execute(*args, **kwargs)
                    def print_thread_clusters(self, *args, **kwargs):
                        """
                        Prints the following for all boundary threads: thread-id, number of faces, faces per surface cluster, and the number of surface clusters.
                        """
                        return PyMenu(self.service, "/define/models/radiation/s2s_parameters/print_thread_clusters").execute(*args, **kwargs)
                    def print_zonewise_radiation(self, *args, **kwargs):
                        """
                        Prints the zonewise incoming radiation, viewfactors, and average temperature.
                        """
                        return PyMenu(self.service, "/define/models/radiation/s2s_parameters/print_zonewise_radiation").execute(*args, **kwargs)
                    def use_old_cluster_algorithm(self, *args, **kwargs):
                        """
                        Use the old surface clustering algorithm.
                        """
                        return PyMenu(self.service, "/define/models/radiation/s2s_parameters/use_old_cluster_algorithm").execute(*args, **kwargs)
                    def use_new_cluster_algorithm(self, *args, **kwargs):
                        """
                        Use the new surface clustering algorithm.
                        """
                        return PyMenu(self.service, "/define/models/radiation/s2s_parameters/use_new_cluster_algorithm").execute(*args, **kwargs)
                    def compute_fpsc_values(self, *args, **kwargs):
                        """
                        Compute only fpsc values based on current settings.
                        """
                        return PyMenu(self.service, "/define/models/radiation/s2s_parameters/compute_fpsc_values").execute(*args, **kwargs)
                    def enable_mesh_interface_clustering(self, *args, **kwargs):
                        """
                        Enable clustering on mesh interfaces?.
                        """
                        return PyMenu(self.service, "/define/models/radiation/s2s_parameters/enable_mesh_interface_clustering").execute(*args, **kwargs)

                class dtrm_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the DTRM parameters menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def controls(self, *args, **kwargs):
                        """
                        Set DTRM solution controls.
                        """
                        return PyMenu(self.service, "/define/models/radiation/dtrm_parameters/controls").execute(*args, **kwargs)
                    def make_globs(self, *args, **kwargs):
                        """
                        Make globs (coarser mesh) for radiation.
                        """
                        return PyMenu(self.service, "/define/models/radiation/dtrm_parameters/make_globs").execute(*args, **kwargs)
                    def ray_trace(self, *args, **kwargs):
                        """
                        Create DTRM rays for radiation.
                        """
                        return PyMenu(self.service, "/define/models/radiation/dtrm_parameters/ray_trace").execute(*args, **kwargs)
                    def check_ray_file(self, *args, **kwargs):
                        """
                        Read DTRM rays file.
                        """
                        return PyMenu(self.service, "/define/models/radiation/dtrm_parameters/check_ray_file").execute(*args, **kwargs)

                class solar_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the solar parameters menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def autosave_solar_data(self, *args, **kwargs):
                        """
                        Set autosave solar data parameters.
                        """
                        return PyMenu(self.service, "/define/models/radiation/solar_parameters/autosave_solar_data").execute(*args, **kwargs)
                    def autoread_solar_data(self, *args, **kwargs):
                        """
                        Set autoread solar data parameters.
                        """
                        return PyMenu(self.service, "/define/models/radiation/solar_parameters/autoread_solar_data").execute(*args, **kwargs)
                    def sun_direction_vector(self, *args, **kwargs):
                        """
                        Set sun direction vector.
                        """
                        return PyMenu(self.service, "/define/models/radiation/solar_parameters/sun_direction_vector").execute(*args, **kwargs)
                    def illumination_parameters(self, *args, **kwargs):
                        """
                        Set illumination parameters.
                        """
                        return PyMenu(self.service, "/define/models/radiation/solar_parameters/illumination_parameters").execute(*args, **kwargs)
                    def iteration_parameters(self, *args, **kwargs):
                        """
                        Set update parameters.
                        """
                        return PyMenu(self.service, "/define/models/radiation/solar_parameters/iteration_parameters").execute(*args, **kwargs)
                    def quad_tree_parameters(self, *args, **kwargs):
                        """
                        Set quad-tree refinement parameters.
                        """
                        return PyMenu(self.service, "/define/models/radiation/solar_parameters/quad_tree_parameters").execute(*args, **kwargs)
                    def ground_reflectivity(self, *args, **kwargs):
                        """
                        Set ground reflectivity parameters.
                        """
                        return PyMenu(self.service, "/define/models/radiation/solar_parameters/ground_reflectivity").execute(*args, **kwargs)
                    def scattering_fraction(self, *args, **kwargs):
                        """
                        Set scattering fraction parameters.
                        """
                        return PyMenu(self.service, "/define/models/radiation/solar_parameters/scattering_fraction").execute(*args, **kwargs)
                    def sol_on_demand(self, *args, **kwargs):
                        """
                        Enable  solar load on demand.
                        """
                        return PyMenu(self.service, "/define/models/radiation/solar_parameters/sol_on_demand").execute(*args, **kwargs)
                    def sol_camera_pos(self, *args, **kwargs):
                        """
                        Set camera position based on sun direction vector.
                        """
                        return PyMenu(self.service, "/define/models/radiation/solar_parameters/sol_camera_pos").execute(*args, **kwargs)
                    def sol_adjacent_fluidcells(self, *args, **kwargs):
                        """
                        Enable solar load for adjacent fluid cells.
                        """
                        return PyMenu(self.service, "/define/models/radiation/solar_parameters/sol_adjacent_fluidcells").execute(*args, **kwargs)
                    def use_direction_from_sol_calc(self, *args, **kwargs):
                        """
                        Set direction computed from solar calculator.
                        """
                        return PyMenu(self.service, "/define/models/radiation/solar_parameters/use_direction_from_sol_calc").execute(*args, **kwargs)
                    def solar_thread_control(self, *args, **kwargs):
                        """
                        Solar thread control.
                        """
                        return PyMenu(self.service, "/define/models/radiation/solar_parameters/solar_thread_control").execute(*args, **kwargs)

            class solver(metaclass=PyMenuMeta):
                """
                Enter the menu to select the solver.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def pressure_based(self, *args, **kwargs):
                    """
                    Enable/disable the segregated solver.
                    """
                    return PyMenu(self.service, "/define/models/solver/pressure_based").execute(*args, **kwargs)
                def density_based_explicit(self, *args, **kwargs):
                    """
                    Enable/disable the coupled-explicit solver.
                    """
                    return PyMenu(self.service, "/define/models/solver/density_based_explicit").execute(*args, **kwargs)
                def density_based_implicit(self, *args, **kwargs):
                    """
                    Enable/disable the coupled-implicit solver.
                    """
                    return PyMenu(self.service, "/define/models/solver/density_based_implicit").execute(*args, **kwargs)
                def adjust_solver_defaults_based_on_setup(self, *args, **kwargs):
                    """
                    Enable/disable adjustment of solver defaults based on setup.
                    """
                    return PyMenu(self.service, "/define/models/solver/adjust_solver_defaults_based_on_setup").execute(*args, **kwargs)

            class species(metaclass=PyMenuMeta):
                """
                Enter the species models menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.CHEMKIN_CFD_parameters = self.__class__.CHEMKIN_CFD_parameters(path + [("CHEMKIN_CFD_parameters", None)], service)
                def off(self, *args, **kwargs):
                    """
                    Enable/disable solution of species models.
                    """
                    return PyMenu(self.service, "/define/models/species/off").execute(*args, **kwargs)
                def species_transport(self, *args, **kwargs):
                    """
                    Enable/disable the species transport model.
                    """
                    return PyMenu(self.service, "/define/models/species/species_transport").execute(*args, **kwargs)
                def non_premixed_combustion(self, *args, **kwargs):
                    """
                    Enable/disable the non-premixed combustion model.
                    """
                    return PyMenu(self.service, "/define/models/species/non_premixed_combustion").execute(*args, **kwargs)
                def premixed_combustion(self, *args, **kwargs):
                    """
                    Enable/disable the premixed combustion model.
                    """
                    return PyMenu(self.service, "/define/models/species/premixed_combustion").execute(*args, **kwargs)
                def partially_premixed_combustion(self, *args, **kwargs):
                    """
                    Enable/disable partially premixed combustion model.
                    """
                    return PyMenu(self.service, "/define/models/species/partially_premixed_combustion").execute(*args, **kwargs)
                def premixed_model(self, *args, **kwargs):
                    """
                    Set premixed combustion model.
                    """
                    return PyMenu(self.service, "/define/models/species/premixed_model").execute(*args, **kwargs)
                def pdf_transport(self, *args, **kwargs):
                    """
                    Enable/disable the composition PDF transport combustion model.
                    """
                    return PyMenu(self.service, "/define/models/species/pdf_transport").execute(*args, **kwargs)
                def save_gradients(self, *args, **kwargs):
                    """
                    Enable/disable storage of species mass fraction gradients.
                    """
                    return PyMenu(self.service, "/define/models/species/save_gradients").execute(*args, **kwargs)
                def liquid_energy_diffusion(self, *args, **kwargs):
                    """
                    Enable/disable energy diffusion for liquid regime.
                    """
                    return PyMenu(self.service, "/define/models/species/liquid_energy_diffusion").execute(*args, **kwargs)
                def volumetric_reactions(self, *args, **kwargs):
                    """
                    Enable/disable volumetric reactions.
                    """
                    return PyMenu(self.service, "/define/models/species/volumetric_reactions").execute(*args, **kwargs)
                def species_transport_expert(self, *args, **kwargs):
                    """
                    Set species transport expert options.
                    """
                    return PyMenu(self.service, "/define/models/species/species_transport_expert").execute(*args, **kwargs)
                def coal_calculator(self, *args, **kwargs):
                    """
                    Set up coal modeling inputs.
                    """
                    return PyMenu(self.service, "/define/models/species/coal_calculator").execute(*args, **kwargs)
                def mixing_model(self, *args, **kwargs):
                    """
                    Set PDF transport mixing model.
                    """
                    return PyMenu(self.service, "/define/models/species/mixing_model").execute(*args, **kwargs)
                def stiff_chemistry(self, *args, **kwargs):
                    """
                    Enable/disable stiff chemistry option.
                    """
                    return PyMenu(self.service, "/define/models/species/stiff_chemistry").execute(*args, **kwargs)
                def liquid_micro_mixing(self, *args, **kwargs):
                    """
                    Enable/disable liquid micro mixing option.
                    """
                    return PyMenu(self.service, "/define/models/species/liquid_micro_mixing").execute(*args, **kwargs)
                def epdf_energy(self, *args, **kwargs):
                    """
                    Enable/disable EPDF energy  option.
                    """
                    return PyMenu(self.service, "/define/models/species/epdf_energy").execute(*args, **kwargs)
                def integration_parameters(self, *args, **kwargs):
                    """
                    Set ISAT parameters.
                    """
                    return PyMenu(self.service, "/define/models/species/integration_parameters").execute(*args, **kwargs)
                def clear_isat_table(self, *args, **kwargs):
                    """
                    Clear the ISAT table.
                    """
                    return PyMenu(self.service, "/define/models/species/clear_isat_table").execute(*args, **kwargs)
                def pdf_transport_expert(self, *args, **kwargs):
                    """
                    Enable/disable PDF transport expert user.
                    """
                    return PyMenu(self.service, "/define/models/species/pdf_transport_expert").execute(*args, **kwargs)
                def set_turb_chem_interaction(self, *args, **kwargs):
                    """
                    Set Eddy-Dissipation Concept model constants.
                    """
                    return PyMenu(self.service, "/define/models/species/set_turb_chem_interaction").execute(*args, **kwargs)
                def spark_model(self, *args, **kwargs):
                    """
                    Set spark model parameters.
                    """
                    return PyMenu(self.service, "/define/models/species/spark_model").execute(*args, **kwargs)
                def ignition_model(self, *args, **kwargs):
                    """
                    Enable/disable the ignition model.
                    """
                    return PyMenu(self.service, "/define/models/species/ignition_model").execute(*args, **kwargs)
                def ignition_model_controls(self, *args, **kwargs):
                    """
                    Set ignition model parameters.
                    """
                    return PyMenu(self.service, "/define/models/species/ignition_model_controls").execute(*args, **kwargs)
                def inert_transport_model(self, *args, **kwargs):
                    """
                    Enable/disable the inert transport model.
                    """
                    return PyMenu(self.service, "/define/models/species/inert_transport_model").execute(*args, **kwargs)
                def inert_transport_controls(self, *args, **kwargs):
                    """
                    Set inert transport model parameters.
                    """
                    return PyMenu(self.service, "/define/models/species/inert_transport_controls").execute(*args, **kwargs)
                def particle_surface_reactions(self, *args, **kwargs):
                    """
                    Enable/disable particle surface reactions.
                    """
                    return PyMenu(self.service, "/define/models/species/particle_surface_reactions").execute(*args, **kwargs)
                def wall_surface_reactions(self, *args, **kwargs):
                    """
                    Enable/disable wall surface reactions.
                    """
                    return PyMenu(self.service, "/define/models/species/wall_surface_reactions").execute(*args, **kwargs)
                def heat_of_surface_reactions(self, *args, **kwargs):
                    """
                    Enable/disable heat of surface reactions.
                    """
                    return PyMenu(self.service, "/define/models/species/heat_of_surface_reactions").execute(*args, **kwargs)
                def mass_deposition_source(self, *args, **kwargs):
                    """
                    Enable/disable mass deposition source due to surface reactions.
                    """
                    return PyMenu(self.service, "/define/models/species/mass_deposition_source").execute(*args, **kwargs)
                def electro_chemical_surface_reactions(self, *args, **kwargs):
                    """
                    Enable/disable electrochemical surface reactions.
                    """
                    return PyMenu(self.service, "/define/models/species/electro_chemical_surface_reactions").execute(*args, **kwargs)
                def species_migration(self, *args, **kwargs):
                    """
                    Enable/disable ion species migration in electric field.
                    """
                    return PyMenu(self.service, "/define/models/species/species_migration").execute(*args, **kwargs)
                def reaction_diffusion_balance(self, *args, **kwargs):
                    """
                    Enable/disable reaction diffusion balance at reacting surface for surface reactions.
                    """
                    return PyMenu(self.service, "/define/models/species/reaction_diffusion_balance").execute(*args, **kwargs)
                def surf_reaction_aggressiveness_factor(self, *args, **kwargs):
                    """
                    Set the surface reaction aggressiveness factor.
                    """
                    return PyMenu(self.service, "/define/models/species/surf_reaction_aggressiveness_factor").execute(*args, **kwargs)
                def surf_reaction_netm_params(self, *args, **kwargs):
                    """
                    Set the surface reaction parameters for the Non-Equilibrium Thermal Model.
                    """
                    return PyMenu(self.service, "/define/models/species/surf_reaction_netm_params").execute(*args, **kwargs)
                def inlet_diffusion(self, *args, **kwargs):
                    """
                    Enable/disable inclusion of diffusion at inlets.
                    """
                    return PyMenu(self.service, "/define/models/species/inlet_diffusion").execute(*args, **kwargs)
                def diffusion_energy_source(self, *args, **kwargs):
                    """
                    Enable/disable diffusion energy source.
                    """
                    return PyMenu(self.service, "/define/models/species/diffusion_energy_source").execute(*args, **kwargs)
                def multicomponent_diffusion(self, *args, **kwargs):
                    """
                    Enable/disable multicomponent diffusion.
                    """
                    return PyMenu(self.service, "/define/models/species/multicomponent_diffusion").execute(*args, **kwargs)
                def thermal_diffusion(self, *args, **kwargs):
                    """
                    Enable/disable thermal diffusion.
                    """
                    return PyMenu(self.service, "/define/models/species/thermal_diffusion").execute(*args, **kwargs)
                def CHEMKIN_CFD(self, *args, **kwargs):
                    """
                    Enable/disable CHEMKIN-CFD.
                    """
                    return PyMenu(self.service, "/define/models/species/CHEMKIN_CFD").execute(*args, **kwargs)
                def non_premixed_combustion_parameters(self, *args, **kwargs):
                    """
                    Set PDF parameters.
                    """
                    return PyMenu(self.service, "/define/models/species/non_premixed_combustion_parameters").execute(*args, **kwargs)
                def partially_premixed_combustion_parameters(self, *args, **kwargs):
                    """
                    Set PDF parameters.
                    """
                    return PyMenu(self.service, "/define/models/species/partially_premixed_combustion_parameters").execute(*args, **kwargs)
                def partially_premixed_properties(self, *args, **kwargs):
                    """
                    Set/Change partially premixed mixture properties.
                    """
                    return PyMenu(self.service, "/define/models/species/partially_premixed_properties").execute(*args, **kwargs)
                def re_calc_par_premix_props(self, *args, **kwargs):
                    """
                    Re-calculate partially-premixed properties.
                    """
                    return PyMenu(self.service, "/define/models/species/re_calc_par_premix_props").execute(*args, **kwargs)
                def full_tabulation(self, *args, **kwargs):
                    """
                    Enable/disable building of a full 2 mixture fraction table.
                    """
                    return PyMenu(self.service, "/define/models/species/full_tabulation").execute(*args, **kwargs)
                def init_unsteady_flamelet_prob(self, *args, **kwargs):
                    """
                    Initialize Unsteady Flamelet Probability.
                    """
                    return PyMenu(self.service, "/define/models/species/init_unsteady_flamelet_prob").execute(*args, **kwargs)
                def import_flamelet_for_restart(self, *args, **kwargs):
                    """
                    Import Flamelet File for Restart.
                    """
                    return PyMenu(self.service, "/define/models/species/import_flamelet_for_restart").execute(*args, **kwargs)
                def non_premixed_combustion_expert(self, *args, **kwargs):
                    """
                    Set PDF expert parameters.
                    """
                    return PyMenu(self.service, "/define/models/species/non_premixed_combustion_expert").execute(*args, **kwargs)
                def partially_premixed_combustion_expert(self, *args, **kwargs):
                    """
                    Set PDF expert parameters.
                    """
                    return PyMenu(self.service, "/define/models/species/partially_premixed_combustion_expert").execute(*args, **kwargs)
                def partially_premixed_combustion_grids(self, *args, **kwargs):
                    """
                    Set user specified grid parameters for PDF and flamelet.
                    """
                    return PyMenu(self.service, "/define/models/species/partially_premixed_combustion_grids").execute(*args, **kwargs)
                def flamelet_expert(self, *args, **kwargs):
                    """
                    Set flamelet expert parameters.
                    """
                    return PyMenu(self.service, "/define/models/species/flamelet_expert").execute(*args, **kwargs)
                def combustion_expert(self, *args, **kwargs):
                    """
                    Set combustion expert parameters.
                    """
                    return PyMenu(self.service, "/define/models/species/combustion_expert").execute(*args, **kwargs)
                def set_premixed_combustion(self, *args, **kwargs):
                    """
                    Set premixed combustion parameters.
                    """
                    return PyMenu(self.service, "/define/models/species/set_premixed_combustion").execute(*args, **kwargs)
                def set_multi_regime_fgm(self, *args, **kwargs):
                    """
                    Set-multi-regim-fgm-parameters.
                    """
                    return PyMenu(self.service, "/define/models/species/set_multi_regime_fgm").execute(*args, **kwargs)
                def relax_to_equil(self, *args, **kwargs):
                    """
                    Enable/disable the Relaxation to Chemical Equilibrium model.
                    """
                    return PyMenu(self.service, "/define/models/species/relax_to_equil").execute(*args, **kwargs)
                def thickened_flame_model(self, *args, **kwargs):
                    """
                    Enable/disable the Relaxation to Chemical Equilibrium model.
                    """
                    return PyMenu(self.service, "/define/models/species/thickened_flame_model").execute(*args, **kwargs)
                def decoupled_detailed_chemistry(self, *args, **kwargs):
                    """
                    Enable/disable the Decoupled Detailed Chemistry model.
                    """
                    return PyMenu(self.service, "/define/models/species/decoupled_detailed_chemistry").execute(*args, **kwargs)
                def reactor_network_model(self, *args, **kwargs):
                    """
                    Enable/disable the Reactor Network model.
                    """
                    return PyMenu(self.service, "/define/models/species/reactor_network_model").execute(*args, **kwargs)
                def reacting_channel_model(self, *args, **kwargs):
                    """
                    Enable/Disable the Reacting Channel Model.
                    """
                    return PyMenu(self.service, "/define/models/species/reacting_channel_model").execute(*args, **kwargs)
                def reacting_channel_model_options(self, *args, **kwargs):
                    """
                    Set Reacting Channel Model parameters.
                    """
                    return PyMenu(self.service, "/define/models/species/reacting_channel_model_options").execute(*args, **kwargs)
                def combustion_numerics(self, *args, **kwargs):
                    """
                    Set combustion numerics options.
                    """
                    return PyMenu(self.service, "/define/models/species/combustion_numerics").execute(*args, **kwargs)

                class CHEMKIN_CFD_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the expert CHEMKIN-CFD parameters menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def basic_options(self, *args, **kwargs):
                        """
                        Set basic parameter options.
                        """
                        return PyMenu(self.service, "/define/models/species/CHEMKIN_CFD_parameters/basic_options").execute(*args, **kwargs)
                    def advanced_options(self, *args, **kwargs):
                        """
                        Set advanced parameter options.
                        """
                        return PyMenu(self.service, "/define/models/species/CHEMKIN_CFD_parameters/advanced_options").execute(*args, **kwargs)
                    def add_cell_monitor(self, *args, **kwargs):
                        """
                        Add a monitor cell for debug output.
                        """
                        return PyMenu(self.service, "/define/models/species/CHEMKIN_CFD_parameters/add_cell_monitor").execute(*args, **kwargs)
                    def list_cell_monitors(self, *args, **kwargs):
                        """
                        List cell monitors.
                        """
                        return PyMenu(self.service, "/define/models/species/CHEMKIN_CFD_parameters/list_cell_monitors").execute(*args, **kwargs)
                    def delete_cell_monitors(self, *args, **kwargs):
                        """
                        Delete cell monitors.
                        """
                        return PyMenu(self.service, "/define/models/species/CHEMKIN_CFD_parameters/delete_cell_monitors").execute(*args, **kwargs)

            class viscous(metaclass=PyMenuMeta):
                """
                Enter the viscous model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.near_wall_treatment = self.__class__.near_wall_treatment(path + [("near_wall_treatment", None)], service)
                    self.multiphase_turbulence = self.__class__.multiphase_turbulence(path + [("multiphase_turbulence", None)], service)
                    self.turbulence_expert = self.__class__.turbulence_expert(path + [("turbulence_expert", None)], service)
                    self.geko_options = self.__class__.geko_options(path + [("geko_options", None)], service)
                    self.transition_model_options = self.__class__.transition_model_options(path + [("transition_model_options", None)], service)
                def inviscid(self, *args, **kwargs):
                    """
                    Enable/disable the inviscid flow model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/inviscid").execute(*args, **kwargs)
                def laminar(self, *args, **kwargs):
                    """
                    Enable/disable the laminar flow model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/laminar").execute(*args, **kwargs)
                def low_pressure_boundary_slip(self, *args, **kwargs):
                    """
                    Enable/disable the slip boundary formulation for low-pressure gas systems.
                    """
                    return PyMenu(self.service, "/define/models/viscous/low_pressure_boundary_slip").execute(*args, **kwargs)
                def mixing_length(self, *args, **kwargs):
                    """
                    Enable/disable the mixing-length (algebraic) turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/mixing_length").execute(*args, **kwargs)
                def zero_equation_hvac(self, *args, **kwargs):
                    """
                    Enable/disable the zero-equation HVAC turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/zero_equation_hvac").execute(*args, **kwargs)
                def spalart_allmaras(self, *args, **kwargs):
                    """
                    Enable/disable the Spalart-Allmaras turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/spalart_allmaras").execute(*args, **kwargs)
                def ke1e(self, *args, **kwargs):
                    """
                    Enable/disable the KE1E turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/ke1e").execute(*args, **kwargs)
                def sa_enhanced_wall_treatment(self, *args, **kwargs):
                    """
                    Enable/disable the enhanced wall treatment for the Spalart-Allmaras model.
                    If disabled, no smooth blending between the viscous sublayer and the
                    log-law formulation is employed, as was done in versions previous to Fluent14.
                    """
                    return PyMenu(self.service, "/define/models/viscous/sa_enhanced_wall_treatment").execute(*args, **kwargs)
                def sa_alternate_prod(self, *args, **kwargs):
                    """
                    Enable/disable strain/vorticity production in Spalart-Allmaras model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/sa_alternate_prod").execute(*args, **kwargs)
                def sa_damping(self, *args, **kwargs):
                    """
                    Enable/disable the full low-Reynolds number form of Spalart-Allmaras model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/sa_damping").execute(*args, **kwargs)
                def ke_standard(self, *args, **kwargs):
                    """
                    Enable/disable the standard k-epsilon turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/ke_standard").execute(*args, **kwargs)
                def ke_easm(self, *args, **kwargs):
                    """
                    Enable/disable the EASM k-epsilon turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/ke_easm").execute(*args, **kwargs)
                def ke_realizable(self, *args, **kwargs):
                    """
                    Enable/disable the realizable k-epsilon turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/ke_realizable").execute(*args, **kwargs)
                def ke_rng(self, *args, **kwargs):
                    """
                    Enable/disable the RNG k-epsilon turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/ke_rng").execute(*args, **kwargs)
                def rng_differential_visc(self, *args, **kwargs):
                    """
                    Enable/disable the differential-viscosity model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/rng_differential_visc").execute(*args, **kwargs)
                def rng_swirl_model(self, *args, **kwargs):
                    """
                    Enable/disable swirl corrections for rng-model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/rng_swirl_model").execute(*args, **kwargs)
                def kw_standard(self, *args, **kwargs):
                    """
                    Enable/disable the standard k-omega turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/kw_standard").execute(*args, **kwargs)
                def kw_easm(self, *args, **kwargs):
                    """
                    Enable/disable the EASM k-omega turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/kw_easm").execute(*args, **kwargs)
                def kw_bsl(self, *args, **kwargs):
                    """
                    Enable/disable the BSL k-omega turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/kw_bsl").execute(*args, **kwargs)
                def kw_geko(self, *args, **kwargs):
                    """
                    Enable/disable the GEKO turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/kw_geko").execute(*args, **kwargs)
                def kw_sst(self, *args, **kwargs):
                    """
                    Enable/disable the SST k-omega turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/kw_sst").execute(*args, **kwargs)
                def kw_wj_bsl_earsm(self, *args, **kwargs):
                    """
                    Enable/disable the EASM k-omega turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/kw_wj_bsl_earsm").execute(*args, **kwargs)
                def kw_low_re_correction(self, *args, **kwargs):
                    """
                    Enable/disable the k-omega low Re option.
                    """
                    return PyMenu(self.service, "/define/models/viscous/kw_low_re_correction").execute(*args, **kwargs)
                def kw_shear_correction(self, *args, **kwargs):
                    """
                    Enable/disable the k-omega shear-flow correction option.
                    """
                    return PyMenu(self.service, "/define/models/viscous/kw_shear_correction").execute(*args, **kwargs)
                def turb_compressibility(self, *args, **kwargs):
                    """
                    Enable/disable the compressibility correction option.
                    """
                    return PyMenu(self.service, "/define/models/viscous/turb_compressibility").execute(*args, **kwargs)
                def k_kl_w(self, *args, **kwargs):
                    """
                    Enable/disable the k-kl-omega turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/k_kl_w").execute(*args, **kwargs)
                def transition_sst(self, *args, **kwargs):
                    """
                    Enable/disable the transition SST turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/transition_sst").execute(*args, **kwargs)
                def v2f(self, *args, **kwargs):
                    """
                    Enable/disable the V2F turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/v2f").execute(*args, **kwargs)
                def reynolds_stress_model(self, *args, **kwargs):
                    """
                    Enable/disable the RSM turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/reynolds_stress_model").execute(*args, **kwargs)
                def rsm_solve_tke(self, *args, **kwargs):
                    """
                    Enable/disable the solution of T.K.E. in RSM model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/rsm_solve_tke").execute(*args, **kwargs)
                def rsm_wall_echo(self, *args, **kwargs):
                    """
                    Enable/disable wall-echo effects in RSM model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/rsm_wall_echo").execute(*args, **kwargs)
                def rsm_linear_pressure_strain(self, *args, **kwargs):
                    """
                    Enable/disable the linear pressure-strain model in RSM.
                    """
                    return PyMenu(self.service, "/define/models/viscous/rsm_linear_pressure_strain").execute(*args, **kwargs)
                def rsm_ssg_pressure_strain(self, *args, **kwargs):
                    """
                    Enable/disable the quadratic pressure-strain model in RSM.
                    """
                    return PyMenu(self.service, "/define/models/viscous/rsm_ssg_pressure_strain").execute(*args, **kwargs)
                def rsm_omega_based(self, *args, **kwargs):
                    """
                    Enable/disable the Stress-omega model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/rsm_omega_based").execute(*args, **kwargs)
                def rsm_bsl_based(self, *args, **kwargs):
                    """
                    Enable/disable the Stress-BSL model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/rsm_bsl_based").execute(*args, **kwargs)
                def sas(self, *args, **kwargs):
                    """
                    Enable/disable the SAS turbulence model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/sas").execute(*args, **kwargs)
                def detached_eddy_simulation(self, *args, **kwargs):
                    """
                    Enable/disable detached eddy simulation.
                    """
                    return PyMenu(self.service, "/define/models/viscous/detached_eddy_simulation").execute(*args, **kwargs)
                def des_limiter_option(self, *args, **kwargs):
                    """
                    Select DES limiter option.
                    """
                    return PyMenu(self.service, "/define/models/viscous/des_limiter_option").execute(*args, **kwargs)
                def large_eddy_simulation(self, *args, **kwargs):
                    """
                    Enable/disable large eddy simulation.
                    """
                    return PyMenu(self.service, "/define/models/viscous/large_eddy_simulation").execute(*args, **kwargs)
                def les_subgrid_smagorinsky(self, *args, **kwargs):
                    """
                    Enable/disable the Smagorinsky-Lilly subgrid-scale model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/les_subgrid_smagorinsky").execute(*args, **kwargs)
                def les_dynamic_energy_flux(self, *args, **kwargs):
                    """
                    Enable/disable the dynamic sub-grid scale turbulent Prandtl Number.
                    """
                    return PyMenu(self.service, "/define/models/viscous/les_dynamic_energy_flux").execute(*args, **kwargs)
                def les_dynamic_scalar_flux(self, *args, **kwargs):
                    """
                    Enable/disable the dynamic sub-grid scale turbulent Schmidt Number.
                    """
                    return PyMenu(self.service, "/define/models/viscous/les_dynamic_scalar_flux").execute(*args, **kwargs)
                def les_subgrid_dynamic_fvar(self, *args, **kwargs):
                    """
                    Enable/disable the dynamic subgrid-scale mixture fraction variance model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/les_subgrid_dynamic_fvar").execute(*args, **kwargs)
                def les_subgrid_rng(self, *args, **kwargs):
                    """
                    Enable/disable the RNG subgrid-scale model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/les_subgrid_rng").execute(*args, **kwargs)
                def les_subgrid_wale(self, *args, **kwargs):
                    """
                    Enable/disable the WALE subgrid-scale model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/les_subgrid_wale").execute(*args, **kwargs)
                def les_subgrid_wmles(self, *args, **kwargs):
                    """
                    Enable/disable the WMLES subgrid-scale model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/les_subgrid_wmles").execute(*args, **kwargs)
                def les_subgrid_wmles_s_minus_omega(self, *args, **kwargs):
                    """
                    Enable/disable the WMLES S-Omega subgrid-scale model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/les_subgrid_wmles_s_minus_omega").execute(*args, **kwargs)
                def les_subgrid_tke(self, *args, **kwargs):
                    """
                    Enable/disable the kinetic energy transport subgrid-scale model.
                    """
                    return PyMenu(self.service, "/define/models/viscous/les_subgrid_tke").execute(*args, **kwargs)
                def turb_buoyancy_effects(self, *args, **kwargs):
                    """
                    Select buoyancy effects on turbulence.
                    """
                    return PyMenu(self.service, "/define/models/viscous/turb_buoyancy_effects").execute(*args, **kwargs)
                def curvature_correction(self, *args, **kwargs):
                    """
                    Enable/disable the curvature correction.
                    """
                    return PyMenu(self.service, "/define/models/viscous/curvature_correction").execute(*args, **kwargs)
                def curvature_correction_ccurv(self, *args, **kwargs):
                    """
                    Set the curvature correction coefficient CCURV.
                    """
                    return PyMenu(self.service, "/define/models/viscous/curvature_correction_ccurv").execute(*args, **kwargs)
                def corner_flow_correction(self, *args, **kwargs):
                    """
                    Enable/disable the corner flow correction.
                    """
                    return PyMenu(self.service, "/define/models/viscous/corner_flow_correction").execute(*args, **kwargs)
                def corner_flow_correction_ccorner(self, *args, **kwargs):
                    """
                    Set the corner flow correction coefficient CCORNER.
                    """
                    return PyMenu(self.service, "/define/models/viscous/corner_flow_correction_ccorner").execute(*args, **kwargs)
                def rsm_or_earsm_geko_option(self, *args, **kwargs):
                    """
                    Enable/disable the GEKO option for RSM or EARSM.
                    """
                    return PyMenu(self.service, "/define/models/viscous/rsm_or_earsm_geko_option").execute(*args, **kwargs)
                def add_transition_model(self, *args, **kwargs):
                    """
                    Enable/disable a transition model to account for transitional effects.
                    """
                    return PyMenu(self.service, "/define/models/viscous/add_transition_model").execute(*args, **kwargs)
                def user_defined(self, *args, **kwargs):
                    """
                    Select user-defined functions to define the turbulent viscosity and the turbulent Prandtl and Schmidt numbers.
                    """
                    return PyMenu(self.service, "/define/models/viscous/user_defined").execute(*args, **kwargs)
                def user_defined_transition(self, *args, **kwargs):
                    """
                    Set user-defined transition correlations.
                    """
                    return PyMenu(self.service, "/define/models/viscous/user_defined_transition").execute(*args, **kwargs)
                def trans_sst_roughness_correlation(self, *args, **kwargs):
                    """
                    Enable/disable the Transition-SST roughness correlation option.
                    """
                    return PyMenu(self.service, "/define/models/viscous/trans_sst_roughness_correlation").execute(*args, **kwargs)

                class near_wall_treatment(metaclass=PyMenuMeta):
                    """
                    Enter the near wall treatment menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def non_equilibrium_wall_fn(self, *args, **kwargs):
                        """
                        Enable/disable non-equilibrium wall functions.
                        """
                        return PyMenu(self.service, "/define/models/viscous/near_wall_treatment/non_equilibrium_wall_fn").execute(*args, **kwargs)
                    def enhanced_wall_treatment(self, *args, **kwargs):
                        """
                        Enable/disable enhanced wall functions.
                        """
                        return PyMenu(self.service, "/define/models/viscous/near_wall_treatment/enhanced_wall_treatment").execute(*args, **kwargs)
                    def menter_lechner(self, *args, **kwargs):
                        """
                        Enable/disable near wall treatment Menter-Lechner.
                        """
                        return PyMenu(self.service, "/define/models/viscous/near_wall_treatment/menter_lechner").execute(*args, **kwargs)
                    def scalable_wall_functions(self, *args, **kwargs):
                        """
                        Enable/disable scalable wall functions.
                        """
                        return PyMenu(self.service, "/define/models/viscous/near_wall_treatment/scalable_wall_functions").execute(*args, **kwargs)
                    def user_defined_wall_functions(self, *args, **kwargs):
                        """
                        Enable user defined wall functions.
                        """
                        return PyMenu(self.service, "/define/models/viscous/near_wall_treatment/user_defined_wall_functions").execute(*args, **kwargs)
                    def werner_wengle_wall_fn(self, *args, **kwargs):
                        """
                        Enable/disable Werner-Wengle wall functions.
                        """
                        return PyMenu(self.service, "/define/models/viscous/near_wall_treatment/werner_wengle_wall_fn").execute(*args, **kwargs)
                    def wf_pressure_gradient_effects(self, *args, **kwargs):
                        """
                        Enable/disable wall function pressure-gradient effects.
                        """
                        return PyMenu(self.service, "/define/models/viscous/near_wall_treatment/wf_pressure_gradient_effects").execute(*args, **kwargs)
                    def wf_thermal_effects(self, *args, **kwargs):
                        """
                        Enable/disable wall function thermal effects.
                        """
                        return PyMenu(self.service, "/define/models/viscous/near_wall_treatment/wf_thermal_effects").execute(*args, **kwargs)

                class multiphase_turbulence(metaclass=PyMenuMeta):
                    """
                    Enter the multiphase turbulence menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def multiphase_options(self, *args, **kwargs):
                        """
                        Enable/disable multiphase options.
                        """
                        return PyMenu(self.service, "/define/models/viscous/multiphase_turbulence/multiphase_options").execute(*args, **kwargs)
                    def turbulence_multiphase_models(self, *args, **kwargs):
                        """
                        Select the k-epsilon multiphase model.
                        """
                        return PyMenu(self.service, "/define/models/viscous/multiphase_turbulence/turbulence_multiphase_models").execute(*args, **kwargs)
                    def rsm_multiphase_models(self, *args, **kwargs):
                        """
                        Enable/disable the Reynolds Stress multiphase model.
                        """
                        return PyMenu(self.service, "/define/models/viscous/multiphase_turbulence/rsm_multiphase_models").execute(*args, **kwargs)
                    def subgrid_turbulence_contribution_aiad(self, *args, **kwargs):
                        """
                        Enable/disable the Subgrid Turbulence Contribution for the AIAD model.
                        """
                        return PyMenu(self.service, "/define/models/viscous/multiphase_turbulence/subgrid_turbulence_contribution_aiad").execute(*args, **kwargs)

                class turbulence_expert(metaclass=PyMenuMeta):
                    """
                    Enter the turbulence expert menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def low_re_ke(self, *args, **kwargs):
                        """
                        Enable/disable the low-Re k-epsilon turbulence model.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/low_re_ke").execute(*args, **kwargs)
                    def low_re_ke_index(self, *args, **kwargs):
                        """
                        Enable/disable the low-Re k-epsilon model version.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/low_re_ke_index").execute(*args, **kwargs)
                    def kato_launder_model(self, *args, **kwargs):
                        """
                        Enable/disable Kato-Launder modification for production.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/kato_launder_model").execute(*args, **kwargs)
                    def production_limiter(self, *args, **kwargs):
                        """
                        Enable/disable the Production Limiter.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/production_limiter").execute(*args, **kwargs)
                    def kw_vorticity_based_production(self, *args, **kwargs):
                        """
                        Enable/disable vorticity based production.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/kw_vorticity_based_production").execute(*args, **kwargs)
                    def kw_add_sas(self, *args, **kwargs):
                        """
                        Enable/disable the SAS-mode with the current turbulence model.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/kw_add_sas").execute(*args, **kwargs)
                    def kw_add_des(self, *args, **kwargs):
                        """
                        Enable/disable DES-mode with the current turbulence model.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/kw_add_des").execute(*args, **kwargs)
                    def turb_add_sbes_sdes(self, *args, **kwargs):
                        """
                        Enable/disable SBES / SDES with the current turbulence model.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/turb_add_sbes_sdes").execute(*args, **kwargs)
                    def sbes_sdes_hybrid_model(self, *args, **kwargs):
                        """
                        Select the SBES / SDES hybrid model.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/sbes_sdes_hybrid_model").execute(*args, **kwargs)
                    def sbes_update_interval_k_omega(self, *args, **kwargs):
                        """
                        Set an integer value how often the k and omega equations are updated in a transient SBES run.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/sbes_update_interval_k_omega").execute(*args, **kwargs)
                    def sbes_sgs_option(self, *args, **kwargs):
                        """
                        Select SBES subgrid-scale model.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/sbes_sgs_option").execute(*args, **kwargs)
                    def sbes_les_subgrid_dynamic_fvar(self, *args, **kwargs):
                        """
                        Enable/disable the dynamic subgrid-scale mixture fraction variance model.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/sbes_les_subgrid_dynamic_fvar").execute(*args, **kwargs)
                    def turbulence_damping(self, *args, **kwargs):
                        """
                        Enable/disable turbulence damping and set turbulence damping parameters.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/turbulence_damping").execute(*args, **kwargs)
                    def rke_cmu_rotation_term(self, *args, **kwargs):
                        """
                        Enable/disable inclusion of omega in the Cmu definition.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/rke_cmu_rotation_term").execute(*args, **kwargs)
                    def turb_non_newtonian(self, *args, **kwargs):
                        """
                        Enable/disable turbulence for non-Newtonian fluids.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/turb_non_newtonian").execute(*args, **kwargs)
                    def non_newtonian_modification(self, *args, **kwargs):
                        """
                        Enable/disable non-Newtonian modification for Lam-Bremhorst model.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/non_newtonian_modification").execute(*args, **kwargs)
                    def turb_pk_compressible(self, *args, **kwargs):
                        """
                        Enable/disable turbulent production due to compressible divergence.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/turb_pk_compressible").execute(*args, **kwargs)
                    def thermal_p_function(self, *args, **kwargs):
                        """
                        Enable/disable the Jayatilleke P function.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/thermal_p_function").execute(*args, **kwargs)
                    def restore_sst_v61(self, *args, **kwargs):
                        """
                        Enable/disable SST formulation of v6.1.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/restore_sst_v61").execute(*args, **kwargs)
                    def stg_set_ti_and_tvr_limiters(self, *args, **kwargs):
                        """
                        
                        Specify minimum Turbulence Intensity (TI) and Turbulent Viscosity Ratio (TVR)
                        to search STG scales only at inlet areas where TVR > TVR_min and TI > TI_min.
                        """
                        return PyMenu(self.service, "/define/models/viscous/turbulence_expert/stg_set_ti_and_tvr_limiters").execute(*args, **kwargs)

                class geko_options(metaclass=PyMenuMeta):
                    """
                    Enter the GEKO options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def wall_distance_free(self, *args, **kwargs):
                        """
                        Enable/disable wall-distance-free version of GEKO model.
                        """
                        return PyMenu(self.service, "/define/models/viscous/geko_options/wall_distance_free").execute(*args, **kwargs)
                    def csep(self, *args, **kwargs):
                        """
                        Set the GEKO model coefficient CSEP.
                        """
                        return PyMenu(self.service, "/define/models/viscous/geko_options/csep").execute(*args, **kwargs)
                    def cnw(self, *args, **kwargs):
                        """
                        Set the GEKO model coefficient CNW.
                        """
                        return PyMenu(self.service, "/define/models/viscous/geko_options/cnw").execute(*args, **kwargs)
                    def cmix(self, *args, **kwargs):
                        """
                        Set the GEKO model coefficient CMIX.
                        """
                        return PyMenu(self.service, "/define/models/viscous/geko_options/cmix").execute(*args, **kwargs)
                    def cjet(self, *args, **kwargs):
                        """
                        Set the GEKO model coefficient CJET.
                        """
                        return PyMenu(self.service, "/define/models/viscous/geko_options/cjet").execute(*args, **kwargs)
                    def blending_function(self, *args, **kwargs):
                        """
                        Set the GEKO model blending function.
                        """
                        return PyMenu(self.service, "/define/models/viscous/geko_options/blending_function").execute(*args, **kwargs)
                    def creal(self, *args, **kwargs):
                        """
                        Set the GEKO model coefficient CREAL.
                        """
                        return PyMenu(self.service, "/define/models/viscous/geko_options/creal").execute(*args, **kwargs)
                    def cnw_sub(self, *args, **kwargs):
                        """
                        Set the GEKO model coefficient CNW_SUB.
                        """
                        return PyMenu(self.service, "/define/models/viscous/geko_options/cnw_sub").execute(*args, **kwargs)
                    def cjet_aux(self, *args, **kwargs):
                        """
                        Set the GEKO model coefficient CJET_AUX.
                        """
                        return PyMenu(self.service, "/define/models/viscous/geko_options/cjet_aux").execute(*args, **kwargs)
                    def cbf_lam(self, *args, **kwargs):
                        """
                        Set the GEKO model coefficient CBF_LAM.
                        """
                        return PyMenu(self.service, "/define/models/viscous/geko_options/cbf_lam").execute(*args, **kwargs)
                    def cbf_tur(self, *args, **kwargs):
                        """
                        Set the GEKO model coefficient CBF_TUR.
                        """
                        return PyMenu(self.service, "/define/models/viscous/geko_options/cbf_tur").execute(*args, **kwargs)
                    def geko_defaults(self, *args, **kwargs):
                        """
                        Set GEKO options to default.
                        """
                        return PyMenu(self.service, "/define/models/viscous/geko_options/geko_defaults").execute(*args, **kwargs)

                class transition_model_options(metaclass=PyMenuMeta):
                    """
                    Enter the transition model options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def crossflow_transition(self, *args, **kwargs):
                        """
                        Enable/disable crossflow transition for the intermittency transition model.
                        """
                        return PyMenu(self.service, "/define/models/viscous/transition_model_options/crossflow_transition").execute(*args, **kwargs)
                    def critical_reynolds_number_correlation(self, *args, **kwargs):
                        """
                        Set the critical Reynolds number correlation.
                        """
                        return PyMenu(self.service, "/define/models/viscous/transition_model_options/critical_reynolds_number_correlation").execute(*args, **kwargs)
                    def clambda_scale(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient CLAMBDA_SCALE.
                        """
                        return PyMenu(self.service, "/define/models/viscous/transition_model_options/clambda_scale").execute(*args, **kwargs)
                    def capg_hightu(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient CAPG_HIGHTU.
                        """
                        return PyMenu(self.service, "/define/models/viscous/transition_model_options/capg_hightu").execute(*args, **kwargs)
                    def cfpg_hightu(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient CFPG_HIGHTU.
                        """
                        return PyMenu(self.service, "/define/models/viscous/transition_model_options/cfpg_hightu").execute(*args, **kwargs)
                    def capg_lowtu(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient CAPG_LOWTU.
                        """
                        return PyMenu(self.service, "/define/models/viscous/transition_model_options/capg_lowtu").execute(*args, **kwargs)
                    def cfpg_lowtu(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient CFPG_LOWTU.
                        """
                        return PyMenu(self.service, "/define/models/viscous/transition_model_options/cfpg_lowtu").execute(*args, **kwargs)
                    def ctu_hightu(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient CTU_HIGHTU.
                        """
                        return PyMenu(self.service, "/define/models/viscous/transition_model_options/ctu_hightu").execute(*args, **kwargs)
                    def ctu_lowtu(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient CTU_LOWTU.
                        """
                        return PyMenu(self.service, "/define/models/viscous/transition_model_options/ctu_lowtu").execute(*args, **kwargs)
                    def rec_max(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient REC_MAX.
                        """
                        return PyMenu(self.service, "/define/models/viscous/transition_model_options/rec_max").execute(*args, **kwargs)
                    def rec_c1(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient REC_C1.
                        """
                        return PyMenu(self.service, "/define/models/viscous/transition_model_options/rec_c1").execute(*args, **kwargs)
                    def rec_c2(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient REC_C2.
                        """
                        return PyMenu(self.service, "/define/models/viscous/transition_model_options/rec_c2").execute(*args, **kwargs)
                    def cbubble_c1(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient CBUBBLE_C1.
                        """
                        return PyMenu(self.service, "/define/models/viscous/transition_model_options/cbubble_c1").execute(*args, **kwargs)
                    def cbubble_c2(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient CBUBBLE_C2.
                        """
                        return PyMenu(self.service, "/define/models/viscous/transition_model_options/cbubble_c2").execute(*args, **kwargs)
                    def rv1_switch(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient RV1_SWITCH.
                        """
                        return PyMenu(self.service, "/define/models/viscous/transition_model_options/rv1_switch").execute(*args, **kwargs)

            class structure(metaclass=PyMenuMeta):
                """
                Enter the structure model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.controls = self.__class__.controls(path + [("controls", None)], service)
                    self.expert = self.__class__.expert(path + [("expert", None)], service)
                def structure_off(self, *args, **kwargs):
                    """
                    Disable the structural model.
                    """
                    return PyMenu(self.service, "/define/models/structure/structure_off").execute(*args, **kwargs)
                def linear_elasticity(self, *args, **kwargs):
                    """
                    Enable the linear elasticity model.
                    """
                    return PyMenu(self.service, "/define/models/structure/linear_elasticity").execute(*args, **kwargs)
                def nonlinear_elasticity(self, *args, **kwargs):
                    """
                    Enable the nonlinear elasticity model.
                    """
                    return PyMenu(self.service, "/define/models/structure/nonlinear_elasticity").execute(*args, **kwargs)
                def thermal_effects(self, *args, **kwargs):
                    """
                    Enable structure thermal effects.
                    """
                    return PyMenu(self.service, "/define/models/structure/thermal_effects").execute(*args, **kwargs)

                class controls(metaclass=PyMenuMeta):
                    """
                    Enter the structure controls menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def numerical_damping_factor(self, *args, **kwargs):
                        """
                        Set structure damping parameters.
                        """
                        return PyMenu(self.service, "/define/models/structure/controls/numerical_damping_factor").execute(*args, **kwargs)
                    def enhanced_strain(self, *args, **kwargs):
                        """
                        Enable enhanced strain element.
                        """
                        return PyMenu(self.service, "/define/models/structure/controls/enhanced_strain").execute(*args, **kwargs)
                    def unsteady_damping_rayleigh(self, *args, **kwargs):
                        """
                        Enable/disable Newmark unsteady solution model.
                        """
                        return PyMenu(self.service, "/define/models/structure/controls/unsteady_damping_rayleigh").execute(*args, **kwargs)
                    def amg_stabilization(self, *args, **kwargs):
                        """
                        Set the AMG stabilization method for structural solver.
                        """
                        return PyMenu(self.service, "/define/models/structure/controls/amg_stabilization").execute(*args, **kwargs)
                    def max_iter(self, *args, **kwargs):
                        """
                        Set the maximum number of iterations for structural solver.
                        """
                        return PyMenu(self.service, "/define/models/structure/controls/max_iter").execute(*args, **kwargs)

                class expert(metaclass=PyMenuMeta):
                    """
                    Enter the structure expert menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def include_pop_in_fsi_force(self, *args, **kwargs):
                        """
                        Enable inclusion of operating p into fsi force.
                        """
                        return PyMenu(self.service, "/define/models/structure/expert/include_pop_in_fsi_force").execute(*args, **kwargs)
                    def steady_2way_fsi(self, *args, **kwargs):
                        """
                        Enable steady 2-way fsi workflow.
                        """
                        return PyMenu(self.service, "/define/models/structure/expert/steady_2way_fsi").execute(*args, **kwargs)
                    def include_viscous_fsi_force(self, *args, **kwargs):
                        """
                        Enable inclusion of viscous fsi force.
                        """
                        return PyMenu(self.service, "/define/models/structure/expert/include_viscous_fsi_force").execute(*args, **kwargs)
                    def explicit_fsi_force(self, *args, **kwargs):
                        """
                        Enable explicit fsi force.
                        """
                        return PyMenu(self.service, "/define/models/structure/expert/explicit_fsi_force").execute(*args, **kwargs)

            class heat_exchanger(metaclass=PyMenuMeta):
                """
                Enter the heat exchanger menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.macro_model = self.__class__.macro_model(path + [("macro_model", None)], service)
                    self.dual_cell_model = self.__class__.dual_cell_model(path + [("dual_cell_model", None)], service)

                class macro_model(metaclass=PyMenuMeta):
                    """
                    Enter the heat macro-model menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def heat_exchanger(self, *args, **kwargs):
                        """
                        Enable/disable heat-exchanger model.
                        """
                        return PyMenu(self.service, "/define/models/heat_exchanger/macro_model/heat_exchanger").execute(*args, **kwargs)
                    def heat_exchanger_model(self, *args, **kwargs):
                        """
                        Define heat-exchanger core model.
                        """
                        return PyMenu(self.service, "/define/models/heat_exchanger/macro_model/heat_exchanger_model").execute(*args, **kwargs)
                    def heat_exchanger_zone(self, *args, **kwargs):
                        """
                        Define heat-exchanger zone.
                        """
                        return PyMenu(self.service, "/define/models/heat_exchanger/macro_model/heat_exchanger_zone").execute(*args, **kwargs)
                    def heat_exchanger_group(self, *args, **kwargs):
                        """
                        Define heat-exchanger group.
                        """
                        return PyMenu(self.service, "/define/models/heat_exchanger/macro_model/heat_exchanger_group").execute(*args, **kwargs)
                    def delete_heat_exchanger_group(self, *args, **kwargs):
                        """
                        Delete heat-exchanger group.
                        """
                        return PyMenu(self.service, "/define/models/heat_exchanger/macro_model/delete_heat_exchanger_group").execute(*args, **kwargs)
                    def heat_exchanger_report(self, *args, **kwargs):
                        """
                        Report heat-exchanger information.
                        """
                        return PyMenu(self.service, "/define/models/heat_exchanger/macro_model/heat_exchanger_report").execute(*args, **kwargs)
                    def heat_exchanger_macro_report(self, *args, **kwargs):
                        """
                        Report heat-exchanger information for all the macros.
                        """
                        return PyMenu(self.service, "/define/models/heat_exchanger/macro_model/heat_exchanger_macro_report").execute(*args, **kwargs)
                    def plot_NTU(self, *args, **kwargs):
                        """
                        Plot NTU vs primary mass flow rate for each auxiliary mass flow rate.
                        """
                        return PyMenu(self.service, "/define/models/heat_exchanger/macro_model/plot_NTU").execute(*args, **kwargs)
                    def write_NTU(self, *args, **kwargs):
                        """
                        Write NTU vs primary mass flow rate for each auxiliary mass flow rate.
                        """
                        return PyMenu(self.service, "/define/models/heat_exchanger/macro_model/write_NTU").execute(*args, **kwargs)

                class dual_cell_model(metaclass=PyMenuMeta):
                    """
                    Enter the dual cell model menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def heat_exchanger(self, *args, **kwargs):
                        """
                        Enable/disable the dual cell heat-exchanger model.
                        """
                        return PyMenu(self.service, "/define/models/heat_exchanger/dual_cell_model/heat_exchanger").execute(*args, **kwargs)
                    def add_heat_exchanger(self, *args, **kwargs):
                        """
                        Add heat-exchanger.
                        """
                        return PyMenu(self.service, "/define/models/heat_exchanger/dual_cell_model/add_heat_exchanger").execute(*args, **kwargs)
                    def modify_heat_exchanger(self, *args, **kwargs):
                        """
                        Modify heat-exchanger.
                        """
                        return PyMenu(self.service, "/define/models/heat_exchanger/dual_cell_model/modify_heat_exchanger").execute(*args, **kwargs)
                    def delete_heat_exchanger(self, *args, **kwargs):
                        """
                        Delete heat-exchanger.
                        """
                        return PyMenu(self.service, "/define/models/heat_exchanger/dual_cell_model/delete_heat_exchanger").execute(*args, **kwargs)
                    def plot_NTU(self, *args, **kwargs):
                        """
                        Plot NTU vs primary mass flow rate for each auxiliary mass flow rate.
                        """
                        return PyMenu(self.service, "/define/models/heat_exchanger/dual_cell_model/plot_NTU").execute(*args, **kwargs)
                    def write_NTU(self, *args, **kwargs):
                        """
                        Write NTU vs primary mass flow rate for each auxiliary mass flow rate.
                        """
                        return PyMenu(self.service, "/define/models/heat_exchanger/dual_cell_model/write_NTU").execute(*args, **kwargs)
                    def alternative_formulation(self, *args, **kwargs):
                        """
                        Enable/disable alternative formulation for heat transfer calculations.
                        """
                        return PyMenu(self.service, "/define/models/heat_exchanger/dual_cell_model/alternative_formulation").execute(*args, **kwargs)

            class electrolysis_setup(metaclass=PyMenuMeta):
                """
                Enter the electrolysis model setup menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.anode_setup = self.__class__.anode_setup(path + [("anode_setup", None)], service)
                    self.cathode_setup = self.__class__.cathode_setup(path + [("cathode_setup", None)], service)
                    self.membrane_setup = self.__class__.membrane_setup(path + [("membrane_setup", None)], service)
                def model_options(self, *args, **kwargs):
                    """
                    Model Options.
                    """
                    return PyMenu(self.service, "/define/models/electrolysis_setup/model_options").execute(*args, **kwargs)
                def parameters(self, *args, **kwargs):
                    """
                    Model Parameters.
                    """
                    return PyMenu(self.service, "/define/models/electrolysis_setup/parameters").execute(*args, **kwargs)
                def electrical_tabs_setup(self, *args, **kwargs):
                    """
                    Electrical Tabs Setup.
                    """
                    return PyMenu(self.service, "/define/models/electrolysis_setup/electrical_tabs_setup").execute(*args, **kwargs)

                class anode_setup(metaclass=PyMenuMeta):
                    """
                    Anode Setup.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def current_collector(self, *args, **kwargs):
                        """
                        Set Current Collector.
                        """
                        return PyMenu(self.service, "/define/models/electrolysis_setup/anode_setup/current_collector").execute(*args, **kwargs)
                    def flow_channel(self, *args, **kwargs):
                        """
                        Set Flow Channel.
                        """
                        return PyMenu(self.service, "/define/models/electrolysis_setup/anode_setup/flow_channel").execute(*args, **kwargs)
                    def porous_layer(self, *args, **kwargs):
                        """
                        Set Porous Layer.
                        """
                        return PyMenu(self.service, "/define/models/electrolysis_setup/anode_setup/porous_layer").execute(*args, **kwargs)
                    def catalyst_layer(self, *args, **kwargs):
                        """
                        Set Catalyst Layer.
                        """
                        return PyMenu(self.service, "/define/models/electrolysis_setup/anode_setup/catalyst_layer").execute(*args, **kwargs)
                    def electrolyte(self, *args, **kwargs):
                        """
                        Set Electrolyte.
                        """
                        return PyMenu(self.service, "/define/models/electrolysis_setup/anode_setup/electrolyte").execute(*args, **kwargs)

                class cathode_setup(metaclass=PyMenuMeta):
                    """
                    Cathode Setup.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def current_collector(self, *args, **kwargs):
                        """
                        Set Current Collector.
                        """
                        return PyMenu(self.service, "/define/models/electrolysis_setup/cathode_setup/current_collector").execute(*args, **kwargs)
                    def flow_channel(self, *args, **kwargs):
                        """
                        Set Flow Channel.
                        """
                        return PyMenu(self.service, "/define/models/electrolysis_setup/cathode_setup/flow_channel").execute(*args, **kwargs)
                    def porous_layer(self, *args, **kwargs):
                        """
                        Set Porous Layer.
                        """
                        return PyMenu(self.service, "/define/models/electrolysis_setup/cathode_setup/porous_layer").execute(*args, **kwargs)
                    def catalyst_layer(self, *args, **kwargs):
                        """
                        Set Catalyst Layer.
                        """
                        return PyMenu(self.service, "/define/models/electrolysis_setup/cathode_setup/catalyst_layer").execute(*args, **kwargs)
                    def electrolyte(self, *args, **kwargs):
                        """
                        Set Electrolyte.
                        """
                        return PyMenu(self.service, "/define/models/electrolysis_setup/cathode_setup/electrolyte").execute(*args, **kwargs)

                class membrane_setup(metaclass=PyMenuMeta):
                    """
                    Membrane Setup.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def current_collector(self, *args, **kwargs):
                        """
                        Set Current Collector.
                        """
                        return PyMenu(self.service, "/define/models/electrolysis_setup/membrane_setup/current_collector").execute(*args, **kwargs)
                    def flow_channel(self, *args, **kwargs):
                        """
                        Set Flow Channel.
                        """
                        return PyMenu(self.service, "/define/models/electrolysis_setup/membrane_setup/flow_channel").execute(*args, **kwargs)
                    def porous_layer(self, *args, **kwargs):
                        """
                        Set Porous Layer.
                        """
                        return PyMenu(self.service, "/define/models/electrolysis_setup/membrane_setup/porous_layer").execute(*args, **kwargs)
                    def catalyst_layer(self, *args, **kwargs):
                        """
                        Set Catalyst Layer.
                        """
                        return PyMenu(self.service, "/define/models/electrolysis_setup/membrane_setup/catalyst_layer").execute(*args, **kwargs)
                    def electrolyte(self, *args, **kwargs):
                        """
                        Set Electrolyte.
                        """
                        return PyMenu(self.service, "/define/models/electrolysis_setup/membrane_setup/electrolyte").execute(*args, **kwargs)

        class overset_interfaces(metaclass=PyMenuMeta):
            """
            Enter the overset-interfaces menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.options = self.__class__.options(path + [("options", None)], service)
                self.cut_control = self.__class__.cut_control(path + [("cut_control", None)], service)
                self.adapt = self.__class__.adapt(path + [("adapt", None)], service)
            def create(self, *args, **kwargs):
                """
                Create an overset interface.
                """
                return PyMenu(self.service, "/define/overset_interfaces/create").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an overset interface.
                """
                return PyMenu(self.service, "/define/overset_interfaces/delete").execute(*args, **kwargs)
            def delete_all(self, *args, **kwargs):
                """
                Delete all overset interfaces.
                """
                return PyMenu(self.service, "/define/overset_interfaces/delete_all").execute(*args, **kwargs)
            def intersect(self, *args, **kwargs):
                """
                Intersect an overset interface.
                """
                return PyMenu(self.service, "/define/overset_interfaces/intersect").execute(*args, **kwargs)
            def intersect_all(self, *args, **kwargs):
                """
                Intersect all overset interfaces.
                """
                return PyMenu(self.service, "/define/overset_interfaces/intersect_all").execute(*args, **kwargs)
            def clear(self, *args, **kwargs):
                """
                Clear an overset interface.
                """
                return PyMenu(self.service, "/define/overset_interfaces/clear").execute(*args, **kwargs)
            def clear_all(self, *args, **kwargs):
                """
                Clear all overset interfaces.
                """
                return PyMenu(self.service, "/define/overset_interfaces/clear_all").execute(*args, **kwargs)
            def grid_priorities(self, *args, **kwargs):
                """
                Edit grid priorities for an overset interface.
                """
                return PyMenu(self.service, "/define/overset_interfaces/grid_priorities").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List all overset interfaces.
                """
                return PyMenu(self.service, "/define/overset_interfaces/list").execute(*args, **kwargs)
            def mark_cells(self, *args, **kwargs):
                """
                Mark overset interface related cell types.
                """
                return PyMenu(self.service, "/define/overset_interfaces/mark_cells").execute(*args, **kwargs)
            def display_cells(self, *args, **kwargs):
                """
                Display the marked overset cells.
                """
                return PyMenu(self.service, "/define/overset_interfaces/display_cells").execute(*args, **kwargs)
            def mark_cell_change(self, *args, **kwargs):
                """
                Mark overset interface related cell type change.
                """
                return PyMenu(self.service, "/define/overset_interfaces/mark_cell_change").execute(*args, **kwargs)
            def set_mark_bounds(self, *args, **kwargs):
                """
                Set bounds (center, radius) for overset cell marking.
                """
                return PyMenu(self.service, "/define/overset_interfaces/set_mark_bounds").execute(*args, **kwargs)
            def check(self, *args, **kwargs):
                """
                Check all overset interfaces.
                """
                return PyMenu(self.service, "/define/overset_interfaces/check").execute(*args, **kwargs)
            def debug_hole_cut(self, *args, **kwargs):
                """
                Debugging tool for overset hole cutting.
                """
                return PyMenu(self.service, "/define/overset_interfaces/debug_hole_cut").execute(*args, **kwargs)
            def fill_dci(self, *args, **kwargs):
                """
                Fill overset domain connectivity information (DCI).
                """
                return PyMenu(self.service, "/define/overset_interfaces/fill_dci").execute(*args, **kwargs)
            def free_dci(self, *args, **kwargs):
                """
                Free overset domain connectivity information (DCI).
                """
                return PyMenu(self.service, "/define/overset_interfaces/free_dci").execute(*args, **kwargs)
            def update_from_dci(self, *args, **kwargs):
                """
                Update all overset intrfaces from stored domain connectivity information (DCI).
                """
                return PyMenu(self.service, "/define/overset_interfaces/update_from_dci").execute(*args, **kwargs)
            def write_dci_to_case(self, *args, **kwargs):
                """
                Save domain connectivity information (DCI) to case file.
                """
                return PyMenu(self.service, "/define/overset_interfaces/write_dci_to_case").execute(*args, **kwargs)
            def read_dci_from_case(self, *args, **kwargs):
                """
                Read domain connectivity information (DCI) from case file.
                """
                return PyMenu(self.service, "/define/overset_interfaces/read_dci_from_case").execute(*args, **kwargs)
            def write_dci(self, *args, **kwargs):
                """
                Save domain connectivity information (DCI) to a text file.
                """
                return PyMenu(self.service, "/define/overset_interfaces/write_dci").execute(*args, **kwargs)
            def write_cell_types(self, *args, **kwargs):
                """
                Write overset cell types into file.
                """
                return PyMenu(self.service, "/define/overset_interfaces/write_cell_types").execute(*args, **kwargs)
            def find_bounding_cell(self, *args, **kwargs):
                """
                Find bounding cell for given cell or search point.
                """
                return PyMenu(self.service, "/define/overset_interfaces/find_bounding_cell").execute(*args, **kwargs)
            def find_all_bounding_cells(self, *args, **kwargs):
                """
                Find bounding cells for all cell centroids.
                """
                return PyMenu(self.service, "/define/overset_interfaces/find_all_bounding_cells").execute(*args, **kwargs)

            class options(metaclass=PyMenuMeta):
                """
                Enter the overset interface options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def expert(self, *args, **kwargs):
                    """
                    Enable additional overset options and tools.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/options/expert").execute(*args, **kwargs)
                def render_receptor_cells(self, *args, **kwargs):
                    """
                    Set the option to include receptor cells in postprocessing.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/options/render_receptor_cells").execute(*args, **kwargs)
                def partial_cut_faces(self, *args, **kwargs):
                    """
                    Enable enhanced hole cutting where cut faces partially overlap.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/options/partial_cut_faces").execute(*args, **kwargs)
                def auto_create(self, *args, **kwargs):
                    """
                    Enable automatic creation of default overset interface.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/options/auto_create").execute(*args, **kwargs)
                def minimize_overlap(self, *args, **kwargs):
                    """
                    Enable overlap minimization for overset interfaces.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/options/minimize_overlap").execute(*args, **kwargs)
                def overlap_boundaries(self, *args, **kwargs):
                    """
                    Enable overset topologies with overlap boundaries.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/options/overlap_boundaries").execute(*args, **kwargs)
                def mesh_interfaces(self, *args, **kwargs):
                    """
                    Allow mesh interfaces inside overset cell zones.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/options/mesh_interfaces").execute(*args, **kwargs)
                def node_connected_donors(self, *args, **kwargs):
                    """
                    Enable node or face connected donor cells.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/options/node_connected_donors").execute(*args, **kwargs)
                def donor_priority_method(self, *args, **kwargs):
                    """
                    Set method used to evaludate the cell donor priority.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/options/donor_priority_method").execute(*args, **kwargs)
                def solve_island_removal(self, *args, **kwargs):
                    """
                    Set method used to control the removal of isolated patches of solve cells.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/options/solve_island_removal").execute(*args, **kwargs)
                def transient_caching(self, *args, **kwargs):
                    """
                    Set options to control caching of entities in transient overset simulations.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/options/transient_caching").execute(*args, **kwargs)
                def modified_donor_search(self, *args, **kwargs):
                    """
                    Enable modified and more extensive donor search.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/options/modified_donor_search").execute(*args, **kwargs)
                def modified_hole_cutting(self, *args, **kwargs):
                    """
                    Enable modified hole cutting parameters.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/options/modified_hole_cutting").execute(*args, **kwargs)
                def dead_cell_update(self, *args, **kwargs):
                    """
                    Enable dead cell update in moving or dynamic mesh simulations.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/options/dead_cell_update").execute(*args, **kwargs)
                def update_before_case_write(self, *args, **kwargs):
                    """
                    Enable update of overset interfaces before writing case file (CFF format only).
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/options/update_before_case_write").execute(*args, **kwargs)
                def parallel(self, *args, **kwargs):
                    """
                    Set options to control running overset in parallel.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/options/parallel").execute(*args, **kwargs)
                def verbosity(self, *args, **kwargs):
                    """
                    Set overset mesh reporting verbosity.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/options/verbosity").execute(*args, **kwargs)

            class cut_control(metaclass=PyMenuMeta):
                """
                Enter the overset hole cut control menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.cut_seeds = self.__class__.cut_seeds(path + [("cut_seeds", None)], service)
                def add(self, *args, **kwargs):
                    """
                    Add hole cut control for a boundary zone.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/cut_control/add").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete hole cut control for a boundary zone.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/cut_control/delete").execute(*args, **kwargs)
                def delete_all(self, *args, **kwargs):
                    """
                    Delete the hole cut controls for all boundary zones.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/cut_control/delete_all").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    List the defined hole cut controls.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/cut_control/list").execute(*args, **kwargs)

                class cut_seeds(metaclass=PyMenuMeta):
                    """
                    Enter the overset hole cut seed menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def add(self, *args, **kwargs):
                        """
                        Add a hole cut seed.
                        """
                        return PyMenu(self.service, "/define/overset_interfaces/cut_control/cut_seeds/add").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete a hole cut seed.
                        """
                        return PyMenu(self.service, "/define/overset_interfaces/cut_control/cut_seeds/delete").execute(*args, **kwargs)
                    def delete_all(self, *args, **kwargs):
                        """
                        Delete all hole cut seeds.
                        """
                        return PyMenu(self.service, "/define/overset_interfaces/cut_control/cut_seeds/delete_all").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        List the defined hole cut seeds.
                        """
                        return PyMenu(self.service, "/define/overset_interfaces/cut_control/cut_seeds/list").execute(*args, **kwargs)
                    def cut_seeds_for_all_component_zones(self, *args, **kwargs):
                        """
                        Enable that all component zones get a cut seed.
                        """
                        return PyMenu(self.service, "/define/overset_interfaces/cut_control/cut_seeds/cut_seeds_for_all_component_zones").execute(*args, **kwargs)

            class adapt(metaclass=PyMenuMeta):
                """
                Enter the overset adaption menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.set = self.__class__.set(path + [("set", None)], service)
                def mark_adaption(self, *args, **kwargs):
                    """
                    Mark cells for overset orphan adaption and donor-receptor size differences.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/adapt/mark_adaption").execute(*args, **kwargs)
                def adapt_mesh(self, *args, **kwargs):
                    """
                    Mark and adapt the mesh to remove orphan cells and large donor-receptor cell size differences.
                    """
                    return PyMenu(self.service, "/define/overset_interfaces/adapt/adapt_mesh").execute(*args, **kwargs)

                class set(metaclass=PyMenuMeta):
                    """
                    Enter the overset adaption set menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def mark_orphans(self, *args, **kwargs):
                        """
                        Enable the option to adapt for orphan reduction.
                        """
                        return PyMenu(self.service, "/define/overset_interfaces/adapt/set/mark_orphans").execute(*args, **kwargs)
                    def mark_fixed_orphans(self, *args, **kwargs):
                        """
                        Enable the option to adapt for orphans which were removed by accepting neighbor donors.
                        """
                        return PyMenu(self.service, "/define/overset_interfaces/adapt/set/mark_fixed_orphans").execute(*args, **kwargs)
                    def mark_size(self, *args, **kwargs):
                        """
                        Enable the option to adapt for donor-receptor cell size differences.
                        """
                        return PyMenu(self.service, "/define/overset_interfaces/adapt/set/mark_size").execute(*args, **kwargs)
                    def mark_gaps(self, *args, **kwargs):
                        """
                        Enable the option to adapt underresolved gaps.
                        """
                        return PyMenu(self.service, "/define/overset_interfaces/adapt/set/mark_gaps").execute(*args, **kwargs)
                    def mark_coarsening(self, *args, **kwargs):
                        """
                        Enable the option to coarsen the mesh during overset adaption.
                        """
                        return PyMenu(self.service, "/define/overset_interfaces/adapt/set/mark_coarsening").execute(*args, **kwargs)
                    def anisotropic(self, *args, **kwargs):
                        """
                        Enable the option to use anisotropic adaption in prismatic cells.
                        """
                        return PyMenu(self.service, "/define/overset_interfaces/adapt/set/anisotropic").execute(*args, **kwargs)
                    def automatic(self, *args, **kwargs):
                        """
                        Enable the option to automatically adapt overset meshes during solution update.
                        """
                        return PyMenu(self.service, "/define/overset_interfaces/adapt/set/automatic").execute(*args, **kwargs)
                    def length_ratio_max(self, *args, **kwargs):
                        """
                        Set the length scale ratio threshold used to determine which cells are marked for adaption based on donor-receptor cell size differences.
                        """
                        return PyMenu(self.service, "/define/overset_interfaces/adapt/set/length_ratio_max").execute(*args, **kwargs)
                    def buffer_layers(self, *args, **kwargs):
                        """
                        Set the number of cell layers marked in addition to the cells marked for orphan adaption.
                        """
                        return PyMenu(self.service, "/define/overset_interfaces/adapt/set/buffer_layers").execute(*args, **kwargs)
                    def adaption_sweeps(self, *args, **kwargs):
                        """
                        Set the number of adaption sweeps per overset adaption.
                        """
                        return PyMenu(self.service, "/define/overset_interfaces/adapt/set/adaption_sweeps").execute(*args, **kwargs)
                    def maximum_refinement_level(self, *args, **kwargs):
                        """
                        Set the maximum level of refinement in overset adaption.
                        """
                        return PyMenu(self.service, "/define/overset_interfaces/adapt/set/maximum_refinement_level").execute(*args, **kwargs)

        class operating_conditions(metaclass=PyMenuMeta):
            """
            Enter the define operating conditions menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def gravity(self, *args, **kwargs):
                """
                Set gravitational acceleration.
                """
                return PyMenu(self.service, "/define/operating_conditions/gravity").execute(*args, **kwargs)
            def gravity_mrf_rotation(self, *args, **kwargs):
                """
                Enable/disable rotation of gravity vector in moving reference frame simulations.
                """
                return PyMenu(self.service, "/define/operating_conditions/gravity_mrf_rotation").execute(*args, **kwargs)
            def set_state(self, *args, **kwargs):
                """
                Select state for real gas EOS subcritical condition.
                """
                return PyMenu(self.service, "/define/operating_conditions/set_state").execute(*args, **kwargs)
            def operating_pressure(self, *args, **kwargs):
                """
                Set the operating pressure.
                """
                return PyMenu(self.service, "/define/operating_conditions/operating_pressure").execute(*args, **kwargs)
            def reference_pressure_location(self, *args, **kwargs):
                """
                Set coordinates of reference pressure.
                """
                return PyMenu(self.service, "/define/operating_conditions/reference_pressure_location").execute(*args, **kwargs)
            def reference_pressure_method(self, *args, **kwargs):
                """
                Choosing reference pressure type.
                """
                return PyMenu(self.service, "/define/operating_conditions/reference_pressure_method").execute(*args, **kwargs)
            def used_ref_pressure_location(self, *args, **kwargs):
                """
                See the actual coordinates of reference pressure used.
                """
                return PyMenu(self.service, "/define/operating_conditions/used_ref_pressure_location").execute(*args, **kwargs)
            def operating_density(self, *args, **kwargs):
                """
                Enable/disable use of a specified operating density.
                """
                return PyMenu(self.service, "/define/operating_conditions/operating_density").execute(*args, **kwargs)
            def use_inlet_temperature_for_operating_density(self, *args, **kwargs):
                """
                Use Inlet Temperature to calculate Opearating Density.
                """
                return PyMenu(self.service, "/define/operating_conditions/use_inlet_temperature_for_operating_density").execute(*args, **kwargs)
            def operating_temperature(self, *args, **kwargs):
                """
                Set the operating temperature for Boussinesq.
                """
                return PyMenu(self.service, "/define/operating_conditions/operating_temperature").execute(*args, **kwargs)

        class parameters(metaclass=PyMenuMeta):
            """
            Enter the parameters menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.input_parameters = self.__class__.input_parameters(path + [("input_parameters", None)], service)
                self.output_parameters = self.__class__.output_parameters(path + [("output_parameters", None)], service)
                self.list_parameters = self.__class__.list_parameters(path + [("list_parameters", None)], service)
            def enable_in_TUI(self, *args, **kwargs):
                """
                Enable/disable parameters in the text user interface.
                """
                return PyMenu(self.service, "/define/parameters/enable_in_TUI").execute(*args, **kwargs)

            class input_parameters(metaclass=PyMenuMeta):
                """
                Enter the input-parameters menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.advance = self.__class__.advance(path + [("advance", None)], service)
                def edit(self, *args, **kwargs):
                    """
                    Edit an input parameter.
                    """
                    return PyMenu(self.service, "/define/parameters/input_parameters/edit").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete an input parameter.
                    """
                    return PyMenu(self.service, "/define/parameters/input_parameters/delete").execute(*args, **kwargs)

                class advance(metaclass=PyMenuMeta):
                    """
                    Define custom variable to use input parameter.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def use_in(self, *args, **kwargs):
                        """
                        Use input parameter in solver-udf or in scheme-procedure.
                        """
                        return PyMenu(self.service, "/define/parameters/input_parameters/advance/use_in").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        List of custom-input-parameters.
                        """
                        return PyMenu(self.service, "/define/parameters/input_parameters/advance/list").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete selected custom-input-parameters.
                        """
                        return PyMenu(self.service, "/define/parameters/input_parameters/advance/delete").execute(*args, **kwargs)

            class output_parameters(metaclass=PyMenuMeta):
                """
                Enter the output-parameters menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def create(self, *args, **kwargs):
                    """
                    Create an output parameter.
                    """
                    return PyMenu(self.service, "/define/parameters/output_parameters/create").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit an output parameter.
                    """
                    return PyMenu(self.service, "/define/parameters/output_parameters/edit").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename an output parameter.
                    """
                    return PyMenu(self.service, "/define/parameters/output_parameters/rename").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete an output parameter.
                    """
                    return PyMenu(self.service, "/define/parameters/output_parameters/delete").execute(*args, **kwargs)
                def print_to_console(self, *args, **kwargs):
                    """
                    Print parameter value to console.
                    """
                    return PyMenu(self.service, "/define/parameters/output_parameters/print_to_console").execute(*args, **kwargs)
                def print_all_to_console(self, *args, **kwargs):
                    """
                    Print all parameter values to console.
                    """
                    return PyMenu(self.service, "/define/parameters/output_parameters/print_all_to_console").execute(*args, **kwargs)
                def write_to_file(self, *args, **kwargs):
                    """
                    Write parameter value to file.
                    """
                    return PyMenu(self.service, "/define/parameters/output_parameters/write_to_file").execute(*args, **kwargs)
                def write_all_to_file(self, *args, **kwargs):
                    """
                    Write all parameter values to file.
                    """
                    return PyMenu(self.service, "/define/parameters/output_parameters/write_all_to_file").execute(*args, **kwargs)

            class list_parameters(metaclass=PyMenuMeta):
                """
                Enter list-param menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def input_parameters(self, *args, **kwargs):
                    """
                    List all input parameters.
                    """
                    return PyMenu(self.service, "/define/parameters/list_parameters/input_parameters").execute(*args, **kwargs)
                def output_parameters(self, *args, **kwargs):
                    """
                    List all output parameters.
                    """
                    return PyMenu(self.service, "/define/parameters/list_parameters/output_parameters").execute(*args, **kwargs)

        class periodic_conditions(metaclass=PyMenuMeta):
            """
            Enter the periodic conditions menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def massflow_rate_specification(self, *args, **kwargs):
                """
                Enable/disable specification of mass flow rate at the periodic boundary.
                """
                return PyMenu(self.service, "/define/periodic_conditions/massflow_rate_specification").execute(*args, **kwargs)
            def pressure_gradient_specification(self, *args, **kwargs):
                """
                Enable/disable specification of pressure gradient at the periodic boundary.
                """
                return PyMenu(self.service, "/define/periodic_conditions/pressure_gradient_specification").execute(*args, **kwargs)

        class turbo_model(metaclass=PyMenuMeta):
            """
            Turbo features menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.turbo_topology = self.__class__.turbo_topology(path + [("turbo_topology", None)], service)
                self.general_turbo_interface_settings = self.__class__.general_turbo_interface_settings(path + [("general_turbo_interface_settings", None)], service)
                self.blade_flutter_harmonics = self.__class__.blade_flutter_harmonics(path + [("blade_flutter_harmonics", None)], service)
            def enable_turbo_model(self, *args, **kwargs):
                """
                Enable/disable turbo model menu.
                """
                return PyMenu(self.service, "/define/turbo_model/enable_turbo_model").execute(*args, **kwargs)
            def separate_nonoverlapping_interface_boundary(self, *args, **kwargs):
                """
                Split a general turbo interface non-overlapping zone.
                """
                return PyMenu(self.service, "/define/turbo_model/separate_nonoverlapping_interface_boundary").execute(*args, **kwargs)
            def turbo_create(self, *args, **kwargs):
                """
                Create a general turbo interface.
                """
                return PyMenu(self.service, "/define/turbo_model/turbo_create").execute(*args, **kwargs)
            def number_of_blades_in_row(self, *args, **kwargs):
                """
                Define the total number of blades in blade flutter row.
                """
                return PyMenu(self.service, "/define/turbo_model/number_of_blades_in_row").execute(*args, **kwargs)
            def create_turbomachine_description(self, *args, **kwargs):
                """
                Define turbomachine description.
                """
                return PyMenu(self.service, "/define/turbo_model/create_turbomachine_description").execute(*args, **kwargs)
            def create_phaselag_spectral_content(self, *args, **kwargs):
                """
                Define phaselag related spectral content.
                """
                return PyMenu(self.service, "/define/turbo_model/create_phaselag_spectral_content").execute(*args, **kwargs)
            def phaselag_extra_settings(self, *args, **kwargs):
                """
                Define phaselag related extra settings.
                """
                return PyMenu(self.service, "/define/turbo_model/phaselag_extra_settings").execute(*args, **kwargs)
            def create_graphics_spectral_content(self, *args, **kwargs):
                """
                Define post-processing related spectral content.
                """
                return PyMenu(self.service, "/define/turbo_model/create_graphics_spectral_content").execute(*args, **kwargs)
            def graphics_extra_settings(self, *args, **kwargs):
                """
                Define phaselag related extra settings.
                """
                return PyMenu(self.service, "/define/turbo_model/graphics_extra_settings").execute(*args, **kwargs)
            def delete_turbomachine_description(self, *args, **kwargs):
                """
                Delete turbomachine description.
                """
                return PyMenu(self.service, "/define/turbo_model/delete_turbomachine_description").execute(*args, **kwargs)
            def delete_phaselag_spectral_content(self, *args, **kwargs):
                """
                Delete phaselag related spectral content.
                """
                return PyMenu(self.service, "/define/turbo_model/delete_phaselag_spectral_content").execute(*args, **kwargs)
            def delete_graphics_spectral_content(self, *args, **kwargs):
                """
                Delete post-processing related spectral content.
                """
                return PyMenu(self.service, "/define/turbo_model/delete_graphics_spectral_content").execute(*args, **kwargs)
            def list_turbomachine_description(self, *args, **kwargs):
                """
                List turbomachine description.
                """
                return PyMenu(self.service, "/define/turbo_model/list_turbomachine_description").execute(*args, **kwargs)
            def list_graphics_spectral_content(self, *args, **kwargs):
                """
                List post-processing related spectral content.
                """
                return PyMenu(self.service, "/define/turbo_model/list_graphics_spectral_content").execute(*args, **kwargs)
            def list_phaselag_state(self, *args, **kwargs):
                """
                List all phaselag related case settings.
                """
                return PyMenu(self.service, "/define/turbo_model/list_phaselag_state").execute(*args, **kwargs)
            def make_phaselag_from_boundaries(self, *args, **kwargs):
                """
                Make interface zones phase lagged.
                """
                return PyMenu(self.service, "/define/turbo_model/make_phaselag_from_boundaries").execute(*args, **kwargs)
            def make_phaselag_from_periodic(self, *args, **kwargs):
                """
                Convert periodic interface to phase lagged.
                """
                return PyMenu(self.service, "/define/turbo_model/make_phaselag_from_periodic").execute(*args, **kwargs)

            class turbo_topology(metaclass=PyMenuMeta):
                """
                Define turbo topology.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def define_topology(self, *args, **kwargs):
                    """
                    Define a turbo topology.
                    """
                    return PyMenu(self.service, "/define/turbo_model/turbo_topology/define_topology").execute(*args, **kwargs)
                def mesh_method(self, *args, **kwargs):
                    """
                    Set turbo structured mesh generation method.
                    """
                    return PyMenu(self.service, "/define/turbo_model/turbo_topology/mesh_method").execute(*args, **kwargs)
                def search_method(self, *args, **kwargs):
                    """
                    Set search method for a topology.
                    """
                    return PyMenu(self.service, "/define/turbo_model/turbo_topology/search_method").execute(*args, **kwargs)
                def projection_method(self, *args, **kwargs):
                    """
                    Set 2D projection method.
                    """
                    return PyMenu(self.service, "/define/turbo_model/turbo_topology/projection_method").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete a turbo topology.
                    """
                    return PyMenu(self.service, "/define/turbo_model/turbo_topology/delete").execute(*args, **kwargs)

            class general_turbo_interface_settings(metaclass=PyMenuMeta):
                """
                Set General Turbo Interface options.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.mixing_plane_model_settings = self.__class__.mixing_plane_model_settings(path + [("mixing_plane_model_settings", None)], service)
                    self.pitch_scale_model_settings = self.__class__.pitch_scale_model_settings(path + [("pitch_scale_model_settings", None)], service)
                    self.no_pitch_scale_model_settings = self.__class__.no_pitch_scale_model_settings(path + [("no_pitch_scale_model_settings", None)], service)
                    self.expert = self.__class__.expert(path + [("expert", None)], service)

                class mixing_plane_model_settings(metaclass=PyMenuMeta):
                    """
                    Set the mixing plane model settings.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.number_of_bands = self.__class__.number_of_bands(path + [("number_of_bands", None)], service)
                    def averaging_method(self, *args, **kwargs):
                        """
                        Set the averaging method for the mixing.
                        """
                        return PyMenu(self.service, "/define/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/averaging_method").execute(*args, **kwargs)
                    def mixing_set_constraint(self, *args, **kwargs):
                        """
                        To set the mixing of primitive or total variable approach.
                        """
                        return PyMenu(self.service, "/define/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/mixing_set_constraint").execute(*args, **kwargs)
                    def bands_type(self, *args, **kwargs):
                        """
                        To set the mixing plane bands type.
                        """
                        return PyMenu(self.service, "/define/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/bands_type").execute(*args, **kwargs)
                    def number_of_inner_iterations(self, *args, **kwargs):
                        """
                        To set the number of iteration used for the scaling.
                        """
                        return PyMenu(self.service, "/define/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/number_of_inner_iterations").execute(*args, **kwargs)
                    def list_mixing_planes(self, *args, **kwargs):
                        """
                        List the settings of mixing planes in the case.
                        """
                        return PyMenu(self.service, "/define/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/list_mixing_planes").execute(*args, **kwargs)

                    class number_of_bands(metaclass=PyMenuMeta):
                        """
                        Set the maximum number of bands to be used for mixing.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def set_specific_interface(self, *args, **kwargs):
                            """
                            Set number of band to be used for mixing.
                            """
                            return PyMenu(self.service, "/define/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/number_of_bands/set_specific_interface").execute(*args, **kwargs)
                        def set_all_interfaces(self, *args, **kwargs):
                            """
                            Set number of band to be used for mixing.
                            """
                            return PyMenu(self.service, "/define/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/number_of_bands/set_all_interfaces").execute(*args, **kwargs)

                class pitch_scale_model_settings(metaclass=PyMenuMeta):
                    """
                    Set the pitch scale model settings.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def scale_mflux(self, *args, **kwargs):
                        """
                        Scale mass flux to improve the conservation.
                        """
                        return PyMenu(self.service, "/define/turbo_model/general_turbo_interface_settings/pitch_scale_model_settings/scale_mflux").execute(*args, **kwargs)

                class no_pitch_scale_model_settings(metaclass=PyMenuMeta):
                    """
                    Set the no pitch scale model settings.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def scale_mflux(self, *args, **kwargs):
                        """
                        Scale mass flux to improve the conservation.
                        """
                        return PyMenu(self.service, "/define/turbo_model/general_turbo_interface_settings/no_pitch_scale_model_settings/scale_mflux").execute(*args, **kwargs)

                class expert(metaclass=PyMenuMeta):
                    """
                    Set the expert parameters for turbo interfaces.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def enforce_flux_scaling(self, *args, **kwargs):
                        """
                        Enforce flux scaling ON/OFF at the turbo interfaces.
                        """
                        return PyMenu(self.service, "/define/turbo_model/general_turbo_interface_settings/expert/enforce_flux_scaling").execute(*args, **kwargs)
                    def list_settings(self, *args, **kwargs):
                        """
                        List the flux scale settings at the turbo interfaces.
                        """
                        return PyMenu(self.service, "/define/turbo_model/general_turbo_interface_settings/expert/list_settings").execute(*args, **kwargs)

            class blade_flutter_harmonics(metaclass=PyMenuMeta):
                """
                Enter the blade flutter harmonics menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def enable_harmonic_postprocessing(self, *args, **kwargs):
                    """
                    Calculates/Deletes Postprocessing Fourier coefficients data.
                    """
                    return PyMenu(self.service, "/define/turbo_model/blade_flutter_harmonics/enable_harmonic_postprocessing").execute(*args, **kwargs)
                def enable_harmonic_exports(self, *args, **kwargs):
                    """
                    Calculates/Deletes flutter harmonic export data.
                    """
                    return PyMenu(self.service, "/define/turbo_model/blade_flutter_harmonics/enable_harmonic_exports").execute(*args, **kwargs)
                def write_harmonic_exports(self, *args, **kwargs):
                    """
                    Writes harmonic export data.
                    """
                    return PyMenu(self.service, "/define/turbo_model/blade_flutter_harmonics/write_harmonic_exports").execute(*args, **kwargs)
                def write_aerodamping_vs_nodal_diameter(self, *args, **kwargs):
                    """
                    Reads report definition file and Writes influence coefficient aerodynamic damping values vs nodal diameter.
                    """
                    return PyMenu(self.service, "/define/turbo_model/blade_flutter_harmonics/write_aerodamping_vs_nodal_diameter").execute(*args, **kwargs)

        class phases(metaclass=PyMenuMeta):
            """
            Enter the phases menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.set_domain_properties = self.__class__.set_domain_properties(path + [("set_domain_properties", None)], service)
                self.iac_expert = self.__class__.iac_expert(path + [("iac_expert", None)], service)

            class set_domain_properties(metaclass=PyMenuMeta):
                """
                Enter the menu to set domain properties.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.interaction_domain = self.__class__.interaction_domain(path + [("interaction_domain", None)], service)
                def change_phases_names(self, *args, **kwargs):
                    """
                    Change names for all defined phases?.
                    """
                    return PyMenu(self.service, "/define/phases/set_domain_properties/change_phases_names").execute(*args, **kwargs)
                def phase_domains(self, *args, **kwargs):
                    """
                    Enter the menu to select a specific phase domain.
                    """
                    return PyMenu(self.service, "/define/phases/set_domain_properties/phase_domains").execute(*args, **kwargs)

                class interaction_domain(metaclass=PyMenuMeta):
                    """
                    Enter the menu to set the interaction domain properties.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.forces = self.__class__.forces(path + [("forces", None)], service)
                        self.heat_mass_reactions = self.__class__.heat_mass_reactions(path + [("heat_mass_reactions", None)], service)
                        self.interfacial_area = self.__class__.interfacial_area(path + [("interfacial_area", None)], service)
                        self.model_transition = self.__class__.model_transition(path + [("model_transition", None)], service)
                        self.numerics = self.__class__.numerics(path + [("numerics", None)], service)

                    class forces(metaclass=PyMenuMeta):
                        """
                        Enter the menu to set interfacial forces related models.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.cavitation = self.__class__.cavitation(path + [("cavitation", None)], service)
                            self.interphase_discretization = self.__class__.interphase_discretization(path + [("interphase_discretization", None)], service)
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(path + [("interphase_viscous_dissipation", None)], service)
                            self.lift = self.__class__.lift(path + [("lift", None)], service)
                            self.surface_tension = self.__class__.surface_tension(path + [("surface_tension", None)], service)
                            self.virtual_mass = self.__class__.virtual_mass(path + [("virtual_mass", None)], service)
                        def drag(self, *args, **kwargs):
                            """
                            Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/drag").execute(*args, **kwargs)
                        def heat_coeff(self, *args, **kwargs):
                            """
                            Specify the heat transfer coefficient function between each pair of phases.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/heat_coeff").execute(*args, **kwargs)
                        def interfacial_area(self, *args, **kwargs):
                            """
                            Set the interfacial area parameters for each pair of phases.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interfacial_area").execute(*args, **kwargs)
                        def mass_transfer(self, *args, **kwargs):
                            """
                            Specify the mass transfer mechanisms.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/mass_transfer").execute(*args, **kwargs)
                        def model_transition(self, *args, **kwargs):
                            """
                            Set the model transition mechanism.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/model_transition").execute(*args, **kwargs)
                        def reactions(self, *args, **kwargs):
                            """
                            Define multiple heterogeneous reactions and stoichiometry.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/reactions").execute(*args, **kwargs)
                        def restitution(self, *args, **kwargs):
                            """
                            Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/restitution").execute(*args, **kwargs)
                        def slip_velocity(self, *args, **kwargs):
                            """
                            Specify the slip velocity function for each secondary phase with respect to the primary phase.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/slip_velocity").execute(*args, **kwargs)
                        def turbulence_interaction(self, *args, **kwargs):
                            """
                            Specify the turbulence interaction model for each primary-secondary phase pair.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/turbulence_interaction").execute(*args, **kwargs)
                        def turbulent_dispersion(self, *args, **kwargs):
                            """
                            Specify the turbulent dispersion model for each primary-secondary phase pair.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/turbulent_dispersion").execute(*args, **kwargs)
                        def wall_lubrication(self, *args, **kwargs):
                            """
                            Specify the wall lubrication model for each primary-secondary phase pair.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/wall_lubrication").execute(*args, **kwargs)

                        class cavitation(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set cavitation models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/cavitation/wall_adhesion").execute(*args, **kwargs)

                        class interphase_discretization(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set interphase discretization models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/wall_adhesion").execute(*args, **kwargs)

                        class interphase_viscous_dissipation(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)

                        class lift(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set lift models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/lift/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/lift/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/lift/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/lift/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/lift/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/lift/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/lift/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/lift/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/lift/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/lift/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/lift/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/lift/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/lift/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/lift/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/lift/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/lift/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/lift/wall_adhesion").execute(*args, **kwargs)

                        class surface_tension(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set surface tension models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/surface_tension/wall_adhesion").execute(*args, **kwargs)

                        class virtual_mass(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set virtual mass models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/forces/virtual_mass/wall_adhesion").execute(*args, **kwargs)

                    class heat_mass_reactions(metaclass=PyMenuMeta):
                        """
                        Enter the menu to set heat, mass-transfer, or reaction related models.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.cavitation = self.__class__.cavitation(path + [("cavitation", None)], service)
                            self.interphase_discretization = self.__class__.interphase_discretization(path + [("interphase_discretization", None)], service)
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(path + [("interphase_viscous_dissipation", None)], service)
                            self.lift = self.__class__.lift(path + [("lift", None)], service)
                            self.surface_tension = self.__class__.surface_tension(path + [("surface_tension", None)], service)
                            self.virtual_mass = self.__class__.virtual_mass(path + [("virtual_mass", None)], service)
                        def drag(self, *args, **kwargs):
                            """
                            Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/drag").execute(*args, **kwargs)
                        def heat_coeff(self, *args, **kwargs):
                            """
                            Specify the heat transfer coefficient function between each pair of phases.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/heat_coeff").execute(*args, **kwargs)
                        def interfacial_area(self, *args, **kwargs):
                            """
                            Set the interfacial area parameters for each pair of phases.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interfacial_area").execute(*args, **kwargs)
                        def mass_transfer(self, *args, **kwargs):
                            """
                            Specify the mass transfer mechanisms.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/mass_transfer").execute(*args, **kwargs)
                        def model_transition(self, *args, **kwargs):
                            """
                            Set the model transition mechanism.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/model_transition").execute(*args, **kwargs)
                        def reactions(self, *args, **kwargs):
                            """
                            Define multiple heterogeneous reactions and stoichiometry.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/reactions").execute(*args, **kwargs)
                        def restitution(self, *args, **kwargs):
                            """
                            Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/restitution").execute(*args, **kwargs)
                        def slip_velocity(self, *args, **kwargs):
                            """
                            Specify the slip velocity function for each secondary phase with respect to the primary phase.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/slip_velocity").execute(*args, **kwargs)
                        def turbulence_interaction(self, *args, **kwargs):
                            """
                            Specify the turbulence interaction model for each primary-secondary phase pair.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/turbulence_interaction").execute(*args, **kwargs)
                        def turbulent_dispersion(self, *args, **kwargs):
                            """
                            Specify the turbulent dispersion model for each primary-secondary phase pair.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/turbulent_dispersion").execute(*args, **kwargs)
                        def wall_lubrication(self, *args, **kwargs):
                            """
                            Specify the wall lubrication model for each primary-secondary phase pair.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/wall_lubrication").execute(*args, **kwargs)

                        class cavitation(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set cavitation models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/wall_adhesion").execute(*args, **kwargs)

                        class interphase_discretization(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set interphase discretization models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/wall_adhesion").execute(*args, **kwargs)

                        class interphase_viscous_dissipation(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)

                        class lift(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set lift models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/wall_adhesion").execute(*args, **kwargs)

                        class surface_tension(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set surface tension models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/wall_adhesion").execute(*args, **kwargs)

                        class virtual_mass(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set virtual mass models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/wall_adhesion").execute(*args, **kwargs)

                    class interfacial_area(metaclass=PyMenuMeta):
                        """
                        Enter the menu to set interfacial area models.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.cavitation = self.__class__.cavitation(path + [("cavitation", None)], service)
                            self.interphase_discretization = self.__class__.interphase_discretization(path + [("interphase_discretization", None)], service)
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(path + [("interphase_viscous_dissipation", None)], service)
                            self.lift = self.__class__.lift(path + [("lift", None)], service)
                            self.surface_tension = self.__class__.surface_tension(path + [("surface_tension", None)], service)
                            self.virtual_mass = self.__class__.virtual_mass(path + [("virtual_mass", None)], service)
                        def drag(self, *args, **kwargs):
                            """
                            Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/drag").execute(*args, **kwargs)
                        def heat_coeff(self, *args, **kwargs):
                            """
                            Specify the heat transfer coefficient function between each pair of phases.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/heat_coeff").execute(*args, **kwargs)
                        def interfacial_area(self, *args, **kwargs):
                            """
                            Set the interfacial area parameters for each pair of phases.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interfacial_area").execute(*args, **kwargs)
                        def mass_transfer(self, *args, **kwargs):
                            """
                            Specify the mass transfer mechanisms.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/mass_transfer").execute(*args, **kwargs)
                        def model_transition(self, *args, **kwargs):
                            """
                            Set the model transition mechanism.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/model_transition").execute(*args, **kwargs)
                        def reactions(self, *args, **kwargs):
                            """
                            Define multiple heterogeneous reactions and stoichiometry.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/reactions").execute(*args, **kwargs)
                        def restitution(self, *args, **kwargs):
                            """
                            Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/restitution").execute(*args, **kwargs)
                        def slip_velocity(self, *args, **kwargs):
                            """
                            Specify the slip velocity function for each secondary phase with respect to the primary phase.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/slip_velocity").execute(*args, **kwargs)
                        def turbulence_interaction(self, *args, **kwargs):
                            """
                            Specify the turbulence interaction model for each primary-secondary phase pair.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/turbulence_interaction").execute(*args, **kwargs)
                        def turbulent_dispersion(self, *args, **kwargs):
                            """
                            Specify the turbulent dispersion model for each primary-secondary phase pair.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/turbulent_dispersion").execute(*args, **kwargs)
                        def wall_lubrication(self, *args, **kwargs):
                            """
                            Specify the wall lubrication model for each primary-secondary phase pair.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/wall_lubrication").execute(*args, **kwargs)

                        class cavitation(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set cavitation models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/wall_adhesion").execute(*args, **kwargs)

                        class interphase_discretization(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set interphase discretization models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/wall_adhesion").execute(*args, **kwargs)

                        class interphase_viscous_dissipation(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)

                        class lift(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set lift models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/lift/wall_adhesion").execute(*args, **kwargs)

                        class surface_tension(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set surface tension models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/wall_adhesion").execute(*args, **kwargs)

                        class virtual_mass(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set virtual mass models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/wall_adhesion").execute(*args, **kwargs)

                    class model_transition(metaclass=PyMenuMeta):
                        """
                        Enter the menu to set model transition mechanisms.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.cavitation = self.__class__.cavitation(path + [("cavitation", None)], service)
                            self.interphase_discretization = self.__class__.interphase_discretization(path + [("interphase_discretization", None)], service)
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(path + [("interphase_viscous_dissipation", None)], service)
                            self.lift = self.__class__.lift(path + [("lift", None)], service)
                            self.surface_tension = self.__class__.surface_tension(path + [("surface_tension", None)], service)
                            self.virtual_mass = self.__class__.virtual_mass(path + [("virtual_mass", None)], service)
                        def drag(self, *args, **kwargs):
                            """
                            Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/drag").execute(*args, **kwargs)
                        def heat_coeff(self, *args, **kwargs):
                            """
                            Specify the heat transfer coefficient function between each pair of phases.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/heat_coeff").execute(*args, **kwargs)
                        def interfacial_area(self, *args, **kwargs):
                            """
                            Set the interfacial area parameters for each pair of phases.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interfacial_area").execute(*args, **kwargs)
                        def mass_transfer(self, *args, **kwargs):
                            """
                            Specify the mass transfer mechanisms.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/mass_transfer").execute(*args, **kwargs)
                        def model_transition(self, *args, **kwargs):
                            """
                            Set the model transition mechanism.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/model_transition").execute(*args, **kwargs)
                        def reactions(self, *args, **kwargs):
                            """
                            Define multiple heterogeneous reactions and stoichiometry.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/reactions").execute(*args, **kwargs)
                        def restitution(self, *args, **kwargs):
                            """
                            Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/restitution").execute(*args, **kwargs)
                        def slip_velocity(self, *args, **kwargs):
                            """
                            Specify the slip velocity function for each secondary phase with respect to the primary phase.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/slip_velocity").execute(*args, **kwargs)
                        def turbulence_interaction(self, *args, **kwargs):
                            """
                            Specify the turbulence interaction model for each primary-secondary phase pair.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/turbulence_interaction").execute(*args, **kwargs)
                        def turbulent_dispersion(self, *args, **kwargs):
                            """
                            Specify the turbulent dispersion model for each primary-secondary phase pair.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/turbulent_dispersion").execute(*args, **kwargs)
                        def wall_lubrication(self, *args, **kwargs):
                            """
                            Specify the wall lubrication model for each primary-secondary phase pair.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/wall_lubrication").execute(*args, **kwargs)

                        class cavitation(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set cavitation models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/cavitation/wall_adhesion").execute(*args, **kwargs)

                        class interphase_discretization(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set interphase discretization models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/wall_adhesion").execute(*args, **kwargs)

                        class interphase_viscous_dissipation(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)

                        class lift(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set lift models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/lift/wall_adhesion").execute(*args, **kwargs)

                        class surface_tension(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set surface tension models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/wall_adhesion").execute(*args, **kwargs)

                        class virtual_mass(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set virtual mass models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/wall_adhesion").execute(*args, **kwargs)

                    class numerics(metaclass=PyMenuMeta):
                        """
                        Enter the menu to set numerics models.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.cavitation = self.__class__.cavitation(path + [("cavitation", None)], service)
                            self.interphase_discretization = self.__class__.interphase_discretization(path + [("interphase_discretization", None)], service)
                            self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(path + [("interphase_viscous_dissipation", None)], service)
                            self.lift = self.__class__.lift(path + [("lift", None)], service)
                            self.surface_tension = self.__class__.surface_tension(path + [("surface_tension", None)], service)
                            self.virtual_mass = self.__class__.virtual_mass(path + [("virtual_mass", None)], service)
                        def drag(self, *args, **kwargs):
                            """
                            Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/drag").execute(*args, **kwargs)
                        def heat_coeff(self, *args, **kwargs):
                            """
                            Specify the heat transfer coefficient function between each pair of phases.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/heat_coeff").execute(*args, **kwargs)
                        def interfacial_area(self, *args, **kwargs):
                            """
                            Set the interfacial area parameters for each pair of phases.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interfacial_area").execute(*args, **kwargs)
                        def mass_transfer(self, *args, **kwargs):
                            """
                            Specify the mass transfer mechanisms.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/mass_transfer").execute(*args, **kwargs)
                        def model_transition(self, *args, **kwargs):
                            """
                            Set the model transition mechanism.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/model_transition").execute(*args, **kwargs)
                        def reactions(self, *args, **kwargs):
                            """
                            Define multiple heterogeneous reactions and stoichiometry.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/reactions").execute(*args, **kwargs)
                        def restitution(self, *args, **kwargs):
                            """
                            Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/restitution").execute(*args, **kwargs)
                        def slip_velocity(self, *args, **kwargs):
                            """
                            Specify the slip velocity function for each secondary phase with respect to the primary phase.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/slip_velocity").execute(*args, **kwargs)
                        def turbulence_interaction(self, *args, **kwargs):
                            """
                            Specify the turbulence interaction model for each primary-secondary phase pair.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/turbulence_interaction").execute(*args, **kwargs)
                        def turbulent_dispersion(self, *args, **kwargs):
                            """
                            Specify the turbulent dispersion model for each primary-secondary phase pair.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/turbulent_dispersion").execute(*args, **kwargs)
                        def wall_lubrication(self, *args, **kwargs):
                            """
                            Specify the wall lubrication model for each primary-secondary phase pair.
                            """
                            return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/wall_lubrication").execute(*args, **kwargs)

                        class cavitation(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set cavitation models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/cavitation/wall_adhesion").execute(*args, **kwargs)

                        class interphase_discretization(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set interphase discretization models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/wall_adhesion").execute(*args, **kwargs)

                        class interphase_viscous_dissipation(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set interphase viscous dissipation related models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)

                        class lift(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set lift models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/lift/wall_adhesion").execute(*args, **kwargs)

                        class surface_tension(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set surface tension models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/surface_tension/wall_adhesion").execute(*args, **kwargs)

                        class virtual_mass(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set virtual mass models.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def cavitation(self, *args, **kwargs):
                                """
                                Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/cavitation").execute(*args, **kwargs)
                            def interphase_discr(self, *args, **kwargs):
                                """
                                Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/interphase_discr").execute(*args, **kwargs)
                            def interphase_visc_disp(self, *args, **kwargs):
                                """
                                Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                            def jump_adhesion(self, *args, **kwargs):
                                """
                                Enable the treatment of the contact angle specification at the porous jump boundary?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                            def lift(self, *args, **kwargs):
                                """
                                .
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/lift").execute(*args, **kwargs)
                            def lift_montoya(self, *args, **kwargs):
                                """
                                Include the Montoya correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/lift_montoya").execute(*args, **kwargs)
                            def lift_shaver_podowski(self, *args, **kwargs):
                                """
                                Include the Shaver-Podowski correction for Lift.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                            def sfc_model_type(self, *args, **kwargs):
                                """
                                Select the surface tension model.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                            def sfc_modeling(self, *args, **kwargs):
                                """
                                Include the effects of surface tension along the fluid-fluid interface?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                            def sfc_tension_coeff(self, *args, **kwargs):
                                """
                                Specify the surface tension coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                            def slope_limiter(self, *args, **kwargs):
                                """
                                Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/slope_limiter").execute(*args, **kwargs)
                            def virtual_mass(self, *args, **kwargs):
                                """
                                Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/virtual_mass").execute(*args, **kwargs)
                            def visc_disp_factor(self, *args, **kwargs):
                                """
                                Set the dissipation intensity.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                            def vmass_coeff(self, *args, **kwargs):
                                """
                                Specify the virtual mass coefficient for each pair of phases.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                            def vmass_implicit_options(self, *args, **kwargs):
                                """
                                Select the virtual mass implicit option.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                            def vmass_implicit(self, *args, **kwargs):
                                """
                                Enable the implicit method for the virtual mass force?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                            def wall_adhesion(self, *args, **kwargs):
                                """
                                Enable the specification for a wall adhesion angle?.
                                """
                                return PyMenu(self.service, "/define/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/wall_adhesion").execute(*args, **kwargs)

            class iac_expert(metaclass=PyMenuMeta):
                """
                Enter the IAC expert setting menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def ishii_kim_model(self, *args, **kwargs):
                    """
                    Set ik model coefficients.
                    """
                    return PyMenu(self.service, "/define/phases/iac_expert/ishii_kim_model").execute(*args, **kwargs)
                def hibiki_ishii_model(self, *args, **kwargs):
                    """
                    Set hi model coefficients.
                    """
                    return PyMenu(self.service, "/define/phases/iac_expert/hibiki_ishii_model").execute(*args, **kwargs)
                def yao_morel_model(self, *args, **kwargs):
                    """
                    Set ym model coefficients.
                    """
                    return PyMenu(self.service, "/define/phases/iac_expert/yao_morel_model").execute(*args, **kwargs)
                def iac_pseudo_time_step(self, *args, **kwargs):
                    """
                    Set iac pseudo-time.
                    """
                    return PyMenu(self.service, "/define/phases/iac_expert/iac_pseudo_time_step").execute(*args, **kwargs)

        class profiles(metaclass=PyMenuMeta):
            """
            Enter the boundary profiles menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def display_profile_surface(self, *args, **kwargs):
                """
                Display a profile.
                """
                return PyMenu(self.service, "/define/profiles/display_profile_surface").execute(*args, **kwargs)
            def display_profile_point_cloud_data(self, *args, **kwargs):
                """
                Display Profile Point Cloud Data.
                """
                return PyMenu(self.service, "/define/profiles/display_profile_point_cloud_data").execute(*args, **kwargs)
            def overlay_profile_surface(self, *args, **kwargs):
                """
                Overlay Profile Surface.
                """
                return PyMenu(self.service, "/define/profiles/overlay_profile_surface").execute(*args, **kwargs)
            def overlay_profile_point_cloud_data(self, *args, **kwargs):
                """
                Overlay Profile Point Cloud Data.
                """
                return PyMenu(self.service, "/define/profiles/overlay_profile_point_cloud_data").execute(*args, **kwargs)
            def set_preference_profile_point_cloud_data(self, *args, **kwargs):
                """
                Set Preference Profile Point Cloud Data e.g., Point marker symbol,size,color.
                """
                return PyMenu(self.service, "/define/profiles/set_preference_profile_point_cloud_data").execute(*args, **kwargs)
            def list_profile_parameters(self, *args, **kwargs):
                """
                List the parameters of a particular profile.
                """
                return PyMenu(self.service, "/define/profiles/list_profile_parameters").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete a profile.
                """
                return PyMenu(self.service, "/define/profiles/delete").execute(*args, **kwargs)
            def delete_all(self, *args, **kwargs):
                """
                Delete all boundary-profiles.
                """
                return PyMenu(self.service, "/define/profiles/delete_all").execute(*args, **kwargs)
            def list_profiles(self, *args, **kwargs):
                """
                List all profiles.
                """
                return PyMenu(self.service, "/define/profiles/list_profiles").execute(*args, **kwargs)
            def list_profile_fields(self, *args, **kwargs):
                """
                List the fields of a particular profile.
                """
                return PyMenu(self.service, "/define/profiles/list_profile_fields").execute(*args, **kwargs)
            def interpolation_method(self, *args, **kwargs):
                """
                Choose the method for interpolation of profiles.
                """
                return PyMenu(self.service, "/define/profiles/interpolation_method").execute(*args, **kwargs)
            def morphing(self, *args, **kwargs):
                """
                Enable/disable profile morphing options in Orient Profile panel.
                """
                return PyMenu(self.service, "/define/profiles/morphing").execute(*args, **kwargs)
            def update_interval(self, *args, **kwargs):
                """
                Set interval between updates of dynamic profiles.
                """
                return PyMenu(self.service, "/define/profiles/update_interval").execute(*args, **kwargs)
            def link_profile_to_reference_frame(self, *args, **kwargs):
                """
                Link profile to a reference frame.
                """
                return PyMenu(self.service, "/define/profiles/link_profile_to_reference_frame").execute(*args, **kwargs)
            def replicate_profile(self, *args, **kwargs):
                """
                Replicate Profile.
                """
                return PyMenu(self.service, "/define/profiles/replicate_profile").execute(*args, **kwargs)
            def orient_profile(self, *args, **kwargs):
                """
                Orient Profile.
                """
                return PyMenu(self.service, "/define/profiles/orient_profile").execute(*args, **kwargs)

        class solution_strategy(metaclass=PyMenuMeta):
            """
            Enter the automatic initialization and case modification strategy menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.automatic_case_modification = self.__class__.automatic_case_modification(path + [("automatic_case_modification", None)], service)
            def enable_strategy(self, *args, **kwargs):
                """
                Specify whether automatic initialization and case modification should be enabled.
                """
                return PyMenu(self.service, "/define/solution_strategy/enable_strategy").execute(*args, **kwargs)
            def execute_strategy(self, *args, **kwargs):
                """
                Execute the automatic initialization and case modification strategy defined at present.
                """
                return PyMenu(self.service, "/define/solution_strategy/execute_strategy").execute(*args, **kwargs)
            def add_edit_modification(self, *args, **kwargs):
                """
                Define a single case modification.
                """
                return PyMenu(self.service, "/define/solution_strategy/add_edit_modification").execute(*args, **kwargs)
            def copy_modification(self, *args, **kwargs):
                """
                Copy a single case modification.
                """
                return PyMenu(self.service, "/define/solution_strategy/copy_modification").execute(*args, **kwargs)
            def delete_modification(self, *args, **kwargs):
                """
                Delete a single case modification.
                """
                return PyMenu(self.service, "/define/solution_strategy/delete_modification").execute(*args, **kwargs)
            def enable_modification(self, *args, **kwargs):
                """
                Enable a single defined case modification.
                """
                return PyMenu(self.service, "/define/solution_strategy/enable_modification").execute(*args, **kwargs)
            def disable_modification(self, *args, **kwargs):
                """
                Disable a single defined case modification.
                """
                return PyMenu(self.service, "/define/solution_strategy/disable_modification").execute(*args, **kwargs)
            def import_modifications(self, *args, **kwargs):
                """
                Import a list of case modifications from a tsv file.
                """
                return PyMenu(self.service, "/define/solution_strategy/import_modifications").execute(*args, **kwargs)
            def export_modifications(self, *args, **kwargs):
                """
                Export all case modifications to a tsv file.
                """
                return PyMenu(self.service, "/define/solution_strategy/export_modifications").execute(*args, **kwargs)
            def continue_strategy_execution(self, *args, **kwargs):
                """
                Continue execution of the automatic initialization and case modification strategy defined at present.
                """
                return PyMenu(self.service, "/define/solution_strategy/continue_strategy_execution").execute(*args, **kwargs)
            def automatic_initialization(self, *args, **kwargs):
                """
                Define how the case is to be initialized automatically.
                """
                return PyMenu(self.service, "/define/solution_strategy/automatic_initialization").execute(*args, **kwargs)

            class automatic_case_modification(metaclass=PyMenuMeta):
                """
                Define how the case is to be modified as the solution progresses.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def before_init_modification(self, *args, **kwargs):
                    """
                    Specify modification to be performed before initialization.
                    """
                    return PyMenu(self.service, "/define/solution_strategy/automatic_case_modification/before_init_modification").execute(*args, **kwargs)
                def original_settings(self, *args, **kwargs):
                    """
                    Specify modification to be performed after initialization to restore to original settings.
                    """
                    return PyMenu(self.service, "/define/solution_strategy/automatic_case_modification/original_settings").execute(*args, **kwargs)
                def modifications(self, *args, **kwargs):
                    """
                    Specify modifications to be performed during solution.
                    """
                    return PyMenu(self.service, "/define/solution_strategy/automatic_case_modification/modifications").execute(*args, **kwargs)

        class reference_frames(metaclass=PyMenuMeta):
            """
            Manage reference frames.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def add(self, *args, **kwargs):
                """
                Add a new object.
                """
                return PyMenu(self.service, "/define/reference_frames/add").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                Display Reference Frame.
                """
                return PyMenu(self.service, "/define/reference_frames/display").execute(*args, **kwargs)
            def display_edit(self, *args, **kwargs):
                """
                Display and edit reference frame from graphics.
                """
                return PyMenu(self.service, "/define/reference_frames/display_edit").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an object.
                """
                return PyMenu(self.service, "/define/reference_frames/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an object.
                """
                return PyMenu(self.service, "/define/reference_frames/delete").execute(*args, **kwargs)
            def hide(self, *args, **kwargs):
                """
                Hide Reference Frame.
                """
                return PyMenu(self.service, "/define/reference_frames/hide").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List objects.
                """
                return PyMenu(self.service, "/define/reference_frames/list").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                List properties of an object.
                """
                return PyMenu(self.service, "/define/reference_frames/list_properties").execute(*args, **kwargs)

        class user_defined(metaclass=PyMenuMeta):
            """
            Enter the user-defined functions and scalars menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.real_gas_models = self.__class__.real_gas_models(path + [("real_gas_models", None)], service)
            def auto_compile_compiled_udfs(self, *args, **kwargs):
                """
                For this Fluent session, specify whether to allow auto-compilation of compiled UDF when a case file (or settings file) is read.
                """
                return PyMenu(self.service, "/define/user_defined/auto_compile_compiled_udfs").execute(*args, **kwargs)
            def compiled_functions(self, *args, **kwargs):
                """
                Open user-defined function library.
                """
                return PyMenu(self.service, "/define/user_defined/compiled_functions").execute(*args, **kwargs)
            def use_built_in_compiler(self, *args, **kwargs):
                """
                Enable/disable the use of the built-in compiler.
                """
                return PyMenu(self.service, "/define/user_defined/use_built_in_compiler").execute(*args, **kwargs)
            def interpreted_functions(self, *args, **kwargs):
                """
                Load interpreted user-defined functions.
                """
                return PyMenu(self.service, "/define/user_defined/interpreted_functions").execute(*args, **kwargs)
            def function_hooks(self, *args, **kwargs):
                """
                Hook up user-defined functions.
                """
                return PyMenu(self.service, "/define/user_defined/function_hooks").execute(*args, **kwargs)
            def execute_on_demand(self, *args, **kwargs):
                """
                Execute UDFs on demand.
                """
                return PyMenu(self.service, "/define/user_defined/execute_on_demand").execute(*args, **kwargs)
            def user_defined_memory(self, *args, **kwargs):
                """
                Allocate user-defined memory.
                """
                return PyMenu(self.service, "/define/user_defined/user_defined_memory").execute(*args, **kwargs)
            def user_defined_node_memory(self, *args, **kwargs):
                """
                Allocate user-defined node memory.
                """
                return PyMenu(self.service, "/define/user_defined/user_defined_node_memory").execute(*args, **kwargs)
            def use_contributed_cpp(self, *args, **kwargs):
                """
                Enable/disable use of cpp from the Fluent.Inc/contrib directory.
                """
                return PyMenu(self.service, "/define/user_defined/use_contributed_cpp").execute(*args, **kwargs)
            def fan_model(self, *args, **kwargs):
                """
                Configure user-defined fan model.
                """
                return PyMenu(self.service, "/define/user_defined/fan_model").execute(*args, **kwargs)
            def one_D_coupling(self, *args, **kwargs):
                """
                Load 1D library.
                """
                return PyMenu(self.service, "/define/user_defined/one_D_coupling").execute(*args, **kwargs)
            def user_defined_scalars(self, *args, **kwargs):
                """
                Define user-defined scalars.
                """
                return PyMenu(self.service, "/define/user_defined/user_defined_scalars").execute(*args, **kwargs)
            def enable_udf_on_gpu(self, *args, **kwargs):
                """
                Compile UDFs with OpenCL support.
                """
                return PyMenu(self.service, "/define/user_defined/enable_udf_on_gpu").execute(*args, **kwargs)
            def compile_customized_addon_module(self, *args, **kwargs):
                """
                Compile customized addon module?.
                """
                return PyMenu(self.service, "/define/user_defined/compile_customized_addon_module").execute(*args, **kwargs)

            class real_gas_models(metaclass=PyMenuMeta):
                """
                Enable/configure real gas model.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def nist_real_gas_model(self, *args, **kwargs):
                    """
                    Load NIST real gas library.
                    """
                    return PyMenu(self.service, "/define/user_defined/real_gas_models/nist_real_gas_model").execute(*args, **kwargs)
                def nist_multispecies_real_gas_model(self, *args, **kwargs):
                    """
                    Load NIST real gas library.
                    """
                    return PyMenu(self.service, "/define/user_defined/real_gas_models/nist_multispecies_real_gas_model").execute(*args, **kwargs)
                def set_state(self, *args, **kwargs):
                    """
                    Select state for NIST real gas model.
                    """
                    return PyMenu(self.service, "/define/user_defined/real_gas_models/set_state").execute(*args, **kwargs)
                def nist_settings(self, *args, **kwargs):
                    """
                    Select refprop library.
                    """
                    return PyMenu(self.service, "/define/user_defined/real_gas_models/nist_settings").execute(*args, **kwargs)
                def user_defined_real_gas_model(self, *args, **kwargs):
                    """
                    Load user-defined real gas library.
                    """
                    return PyMenu(self.service, "/define/user_defined/real_gas_models/user_defined_real_gas_model").execute(*args, **kwargs)
                def user_defined_multispecies_real_gas_model(self, *args, **kwargs):
                    """
                    Load user-defined multispecies real gas library.
                    """
                    return PyMenu(self.service, "/define/user_defined/real_gas_models/user_defined_multispecies_real_gas_model").execute(*args, **kwargs)

        class named_expressions(metaclass=PyMenuMeta):
            """
            Manage named expressions.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def add(self, *args, **kwargs):
                """
                Add a new object.
                """
                return PyMenu(self.service, "/define/named_expressions/add").execute(*args, **kwargs)
            def compute(self, *args, **kwargs):
                """
                Compute expression.
                """
                return PyMenu(self.service, "/define/named_expressions/compute").execute(*args, **kwargs)
            def copy(self, *args, **kwargs):
                """
                Copy expression.
                """
                return PyMenu(self.service, "/define/named_expressions/copy").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an object.
                """
                return PyMenu(self.service, "/define/named_expressions/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an object.
                """
                return PyMenu(self.service, "/define/named_expressions/delete").execute(*args, **kwargs)
            def export_to_tsv(self, *args, **kwargs):
                """
                Export expressions.
                """
                return PyMenu(self.service, "/define/named_expressions/export_to_tsv").execute(*args, **kwargs)
            def import_from_tsv(self, *args, **kwargs):
                """
                Export expressions.
                """
                return PyMenu(self.service, "/define/named_expressions/import_from_tsv").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List objects.
                """
                return PyMenu(self.service, "/define/named_expressions/list").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                List properties of an object.
                """
                return PyMenu(self.service, "/define/named_expressions/list_properties").execute(*args, **kwargs)

        class virtual_boundary(metaclass=PyMenuMeta):
            """
            Manage Virtual Boundaries.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def boundary_interface(self, *args, **kwargs):
                """
                Create a Boundary Interface.
                """
                return PyMenu(self.service, "/define/virtual_boundary/boundary_interface").execute(*args, **kwargs)
            def hole_geometry(self, *args, **kwargs):
                """
                Create a Hole Geometry template.
                """
                return PyMenu(self.service, "/define/virtual_boundary/hole_geometry").execute(*args, **kwargs)

        class curvilinear_coordinate_system(metaclass=PyMenuMeta):
            """
            Curvilinear Coordinate System.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def calculation_settings(self, *args, **kwargs):
                """
                Define Settings for curvilinear coordinate system.
                """
                return PyMenu(self.service, "/define/curvilinear_coordinate_system/calculation_settings").execute(*args, **kwargs)
            def new(self, *args, **kwargs):
                """
                Define a new curvilinear coordinate system.
                """
                return PyMenu(self.service, "/define/curvilinear_coordinate_system/new").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an existing curvilinear coordinate system.
                """
                return PyMenu(self.service, "/define/curvilinear_coordinate_system/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete Curvilinear Coordinate System.
                """
                return PyMenu(self.service, "/define/curvilinear_coordinate_system/delete").execute(*args, **kwargs)
            def display_settings(self, *args, **kwargs):
                """
                Display settings for Curvilinear Coordinate System.
                """
                return PyMenu(self.service, "/define/curvilinear_coordinate_system/display_settings").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                Display Curvilinear Coordinate System.
                """
                return PyMenu(self.service, "/define/curvilinear_coordinate_system/display").execute(*args, **kwargs)

    class file(metaclass=PyMenuMeta):
        """
        Enter the file menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
            self.auto_save = self.__class__.auto_save(path + [("auto_save", None)], service)
            self.cffio_options = self.__class__.cffio_options(path + [("cffio_options", None)], service)
            self.export = self.__class__.export(path + [("export", None)], service)
            self.transient_export = self.__class__.transient_export(path + [("transient_export", None)], service)
            self.em_mapping = self.__class__.em_mapping(path + [("em_mapping", None)], service)
            self.import_ = self.__class__.import_(path + [("import", None)], service)
            self.interpolate = self.__class__.interpolate(path + [("interpolate", None)], service)
            self.fsi = self.__class__.fsi(path + [("fsi", None)], service)
            self.parametric_project = self.__class__.parametric_project(path + [("parametric_project", None)], service)
            self.project_beta = self.__class__.project_beta(path + [("project[beta]", None)], service)
            self.table_manager = self.__class__.table_manager(path + [("table_manager", None)], service)
            self.solution_files = self.__class__.solution_files(path + [("solution_files", None)], service)
        def single_precision_coordinates(self, *args, **kwargs):
            """
            Indicate whether to write nodal coordinates in single precision.
            """
            return PyMenu(self.service, "/file/single_precision_coordinates").execute(*args, **kwargs)
        def binary_legacy_files(self, *args, **kwargs):
            """
            Indicate whether to write binary or text format case and data files.
            """
            return PyMenu(self.service, "/file/binary_legacy_files").execute(*args, **kwargs)
        def cff_files(self, *args, **kwargs):
            """
            Indicate whether to write ANSYS common fluids format (CFF) files or legacy case and data files.
            """
            return PyMenu(self.service, "/file/cff_files").execute(*args, **kwargs)
        def async_optimize(self, *args, **kwargs):
            """
            Choose whether to optimize file IO using scratch disks and asynchronous operations.
            """
            return PyMenu(self.service, "/file/async_optimize").execute(*args, **kwargs)
        def write_pdat(self, *args, **kwargs):
            """
            Indicate whether to attempt to save pdat files.
            """
            return PyMenu(self.service, "/file/write_pdat").execute(*args, **kwargs)
        def confirm_overwrite(self, *args, **kwargs):
            """
            Indicate whether or not to confirm attempts to overwrite existing files.
            """
            return PyMenu(self.service, "/file/confirm_overwrite").execute(*args, **kwargs)
        def define_macro(self, *args, **kwargs):
            """
            Save input to a named macro.
            """
            return PyMenu(self.service, "/file/define_macro").execute(*args, **kwargs)
        def export_to_cfd_post(self, *args, **kwargs):
            """
            Export to CFD-Post compabitble data file.
            """
            return PyMenu(self.service, "/file/export_to_cfd_post").execute(*args, **kwargs)
        def execute_macro(self, *args, **kwargs):
            """
            Run a previously defined macro.
            """
            return PyMenu(self.service, "/file/execute_macro").execute(*args, **kwargs)
        def read_settings(self, *args, **kwargs):
            """
            Read and set boundary conditions from specified file.
            """
            return PyMenu(self.service, "/file/read_settings").execute(*args, **kwargs)
        def read_case(self, *args, **kwargs):
            """
            Read a case file.
            
            Parameters
            ----------
            case_file_name : str
            """
            return PyMenu(self.service, "/file/read_case").execute(*args, **kwargs)
        def read_case_light(self, *args, **kwargs):
            """
            Read a case file while skipping mesh elements.
            """
            return PyMenu(self.service, "/file/read_case_light").execute(*args, **kwargs)
        def read_case_data(self, *args, **kwargs):
            """
            Read a case and a data file.
            """
            return PyMenu(self.service, "/file/read_case_data").execute(*args, **kwargs)
        def read_data(self, *args, **kwargs):
            """
            Read a data file.
            """
            return PyMenu(self.service, "/file/read_data").execute(*args, **kwargs)
        def read_case_info(self, *args, **kwargs):
            """
            Read basic case info.
            """
            return PyMenu(self.service, "/file/read_case_info").execute(*args, **kwargs)
        def read_field_functions(self, *args, **kwargs):
            """
            Read custom field-function definitions from a file.
            """
            return PyMenu(self.service, "/file/read_field_functions").execute(*args, **kwargs)
        def read_injections(self, *args, **kwargs):
            """
            Read all DPM injections from a file.
            """
            return PyMenu(self.service, "/file/read_injections").execute(*args, **kwargs)
        def read_journal(self, *args, **kwargs):
            """
            Read a journal file.
            """
            return PyMenu(self.service, "/file/read_journal").execute(*args, **kwargs)
        def read_macros(self, *args, **kwargs):
            """
            Read macro definitions from a file.
            """
            return PyMenu(self.service, "/file/read_macros").execute(*args, **kwargs)
        def read_profile(self, *args, **kwargs):
            """
            Read boundary profile data (\*.prof, \*.csv). Default is \*.prof.
            """
            return PyMenu(self.service, "/file/read_profile").execute(*args, **kwargs)
        def read_transient_table(self, *args, **kwargs):
            """
            Read a table of transient boundary profile data.
            """
            return PyMenu(self.service, "/file/read_transient_table").execute(*args, **kwargs)
        def read_pdf(self, *args, **kwargs):
            """
            Read a PDF file.
            """
            return PyMenu(self.service, "/file/read_pdf").execute(*args, **kwargs)
        def read_rays(self, *args, **kwargs):
            """
            Read a DTRM rays file.
            """
            return PyMenu(self.service, "/file/read_rays").execute(*args, **kwargs)
        def read_surface_clusters(self, *args, **kwargs):
            """
            Read an S2S file.
            """
            return PyMenu(self.service, "/file/read_surface_clusters").execute(*args, **kwargs)
        def read_viewfactors(self, *args, **kwargs):
            """
            Read an S2S file.
            """
            return PyMenu(self.service, "/file/read_viewfactors").execute(*args, **kwargs)
        def read_isat_table(self, *args, **kwargs):
            """
            Read an ISAT table.
            """
            return PyMenu(self.service, "/file/read_isat_table").execute(*args, **kwargs)
        def replace_mesh(self, *args, **kwargs):
            """
            Replace the mesh with a new one while preserving settings.
            """
            return PyMenu(self.service, "/file/replace_mesh").execute(*args, **kwargs)
        def reload_setup(self, *args, **kwargs):
            """
            Reload case and settings from last saved state.
            """
            return PyMenu(self.service, "/file/reload_setup").execute(*args, **kwargs)
        def close_without_save(self, *args, **kwargs):
            """
            Exit without save.
            """
            return PyMenu(self.service, "/file/close_without_save").execute(*args, **kwargs)
        def sync_workbench(self, *args, **kwargs):
            """
            Sync Fluent changes with WorkBench.
            """
            return PyMenu(self.service, "/file/sync_workbench").execute(*args, **kwargs)
        def set_batch_options(self, *args, **kwargs):
            """
            Set the batch options.
            """
            return PyMenu(self.service, "/file/set_batch_options").execute(*args, **kwargs)
        def set_idle_timeout(self, *args, **kwargs):
            """
            Set the idle timeout.
            """
            return PyMenu(self.service, "/file/set_idle_timeout").execute(*args, **kwargs)
        def show_configuration(self, *args, **kwargs):
            """
            Display current release and version information.
            """
            return PyMenu(self.service, "/file/show_configuration").execute(*args, **kwargs)
        def start_journal(self, *args, **kwargs):
            """
            Start recording all input in a file.
            """
            return PyMenu(self.service, "/file/start_journal").execute(*args, **kwargs)
        def stop_journal(self, *args, **kwargs):
            """
            Stop recording input and close the journal file.
            """
            return PyMenu(self.service, "/file/stop_journal").execute(*args, **kwargs)
        def stop_macro(self, *args, **kwargs):
            """
            Stop recording input to a macro.
            """
            return PyMenu(self.service, "/file/stop_macro").execute(*args, **kwargs)
        def start_transcript(self, *args, **kwargs):
            """
            Start recording input and output in a file.
            """
            return PyMenu(self.service, "/file/start_transcript").execute(*args, **kwargs)
        def stop_transcript(self, *args, **kwargs):
            """
            Stop recording input and output and close the transcript file.
            """
            return PyMenu(self.service, "/file/stop_transcript").execute(*args, **kwargs)
        def write_settings(self, *args, **kwargs):
            """
            Write out current boundary conditions in use.
            """
            return PyMenu(self.service, "/file/write_settings").execute(*args, **kwargs)
        def write_boundary_mesh(self, *args, **kwargs):
            """
            Write the boundary mesh to a file.
            """
            return PyMenu(self.service, "/file/write_boundary_mesh").execute(*args, **kwargs)
        def write_case(self, *args, **kwargs):
            """
            Write a case file.
            """
            return PyMenu(self.service, "/file/write_case").execute(*args, **kwargs)
        def write_case_light(self, *args, **kwargs):
            """
            Save the case file in light-weight mode,i.e. mesh not touched.
            """
            return PyMenu(self.service, "/file/write_case_light").execute(*args, **kwargs)
        def data_file_options(self, *args, **kwargs):
            """
            Set derived quantities to be written in data file.
            """
            return PyMenu(self.service, "/file/data_file_options").execute(*args, **kwargs)
        def write_case_data(self, *args, **kwargs):
            """
            Write a case and a data file.
            """
            return PyMenu(self.service, "/file/write_case_data").execute(*args, **kwargs)
        def write_data(self, *args, **kwargs):
            """
            Write a data file.
            """
            return PyMenu(self.service, "/file/write_data").execute(*args, **kwargs)
        def write_fan_profile(self, *args, **kwargs):
            """
            Compute radial profiles for a fan zone and write them to a profile file.
            """
            return PyMenu(self.service, "/file/write_fan_profile").execute(*args, **kwargs)
        def write_field_functions(self, *args, **kwargs):
            """
            Write the currently defined custom field functions to a file.
            """
            return PyMenu(self.service, "/file/write_field_functions").execute(*args, **kwargs)
        def write_profile(self, *args, **kwargs):
            """
            Write surface data as a boundary profile file. To use \*.csv format specify filename with .csv suffix.
            """
            return PyMenu(self.service, "/file/write_profile").execute(*args, **kwargs)
        def write_currently_defined_profiles(self, *args, **kwargs):
            """
            Write currently defined profiles. To use \*.csv format specify filename with .csv suffix.
            """
            return PyMenu(self.service, "/file/write_currently_defined_profiles").execute(*args, **kwargs)
        def set_target_reference_frame_for_write_profiles(self, *args, **kwargs):
            """
            Set reference frame options, which will be used for position transformation during writing of profiles.
            """
            return PyMenu(self.service, "/file/set_target_reference_frame_for_write_profiles").execute(*args, **kwargs)
        def write_circumferential_averaged_profile(self, *args, **kwargs):
            """
            Write surface data as a boundary profile file. To use \*.csv format specify filename with .csv suffix.
            """
            return PyMenu(self.service, "/file/write_circumferential_averaged_profile").execute(*args, **kwargs)
        def write_merge_profiles(self, *args, **kwargs):
            """
            Write multiple zones surface data as a single boundary profile file. To use \*.csv format specify filename with .csv suffix.
            """
            return PyMenu(self.service, "/file/write_merge_profiles").execute(*args, **kwargs)
        def write_pdf(self, *args, **kwargs):
            """
            Write a pdf file.
            """
            return PyMenu(self.service, "/file/write_pdf").execute(*args, **kwargs)
        def write_flamelet(self, *args, **kwargs):
            """
            Write a flamelet file.
            """
            return PyMenu(self.service, "/file/write_flamelet").execute(*args, **kwargs)
        def write_injections(self, *args, **kwargs):
            """
            Write out selected DPM injections to a file.
            """
            return PyMenu(self.service, "/file/write_injections").execute(*args, **kwargs)
        def write_macros(self, *args, **kwargs):
            """
            Write the currently defined macros to a file.
            """
            return PyMenu(self.service, "/file/write_macros").execute(*args, **kwargs)
        def write_isat_table(self, *args, **kwargs):
            """
            Write an ISAT table.
            """
            return PyMenu(self.service, "/file/write_isat_table").execute(*args, **kwargs)
        def write_cleanup_script(self, *args, **kwargs):
            """
            Write the cleanup-script-file for Fluent.
            """
            return PyMenu(self.service, "/file/write_cleanup_script").execute(*args, **kwargs)
        def load_act_tool(self, *args, **kwargs):
            """
            Load ACT Start Page.
            """
            return PyMenu(self.service, "/file/load_act_tool").execute(*args, **kwargs)
        def set_tui_version(self, *args, **kwargs):
            """
            Set the version of the TUI commands.
            """
            return PyMenu(self.service, "/file/set_tui_version").execute(*args, **kwargs)

        class auto_save(metaclass=PyMenuMeta):
            """
            Enter the auto save menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def case_frequency(self, *args, **kwargs):
                """
                Set the preference for saving case files.
                """
                return PyMenu(self.service, "/file/auto_save/case_frequency").execute(*args, **kwargs)
            def data_frequency(self, *args, **kwargs):
                """
                Set the iteration or time step increment for saving data files.
                """
                return PyMenu(self.service, "/file/auto_save/data_frequency").execute(*args, **kwargs)
            def root_name(self, *args, **kwargs):
                """
                Set the root name for auto-saved files. The number of iterations or time steps will be appended to this root name.
                """
                return PyMenu(self.service, "/file/auto_save/root_name").execute(*args, **kwargs)
            def retain_most_recent_files(self, *args, **kwargs):
                """
                After the maximum (as in max-files) is reached, a file will be deleted for each file saved.
                """
                return PyMenu(self.service, "/file/auto_save/retain_most_recent_files").execute(*args, **kwargs)
            def max_files(self, *args, **kwargs):
                """
                Set the maximum number of data files to save. After the maximum is reached, a file will be deleted for each file saved.
                """
                return PyMenu(self.service, "/file/auto_save/max_files").execute(*args, **kwargs)
            def append_file_name_with(self, *args, **kwargs):
                """
                Set the suffix for auto-saved files. The file name can be appended by flow-time, time-step value or by user specified flags in file name.
                """
                return PyMenu(self.service, "/file/auto_save/append_file_name_with").execute(*args, **kwargs)
            def save_data_file_every(self, *args, **kwargs):
                """
                Set the auto save frequency type to either time-step or crank-angle and set the corresponding frequency.
                """
                return PyMenu(self.service, "/file/auto_save/save_data_file_every").execute(*args, **kwargs)

        class cffio_options(metaclass=PyMenuMeta):
            """
            CFF I/O options.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def io_mode(self, *args, **kwargs):
                """
                Set CFF I/O mode.
                """
                return PyMenu(self.service, "/file/cffio_options/io_mode").execute(*args, **kwargs)
            def compression_level(self, *args, **kwargs):
                """
                Set CFF file compression level.
                """
                return PyMenu(self.service, "/file/cffio_options/compression_level").execute(*args, **kwargs)
            def single_precision_data(self, *args, **kwargs):
                """
                Specify whether the double-precision solver saves single-precision data when writing CFF data files.
                """
                return PyMenu(self.service, "/file/cffio_options/single_precision_data").execute(*args, **kwargs)

        class export(metaclass=PyMenuMeta):
            """
            Enter the export menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.system_coupling_definition_file_settings = self.__class__.system_coupling_definition_file_settings(path + [("system_coupling_definition_file_settings", None)], service)
                self.settings = self.__class__.settings(path + [("settings", None)], service)
            def abaqus(self, *args, **kwargs):
                """
                Write an ABAQUS file.
                """
                return PyMenu(self.service, "/file/export/abaqus").execute(*args, **kwargs)
            def mechanical_apdl(self, *args, **kwargs):
                """
                Write an Mechanical APDL file.
                """
                return PyMenu(self.service, "/file/export/mechanical_apdl").execute(*args, **kwargs)
            def mechanical_apdl_input(self, *args, **kwargs):
                """
                Write an Mechanical APDL Input file.
                """
                return PyMenu(self.service, "/file/export/mechanical_apdl_input").execute(*args, **kwargs)
            def ascii(self, *args, **kwargs):
                """
                Write an ASCII file.
                """
                return PyMenu(self.service, "/file/export/ascii").execute(*args, **kwargs)
            def common_fluids_format_post(self, *args, **kwargs):
                """
                Write an CFF Post-Only file.
                """
                return PyMenu(self.service, "/file/export/common_fluids_format_post").execute(*args, **kwargs)
            def avs(self, *args, **kwargs):
                """
                Write an AVS UCD file.
                """
                return PyMenu(self.service, "/file/export/avs").execute(*args, **kwargs)
            def cdat_for_cfd_post__and__ensight(self, *args, **kwargs):
                """
                Write a CDAT for CFD-Post & EnSight file.
                """
                return PyMenu(self.service, "/file/export/cdat_for_cfd_post__and__ensight").execute(*args, **kwargs)
            def cgns(self, *args, **kwargs):
                """
                Write a CGNS file.
                """
                return PyMenu(self.service, "/file/export/cgns").execute(*args, **kwargs)
            def custom_heat_flux(self, *args, **kwargs):
                """
                Write a generic file for heat transfer.
                """
                return PyMenu(self.service, "/file/export/custom_heat_flux").execute(*args, **kwargs)
            def dx(self, *args, **kwargs):
                """
                Write an IBM Data Explorer format file.
                """
                return PyMenu(self.service, "/file/export/dx").execute(*args, **kwargs)
            def ensight(self, *args, **kwargs):
                """
                Write EnSight 6 geometry, velocity, and scalar files.
                """
                return PyMenu(self.service, "/file/export/ensight").execute(*args, **kwargs)
            def ensight_gold(self, *args, **kwargs):
                """
                Write EnSight Gold geometry, velocity, and scalar files.
                """
                return PyMenu(self.service, "/file/export/ensight_gold").execute(*args, **kwargs)
            def ensight_gold_parallel_surfaces(self, *args, **kwargs):
                """
                Write EnSight Gold geometry, velocity and scalar files for surfaces. Fluent will write files suitable for EnSight Parallel.
                """
                return PyMenu(self.service, "/file/export/ensight_gold_parallel_surfaces").execute(*args, **kwargs)
            def ensight_gold_parallel_volume(self, *args, **kwargs):
                """
                Write EnSight Gold geometry, velocity and scalar files for cell zones and boundaries attached to them. Fluent will write files suitable for EnSight Parallel.
                """
                return PyMenu(self.service, "/file/export/ensight_gold_parallel_volume").execute(*args, **kwargs)
            def ensight_dvs_surfaces(self, *args, **kwargs):
                """
                Write post-processing data(geometry, velocity and scalars) for surfaces using EnSight Dynamic Visualization Store Interface.
                """
                return PyMenu(self.service, "/file/export/ensight_dvs_surfaces").execute(*args, **kwargs)
            def ensight_dvs_volume(self, *args, **kwargs):
                """
                Write post-processing data(geometry, velocity and scalars) for cell zones and boundaries attached to them using EnSight Dynamic Visualization Store Interface.
                """
                return PyMenu(self.service, "/file/export/ensight_dvs_volume").execute(*args, **kwargs)
            def icemcfd_for_icepak(self, *args, **kwargs):
                """
                Write a binary ICEMCFD domain file.
                """
                return PyMenu(self.service, "/file/export/icemcfd_for_icepak").execute(*args, **kwargs)
            def fast_mesh(self, *args, **kwargs):
                """
                Write a FAST/Plot3D unstructured mesh file.
                """
                return PyMenu(self.service, "/file/export/fast_mesh").execute(*args, **kwargs)
            def fast_scalar(self, *args, **kwargs):
                """
                Write a FAST/Plot3D unstructured scalar function file.
                """
                return PyMenu(self.service, "/file/export/fast_scalar").execute(*args, **kwargs)
            def fast_solution(self, *args, **kwargs):
                """
                Write a FAST/Plot3D unstructured solution file.
                """
                return PyMenu(self.service, "/file/export/fast_solution").execute(*args, **kwargs)
            def fast_velocity(self, *args, **kwargs):
                """
                Write a FAST/Plot3D unstructured vector function file.
                """
                return PyMenu(self.service, "/file/export/fast_velocity").execute(*args, **kwargs)
            def fieldview(self, *args, **kwargs):
                """
                Write Fieldview case and data files.
                """
                return PyMenu(self.service, "/file/export/fieldview").execute(*args, **kwargs)
            def fieldview_data(self, *args, **kwargs):
                """
                Write Fieldview case and data files.
                """
                return PyMenu(self.service, "/file/export/fieldview_data").execute(*args, **kwargs)
            def fieldview_unstruct(self, *args, **kwargs):
                """
                Write a Fieldview unstructured combined file.
                """
                return PyMenu(self.service, "/file/export/fieldview_unstruct").execute(*args, **kwargs)
            def fieldview_unstruct_mesh(self, *args, **kwargs):
                """
                Write a Fieldview unstructured mesh only file.
                """
                return PyMenu(self.service, "/file/export/fieldview_unstruct_mesh").execute(*args, **kwargs)
            def fieldview_unstruct_data(self, *args, **kwargs):
                """
                Write a Fieldview unstructured results only file.
                """
                return PyMenu(self.service, "/file/export/fieldview_unstruct_data").execute(*args, **kwargs)
            def fieldview_unstruct_surfaces(self, *args, **kwargs):
                """
                Write a Fieldview unstructured surface mesh, data.
                """
                return PyMenu(self.service, "/file/export/fieldview_unstruct_surfaces").execute(*args, **kwargs)
            def fieldview_xdb(self, *args, **kwargs):
                """
                Write a FieldView XDB format file.
                """
                return PyMenu(self.service, "/file/export/fieldview_xdb").execute(*args, **kwargs)
            def gambit(self, *args, **kwargs):
                """
                Write a Gambit neutral file.
                """
                return PyMenu(self.service, "/file/export/gambit").execute(*args, **kwargs)
            def ideas(self, *args, **kwargs):
                """
                Write an IDEAS universal file.
                """
                return PyMenu(self.service, "/file/export/ideas").execute(*args, **kwargs)
            def nastran(self, *args, **kwargs):
                """
                Write a NASTRAN file.
                """
                return PyMenu(self.service, "/file/export/nastran").execute(*args, **kwargs)
            def patran_neutral(self, *args, **kwargs):
                """
                Write a PATRAN neutral file.
                """
                return PyMenu(self.service, "/file/export/patran_neutral").execute(*args, **kwargs)
            def patran_nodal(self, *args, **kwargs):
                """
                Write a PATRAN nodal results file.
                """
                return PyMenu(self.service, "/file/export/patran_nodal").execute(*args, **kwargs)
            def taitherm(self, *args, **kwargs):
                """
                Write a TAITherm file.
                """
                return PyMenu(self.service, "/file/export/taitherm").execute(*args, **kwargs)
            def tecplot(self, *args, **kwargs):
                """
                Write a Tecplot+3DV format file.
                """
                return PyMenu(self.service, "/file/export/tecplot").execute(*args, **kwargs)
            def particle_history_data(self, *args, **kwargs):
                """
                Export particle-history data.
                """
                return PyMenu(self.service, "/file/export/particle_history_data").execute(*args, **kwargs)

            class system_coupling_definition_file_settings(metaclass=PyMenuMeta):
                """
                File menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def enable_automatic_creation_of_scp_file(self, *args, **kwargs):
                    """
                    Enable/disable automatic creation of scp file during case write.
                    """
                    return PyMenu(self.service, "/file/export/system_coupling_definition_file_settings/enable_automatic_creation_of_scp_file").execute(*args, **kwargs)
                def write_system_coupling_file(self, *args, **kwargs):
                    """
                    Write a Fluent Input File for System Coupling.
                    """
                    return PyMenu(self.service, "/file/export/system_coupling_definition_file_settings/write_system_coupling_file").execute(*args, **kwargs)

            class settings(metaclass=PyMenuMeta):
                """
                Enter the export settings menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def set_cgns_export_filetype(self, *args, **kwargs):
                    """
                    Select HDF5 or ADF as file format for CGNS.
                    """
                    return PyMenu(self.service, "/file/export/settings/set_cgns_export_filetype").execute(*args, **kwargs)

        class transient_export(metaclass=PyMenuMeta):
            """
            Enter the export menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.settings = self.__class__.settings(path + [("settings", None)], service)
            def abaqus(self, *args, **kwargs):
                """
                Write an ABAQUS file.
                """
                return PyMenu(self.service, "/file/transient_export/abaqus").execute(*args, **kwargs)
            def mechanical_apdl_input(self, *args, **kwargs):
                """
                Write an Mechanical APDL Input file.
                """
                return PyMenu(self.service, "/file/transient_export/mechanical_apdl_input").execute(*args, **kwargs)
            def ascii(self, *args, **kwargs):
                """
                Write an ASCII file.
                """
                return PyMenu(self.service, "/file/transient_export/ascii").execute(*args, **kwargs)
            def avs(self, *args, **kwargs):
                """
                Write an AVS UCD file.
                """
                return PyMenu(self.service, "/file/transient_export/avs").execute(*args, **kwargs)
            def cdat_for_cfd_post__and__ensight(self, *args, **kwargs):
                """
                Write a CDAT for CFD-Post & EnSight file.
                """
                return PyMenu(self.service, "/file/transient_export/cdat_for_cfd_post__and__ensight").execute(*args, **kwargs)
            def common_fluids_format_post(self, *args, **kwargs):
                """
                Write an CFF Post-Only file.
                """
                return PyMenu(self.service, "/file/transient_export/common_fluids_format_post").execute(*args, **kwargs)
            def cgns(self, *args, **kwargs):
                """
                Write a CGNS file.
                """
                return PyMenu(self.service, "/file/transient_export/cgns").execute(*args, **kwargs)
            def dx(self, *args, **kwargs):
                """
                Write an IBM Data Explorer format file.
                """
                return PyMenu(self.service, "/file/transient_export/dx").execute(*args, **kwargs)
            def ensight_gold_transient(self, *args, **kwargs):
                """
                Write EnSight Gold geometry, velocity, and scalar files.
                """
                return PyMenu(self.service, "/file/transient_export/ensight_gold_transient").execute(*args, **kwargs)
            def ensight_gold_parallel_surfaces(self, *args, **kwargs):
                """
                Write EnSight Gold geometry, velocity and scalar files for surfaces. Fluent will write files suitable for EnSight Parallel.
                """
                return PyMenu(self.service, "/file/transient_export/ensight_gold_parallel_surfaces").execute(*args, **kwargs)
            def ensight_gold_parallel_volume(self, *args, **kwargs):
                """
                Write EnSight Gold geometry, velocity and scalar files for cell zones and boundaries attached to them. Fluent will write files suitable for EnSight Parallel.
                """
                return PyMenu(self.service, "/file/transient_export/ensight_gold_parallel_volume").execute(*args, **kwargs)
            def ensight_dvs_surfaces(self, *args, **kwargs):
                """
                Write post-processing data(geometry, velocity and scalars) for surfaces using EnSight Dynamic Visualization Store Interface.
                """
                return PyMenu(self.service, "/file/transient_export/ensight_dvs_surfaces").execute(*args, **kwargs)
            def ensight_dvs_volume(self, *args, **kwargs):
                """
                Write post-processing data(geometry, velocity and scalars) for cell zones and boundaries attached to them using EnSight Dynamic Visualization Store Interface.
                """
                return PyMenu(self.service, "/file/transient_export/ensight_dvs_volume").execute(*args, **kwargs)
            def ensight_gold_from_existing_files(self, *args, **kwargs):
                """
                Write EnSight Gold files using Fluent case files.
                """
                return PyMenu(self.service, "/file/transient_export/ensight_gold_from_existing_files").execute(*args, **kwargs)
            def fast(self, *args, **kwargs):
                """
                Write a FAST/Plot3D unstructured mesh velocity scalar file.
                """
                return PyMenu(self.service, "/file/transient_export/fast").execute(*args, **kwargs)
            def fast_solution(self, *args, **kwargs):
                """
                Write a FAST/Plot3D unstructured solution file.
                """
                return PyMenu(self.service, "/file/transient_export/fast_solution").execute(*args, **kwargs)
            def fieldview_unstruct(self, *args, **kwargs):
                """
                Write a Fieldview unstructured combined file.
                """
                return PyMenu(self.service, "/file/transient_export/fieldview_unstruct").execute(*args, **kwargs)
            def fieldview_unstruct_mesh(self, *args, **kwargs):
                """
                Write a Fieldview unstructured mesh only file.
                """
                return PyMenu(self.service, "/file/transient_export/fieldview_unstruct_mesh").execute(*args, **kwargs)
            def fieldview_unstruct_data(self, *args, **kwargs):
                """
                Write a Fieldview unstructured results only file.
                """
                return PyMenu(self.service, "/file/transient_export/fieldview_unstruct_data").execute(*args, **kwargs)
            def fieldview_unstruct_surfaces(self, *args, **kwargs):
                """
                Write a Fieldview unstructured combined file for surfaces.
                """
                return PyMenu(self.service, "/file/transient_export/fieldview_unstruct_surfaces").execute(*args, **kwargs)
            def fieldview_xdb(self, *args, **kwargs):
                """
                Write a FieldView XDB format file.
                """
                return PyMenu(self.service, "/file/transient_export/fieldview_xdb").execute(*args, **kwargs)
            def ideas(self, *args, **kwargs):
                """
                Write an IDEAS universal file.
                """
                return PyMenu(self.service, "/file/transient_export/ideas").execute(*args, **kwargs)
            def nastran(self, *args, **kwargs):
                """
                Write a NASTRAN file.
                """
                return PyMenu(self.service, "/file/transient_export/nastran").execute(*args, **kwargs)
            def patran_neutral(self, *args, **kwargs):
                """
                Write a PATRAN neutral file.
                """
                return PyMenu(self.service, "/file/transient_export/patran_neutral").execute(*args, **kwargs)
            def taitherm(self, *args, **kwargs):
                """
                Write a TAITherm file.
                """
                return PyMenu(self.service, "/file/transient_export/taitherm").execute(*args, **kwargs)
            def tecplot(self, *args, **kwargs):
                """
                Write a Tecplot+3DV format file.
                """
                return PyMenu(self.service, "/file/transient_export/tecplot").execute(*args, **kwargs)
            def particle_history_data(self, *args, **kwargs):
                """
                Setup an automatic particle-history data export.
                """
                return PyMenu(self.service, "/file/transient_export/particle_history_data").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit transient exports.
                """
                return PyMenu(self.service, "/file/transient_export/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete transient exports.
                """
                return PyMenu(self.service, "/file/transient_export/delete").execute(*args, **kwargs)

            class settings(metaclass=PyMenuMeta):
                """
                Enter the automatic export settings menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def cfd_post_compatible(self, *args, **kwargs):
                    """
                    Set settings for CFD-Post compatible file export.
                    """
                    return PyMenu(self.service, "/file/transient_export/settings/cfd_post_compatible").execute(*args, **kwargs)

        class em_mapping(metaclass=PyMenuMeta):
            """
            Assign electro-magnetic losses provided by specified product.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def volumetric_energy_source(self, *args, **kwargs):
                """
                Loss data provided by Ansoft will be assigned to Fluent for selected cell zones.
                """
                return PyMenu(self.service, "/file/em_mapping/volumetric_energy_source").execute(*args, **kwargs)
            def surface_energy_source(self, *args, **kwargs):
                """
                Loss data provided by Ansoft will be assigned to Fluent for selected wall zones.
                """
                return PyMenu(self.service, "/file/em_mapping/surface_energy_source").execute(*args, **kwargs)
            def remove_loss_only(self, *args, **kwargs):
                """
                Remove the loss data provided by Ansoft and keep all other solution data.
                """
                return PyMenu(self.service, "/file/em_mapping/remove_loss_only").execute(*args, **kwargs)
            def maintain_loss_on_initialization(self, *args, **kwargs):
                """
                Maintain the loss data provided by Ansoft even if solution is initialized.
                """
                return PyMenu(self.service, "/file/em_mapping/maintain_loss_on_initialization").execute(*args, **kwargs)

        class import_(metaclass=PyMenuMeta):
            """
            Enter the import menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.mechanical_apdl = self.__class__.mechanical_apdl(path + [("mechanical_apdl", None)], service)
                self.abaqus = self.__class__.abaqus(path + [("abaqus", None)], service)
                self.cfx = self.__class__.cfx(path + [("cfx", None)], service)
                self.cgns = self.__class__.cgns(path + [("cgns", None)], service)
                self.fmu_file = self.__class__.fmu_file(path + [("fmu_file", None)], service)
                self.flamelet = self.__class__.flamelet(path + [("flamelet", None)], service)
                self.lstc = self.__class__.lstc(path + [("lstc", None)], service)
                self.nastran = self.__class__.nastran(path + [("nastran", None)], service)
                self.partition = self.__class__.partition(path + [("partition", None)], service)
                self.patran = self.__class__.patran(path + [("patran", None)], service)
                self.plot3d = self.__class__.plot3d(path + [("plot3d", None)], service)
                self.tecplot = self.__class__.tecplot(path + [("tecplot", None)], service)
            def chemkin_mechanism(self, *args, **kwargs):
                """
                Read a CHEMKIN mechanism file.
                """
                return PyMenu(self.service, "/file/import/chemkin_mechanism").execute(*args, **kwargs)
            def chemkin_report_each_line(self, *args, **kwargs):
                """
                Enable/disable reporting after reading each line.
                """
                return PyMenu(self.service, "/file/import/chemkin_report_each_line").execute(*args, **kwargs)
            def fidap(self, *args, **kwargs):
                """
                Read a FIDAP neutral file as a case file.
                """
                return PyMenu(self.service, "/file/import/fidap").execute(*args, **kwargs)
            def fluent4_case(self, *args, **kwargs):
                """
                Read a formatted Fluent 4 case file.
                """
                return PyMenu(self.service, "/file/import/fluent4_case").execute(*args, **kwargs)
            def gambit(self, *args, **kwargs):
                """
                Read a GAMBIT neutral file as a case file.
                """
                return PyMenu(self.service, "/file/import/gambit").execute(*args, **kwargs)
            def hypermesh(self, *args, **kwargs):
                """
                Read a HYPERMESH file as a case file.
                """
                return PyMenu(self.service, "/file/import/hypermesh").execute(*args, **kwargs)
            def ensight(self, *args, **kwargs):
                """
                Read an Ensight file as a case file.
                """
                return PyMenu(self.service, "/file/import/ensight").execute(*args, **kwargs)
            def ideas_universal(self, *args, **kwargs):
                """
                Read an IDEAS Universal file as a case file.
                """
                return PyMenu(self.service, "/file/import/ideas_universal").execute(*args, **kwargs)
            def marc_post(self, *args, **kwargs):
                """
                Read a MARC POST file as a case file.
                """
                return PyMenu(self.service, "/file/import/marc_post").execute(*args, **kwargs)
            def ptc_mechanica(self, *args, **kwargs):
                """
                Read a PTC Mechanica file as a case file.
                """
                return PyMenu(self.service, "/file/import/ptc_mechanica").execute(*args, **kwargs)
            def prebfc_structured(self, *args, **kwargs):
                """
                Read a formatted preBFC structured mesh (grid) file.
                """
                return PyMenu(self.service, "/file/import/prebfc_structured").execute(*args, **kwargs)

            class mechanical_apdl(metaclass=PyMenuMeta):
                """
                Enter the Mechanical APDL menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def input(self, *args, **kwargs):
                    """
                    Read an Mechanical APDL file as a case file.
                    """
                    return PyMenu(self.service, "/file/import/mechanical_apdl/input").execute(*args, **kwargs)
                def result(self, *args, **kwargs):
                    """
                    Read an Mechanical APDL result file as a case file.
                    """
                    return PyMenu(self.service, "/file/import/mechanical_apdl/result").execute(*args, **kwargs)

            class abaqus(metaclass=PyMenuMeta):
                """
                Enter the Abaqus menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def fil(self, *args, **kwargs):
                    """
                    Read an Abaqus .fil result file as a case file.
                    """
                    return PyMenu(self.service, "/file/import/abaqus/fil").execute(*args, **kwargs)
                def input(self, *args, **kwargs):
                    """
                    Read an Abaqus Input file as a case file.
                    """
                    return PyMenu(self.service, "/file/import/abaqus/input").execute(*args, **kwargs)
                def odb(self, *args, **kwargs):
                    """
                    Read an Abaqus odb file as a case file.
                    """
                    return PyMenu(self.service, "/file/import/abaqus/odb").execute(*args, **kwargs)

            class cfx(metaclass=PyMenuMeta):
                """
                Enter the CFX menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def definition(self, *args, **kwargs):
                    """
                    Read a CFX definition file as a case file.
                    """
                    return PyMenu(self.service, "/file/import/cfx/definition").execute(*args, **kwargs)
                def result(self, *args, **kwargs):
                    """
                    Read a CFX result file as a case file.
                    """
                    return PyMenu(self.service, "/file/import/cfx/result").execute(*args, **kwargs)

            class cgns(metaclass=PyMenuMeta):
                """
                Enter the CGNS menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def mesh(self, *args, **kwargs):
                    """
                    Read a CGNS file as a case file.
                    """
                    return PyMenu(self.service, "/file/import/cgns/mesh").execute(*args, **kwargs)
                def data(self, *args, **kwargs):
                    """
                    Read data from CGNS file.
                    """
                    return PyMenu(self.service, "/file/import/cgns/data").execute(*args, **kwargs)
                def mesh_data(self, *args, **kwargs):
                    """
                    Read a CGNS file as a case file.
                    """
                    return PyMenu(self.service, "/file/import/cgns/mesh_data").execute(*args, **kwargs)

            class fmu_file(metaclass=PyMenuMeta):
                """
                Read a FMU file.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def import_fmu(self, *args, **kwargs):
                    """
                    Import a FMU file.
                    """
                    return PyMenu(self.service, "/file/import/fmu_file/import_fmu").execute(*args, **kwargs)
                def define_fmu(self, *args, **kwargs):
                    """
                    Link the FMU variables with Fluent parameters.
                    """
                    return PyMenu(self.service, "/file/import/fmu_file/define_fmu").execute(*args, **kwargs)
                def select_fmu_local(self, *args, **kwargs):
                    """
                    Select the FMU local variables to monitor.
                    """
                    return PyMenu(self.service, "/file/import/fmu_file/select_fmu_local").execute(*args, **kwargs)
                def set_fmu_parameter(self, *args, **kwargs):
                    """
                    Change the values of FMU parameter variables.
                    """
                    return PyMenu(self.service, "/file/import/fmu_file/set_fmu_parameter").execute(*args, **kwargs)

            class flamelet(metaclass=PyMenuMeta):
                """
                Import a flamelet file.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def standard(self, *args, **kwargs):
                    """
                    Read a standard format flamelet file.
                    """
                    return PyMenu(self.service, "/file/import/flamelet/standard").execute(*args, **kwargs)
                def cfx_rif(self, *args, **kwargs):
                    """
                    Read a CFX-RIF format flamelet file.
                    """
                    return PyMenu(self.service, "/file/import/flamelet/cfx_rif").execute(*args, **kwargs)

            class lstc(metaclass=PyMenuMeta):
                """
                Enter the LSTC menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def input(self, *args, **kwargs):
                    """
                    Read an LSTC input file as a case file.
                    """
                    return PyMenu(self.service, "/file/import/lstc/input").execute(*args, **kwargs)
                def state(self, *args, **kwargs):
                    """
                    Read an LSTC result file as a case file.
                    """
                    return PyMenu(self.service, "/file/import/lstc/state").execute(*args, **kwargs)

            class nastran(metaclass=PyMenuMeta):
                """
                Enter the NASTRAN menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def bulkdata(self, *args, **kwargs):
                    """
                    Read a NASTRAN file as a case file.
                    """
                    return PyMenu(self.service, "/file/import/nastran/bulkdata").execute(*args, **kwargs)
                def output2(self, *args, **kwargs):
                    """
                    Read a NASTRAN op2 file as a case file.
                    """
                    return PyMenu(self.service, "/file/import/nastran/output2").execute(*args, **kwargs)

            class partition(metaclass=PyMenuMeta):
                """
                Enter the partition menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def metis(self, *args, **kwargs):
                    """
                    Read and partition a Fluent 5 case file.
                    """
                    return PyMenu(self.service, "/file/import/partition/metis").execute(*args, **kwargs)
                def metis_zone(self, *args, **kwargs):
                    """
                    Read and partition a Fluent 5 case file.
                    """
                    return PyMenu(self.service, "/file/import/partition/metis_zone").execute(*args, **kwargs)

            class patran(metaclass=PyMenuMeta):
                """
                Enter the PATRAN menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def neutral(self, *args, **kwargs):
                    """
                    Read a PATRAN Neutral file (zones defined by named components) as a case file.
                    """
                    return PyMenu(self.service, "/file/import/patran/neutral").execute(*args, **kwargs)

            class plot3d(metaclass=PyMenuMeta):
                """
                Enter the PLOT3D menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def mesh(self, *args, **kwargs):
                    """
                    Read a PLOT3D file as a case file.
                    """
                    return PyMenu(self.service, "/file/import/plot3d/mesh").execute(*args, **kwargs)

            class tecplot(metaclass=PyMenuMeta):
                """
                Enter the Tecplot menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def mesh(self, *args, **kwargs):
                    """
                    Read a Tecplot binary file as a case file.
                    """
                    return PyMenu(self.service, "/file/import/tecplot/mesh").execute(*args, **kwargs)

        class interpolate(metaclass=PyMenuMeta):
            """
            Enter the interpolate menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def write_data(self, *args, **kwargs):
                """
                Write data for interpolation.
                """
                return PyMenu(self.service, "/file/interpolate/write_data").execute(*args, **kwargs)
            def read_data(self, *args, **kwargs):
                """
                Read and interpolate data.
                """
                return PyMenu(self.service, "/file/interpolate/read_data").execute(*args, **kwargs)
            def zone_selection(self, *args, **kwargs):
                """
                Define a list of cell zone IDs. If specified, interpolation data will be
                                read/written for these cell zones only.
                """
                return PyMenu(self.service, "/file/interpolate/zone_selection").execute(*args, **kwargs)

        class fsi(metaclass=PyMenuMeta):
            """
            Enter the fsi menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def read_fsi_mesh(self, *args, **kwargs):
                """
                Read an FEA mesh for one-way FSI.
                """
                return PyMenu(self.service, "/file/fsi/read_fsi_mesh").execute(*args, **kwargs)
            def display_fsi_mesh(self, *args, **kwargs):
                """
                Display the FEA mesh that has been read.
                """
                return PyMenu(self.service, "/file/fsi/display_fsi_mesh").execute(*args, **kwargs)
            def write_fsi_mesh(self, *args, **kwargs):
                """
                Write an FEA mesh file with Fluent data.
                """
                return PyMenu(self.service, "/file/fsi/write_fsi_mesh").execute(*args, **kwargs)
            def conserve_force(self, *args, **kwargs):
                """
                Conserve the forces for linear line, tri and tet elements.
                """
                return PyMenu(self.service, "/file/fsi/conserve_force").execute(*args, **kwargs)

        class parametric_project(metaclass=PyMenuMeta):
            """
            Enter to open, save, archive parametric project.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def open(self, *args, **kwargs):
                """
                Open project.
                """
                return PyMenu(self.service, "/file/parametric_project/open").execute(*args, **kwargs)
            def save(self, *args, **kwargs):
                """
                Save Project.
                """
                return PyMenu(self.service, "/file/parametric_project/save").execute(*args, **kwargs)
            def save_as(self, *args, **kwargs):
                """
                Save As Project.
                """
                return PyMenu(self.service, "/file/parametric_project/save_as").execute(*args, **kwargs)
            def save_as_copy(self, *args, **kwargs):
                """
                Save As Copy.
                """
                return PyMenu(self.service, "/file/parametric_project/save_as_copy").execute(*args, **kwargs)
            def archive(self, *args, **kwargs):
                """
                Archive Project.
                """
                return PyMenu(self.service, "/file/parametric_project/archive").execute(*args, **kwargs)

        class project_beta(metaclass=PyMenuMeta):
            """
            Enter to create new project, open project, save and archive project.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def new(self, *args, **kwargs):
                """
                Create New Project.
                """
                return PyMenu(self.service, "/file/project[beta]/new").execute(*args, **kwargs)
            def open(self, *args, **kwargs):
                """
                Open project.
                """
                return PyMenu(self.service, "/file/project[beta]/open").execute(*args, **kwargs)
            def save(self, *args, **kwargs):
                """
                Save Project.
                """
                return PyMenu(self.service, "/file/project[beta]/save").execute(*args, **kwargs)
            def save_as(self, *args, **kwargs):
                """
                Save As Project.
                """
                return PyMenu(self.service, "/file/project[beta]/save_as").execute(*args, **kwargs)
            def save_as_copy(self, *args, **kwargs):
                """
                Save As Copy.
                """
                return PyMenu(self.service, "/file/project[beta]/save_as_copy").execute(*args, **kwargs)
            def archive(self, *args, **kwargs):
                """
                Archive Project.
                """
                return PyMenu(self.service, "/file/project[beta]/archive").execute(*args, **kwargs)

        class table_manager(metaclass=PyMenuMeta):
            """
            Enter the table manager menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def delete(self, *args, **kwargs):
                """
                Delete a table.
                """
                return PyMenu(self.service, "/file/table_manager/delete").execute(*args, **kwargs)
            def list_matrix_data(self, *args, **kwargs):
                """
                List matrix table data.
                """
                return PyMenu(self.service, "/file/table_manager/list_matrix_data").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                List the properties for a table.
                """
                return PyMenu(self.service, "/file/table_manager/list_properties").execute(*args, **kwargs)
            def list_tables(self, *args, **kwargs):
                """
                List the available tables.
                """
                return PyMenu(self.service, "/file/table_manager/list_tables").execute(*args, **kwargs)
            def read_matrix_data_file(self, *args, **kwargs):
                """
                Read matrix data file.
                """
                return PyMenu(self.service, "/file/table_manager/read_matrix_data_file").execute(*args, **kwargs)
            def read_rgp_file(self, *args, **kwargs):
                """
                Read material from real gas property (RGP) file.
                """
                return PyMenu(self.service, "/file/table_manager/read_rgp_file").execute(*args, **kwargs)
            def rename(self, *args, **kwargs):
                """
                Rename a table.
                """
                return PyMenu(self.service, "/file/table_manager/rename").execute(*args, **kwargs)
            def store_in_case_file(self, *args, **kwargs):
                """
                Set persistence mode for tables (in case or separate file).
                """
                return PyMenu(self.service, "/file/table_manager/store_in_case_file").execute(*args, **kwargs)

        class solution_files(metaclass=PyMenuMeta):
            """
            Enter the solution files menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def print_solution_files(self, *args, **kwargs):
                """
                Print list of available solution files.
                """
                return PyMenu(self.service, "/file/solution_files/print_solution_files").execute(*args, **kwargs)
            def load_solution(self, *args, **kwargs):
                """
                Load a solution file.
                """
                return PyMenu(self.service, "/file/solution_files/load_solution").execute(*args, **kwargs)
            def delete_solution(self, *args, **kwargs):
                """
                Delete solution files.
                """
                return PyMenu(self.service, "/file/solution_files/delete_solution").execute(*args, **kwargs)

    class icing(metaclass=PyMenuMeta):
        """
        FENSAP-ICE options.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
        def file(self, *args, **kwargs):
            """
            File menu.
            """
            return PyMenu(self.service, "/icing/file").execute(*args, **kwargs)
        def flow(self, *args, **kwargs):
            """
            Flow solver menu.
            """
            return PyMenu(self.service, "/icing/flow").execute(*args, **kwargs)
        def drop(self, *args, **kwargs):
            """
            Droplet impingement menu.
            """
            return PyMenu(self.service, "/icing/drop").execute(*args, **kwargs)
        def ice(self, *args, **kwargs):
            """
            Ice accretion menu.
            """
            return PyMenu(self.service, "/icing/ice").execute(*args, **kwargs)
        def multishot(self, *args, **kwargs):
            """
            Multi-shot accretion menu.
            """
            return PyMenu(self.service, "/icing/multishot").execute(*args, **kwargs)
        def settings(self, *args, **kwargs):
            """
            Global settings menu.
            """
            return PyMenu(self.service, "/icing/settings").execute(*args, **kwargs)

    class mesh(metaclass=PyMenuMeta):
        """
        Enter the mesh menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
            self.adapt = self.__class__.adapt(path + [("adapt", None)], service)
            self.modify_zones = self.__class__.modify_zones(path + [("modify_zones", None)], service)
            self.polyhedra = self.__class__.polyhedra(path + [("polyhedra", None)], service)
            self.reorder = self.__class__.reorder(path + [("reorder", None)], service)
            self.repair_improve = self.__class__.repair_improve(path + [("repair_improve", None)], service)
            self.surface_mesh = self.__class__.surface_mesh(path + [("surface_mesh", None)], service)
        def adjacency(self, *args, **kwargs):
            """
            View and rename face zones adjacent to selected cell zones.
            """
            return PyMenu(self.service, "/mesh/adjacency").execute(*args, **kwargs)
        def check(self, *args, **kwargs):
            """
            Perform various mesh consistency checks.
            """
            return PyMenu(self.service, "/mesh/check").execute(*args, **kwargs)
        def check_before_solve(self, *args, **kwargs):
            """
            Perform various mesh consistency checks before solve.
            """
            return PyMenu(self.service, "/mesh/check_before_solve").execute(*args, **kwargs)
        def check_verbosity(self, *args, **kwargs):
            """
            Set verbosity output of mesh check and mesh quality. Higher verbosity corresponds to more detailed information.
            """
            return PyMenu(self.service, "/mesh/check_verbosity").execute(*args, **kwargs)
        def enhanced_orthogonal_quality(self, *args, **kwargs):
            """
            Enable enhanced orthogonal quality method.
            """
            return PyMenu(self.service, "/mesh/enhanced_orthogonal_quality").execute(*args, **kwargs)
        def mesh_info(self, *args, **kwargs):
            """
            Print zone information size.
            """
            return PyMenu(self.service, "/mesh/mesh_info").execute(*args, **kwargs)
        def memory_usage(self, *args, **kwargs):
            """
            Report solver memory use.
            """
            return PyMenu(self.service, "/mesh/memory_usage").execute(*args, **kwargs)
        def quality(self, *args, **kwargs):
            """
            Perform analysis of mesh quality.
            """
            return PyMenu(self.service, "/mesh/quality").execute(*args, **kwargs)
        def redistribute_boundary_layer(self, *args, **kwargs):
            """
            Enforce growth rate in boundary layer.
            """
            return PyMenu(self.service, "/mesh/redistribute_boundary_layer").execute(*args, **kwargs)
        def replace(self, *args, **kwargs):
            """
            Replace mesh and interpolate data.
            """
            return PyMenu(self.service, "/mesh/replace").execute(*args, **kwargs)
        def rotate(self, *args, **kwargs):
            """
            Rotate the mesh.
            """
            return PyMenu(self.service, "/mesh/rotate").execute(*args, **kwargs)
        def scale(self, *args, **kwargs):
            """
            Scale the mesh.
            """
            return PyMenu(self.service, "/mesh/scale").execute(*args, **kwargs)
        def size_info(self, *args, **kwargs):
            """
            Print mesh size.
            """
            return PyMenu(self.service, "/mesh/size_info").execute(*args, **kwargs)
        def smooth_mesh(self, *args, **kwargs):
            """
            Smooth the mesh using quality-based, Laplace or skewness methods.
            """
            return PyMenu(self.service, "/mesh/smooth_mesh").execute(*args, **kwargs)
        def swap_mesh_faces(self, *args, **kwargs):
            """
            Swap mesh faces.
            """
            return PyMenu(self.service, "/mesh/swap_mesh_faces").execute(*args, **kwargs)
        def show_periodic_shadow_zones(self, *args, **kwargs):
            """
            Option to show periodic shadow zones in user interface.
            """
            return PyMenu(self.service, "/mesh/show_periodic_shadow_zones").execute(*args, **kwargs)
        def translate(self, *args, **kwargs):
            """
            Translate the mesh.
            """
            return PyMenu(self.service, "/mesh/translate").execute(*args, **kwargs)
        def set_unit_system(self, *args, **kwargs):
            """
            To apply standard set of units to all quantities.
            """
            return PyMenu(self.service, "/mesh/set_unit_system").execute(*args, **kwargs)
        def units(self, *args, **kwargs):
            """
            Set unit conversion factors.
            """
            return PyMenu(self.service, "/mesh/units").execute(*args, **kwargs)

        class adapt(metaclass=PyMenuMeta):
            """
            Enter the adaption menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.set = self.__class__.set(path + [("set", None)], service)
                self.profile = self.__class__.profile(path + [("profile", None)], service)
                self.cell_registers = self.__class__.cell_registers(path + [("cell_registers", None)], service)
                self.manage_criteria = self.__class__.manage_criteria(path + [("manage_criteria", None)], service)
                self.multi_layer_refinement = self.__class__.multi_layer_refinement(path + [("multi_layer_refinement", None)], service)
                self.geometry = self.__class__.geometry(path + [("geometry", None)], service)
            def refinement_criteria(self, *args, **kwargs):
                """
                Set expression for refinement criterion.
                """
                return PyMenu(self.service, "/mesh/adapt/refinement_criteria").execute(*args, **kwargs)
            def coarsening_criteria(self, *args, **kwargs):
                """
                Set expression for coarsening criterion.
                """
                return PyMenu(self.service, "/mesh/adapt/coarsening_criteria").execute(*args, **kwargs)
            def manual_refinement_criteria(self, *args, **kwargs):
                """
                Set expression for manual refinement criterion.
                """
                return PyMenu(self.service, "/mesh/adapt/manual_refinement_criteria").execute(*args, **kwargs)
            def manual_coarsening_criteria(self, *args, **kwargs):
                """
                Set expression for manual coarsening criterion.
                """
                return PyMenu(self.service, "/mesh/adapt/manual_coarsening_criteria").execute(*args, **kwargs)
            def adapt_mesh(self, *args, **kwargs):
                """
                Adapt the mesh based on set refinement/coarsening criterion.
                """
                return PyMenu(self.service, "/mesh/adapt/adapt_mesh").execute(*args, **kwargs)
            def display_adaption_cells(self, *args, **kwargs):
                """
                Display cells marked for refinement/coarsening.
                """
                return PyMenu(self.service, "/mesh/adapt/display_adaption_cells").execute(*args, **kwargs)
            def list_adaption_cells(self, *args, **kwargs):
                """
                List the number of cells marked for refinement/coarsening.
                """
                return PyMenu(self.service, "/mesh/adapt/list_adaption_cells").execute(*args, **kwargs)
            def free_hierarchy(self, *args, **kwargs):
                """
                Delete the adaption hierarchy.
                """
                return PyMenu(self.service, "/mesh/adapt/free_hierarchy").execute(*args, **kwargs)
            def anisotropic_adaption(self, *args, **kwargs):
                """
                Anisotropically refine boundary layers.
                """
                return PyMenu(self.service, "/mesh/adapt/anisotropic_adaption").execute(*args, **kwargs)

            class set(metaclass=PyMenuMeta):
                """
                Enter the adaption set menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def method(self, *args, **kwargs):
                    """
                    Set the adaption method.
                    """
                    return PyMenu(self.service, "/mesh/adapt/set/method").execute(*args, **kwargs)
                def cell_zones(self, *args, **kwargs):
                    """
                    Set cell zones to be used for marking adaption. An empty list implies that all zones are considered for adaption.
                    """
                    return PyMenu(self.service, "/mesh/adapt/set/cell_zones").execute(*args, **kwargs)
                def verbosity(self, *args, **kwargs):
                    """
                    Set the adaption verbosity.
                    """
                    return PyMenu(self.service, "/mesh/adapt/set/verbosity").execute(*args, **kwargs)
                def encapsulate_children(self, *args, **kwargs):
                    """
                    Encapsulate all children of parent cells on the same partition.
                    """
                    return PyMenu(self.service, "/mesh/adapt/set/encapsulate_children").execute(*args, **kwargs)
                def maximum_refinement_level(self, *args, **kwargs):
                    """
                    Set maximum level of refinement in the mesh.
                    """
                    return PyMenu(self.service, "/mesh/adapt/set/maximum_refinement_level").execute(*args, **kwargs)
                def minimum_edge_length(self, *args, **kwargs):
                    """
                    Set limit on the minimum effective edge-length of cells in the mesh.
                    """
                    return PyMenu(self.service, "/mesh/adapt/set/minimum_edge_length").execute(*args, **kwargs)
                def minimum_cell_quality(self, *args, **kwargs):
                    """
                    Set limit on the minimum cell orthogonal quality during adaption.
                    """
                    return PyMenu(self.service, "/mesh/adapt/set/minimum_cell_quality").execute(*args, **kwargs)
                def maximum_cell_count(self, *args, **kwargs):
                    """
                    Set limit on the maximum number of cells during adaption.
                    """
                    return PyMenu(self.service, "/mesh/adapt/set/maximum_cell_count").execute(*args, **kwargs)
                def additional_refinement_layers(self, *args, **kwargs):
                    """
                    Set the number of additional cell layers for refinement.
                    """
                    return PyMenu(self.service, "/mesh/adapt/set/additional_refinement_layers").execute(*args, **kwargs)
                def anisotropic_adaption(self, *args, **kwargs):
                    """
                    Enable/Disable anisotropic adaption for prismatic cells.
                    """
                    return PyMenu(self.service, "/mesh/adapt/set/anisotropic_adaption").execute(*args, **kwargs)
                def anisotropic_boundary_zones(self, *args, **kwargs):
                    """
                    Set the boundary zones to specify directions for anisotropic refinement.
                    """
                    return PyMenu(self.service, "/mesh/adapt/set/anisotropic_boundary_zones").execute(*args, **kwargs)
                def anisotropic_split_ratio(self, *args, **kwargs):
                    """
                    Set the split ratio for anisotropic refinement of prismatic cells.
                    """
                    return PyMenu(self.service, "/mesh/adapt/set/anisotropic_split_ratio").execute(*args, **kwargs)
                def display_settings(self, *args, **kwargs):
                    """
                    Set the graphics display options for cells marked for adaption.
                    """
                    return PyMenu(self.service, "/mesh/adapt/set/display_settings").execute(*args, **kwargs)
                def dynamic_adaption(self, *args, **kwargs):
                    """
                    Adapt the mesh during solution.
                    """
                    return PyMenu(self.service, "/mesh/adapt/set/dynamic_adaption").execute(*args, **kwargs)
                def dynamic_adaption_frequency(self, *args, **kwargs):
                    """
                    Set frequency for dynamic adaption.
                    """
                    return PyMenu(self.service, "/mesh/adapt/set/dynamic_adaption_frequency").execute(*args, **kwargs)
                def overset_adapt_dead_cells(self, *args, **kwargs):
                    """
                    Enables adaption of dead cells in overset meshes.
                    """
                    return PyMenu(self.service, "/mesh/adapt/set/overset_adapt_dead_cells").execute(*args, **kwargs)

            class profile(metaclass=PyMenuMeta):
                """
                Enter the adaption profile menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def enable(self, *args, **kwargs):
                    """
                    Enable adaption profiling.
                    """
                    return PyMenu(self.service, "/mesh/adapt/profile/enable").execute(*args, **kwargs)
                def disable(self, *args, **kwargs):
                    """
                    Disable adaption profiling.
                    """
                    return PyMenu(self.service, "/mesh/adapt/profile/disable").execute(*args, **kwargs)
                def print(self, *args, **kwargs):
                    """
                    Print adaption profiling results.
                    """
                    return PyMenu(self.service, "/mesh/adapt/profile/print").execute(*args, **kwargs)
                def clear(self, *args, **kwargs):
                    """
                    Clear adaption profiling counters.
                    """
                    return PyMenu(self.service, "/mesh/adapt/profile/clear").execute(*args, **kwargs)

            class cell_registers(metaclass=PyMenuMeta):
                """
                Manage Cell Registers.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def adapt(self, *args, **kwargs):
                    """
                    Adapt cell register objects.
                    """
                    return PyMenu(self.service, "/mesh/adapt/cell_registers/adapt").execute(*args, **kwargs)
                def add(self, *args, **kwargs):
                    """
                    Add a new object.
                    """
                    return PyMenu(self.service, "/mesh/adapt/cell_registers/add").execute(*args, **kwargs)
                def apply_poor_mesh_numerics(self, *args, **kwargs):
                    """
                    Apply poor mesh numerics to cell register objects.
                    """
                    return PyMenu(self.service, "/mesh/adapt/cell_registers/apply_poor_mesh_numerics").execute(*args, **kwargs)
                def coarsen(self, *args, **kwargs):
                    """
                    Coarsen cell register objects.
                    """
                    return PyMenu(self.service, "/mesh/adapt/cell_registers/coarsen").execute(*args, **kwargs)
                def display(self, *args, **kwargs):
                    """
                    Display cell register objects.
                    """
                    return PyMenu(self.service, "/mesh/adapt/cell_registers/display").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit an object.
                    """
                    return PyMenu(self.service, "/mesh/adapt/cell_registers/edit").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete an object.
                    """
                    return PyMenu(self.service, "/mesh/adapt/cell_registers/delete").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    List objects.
                    """
                    return PyMenu(self.service, "/mesh/adapt/cell_registers/list").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    List properties of an object.
                    """
                    return PyMenu(self.service, "/mesh/adapt/cell_registers/list_properties").execute(*args, **kwargs)
                def refine(self, *args, **kwargs):
                    """
                    Refine cell register objects.
                    """
                    return PyMenu(self.service, "/mesh/adapt/cell_registers/refine").execute(*args, **kwargs)

            class manage_criteria(metaclass=PyMenuMeta):
                """
                Manage Adaption Criteria.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def add(self, *args, **kwargs):
                    """
                    Add a new object.
                    """
                    return PyMenu(self.service, "/mesh/adapt/manage_criteria/add").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit an object.
                    """
                    return PyMenu(self.service, "/mesh/adapt/manage_criteria/edit").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete an object.
                    """
                    return PyMenu(self.service, "/mesh/adapt/manage_criteria/delete").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    List objects.
                    """
                    return PyMenu(self.service, "/mesh/adapt/manage_criteria/list").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    List properties of an object.
                    """
                    return PyMenu(self.service, "/mesh/adapt/manage_criteria/list_properties").execute(*args, **kwargs)

            class multi_layer_refinement(metaclass=PyMenuMeta):
                """
                Enter the multiple boundary layer refinement menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def refine_mesh(self, *args, **kwargs):
                    """
                    Refine the mesh for multiple boundary layers.
                    """
                    return PyMenu(self.service, "/mesh/adapt/multi_layer_refinement/refine_mesh").execute(*args, **kwargs)
                def boundary_zones(self, *args, **kwargs):
                    """
                    Specify boundary zones for refinement.
                    """
                    return PyMenu(self.service, "/mesh/adapt/multi_layer_refinement/boundary_zones").execute(*args, **kwargs)
                def layer_count(self, *args, **kwargs):
                    """
                    Specify the layer count for refinement.
                    """
                    return PyMenu(self.service, "/mesh/adapt/multi_layer_refinement/layer_count").execute(*args, **kwargs)
                def parameters(self, *args, **kwargs):
                    """
                    Specify parameters for multiple boundary layer refinement.
                    """
                    return PyMenu(self.service, "/mesh/adapt/multi_layer_refinement/parameters").execute(*args, **kwargs)

            class geometry(metaclass=PyMenuMeta):
                """
                Enter the adaption geometry menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def reconstruct_geometry(self, *args, **kwargs):
                    """
                    Enable/Disable geometry based adaption.
                    """
                    return PyMenu(self.service, "/mesh/adapt/geometry/reconstruct_geometry").execute(*args, **kwargs)
                def set_geometry_controls(self, *args, **kwargs):
                    """
                    Set geometry controls for wall zones.
                    """
                    return PyMenu(self.service, "/mesh/adapt/geometry/set_geometry_controls").execute(*args, **kwargs)

        class modify_zones(metaclass=PyMenuMeta):
            """
            Enter the modify zones menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def activate_cell_zone(self, *args, **kwargs):
                """
                Activate a cell thread.
                """
                return PyMenu(self.service, "/mesh/modify_zones/activate_cell_zone").execute(*args, **kwargs)
            def append_mesh(self, *args, **kwargs):
                """
                Append new mesh.
                """
                return PyMenu(self.service, "/mesh/modify_zones/append_mesh").execute(*args, **kwargs)
            def append_mesh_data(self, *args, **kwargs):
                """
                Append new mesh with data.
                """
                return PyMenu(self.service, "/mesh/modify_zones/append_mesh_data").execute(*args, **kwargs)
            def copy_move_cell_zone(self, *args, **kwargs):
                """
                Copy and translate or rotate a cell zone.
                """
                return PyMenu(self.service, "/mesh/modify_zones/copy_move_cell_zone").execute(*args, **kwargs)
            def create_all_shell_threads(self, *args, **kwargs):
                """
                Mark all finite thickness wall for shell creation. Shell zones will be created at the start of iterations.
                """
                return PyMenu(self.service, "/mesh/modify_zones/create_all_shell_threads").execute(*args, **kwargs)
            def deactivate_cell_zone(self, *args, **kwargs):
                """
                Deactivate cell thread.
                """
                return PyMenu(self.service, "/mesh/modify_zones/deactivate_cell_zone").execute(*args, **kwargs)
            def recreate_all_shells(self, *args, **kwargs):
                """
                Create shell on all the walls where which were deleted using the command delete-all-shells.
                """
                return PyMenu(self.service, "/mesh/modify_zones/recreate_all_shells").execute(*args, **kwargs)
            def delete_all_shells(self, *args, **kwargs):
                """
                Delete all shell zones and switch off shell conduction on all the walls. These zones can be recreated using the command recreate-all-shells.
                """
                return PyMenu(self.service, "/mesh/modify_zones/delete_all_shells").execute(*args, **kwargs)
            def delete_cell_zone(self, *args, **kwargs):
                """
                Delete a cell thread.
                """
                return PyMenu(self.service, "/mesh/modify_zones/delete_cell_zone").execute(*args, **kwargs)
            def extrude_face_zone_delta(self, *args, **kwargs):
                """
                Extrude a face thread a specified distance based on a list of deltas.
                """
                return PyMenu(self.service, "/mesh/modify_zones/extrude_face_zone_delta").execute(*args, **kwargs)
            def extrude_face_zone_para(self, *args, **kwargs):
                """
                Extrude a face thread a specified distance based on a distance and a list of parametric locations between 0 and 1 (eg. 0 0.2 0.4 0.8 1.0).
                """
                return PyMenu(self.service, "/mesh/modify_zones/extrude_face_zone_para").execute(*args, **kwargs)
            def fuse_face_zones(self, *args, **kwargs):
                """
                Attempt to fuse zones by removing duplicate faces and nodes.
                """
                return PyMenu(self.service, "/mesh/modify_zones/fuse_face_zones").execute(*args, **kwargs)
            def list_zones(self, *args, **kwargs):
                """
                List zone IDs, types, kinds, and names.
                """
                return PyMenu(self.service, "/mesh/modify_zones/list_zones").execute(*args, **kwargs)
            def make_periodic(self, *args, **kwargs):
                """
                Attempt to establish periodic/shadow face zone connectivity.
                """
                return PyMenu(self.service, "/mesh/modify_zones/make_periodic").execute(*args, **kwargs)
            def create_periodic_interface(self, *args, **kwargs):
                """
                Create a conformal or non-conformal periodic interface.
                """
                return PyMenu(self.service, "/mesh/modify_zones/create_periodic_interface").execute(*args, **kwargs)
            def scale_zone(self, *args, **kwargs):
                """
                Scale nodal coordinates of input cell zones.
                """
                return PyMenu(self.service, "/mesh/modify_zones/scale_zone").execute(*args, **kwargs)
            def rotate_zone(self, *args, **kwargs):
                """
                Rotate nodal coordinates of input cell zones.
                """
                return PyMenu(self.service, "/mesh/modify_zones/rotate_zone").execute(*args, **kwargs)
            def translate_zone(self, *args, **kwargs):
                """
                Translate nodal coordinates of input cell zones.
                """
                return PyMenu(self.service, "/mesh/modify_zones/translate_zone").execute(*args, **kwargs)
            def matching_tolerance(self, *args, **kwargs):
                """
                Set the normalized tolerance used for finding coincident nodes.
                """
                return PyMenu(self.service, "/mesh/modify_zones/matching_tolerance").execute(*args, **kwargs)
            def merge_zones(self, *args, **kwargs):
                """
                Merge zones of the same type and condition into one.
                """
                return PyMenu(self.service, "/mesh/modify_zones/merge_zones").execute(*args, **kwargs)
            def mrf_to_sliding_mesh(self, *args, **kwargs):
                """
                Change motion specification from MRF to moving mesh.
                """
                return PyMenu(self.service, "/mesh/modify_zones/mrf_to_sliding_mesh").execute(*args, **kwargs)
            def convert_all_solid_mrf_to_solid_motion(self, *args, **kwargs):
                """
                Change all solid zones motion specification from MRF to solid motion.
                """
                return PyMenu(self.service, "/mesh/modify_zones/convert_all_solid_mrf_to_solid_motion").execute(*args, **kwargs)
            def orient_face_zone(self, *args, **kwargs):
                """
                Orient the face zone.
                """
                return PyMenu(self.service, "/mesh/modify_zones/orient_face_zone").execute(*args, **kwargs)
            def replace_zone(self, *args, **kwargs):
                """
                Replace a cell zone.
                """
                return PyMenu(self.service, "/mesh/modify_zones/replace_zone").execute(*args, **kwargs)
            def sep_cell_zone_mark(self, *args, **kwargs):
                """
                Separate a cell zone based on cell marking.
                """
                return PyMenu(self.service, "/mesh/modify_zones/sep_cell_zone_mark").execute(*args, **kwargs)
            def sep_cell_zone_region(self, *args, **kwargs):
                """
                Separate a cell zone based on contiguous regions.
                """
                return PyMenu(self.service, "/mesh/modify_zones/sep_cell_zone_region").execute(*args, **kwargs)
            def sep_face_zone_angle(self, *args, **kwargs):
                """
                Separate a face zone based on significant angle.
                """
                return PyMenu(self.service, "/mesh/modify_zones/sep_face_zone_angle").execute(*args, **kwargs)
            def sep_face_zone_face(self, *args, **kwargs):
                """
                Separate each face in a zone into unique zone.
                """
                return PyMenu(self.service, "/mesh/modify_zones/sep_face_zone_face").execute(*args, **kwargs)
            def sep_face_zone_mark(self, *args, **kwargs):
                """
                Separate a face zone based on cell marking.
                """
                return PyMenu(self.service, "/mesh/modify_zones/sep_face_zone_mark").execute(*args, **kwargs)
            def sep_face_zone_region(self, *args, **kwargs):
                """
                Separate a face zone based on contiguous regions.
                """
                return PyMenu(self.service, "/mesh/modify_zones/sep_face_zone_region").execute(*args, **kwargs)
            def slit_periodic(self, *args, **kwargs):
                """
                Slit a periodic zone into two symmetry zones.
                """
                return PyMenu(self.service, "/mesh/modify_zones/slit_periodic").execute(*args, **kwargs)
            def slit_face_zone(self, *args, **kwargs):
                """
                Slit a two-sided wall into two connected wall zones.
                """
                return PyMenu(self.service, "/mesh/modify_zones/slit_face_zone").execute(*args, **kwargs)
            def slit_interior_between_diff_solids(self, *args, **kwargs):
                """
                Slit interior created between different solids into coupled walls.
                """
                return PyMenu(self.service, "/mesh/modify_zones/slit_interior_between_diff_solids").execute(*args, **kwargs)
            def zone_name(self, *args, **kwargs):
                """
                Give a zone a new name.
                """
                return PyMenu(self.service, "/mesh/modify_zones/zone_name").execute(*args, **kwargs)
            def zone_type(self, *args, **kwargs):
                """
                Set a zone's type.
                """
                return PyMenu(self.service, "/mesh/modify_zones/zone_type").execute(*args, **kwargs)
            def copy_mrf_to_mesh_motion(self, *args, **kwargs):
                """
                Copy motion variable values for origin, axis and velocities from Frame Motion to Mesh Motion.
                """
                return PyMenu(self.service, "/mesh/modify_zones/copy_mrf_to_mesh_motion").execute(*args, **kwargs)
            def copy_mesh_to_mrf_motion(self, *args, **kwargs):
                """
                Copy motion variable values for origin, axis and velocities from Mesh Motion to Frame Motion.
                """
                return PyMenu(self.service, "/mesh/modify_zones/copy_mesh_to_mrf_motion").execute(*args, **kwargs)
            def change_zone_state(self, *args, **kwargs):
                """
                Change the realgas material state for a zone.
                """
                return PyMenu(self.service, "/mesh/modify_zones/change_zone_state").execute(*args, **kwargs)
            def change_zone_phase(self, *args, **kwargs):
                """
                Change the realgas phase for a zone.
                """
                return PyMenu(self.service, "/mesh/modify_zones/change_zone_phase").execute(*args, **kwargs)

        class polyhedra(metaclass=PyMenuMeta):
            """
            Enter the polyhedra menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.options = self.__class__.options(path + [("options", None)], service)
            def convert_domain(self, *args, **kwargs):
                """
                Convert entire domain to polyhedra cells.
                """
                return PyMenu(self.service, "/mesh/polyhedra/convert_domain").execute(*args, **kwargs)
            def convert_hanging_nodes(self, *args, **kwargs):
                """
                Convert cells with hanging nodes and faces to polyhedra.
                """
                return PyMenu(self.service, "/mesh/polyhedra/convert_hanging_nodes").execute(*args, **kwargs)
            def convert_hanging_nodes_zones(self, *args, **kwargs):
                """
                Convert selected cell zones with hanging nodes and faces to polyhedra. 
                The selected cell zones cannot be connected to other zones.
                """
                return PyMenu(self.service, "/mesh/polyhedra/convert_hanging_nodes_zones").execute(*args, **kwargs)
            def convert_skewed_cells(self, *args, **kwargs):
                """
                Convert skewed cells to polyhedra.
                """
                return PyMenu(self.service, "/mesh/polyhedra/convert_skewed_cells").execute(*args, **kwargs)

            class options(metaclass=PyMenuMeta):
                """
                Enter options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def migrate_and_reorder(self, *args, **kwargs):
                    """
                    Perform migration and reordering at the end of the polyhedra conversion.
                    """
                    return PyMenu(self.service, "/mesh/polyhedra/options/migrate_and_reorder").execute(*args, **kwargs)
                def preserve_boundary_layer(self, *args, **kwargs):
                    """
                    0 = Decide at runtime.
                    1 = Never preserve.
                    2 = Always preserve.
                    """
                    return PyMenu(self.service, "/mesh/polyhedra/options/preserve_boundary_layer").execute(*args, **kwargs)
                def preserve_interior_zones(self, *args, **kwargs):
                    """
                    Interior zones with matching name pattern are preserved during polyhedra conversion.
                    """
                    return PyMenu(self.service, "/mesh/polyhedra/options/preserve_interior_zones").execute(*args, **kwargs)

        class reorder(metaclass=PyMenuMeta):
            """
            Enter the reorder domain menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def band_width(self, *args, **kwargs):
                """
                Print cell bandwidth.
                """
                return PyMenu(self.service, "/mesh/reorder/band_width").execute(*args, **kwargs)
            def reorder_domain(self, *args, **kwargs):
                """
                Reorder cells and faces by reverse Cuthill-McKee.
                """
                return PyMenu(self.service, "/mesh/reorder/reorder_domain").execute(*args, **kwargs)
            def reorder_zones(self, *args, **kwargs):
                """
                Reorder zones by partition, type, and id.
                """
                return PyMenu(self.service, "/mesh/reorder/reorder_zones").execute(*args, **kwargs)

        class repair_improve(metaclass=PyMenuMeta):
            """
            Enter the repair and improve quality menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def report_poor_elements(self, *args, **kwargs):
                """
                Report invalid and poor quality elements.
                """
                return PyMenu(self.service, "/mesh/repair_improve/report_poor_elements").execute(*args, **kwargs)
            def improve_quality(self, *args, **kwargs):
                """
                Tries to improve the mesh quality.
                """
                return PyMenu(self.service, "/mesh/repair_improve/improve_quality").execute(*args, **kwargs)
            def repair(self, *args, **kwargs):
                """
                Tries to repair mesh problems identified by mesh check.
                """
                return PyMenu(self.service, "/mesh/repair_improve/repair").execute(*args, **kwargs)
            def repair_face_handedness(self, *args, **kwargs):
                """
                Correct face handedness at left handed faces if possible.
                """
                return PyMenu(self.service, "/mesh/repair_improve/repair_face_handedness").execute(*args, **kwargs)
            def repair_face_node_order(self, *args, **kwargs):
                """
                Reverse order of face nodes if needed.
                """
                return PyMenu(self.service, "/mesh/repair_improve/repair_face_node_order").execute(*args, **kwargs)
            def repair_periodic(self, *args, **kwargs):
                """
                Modify mesh to enforce specified periodic rotation angle.
                """
                return PyMenu(self.service, "/mesh/repair_improve/repair_periodic").execute(*args, **kwargs)
            def repair_wall_distance(self, *args, **kwargs):
                """
                Correct wall distance at very high aspect ratio hexahedral/polyhedral cells.
                """
                return PyMenu(self.service, "/mesh/repair_improve/repair_wall_distance").execute(*args, **kwargs)
            def allow_repair_at_boundaries(self, *args, **kwargs):
                """
                Enable/disable adjustment of boundary nodes during mesh repair.
                """
                return PyMenu(self.service, "/mesh/repair_improve/allow_repair_at_boundaries").execute(*args, **kwargs)
            def include_local_polyhedra_conversion_in_repair(self, *args, **kwargs):
                """
                Enable/disable local conversion to polyhedra during mesh repair.
                """
                return PyMenu(self.service, "/mesh/repair_improve/include_local_polyhedra_conversion_in_repair").execute(*args, **kwargs)

        class surface_mesh(metaclass=PyMenuMeta):
            """
            Enter the surface mesh menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def delete(self, *args, **kwargs):
                """
                Delete surface mesh.
                """
                return PyMenu(self.service, "/mesh/surface_mesh/delete").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                Display surface meshes.
                """
                return PyMenu(self.service, "/mesh/surface_mesh/display").execute(*args, **kwargs)
            def read(self, *args, **kwargs):
                """
                Read surface meshes.
                """
                return PyMenu(self.service, "/mesh/surface_mesh/read").execute(*args, **kwargs)

    class parameters__and__customization(metaclass=PyMenuMeta):
        """
        Enter Parameters and custom menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
            self.parameters = self.__class__.parameters(path + [("parameters", None)], service)
            self.user_defined = self.__class__.user_defined(path + [("user_defined", None)], service)

        class parameters(metaclass=PyMenuMeta):
            """
            Enter the parameters menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.input_parameters = self.__class__.input_parameters(path + [("input_parameters", None)], service)
                self.output_parameters = self.__class__.output_parameters(path + [("output_parameters", None)], service)
                self.list_parameters = self.__class__.list_parameters(path + [("list_parameters", None)], service)
            def enable_in_TUI(self, *args, **kwargs):
                """
                Enable/disable parameters in the text user interface.
                """
                return PyMenu(self.service, "/parameters__and__customization/parameters/enable_in_TUI").execute(*args, **kwargs)

            class input_parameters(metaclass=PyMenuMeta):
                """
                Enter the input-parameters menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.advance = self.__class__.advance(path + [("advance", None)], service)
                def edit(self, *args, **kwargs):
                    """
                    Edit an input parameter.
                    """
                    return PyMenu(self.service, "/parameters__and__customization/parameters/input_parameters/edit").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete an input parameter.
                    """
                    return PyMenu(self.service, "/parameters__and__customization/parameters/input_parameters/delete").execute(*args, **kwargs)

                class advance(metaclass=PyMenuMeta):
                    """
                    Define custom variable to use input parameter.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def use_in(self, *args, **kwargs):
                        """
                        Use input parameter in solver-udf or in scheme-procedure.
                        """
                        return PyMenu(self.service, "/parameters__and__customization/parameters/input_parameters/advance/use_in").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        List of custom-input-parameters.
                        """
                        return PyMenu(self.service, "/parameters__and__customization/parameters/input_parameters/advance/list").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete selected custom-input-parameters.
                        """
                        return PyMenu(self.service, "/parameters__and__customization/parameters/input_parameters/advance/delete").execute(*args, **kwargs)

            class output_parameters(metaclass=PyMenuMeta):
                """
                Enter the output-parameters menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def create(self, *args, **kwargs):
                    """
                    Create an output parameter.
                    """
                    return PyMenu(self.service, "/parameters__and__customization/parameters/output_parameters/create").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit an output parameter.
                    """
                    return PyMenu(self.service, "/parameters__and__customization/parameters/output_parameters/edit").execute(*args, **kwargs)
                def rename(self, *args, **kwargs):
                    """
                    Rename an output parameter.
                    """
                    return PyMenu(self.service, "/parameters__and__customization/parameters/output_parameters/rename").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete an output parameter.
                    """
                    return PyMenu(self.service, "/parameters__and__customization/parameters/output_parameters/delete").execute(*args, **kwargs)
                def print_to_console(self, *args, **kwargs):
                    """
                    Print parameter value to console.
                    """
                    return PyMenu(self.service, "/parameters__and__customization/parameters/output_parameters/print_to_console").execute(*args, **kwargs)
                def print_all_to_console(self, *args, **kwargs):
                    """
                    Print all parameter values to console.
                    """
                    return PyMenu(self.service, "/parameters__and__customization/parameters/output_parameters/print_all_to_console").execute(*args, **kwargs)
                def write_to_file(self, *args, **kwargs):
                    """
                    Write parameter value to file.
                    """
                    return PyMenu(self.service, "/parameters__and__customization/parameters/output_parameters/write_to_file").execute(*args, **kwargs)
                def write_all_to_file(self, *args, **kwargs):
                    """
                    Write all parameter values to file.
                    """
                    return PyMenu(self.service, "/parameters__and__customization/parameters/output_parameters/write_all_to_file").execute(*args, **kwargs)

            class list_parameters(metaclass=PyMenuMeta):
                """
                Enter list-param menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def input_parameters(self, *args, **kwargs):
                    """
                    List all input parameters.
                    """
                    return PyMenu(self.service, "/parameters__and__customization/parameters/list_parameters/input_parameters").execute(*args, **kwargs)
                def output_parameters(self, *args, **kwargs):
                    """
                    List all output parameters.
                    """
                    return PyMenu(self.service, "/parameters__and__customization/parameters/list_parameters/output_parameters").execute(*args, **kwargs)

        class user_defined(metaclass=PyMenuMeta):
            """
            Enter the user-defined functions and scalars menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.real_gas_models = self.__class__.real_gas_models(path + [("real_gas_models", None)], service)
            def auto_compile_compiled_udfs(self, *args, **kwargs):
                """
                For this Fluent session, specify whether to allow auto-compilation of compiled UDF when a case file (or settings file) is read.
                """
                return PyMenu(self.service, "/parameters__and__customization/user_defined/auto_compile_compiled_udfs").execute(*args, **kwargs)
            def compiled_functions(self, *args, **kwargs):
                """
                Open user-defined function library.
                """
                return PyMenu(self.service, "/parameters__and__customization/user_defined/compiled_functions").execute(*args, **kwargs)
            def use_built_in_compiler(self, *args, **kwargs):
                """
                Enable/disable the use of the built-in compiler.
                """
                return PyMenu(self.service, "/parameters__and__customization/user_defined/use_built_in_compiler").execute(*args, **kwargs)
            def interpreted_functions(self, *args, **kwargs):
                """
                Load interpreted user-defined functions.
                """
                return PyMenu(self.service, "/parameters__and__customization/user_defined/interpreted_functions").execute(*args, **kwargs)
            def function_hooks(self, *args, **kwargs):
                """
                Hook up user-defined functions.
                """
                return PyMenu(self.service, "/parameters__and__customization/user_defined/function_hooks").execute(*args, **kwargs)
            def execute_on_demand(self, *args, **kwargs):
                """
                Execute UDFs on demand.
                """
                return PyMenu(self.service, "/parameters__and__customization/user_defined/execute_on_demand").execute(*args, **kwargs)
            def user_defined_memory(self, *args, **kwargs):
                """
                Allocate user-defined memory.
                """
                return PyMenu(self.service, "/parameters__and__customization/user_defined/user_defined_memory").execute(*args, **kwargs)
            def user_defined_node_memory(self, *args, **kwargs):
                """
                Allocate user-defined node memory.
                """
                return PyMenu(self.service, "/parameters__and__customization/user_defined/user_defined_node_memory").execute(*args, **kwargs)
            def use_contributed_cpp(self, *args, **kwargs):
                """
                Enable/disable use of cpp from the Fluent.Inc/contrib directory.
                """
                return PyMenu(self.service, "/parameters__and__customization/user_defined/use_contributed_cpp").execute(*args, **kwargs)
            def fan_model(self, *args, **kwargs):
                """
                Configure user-defined fan model.
                """
                return PyMenu(self.service, "/parameters__and__customization/user_defined/fan_model").execute(*args, **kwargs)
            def one_D_coupling(self, *args, **kwargs):
                """
                Load 1D library.
                """
                return PyMenu(self.service, "/parameters__and__customization/user_defined/one_D_coupling").execute(*args, **kwargs)
            def user_defined_scalars(self, *args, **kwargs):
                """
                Define user-defined scalars.
                """
                return PyMenu(self.service, "/parameters__and__customization/user_defined/user_defined_scalars").execute(*args, **kwargs)
            def enable_udf_on_gpu(self, *args, **kwargs):
                """
                Compile UDFs with OpenCL support.
                """
                return PyMenu(self.service, "/parameters__and__customization/user_defined/enable_udf_on_gpu").execute(*args, **kwargs)
            def compile_customized_addon_module(self, *args, **kwargs):
                """
                Compile customized addon module?.
                """
                return PyMenu(self.service, "/parameters__and__customization/user_defined/compile_customized_addon_module").execute(*args, **kwargs)

            class real_gas_models(metaclass=PyMenuMeta):
                """
                Enable/configure real gas model.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def nist_real_gas_model(self, *args, **kwargs):
                    """
                    Load NIST real gas library.
                    """
                    return PyMenu(self.service, "/parameters__and__customization/user_defined/real_gas_models/nist_real_gas_model").execute(*args, **kwargs)
                def nist_multispecies_real_gas_model(self, *args, **kwargs):
                    """
                    Load NIST real gas library.
                    """
                    return PyMenu(self.service, "/parameters__and__customization/user_defined/real_gas_models/nist_multispecies_real_gas_model").execute(*args, **kwargs)
                def set_state(self, *args, **kwargs):
                    """
                    Select state for NIST real gas model.
                    """
                    return PyMenu(self.service, "/parameters__and__customization/user_defined/real_gas_models/set_state").execute(*args, **kwargs)
                def nist_settings(self, *args, **kwargs):
                    """
                    Select refprop library.
                    """
                    return PyMenu(self.service, "/parameters__and__customization/user_defined/real_gas_models/nist_settings").execute(*args, **kwargs)
                def user_defined_real_gas_model(self, *args, **kwargs):
                    """
                    Load user-defined real gas library.
                    """
                    return PyMenu(self.service, "/parameters__and__customization/user_defined/real_gas_models/user_defined_real_gas_model").execute(*args, **kwargs)
                def user_defined_multispecies_real_gas_model(self, *args, **kwargs):
                    """
                    Load user-defined multispecies real gas library.
                    """
                    return PyMenu(self.service, "/parameters__and__customization/user_defined/real_gas_models/user_defined_multispecies_real_gas_model").execute(*args, **kwargs)

    class parallel(metaclass=PyMenuMeta):
        """
        Enter the parallel processing menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
            self.network = self.__class__.network(path + [("network", None)], service)
            self.partition = self.__class__.partition(path + [("partition", None)], service)
            self.set = self.__class__.set(path + [("set", None)], service)
            self.load_balance = self.__class__.load_balance(path + [("load_balance", None)], service)
            self.gpgpu = self.__class__.gpgpu(path + [("gpgpu", None)], service)
            self.timer = self.__class__.timer(path + [("timer", None)], service)
            self.multidomain = self.__class__.multidomain(path + [("multidomain", None)], service)
        def check(self, *args, **kwargs):
            """
            Parallel check.
            """
            return PyMenu(self.service, "/parallel/check").execute(*args, **kwargs)
        def check_verbosity(self, *args, **kwargs):
            """
            Set verbosity output of parallel check. Higher verbosity corresponds to more detailed information.
            """
            return PyMenu(self.service, "/parallel/check_verbosity").execute(*args, **kwargs)
        def show_connectivity(self, *args, **kwargs):
            """
            Show machine connectivity.
            """
            return PyMenu(self.service, "/parallel/show_connectivity").execute(*args, **kwargs)
        def latency(self, *args, **kwargs):
            """
            Show network latency.
            """
            return PyMenu(self.service, "/parallel/latency").execute(*args, **kwargs)
        def bandwidth(self, *args, **kwargs):
            """
            Show network bandwidth.
            """
            return PyMenu(self.service, "/parallel/bandwidth").execute(*args, **kwargs)
        def thread_number_control(self, *args, **kwargs):
            """
            Thread number control.
            """
            return PyMenu(self.service, "/parallel/thread_number_control").execute(*args, **kwargs)

        class network(metaclass=PyMenuMeta):
            """
            Enter the network configuration menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def kill_all_nodes(self, *args, **kwargs):
                """
                Delete all compute nodes from virtual machine.
                """
                return PyMenu(self.service, "/parallel/network/kill_all_nodes").execute(*args, **kwargs)
            def kill_node(self, *args, **kwargs):
                """
                Kill a compute node process specified by ID.
                """
                return PyMenu(self.service, "/parallel/network/kill_node").execute(*args, **kwargs)
            def load_hosts(self, *args, **kwargs):
                """
                Read a hosts file.
                """
                return PyMenu(self.service, "/parallel/network/load_hosts").execute(*args, **kwargs)
            def path(self, *args, **kwargs):
                """
                Set the Fluent shell script path.
                """
                return PyMenu(self.service, "/parallel/network/path").execute(*args, **kwargs)
            def save_hosts(self, *args, **kwargs):
                """
                Write a hosts file.
                """
                return PyMenu(self.service, "/parallel/network/save_hosts").execute(*args, **kwargs)
            def spawn_node(self, *args, **kwargs):
                """
                Spawn a compute node process on a specified machine.
                """
                return PyMenu(self.service, "/parallel/network/spawn_node").execute(*args, **kwargs)

        class partition(metaclass=PyMenuMeta):
            """
            Enter the partition domain menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.automatic = self.__class__.automatic(path + [("automatic", None)], service)
                self.set = self.__class__.set(path + [("set", None)], service)
            def combine_partition(self, *args, **kwargs):
                """
                Merge every N partitions.
                """
                return PyMenu(self.service, "/parallel/partition/combine_partition").execute(*args, **kwargs)
            def merge_clusters(self, *args, **kwargs):
                """
                Merge partition clusters.
                """
                return PyMenu(self.service, "/parallel/partition/merge_clusters").execute(*args, **kwargs)
            def method(self, *args, **kwargs):
                """
                Partition the domain.
                """
                return PyMenu(self.service, "/parallel/partition/method").execute(*args, **kwargs)
            def print_partitions(self, *args, **kwargs):
                """
                Print partition information.
                """
                return PyMenu(self.service, "/parallel/partition/print_partitions").execute(*args, **kwargs)
            def print_active_partitions(self, *args, **kwargs):
                """
                Print active partition information.
                """
                return PyMenu(self.service, "/parallel/partition/print_active_partitions").execute(*args, **kwargs)
            def print_stored_partitions(self, *args, **kwargs):
                """
                Print stored partition information.
                """
                return PyMenu(self.service, "/parallel/partition/print_stored_partitions").execute(*args, **kwargs)
            def reorder_partitions(self, *args, **kwargs):
                """
                Reorder partitions.
                """
                return PyMenu(self.service, "/parallel/partition/reorder_partitions").execute(*args, **kwargs)
            def reorder_partitions_to_architecture(self, *args, **kwargs):
                """
                Reorder partitions to architecture.
                """
                return PyMenu(self.service, "/parallel/partition/reorder_partitions_to_architecture").execute(*args, **kwargs)
            def smooth_partition(self, *args, **kwargs):
                """
                Smooth partition interface.
                """
                return PyMenu(self.service, "/parallel/partition/smooth_partition").execute(*args, **kwargs)
            def use_stored_partitions(self, *args, **kwargs):
                """
                Use stored partitioning.
                """
                return PyMenu(self.service, "/parallel/partition/use_stored_partitions").execute(*args, **kwargs)

            class automatic(metaclass=PyMenuMeta):
                """
                Enter the menu to set auto partition parameters.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def across_zones(self, *args, **kwargs):
                    """
                    Enable auto partitioning by zone or by domain.
                    """
                    return PyMenu(self.service, "/parallel/partition/automatic/across_zones").execute(*args, **kwargs)
                def method(self, *args, **kwargs):
                    """
                    Set the method for auto partitioning the domain.
                    """
                    return PyMenu(self.service, "/parallel/partition/automatic/method").execute(*args, **kwargs)
                def load_vector(self, *args, **kwargs):
                    """
                    Set auto the partition load vector.
                    """
                    return PyMenu(self.service, "/parallel/partition/automatic/load_vector").execute(*args, **kwargs)
                def pre_test(self, *args, **kwargs):
                    """
                    Set auto partition pre-testing optimization.
                    """
                    return PyMenu(self.service, "/parallel/partition/automatic/pre_test").execute(*args, **kwargs)
                def use_case_file_method(self, *args, **kwargs):
                    """
                    Enable the use-case-file method for auto partitioning.
                    """
                    return PyMenu(self.service, "/parallel/partition/automatic/use_case_file_method").execute(*args, **kwargs)

            class set(metaclass=PyMenuMeta):
                """
                Enter the menu to set partition parameters.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def across_zones(self, *args, **kwargs):
                    """
                    Enable partitioning by zone or by domain.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/across_zones").execute(*args, **kwargs)
                def all_off(self, *args, **kwargs):
                    """
                    Disable all optimization.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/all_off").execute(*args, **kwargs)
                def all_on(self, *args, **kwargs):
                    """
                    Enable all optimization.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/all_on").execute(*args, **kwargs)
                def cell_function(self, *args, **kwargs):
                    """
                    Set cell function.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/cell_function").execute(*args, **kwargs)
                def load_distribution(self, *args, **kwargs):
                    """
                    Set partition load vector.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/load_distribution").execute(*args, **kwargs)
                def merge(self, *args, **kwargs):
                    """
                    Set partition merging optimization.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/merge").execute(*args, **kwargs)
                def origin(self, *args, **kwargs):
                    """
                    Set coordinates of origin.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/origin").execute(*args, **kwargs)
                def pre_test(self, *args, **kwargs):
                    """
                    Set partition pre-testing optimization.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/pre_test").execute(*args, **kwargs)
                def smooth(self, *args, **kwargs):
                    """
                    Set partition smoothing optimization.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/smooth").execute(*args, **kwargs)
                def laplace_smoothing(self, *args, **kwargs):
                    """
                    Laplace smoothing for mesh with stretched cells.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/laplace_smoothing").execute(*args, **kwargs)
                def verbosity(self, *args, **kwargs):
                    """
                    Set partition print verbosity.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/verbosity").execute(*args, **kwargs)
                def nfaces_as_weights(self, *args, **kwargs):
                    """
                    Use number of faces as weights.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/nfaces_as_weights").execute(*args, **kwargs)
                def face_area_as_weights(self, *args, **kwargs):
                    """
                    Use face area as connection weights.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/face_area_as_weights").execute(*args, **kwargs)
                def stretched_mesh_enhancement(self, *args, **kwargs):
                    """
                    Enhancement for mesh with stretched cells.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/stretched_mesh_enhancement").execute(*args, **kwargs)
                def layering(self, *args, **kwargs):
                    """
                    Use layering for partitioning.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/layering").execute(*args, **kwargs)
                def solid_thread_weight(self, *args, **kwargs):
                    """
                    Use solid thread weights.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/solid_thread_weight").execute(*args, **kwargs)
                def particle_weight(self, *args, **kwargs):
                    """
                    Set DPM particle weight.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/particle_weight").execute(*args, **kwargs)
                def vof_free_surface_weight(self, *args, **kwargs):
                    """
                    Set VOF free surface weight.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/vof_free_surface_weight").execute(*args, **kwargs)
                def isat_weight(self, *args, **kwargs):
                    """
                    Set ISAT weight.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/isat_weight").execute(*args, **kwargs)
                def model_weighted_partition(self, *args, **kwargs):
                    """
                    Set model weighted partition.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/model_weighted_partition").execute(*args, **kwargs)
                def fluid_solid_rebalance_after_read_case(self, *args, **kwargs):
                    """
                    Use optimal repartitioning after reading case file with significant solid and fluid zones.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/fluid_solid_rebalance_after_read_case").execute(*args, **kwargs)
                def dpm_load_balancing(self, *args, **kwargs):
                    """
                    Enable automatic load balancing for DPM.
                    """
                    return PyMenu(self.service, "/parallel/partition/set/dpm_load_balancing").execute(*args, **kwargs)

        class set(metaclass=PyMenuMeta):
            """
            Enter the set parallel parameters menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def partition_mask(self, *args, **kwargs):
                """
                Set partition mask.
                """
                return PyMenu(self.service, "/parallel/set/partition_mask").execute(*args, **kwargs)
            def verbosity(self, *args, **kwargs):
                """
                Set the parallel verbosity.
                """
                return PyMenu(self.service, "/parallel/set/verbosity").execute(*args, **kwargs)
            def time_out(self, *args, **kwargs):
                """
                Set spawn timeout seconds.
                """
                return PyMenu(self.service, "/parallel/set/time_out").execute(*args, **kwargs)
            def fast_i(self, *args, **kwargs):
                """
                Use fast I/O option.
                """
                return PyMenu(self.service, "/parallel/set/fast_i").execute(*args, **kwargs)

        class load_balance(metaclass=PyMenuMeta):
            """
            Enter the load balancing parameters menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def physical_models(self, *args, **kwargs):
                """
                Use physical-models load balancing?.
                """
                return PyMenu(self.service, "/parallel/load_balance/physical_models").execute(*args, **kwargs)
            def dynamic_mesh(self, *args, **kwargs):
                """
                Use load balancing for dynamic mesh?.
                """
                return PyMenu(self.service, "/parallel/load_balance/dynamic_mesh").execute(*args, **kwargs)
            def mesh_adaption(self, *args, **kwargs):
                """
                Use load balancing for mesh adaption?.
                """
                return PyMenu(self.service, "/parallel/load_balance/mesh_adaption").execute(*args, **kwargs)

        class gpgpu(metaclass=PyMenuMeta):
            """
            Select and show gpgpu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def show(self, *args, **kwargs):
                """
                Show gpgpu.
                """
                return PyMenu(self.service, "/parallel/gpgpu/show").execute(*args, **kwargs)
            def select(self, *args, **kwargs):
                """
                Select gpgpu.
                """
                return PyMenu(self.service, "/parallel/gpgpu/select").execute(*args, **kwargs)

        class timer(metaclass=PyMenuMeta):
            """
            Enter the timer menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def usage(self, *args, **kwargs):
                """
                Print solver timer.
                """
                return PyMenu(self.service, "/parallel/timer/usage").execute(*args, **kwargs)
            def reset(self, *args, **kwargs):
                """
                Reset domain timers.
                """
                return PyMenu(self.service, "/parallel/timer/reset").execute(*args, **kwargs)

        class multidomain(metaclass=PyMenuMeta):
            """
            Enter the multidomain architecture menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.conjugate_heat_transfer = self.__class__.conjugate_heat_transfer(path + [("conjugate_heat_transfer", None)], service)
                self.solve = self.__class__.solve(path + [("solve", None)], service)

            class conjugate_heat_transfer(metaclass=PyMenuMeta):
                """
                Enter the conjugate heat transfer menu for multidomain simulation.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.set = self.__class__.set(path + [("set", None)], service)
                def enable(self, *args, **kwargs):
                    """
                    Enable/disable loosely coupled conjugate heat transfer.
                    """
                    return PyMenu(self.service, "/parallel/multidomain/conjugate_heat_transfer/enable").execute(*args, **kwargs)

                class set(metaclass=PyMenuMeta):
                    """
                    Enter the set menu for loosely coupled conjugate heat transfer.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def session_mode(self, *args, **kwargs):
                        """
                        Setup session mode (single/multiple) for multidomain conjugate heat transfer.
                        """
                        return PyMenu(self.service, "/parallel/multidomain/conjugate_heat_transfer/set/session_mode").execute(*args, **kwargs)
                    def coupling(self, *args, **kwargs):
                        """
                        Specify when the fluid and solid zone calculations are coupled.
                        """
                        return PyMenu(self.service, "/parallel/multidomain/conjugate_heat_transfer/set/coupling").execute(*args, **kwargs)
                    def helper_session(self, *args, **kwargs):
                        """
                        Setup helper session for multidomain conjugate heat transfer.
                        """
                        return PyMenu(self.service, "/parallel/multidomain/conjugate_heat_transfer/set/helper_session").execute(*args, **kwargs)

            class solve(metaclass=PyMenuMeta):
                """
                Enter the multi-domain simulation solver menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def iterate(self, *args, **kwargs):
                    """
                    Iteration the multidomain conjugate heat transfer.
                    """
                    return PyMenu(self.service, "/parallel/multidomain/solve/iterate").execute(*args, **kwargs)
                def dual_time_iterate(self, *args, **kwargs):
                    """
                    Dual-time iterate the multidomain conjugate heat transfer.
                    """
                    return PyMenu(self.service, "/parallel/multidomain/solve/dual_time_iterate").execute(*args, **kwargs)

    class plot(metaclass=PyMenuMeta):
        """
        Enter the XY plot menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
            self.ansys_sound_analysis = self.__class__.ansys_sound_analysis(path + [("ansys_sound_analysis", None)], service)
            self.cumulative_plot = self.__class__.cumulative_plot(path + [("cumulative_plot", None)], service)
            self.flamelet_curves = self.__class__.flamelet_curves(path + [("flamelet_curves", None)], service)
        def circum_avg_axial(self, *args, **kwargs):
            """
            Compute iso-axial band surfaces and plot data vs axial coordinate on them.
            """
            return PyMenu(self.service, "/plot/circum_avg_axial").execute(*args, **kwargs)
        def circum_avg_radial(self, *args, **kwargs):
            """
            Compute iso-radial band surfaces and plot data vs radius on them.
            """
            return PyMenu(self.service, "/plot/circum_avg_radial").execute(*args, **kwargs)
        def change_fft_ref_pressure(self, *args, **kwargs):
            """
            Change acoustic reference pressure.
            """
            return PyMenu(self.service, "/plot/change_fft_ref_pressure").execute(*args, **kwargs)
        def fft(self, *args, **kwargs):
            """
            Plot FFT of file data.
            """
            return PyMenu(self.service, "/plot/fft").execute(*args, **kwargs)
        def fft_set(self, *args, **kwargs):
            """
            Enter the menu to set histogram plot parameters.
            """
            return PyMenu(self.service, "/plot/fft_set").execute(*args, **kwargs)
        def file(self, *args, **kwargs):
            """
            Plot data from file.
            """
            return PyMenu(self.service, "/plot/file").execute(*args, **kwargs)
        def datasources(self, *args, **kwargs):
            """
            Enter the menu to set data sources.
            """
            return PyMenu(self.service, "/plot/datasources").execute(*args, **kwargs)
        def display_profile_data(self, *args, **kwargs):
            """
            Plot profile data.
            """
            return PyMenu(self.service, "/plot/display_profile_data").execute(*args, **kwargs)
        def file_list(self, *args, **kwargs):
            """
            Plot data from multiple files.
            """
            return PyMenu(self.service, "/plot/file_list").execute(*args, **kwargs)
        def file_set(self, *args, **kwargs):
            """
            Enter the menu to set file plot parameters.
            """
            return PyMenu(self.service, "/plot/file_set").execute(*args, **kwargs)
        def histogram(self, *args, **kwargs):
            """
            Plot a histogram of a specified scalar quantity.
            """
            return PyMenu(self.service, "/plot/histogram").execute(*args, **kwargs)
        def histogram_set(self, *args, **kwargs):
            """
            Enter the menu to set histogram plot parameters.
            """
            return PyMenu(self.service, "/plot/histogram_set").execute(*args, **kwargs)
        def plot(self, *args, **kwargs):
            """
            Plot solution on surfaces.
            """
            return PyMenu(self.service, "/plot/plot").execute(*args, **kwargs)
        def plot_direction(self, *args, **kwargs):
            """
            Set plot direction for xy plot.
            """
            return PyMenu(self.service, "/plot/plot_direction").execute(*args, **kwargs)
        def residuals(self, *args, **kwargs):
            """
            Plot equation residual history.
            """
            return PyMenu(self.service, "/plot/residuals").execute(*args, **kwargs)
        def residuals_set(self, *args, **kwargs):
            """
            Enter the menu to set residual plot parameters.
            """
            return PyMenu(self.service, "/plot/residuals_set").execute(*args, **kwargs)
        def solution(self, *args, **kwargs):
            """
            Plot solution on surfaces and/or zones.
            """
            return PyMenu(self.service, "/plot/solution").execute(*args, **kwargs)
        def solution_set(self, *args, **kwargs):
            """
            Enter the menu to set solution plot parameters.
            """
            return PyMenu(self.service, "/plot/solution_set").execute(*args, **kwargs)
        def set_boundary_val_off(self, *args, **kwargs):
            """
            Set boundary value off when node values off for XY/Solution Plot.
                   
             Note: This setting is valid for current Fluent session only.
            """
            return PyMenu(self.service, "/plot/set_boundary_val_off").execute(*args, **kwargs)
        def label_alignment(self, *args, **kwargs):
            """
            Set the alignment of xy plot label to horizontal or axis aligned.
            """
            return PyMenu(self.service, "/plot/label_alignment").execute(*args, **kwargs)

        class ansys_sound_analysis(metaclass=PyMenuMeta):
            """
            Ansys Sound analysis and specification.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def write_files(self, *args, **kwargs):
                """
                Write Ansys Sound out files.
                """
                return PyMenu(self.service, "/plot/ansys_sound_analysis/write_files").execute(*args, **kwargs)
            def print_indicators(self, *args, **kwargs):
                """
                Print Ansys Sound indicators.
                """
                return PyMenu(self.service, "/plot/ansys_sound_analysis/print_indicators").execute(*args, **kwargs)

        class cumulative_plot(metaclass=PyMenuMeta):
            """
            Plot Cumulative Force and Moments.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def add(self, *args, **kwargs):
                """
                Add a new object.
                """
                return PyMenu(self.service, "/plot/cumulative_plot/add").execute(*args, **kwargs)
            def axes(self, *args, **kwargs):
                """
                Set axes options of an object.
                """
                return PyMenu(self.service, "/plot/cumulative_plot/axes").execute(*args, **kwargs)
            def curves(self, *args, **kwargs):
                """
                Set curves options of an object.
                """
                return PyMenu(self.service, "/plot/cumulative_plot/curves").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an object.
                """
                return PyMenu(self.service, "/plot/cumulative_plot/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an object.
                """
                return PyMenu(self.service, "/plot/cumulative_plot/delete").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List objects.
                """
                return PyMenu(self.service, "/plot/cumulative_plot/list").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                List properties of an object.
                """
                return PyMenu(self.service, "/plot/cumulative_plot/list_properties").execute(*args, **kwargs)
            def plot(self, *args, **kwargs):
                """
                Plot the Cumulative Forces/Moments.
                """
                return PyMenu(self.service, "/plot/cumulative_plot/plot").execute(*args, **kwargs)
            def print(self, *args, **kwargs):
                """
                Print the Cumulative Forces/Moments.
                """
                return PyMenu(self.service, "/plot/cumulative_plot/print").execute(*args, **kwargs)
            def write(self, *args, **kwargs):
                """
                Write the Cumulative Forces/Moments.
                """
                return PyMenu(self.service, "/plot/cumulative_plot/write").execute(*args, **kwargs)

        class flamelet_curves(metaclass=PyMenuMeta):
            """
            Plot flamelet curves.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def write_to_file(self, *args, **kwargs):
                """
                Write curve to a file instead of plot.
                """
                return PyMenu(self.service, "/plot/flamelet_curves/write_to_file").execute(*args, **kwargs)
            def plot_curves(self, *args, **kwargs):
                """
                Plot of a property.
                """
                return PyMenu(self.service, "/plot/flamelet_curves/plot_curves").execute(*args, **kwargs)

    class preferences(metaclass=PyMenuMeta):
        """
        Set preferences.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
            self.appearance = self.__class__.appearance(path + [("appearance", None)], service)
            self.general = self.__class__.general(path + [("general", None)], service)
            self.gpuapp = self.__class__.gpuapp(path + [("gpuapp", None)], service)
            self.graphics = self.__class__.graphics(path + [("graphics", None)], service)
            self.mat_pro_app = self.__class__.mat_pro_app(path + [("mat_pro_app", None)], service)
            self.meshing_workflow = self.__class__.meshing_workflow(path + [("meshing_workflow", None)], service)
            self.navigation = self.__class__.navigation(path + [("navigation", None)], service)
            self.prj_app = self.__class__.prj_app(path + [("prj_app", None)], service)
            self.simulation = self.__class__.simulation(path + [("simulation", None)], service)
            self.turbo_workflow = self.__class__.turbo_workflow(path + [("turbo_workflow", None)], service)

        class appearance(metaclass=PyMenuMeta):
            """
            .
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.ansys_logo = self.__class__.ansys_logo(path + [("ansys_logo", None)], service)
                self.charts = self.__class__.charts(path + [("charts", None)], service)
                self.selections = self.__class__.selections(path + [("selections", None)], service)
            def application_font_size(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/application_font_size").execute(*args, **kwargs)
            def axis_triad(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/axis_triad").execute(*args, **kwargs)
            def color_theme(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/color_theme").execute(*args, **kwargs)
            def completer(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/completer").execute(*args, **kwargs)
            def custom_title_bar(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/custom_title_bar").execute(*args, **kwargs)
            def default_view(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/default_view").execute(*args, **kwargs)
            def graphics_background_color1(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/graphics_background_color1").execute(*args, **kwargs)
            def graphics_background_color2(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/graphics_background_color2").execute(*args, **kwargs)
            def graphics_background_style(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/graphics_background_style").execute(*args, **kwargs)
            def graphics_color_theme(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/graphics_color_theme").execute(*args, **kwargs)
            def graphics_default_manual_face_color(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/graphics_default_manual_face_color").execute(*args, **kwargs)
            def graphics_default_manual_node_color(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/graphics_default_manual_node_color").execute(*args, **kwargs)
            def graphics_edge_color(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/graphics_edge_color").execute(*args, **kwargs)
            def graphics_foreground_color(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/graphics_foreground_color").execute(*args, **kwargs)
            def graphics_partition_boundary_color(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/graphics_partition_boundary_color").execute(*args, **kwargs)
            def graphics_surface_color(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/graphics_surface_color").execute(*args, **kwargs)
            def graphics_title_window_framecolor(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/graphics_title_window_framecolor").execute(*args, **kwargs)
            def graphics_view(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/graphics_view").execute(*args, **kwargs)
            def graphics_wall_face_color(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/graphics_wall_face_color").execute(*args, **kwargs)
            def group_by_tree_view(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/group_by_tree_view").execute(*args, **kwargs)
            def model_color_scheme(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/model_color_scheme").execute(*args, **kwargs)
            def number_of_files_recently_used(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/number_of_files_recently_used").execute(*args, **kwargs)
            def number_of_pastel_colors(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/number_of_pastel_colors").execute(*args, **kwargs)
            def pastel_color_saturation(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/pastel_color_saturation").execute(*args, **kwargs)
            def pastel_color_value(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/pastel_color_value").execute(*args, **kwargs)
            def quick_property_view(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/quick_property_view").execute(*args, **kwargs)
            def ruler(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/ruler").execute(*args, **kwargs)
            def show_enabled_models(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/show_enabled_models").execute(*args, **kwargs)
            def show_interface_children_zone(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/show_interface_children_zone").execute(*args, **kwargs)
            def show_model_edges(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/show_model_edges").execute(*args, **kwargs)
            def solution_mode_edge_color_in_meshing_mode(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/solution_mode_edge_color_in_meshing_mode").execute(*args, **kwargs)
            def startup_page(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/startup_page").execute(*args, **kwargs)
            def surface_emissivity(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/surface_emissivity").execute(*args, **kwargs)
            def surface_specularity(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/surface_specularity").execute(*args, **kwargs)
            def surface_specularity_for_contours(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/surface_specularity_for_contours").execute(*args, **kwargs)
            def titles(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/titles").execute(*args, **kwargs)
            def titles_border_offset(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/appearance/titles_border_offset").execute(*args, **kwargs)

            class ansys_logo(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def color(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/ansys_logo/color").execute(*args, **kwargs)
                def visible(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/ansys_logo/visible").execute(*args, **kwargs)

            class charts(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.font = self.__class__.font(path + [("font", None)], service)
                    self.text_color = self.__class__.text_color(path + [("text_color", None)], service)
                def curve_colors(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/charts/curve_colors").execute(*args, **kwargs)
                def enable_open_glfor_modern_plots(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/charts/enable_open_glfor_modern_plots").execute(*args, **kwargs)
                def legend_alignment(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/charts/legend_alignment").execute(*args, **kwargs)
                def legend_visibility(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/charts/legend_visibility").execute(*args, **kwargs)
                def modern_plots_enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/charts/modern_plots_enabled").execute(*args, **kwargs)
                def modern_plots_points_threshold(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/charts/modern_plots_points_threshold").execute(*args, **kwargs)
                def plots_behavior(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/charts/plots_behavior").execute(*args, **kwargs)
                def print_plot_data(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/charts/print_plot_data").execute(*args, **kwargs)
                def print_residuals_data(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/charts/print_residuals_data").execute(*args, **kwargs)
                def threshold(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/charts/threshold").execute(*args, **kwargs)

                class font(metaclass=PyMenuMeta):
                    """
                    .
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def axes(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/appearance/charts/font/axes").execute(*args, **kwargs)
                    def axes_titles(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/appearance/charts/font/axes_titles").execute(*args, **kwargs)
                    def legend(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/appearance/charts/font/legend").execute(*args, **kwargs)
                    def title(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/appearance/charts/font/title").execute(*args, **kwargs)

                class text_color(metaclass=PyMenuMeta):
                    """
                    .
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def axes(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/appearance/charts/text_color/axes").execute(*args, **kwargs)
                    def axes_titles(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/appearance/charts/text_color/axes_titles").execute(*args, **kwargs)
                    def legend(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/appearance/charts/text_color/legend").execute(*args, **kwargs)
                    def title(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/appearance/charts/text_color/title").execute(*args, **kwargs)

            class selections(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def general_displacement(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/selections/general_displacement").execute(*args, **kwargs)
                def highlight_edge_color(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/selections/highlight_edge_color").execute(*args, **kwargs)
                def highlight_edge_weight(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/selections/highlight_edge_weight").execute(*args, **kwargs)
                def highlight_face_color(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/selections/highlight_face_color").execute(*args, **kwargs)
                def highlight_gloss(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/selections/highlight_gloss").execute(*args, **kwargs)
                def highlight_specular_component(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/selections/highlight_specular_component").execute(*args, **kwargs)
                def highlight_transparency(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/selections/highlight_transparency").execute(*args, **kwargs)
                def mouse_hover_probe_values_enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/selections/mouse_hover_probe_values_enabled").execute(*args, **kwargs)
                def mouse_over_highlight_enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/selections/mouse_over_highlight_enabled").execute(*args, **kwargs)
                def probe_tooltip_hide_delay_timer(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/selections/probe_tooltip_hide_delay_timer").execute(*args, **kwargs)
                def probe_tooltip_show_delay_timer(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/appearance/selections/probe_tooltip_show_delay_timer").execute(*args, **kwargs)

        class general(metaclass=PyMenuMeta):
            """
            .
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def advanced_partition(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/general/advanced_partition").execute(*args, **kwargs)
            def automatic_transcript(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/general/automatic_transcript").execute(*args, **kwargs)
            def default_ioformat(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/general/default_ioformat").execute(*args, **kwargs)
            def dock_editor(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/general/dock_editor").execute(*args, **kwargs)
            def enable_parametric_study(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/general/enable_parametric_study").execute(*args, **kwargs)
            def flow_model(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/general/flow_model").execute(*args, **kwargs)
            def idle_timeout(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/general/idle_timeout").execute(*args, **kwargs)
            def key_behavioral_changes_message(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/general/key_behavioral_changes_message").execute(*args, **kwargs)
            def qaservice_message(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/general/qaservice_message").execute(*args, **kwargs)
            def utlcreate_physics_on_mode_change(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/general/utlcreate_physics_on_mode_change").execute(*args, **kwargs)
            def utlmode(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/general/utlmode").execute(*args, **kwargs)

        class gpuapp(metaclass=PyMenuMeta):
            """
            .
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def alpha_features(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/gpuapp/alpha_features").execute(*args, **kwargs)

        class graphics(metaclass=PyMenuMeta):
            """
            .
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.boundary_markers = self.__class__.boundary_markers(path + [("boundary_markers", None)], service)
                self.colormap_settings = self.__class__.colormap_settings(path + [("colormap_settings", None)], service)
                self.embedded_windows = self.__class__.embedded_windows(path + [("embedded_windows", None)], service)
                self.export_video_settings = self.__class__.export_video_settings(path + [("export_video_settings", None)], service)
                self.graphics_effects = self.__class__.graphics_effects(path + [("graphics_effects", None)], service)
                self.hardcopy_settings = self.__class__.hardcopy_settings(path + [("hardcopy_settings", None)], service)
                self.lighting = self.__class__.lighting(path + [("lighting", None)], service)
                self.manage_hoops_memory = self.__class__.manage_hoops_memory(path + [("manage_hoops_memory", None)], service)
                self.material_effects = self.__class__.material_effects(path + [("material_effects", None)], service)
                self.meshing_mode = self.__class__.meshing_mode(path + [("meshing_mode", None)], service)
                self.performance = self.__class__.performance(path + [("performance", None)], service)
                self.transparency = self.__class__.transparency(path + [("transparency", None)], service)
                self.vector_settings = self.__class__.vector_settings(path + [("vector_settings", None)], service)
            def animation_option(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/animation_option").execute(*args, **kwargs)
            def double_buffering(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/double_buffering").execute(*args, **kwargs)
            def enable_non_object_based_workflow(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/enable_non_object_based_workflow").execute(*args, **kwargs)
            def event_poll_interval(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/event_poll_interval").execute(*args, **kwargs)
            def event_poll_timeout(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/event_poll_timeout").execute(*args, **kwargs)
            def force_key_frame_animation_markers_to_off(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/force_key_frame_animation_markers_to_off").execute(*args, **kwargs)
            def graphics_window_line_width(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/graphics_window_line_width").execute(*args, **kwargs)
            def graphics_window_point_symbol(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/graphics_window_point_symbol").execute(*args, **kwargs)
            def hidden_surface_removal_method(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/hidden_surface_removal_method").execute(*args, **kwargs)
            def higher_resolution_graphics_window_line_width(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/higher_resolution_graphics_window_line_width").execute(*args, **kwargs)
            def lower_resolution_graphics_window_line_width(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/lower_resolution_graphics_window_line_width").execute(*args, **kwargs)
            def marker_drawing_mode(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/marker_drawing_mode").execute(*args, **kwargs)
            def max_graphics_text_size(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/max_graphics_text_size").execute(*args, **kwargs)
            def min_graphics_text_size(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/min_graphics_text_size").execute(*args, **kwargs)
            def plot_legend_margin(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/plot_legend_margin").execute(*args, **kwargs)
            def point_tool_size(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/point_tool_size").execute(*args, **kwargs)
            def remove_partition_lines(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/remove_partition_lines").execute(*args, **kwargs)
            def remove_partition_lines_tolerance(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/remove_partition_lines_tolerance").execute(*args, **kwargs)
            def rotation_centerpoint_visible(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/rotation_centerpoint_visible").execute(*args, **kwargs)
            def scroll_wheel_event_end_timer(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/scroll_wheel_event_end_timer").execute(*args, **kwargs)
            def set_camera_normal_to_surface_increments(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/set_camera_normal_to_surface_increments").execute(*args, **kwargs)
            def show_hidden_lines(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/show_hidden_lines").execute(*args, **kwargs)
            def show_hidden_surfaces(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/show_hidden_surfaces").execute(*args, **kwargs)
            def switch_to_open_glfor_remote_visualization(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/switch_to_open_glfor_remote_visualization").execute(*args, **kwargs)
            def test_use_external_function(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/test_use_external_function").execute(*args, **kwargs)
            def text_window_line_width(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/graphics/text_window_line_width").execute(*args, **kwargs)

            class boundary_markers(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def color_option(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/boundary_markers/color_option").execute(*args, **kwargs)
                def enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/boundary_markers/enabled").execute(*args, **kwargs)
                def exclude_from_bounding(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/boundary_markers/exclude_from_bounding").execute(*args, **kwargs)
                def inlet_color(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/boundary_markers/inlet_color").execute(*args, **kwargs)
                def marker_fraction(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/boundary_markers/marker_fraction").execute(*args, **kwargs)
                def marker_size_limiting_scale_multiplier(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/boundary_markers/marker_size_limiting_scale_multiplier").execute(*args, **kwargs)
                def markers_limit(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/boundary_markers/markers_limit").execute(*args, **kwargs)
                def outlet_color(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/boundary_markers/outlet_color").execute(*args, **kwargs)
                def scale_marker(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/boundary_markers/scale_marker").execute(*args, **kwargs)
                def show_inlet_markers(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/boundary_markers/show_inlet_markers").execute(*args, **kwargs)
                def show_outlet_markers(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/boundary_markers/show_outlet_markers").execute(*args, **kwargs)

            class colormap_settings(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def alignment(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/alignment").execute(*args, **kwargs)
                def aspect_ratio_when_horizontal(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/aspect_ratio_when_horizontal").execute(*args, **kwargs)
                def aspect_ratio_when_vertical(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/aspect_ratio_when_vertical").execute(*args, **kwargs)
                def auto_refit_on_resize(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/auto_refit_on_resize").execute(*args, **kwargs)
                def automatic_resize(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/automatic_resize").execute(*args, **kwargs)
                def border_style(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/border_style").execute(*args, **kwargs)
                def colormap(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/colormap").execute(*args, **kwargs)
                def isolines_position_offset(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/isolines_position_offset").execute(*args, **kwargs)
                def labels(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/labels").execute(*args, **kwargs)
                def levels(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/levels").execute(*args, **kwargs)
                def log_scale(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/log_scale").execute(*args, **kwargs)
                def major_length_to_screen_ratio_when_horizontal(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/major_length_to_screen_ratio_when_horizontal").execute(*args, **kwargs)
                def major_length_to_screen_ratio_when_vertical(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/major_length_to_screen_ratio_when_vertical").execute(*args, **kwargs)
                def margin_from_edge_to_screen_ratio(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/margin_from_edge_to_screen_ratio").execute(*args, **kwargs)
                def max_size_scale_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/max_size_scale_factor").execute(*args, **kwargs)
                def min_size_scale_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/min_size_scale_factor").execute(*args, **kwargs)
                def number_format_precision(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/number_format_precision").execute(*args, **kwargs)
                def number_format_type(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/number_format_type").execute(*args, **kwargs)
                def show_colormap(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/show_colormap").execute(*args, **kwargs)
                def skip_value(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/skip_value").execute(*args, **kwargs)
                def text_behavior(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/text_behavior").execute(*args, **kwargs)
                def text_font_automatic_horizontal_size(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/text_font_automatic_horizontal_size").execute(*args, **kwargs)
                def text_font_automatic_size(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/text_font_automatic_size").execute(*args, **kwargs)
                def text_font_automatic_units(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/text_font_automatic_units").execute(*args, **kwargs)
                def text_font_automatic_vertical_size(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/text_font_automatic_vertical_size").execute(*args, **kwargs)
                def text_font_fixed_horizontal_size(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/text_font_fixed_horizontal_size").execute(*args, **kwargs)
                def text_font_fixed_size(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/text_font_fixed_size").execute(*args, **kwargs)
                def text_font_fixed_units(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/text_font_fixed_units").execute(*args, **kwargs)
                def text_font_fixed_vertical_size(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/text_font_fixed_vertical_size").execute(*args, **kwargs)
                def text_font_name(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/text_font_name").execute(*args, **kwargs)
                def text_truncation_limit_for_horizontal_colormaps(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/text_truncation_limit_for_horizontal_colormaps").execute(*args, **kwargs)
                def text_truncation_limit_for_vertical_colormaps(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/text_truncation_limit_for_vertical_colormaps").execute(*args, **kwargs)
                def type(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/type").execute(*args, **kwargs)
                def use_no_sub_windows(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/colormap_settings/use_no_sub_windows").execute(*args, **kwargs)

            class embedded_windows(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def default_embedded_mesh_windows_view(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/embedded_windows/default_embedded_mesh_windows_view").execute(*args, **kwargs)
                def default_embedded_windows_view(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/embedded_windows/default_embedded_windows_view").execute(*args, **kwargs)
                def save_embedded_window_layout(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/embedded_windows/save_embedded_window_layout").execute(*args, **kwargs)
                def show_border_for_embedded_window(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/embedded_windows/show_border_for_embedded_window").execute(*args, **kwargs)

            class export_video_settings(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.advanced_video_quality_options = self.__class__.advanced_video_quality_options(path + [("advanced_video_quality_options", None)], service)
                def video_format(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/export_video_settings/video_format").execute(*args, **kwargs)
                def video_fps(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/export_video_settings/video_fps").execute(*args, **kwargs)
                def video_quality(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/export_video_settings/video_quality").execute(*args, **kwargs)
                def video_resoution_x(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/export_video_settings/video_resoution_x").execute(*args, **kwargs)
                def video_resoution_y(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/export_video_settings/video_resoution_y").execute(*args, **kwargs)
                def video_scale(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/export_video_settings/video_scale").execute(*args, **kwargs)
                def video_smooth_scaling(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/export_video_settings/video_smooth_scaling").execute(*args, **kwargs)
                def video_use_frame_resolution(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/export_video_settings/video_use_frame_resolution").execute(*args, **kwargs)

                class advanced_video_quality_options(metaclass=PyMenuMeta):
                    """
                    .
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def bit_rate_quality(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/export_video_settings/advanced_video_quality_options/bit_rate_quality").execute(*args, **kwargs)
                    def bitrate(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/export_video_settings/advanced_video_quality_options/bitrate").execute(*args, **kwargs)
                    def compression_method(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/export_video_settings/advanced_video_quality_options/compression_method").execute(*args, **kwargs)
                    def enable_h264(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/export_video_settings/advanced_video_quality_options/enable_h264").execute(*args, **kwargs)
                    def key_frames(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/export_video_settings/advanced_video_quality_options/key_frames").execute(*args, **kwargs)

            class graphics_effects(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def ambient_occlusion_enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/ambient_occlusion_enabled").execute(*args, **kwargs)
                def ambient_occlusion_quality(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/ambient_occlusion_quality").execute(*args, **kwargs)
                def ambient_occlusion_strength(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/ambient_occlusion_strength").execute(*args, **kwargs)
                def anti_aliasing(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/anti_aliasing").execute(*args, **kwargs)
                def bloom_blur(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/bloom_blur").execute(*args, **kwargs)
                def bloom_enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/bloom_enabled").execute(*args, **kwargs)
                def bloom_strength(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/bloom_strength").execute(*args, **kwargs)
                def grid_color(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/grid_color").execute(*args, **kwargs)
                def grid_plane_count(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/grid_plane_count").execute(*args, **kwargs)
                def grid_plane_enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/grid_plane_enabled").execute(*args, **kwargs)
                def grid_plane_offset(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/grid_plane_offset").execute(*args, **kwargs)
                def grid_plane_size_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/grid_plane_size_factor").execute(*args, **kwargs)
                def plane_direction(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/plane_direction").execute(*args, **kwargs)
                def reflections_enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/reflections_enabled").execute(*args, **kwargs)
                def shadow_map_enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/shadow_map_enabled").execute(*args, **kwargs)
                def show_edge_reflections(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/show_edge_reflections").execute(*args, **kwargs)
                def show_marker_reflections(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/show_marker_reflections").execute(*args, **kwargs)
                def simple_shadows_enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/simple_shadows_enabled").execute(*args, **kwargs)
                def update_after_mouse_release(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/graphics_effects/update_after_mouse_release").execute(*args, **kwargs)

            class hardcopy_settings(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def export_edges_for_avz(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/hardcopy_settings/export_edges_for_avz").execute(*args, **kwargs)
                def hardcopy_driver(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/hardcopy_settings/hardcopy_driver").execute(*args, **kwargs)
                def hardcopy_line_width(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/hardcopy_settings/hardcopy_line_width").execute(*args, **kwargs)
                def hardware_image_accel(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/hardcopy_settings/hardware_image_accel").execute(*args, **kwargs)
                def post_script_permission_override(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/hardcopy_settings/post_script_permission_override").execute(*args, **kwargs)
                def save_embedded_hardcopies_separately(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/hardcopy_settings/save_embedded_hardcopies_separately").execute(*args, **kwargs)
                def save_embedded_windows_in_hardcopy(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/hardcopy_settings/save_embedded_windows_in_hardcopy").execute(*args, **kwargs)
                def transparent_embedded_windows(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/hardcopy_settings/transparent_embedded_windows").execute(*args, **kwargs)

            class lighting(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def ambient_light_intensity(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/lighting/ambient_light_intensity").execute(*args, **kwargs)
                def headlight(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/lighting/headlight").execute(*args, **kwargs)
                def headlight_intensity(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/lighting/headlight_intensity").execute(*args, **kwargs)
                def lighting_method(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/lighting/lighting_method").execute(*args, **kwargs)

            class manage_hoops_memory(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def enabled(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/manage_hoops_memory/enabled").execute(*args, **kwargs)
                def hsfimport_limit(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/manage_hoops_memory/hsfimport_limit").execute(*args, **kwargs)

            class material_effects(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def decimation_filter(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/material_effects/decimation_filter").execute(*args, **kwargs)
                def parameterization_source(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/material_effects/parameterization_source").execute(*args, **kwargs)
                def tiling_style(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/material_effects/tiling_style").execute(*args, **kwargs)

            class meshing_mode(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def graphics_window_display_timeout(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/meshing_mode/graphics_window_display_timeout").execute(*args, **kwargs)
                def graphics_window_display_timeout_value(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/meshing_mode/graphics_window_display_timeout_value").execute(*args, **kwargs)

            class performance(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.fast_display_mode = self.__class__.fast_display_mode(path + [("fast_display_mode", None)], service)
                    self.minimum_frame_rate = self.__class__.minimum_frame_rate(path + [("minimum_frame_rate", None)], service)
                def optimize_for(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/performance/optimize_for").execute(*args, **kwargs)
                def ratio_of_target_frame_rate_to_classify_heavy_geometry(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/performance/ratio_of_target_frame_rate_to_classify_heavy_geometry").execute(*args, **kwargs)
                def ratio_of_target_frame_rate_to_declassify_heavy_geometry(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/performance/ratio_of_target_frame_rate_to_declassify_heavy_geometry").execute(*args, **kwargs)

                class fast_display_mode(metaclass=PyMenuMeta):
                    """
                    .
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def culling(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/performance/fast_display_mode/culling").execute(*args, **kwargs)
                    def faces_shown(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/performance/fast_display_mode/faces_shown").execute(*args, **kwargs)
                    def markers_decimation(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/performance/fast_display_mode/markers_decimation").execute(*args, **kwargs)
                    def nodes_shown(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/performance/fast_display_mode/nodes_shown").execute(*args, **kwargs)
                    def perimeter_edges_shown(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/performance/fast_display_mode/perimeter_edges_shown").execute(*args, **kwargs)
                    def silhouette_shown(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/performance/fast_display_mode/silhouette_shown").execute(*args, **kwargs)
                    def status(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/performance/fast_display_mode/status").execute(*args, **kwargs)
                    def transparency(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/performance/fast_display_mode/transparency").execute(*args, **kwargs)

                class minimum_frame_rate(metaclass=PyMenuMeta):
                    """
                    .
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def dynamic_adjustment(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/performance/minimum_frame_rate/dynamic_adjustment").execute(*args, **kwargs)
                    def enabled(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/performance/minimum_frame_rate/enabled").execute(*args, **kwargs)
                    def fixed_culling_value(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/performance/minimum_frame_rate/fixed_culling_value").execute(*args, **kwargs)
                    def maximum_culling_threshold(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/performance/minimum_frame_rate/maximum_culling_threshold").execute(*args, **kwargs)
                    def minimum_culling_threshold(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/performance/minimum_frame_rate/minimum_culling_threshold").execute(*args, **kwargs)
                    def target_fps(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/graphics/performance/minimum_frame_rate/target_fps").execute(*args, **kwargs)

            class transparency(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def algorithm_for_modern_drivers(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/transparency/algorithm_for_modern_drivers").execute(*args, **kwargs)
                def depth_peeling_layers(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/transparency/depth_peeling_layers").execute(*args, **kwargs)
                def depth_peeling_preference(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/transparency/depth_peeling_preference").execute(*args, **kwargs)
                def quick_moves(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/transparency/quick_moves").execute(*args, **kwargs)
                def zsort_options(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/transparency/zsort_options").execute(*args, **kwargs)

            class vector_settings(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def arrow3_dradius1_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/vector_settings/arrow3_dradius1_factor").execute(*args, **kwargs)
                def arrow3_dradius2_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/vector_settings/arrow3_dradius2_factor").execute(*args, **kwargs)
                def arrowhead3_dradius1_factor(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/vector_settings/arrowhead3_dradius1_factor").execute(*args, **kwargs)
                def line_arrow3_dperpendicular_radius(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/graphics/vector_settings/line_arrow3_dperpendicular_radius").execute(*args, **kwargs)

        class mat_pro_app(metaclass=PyMenuMeta):
            """
            .
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def beta_features(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/mat_pro_app/beta_features").execute(*args, **kwargs)
            def focus(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/mat_pro_app/focus").execute(*args, **kwargs)
            def warning(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/mat_pro_app/warning").execute(*args, **kwargs)

        class meshing_workflow(metaclass=PyMenuMeta):
            """
            .
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.draw_settings = self.__class__.draw_settings(path + [("draw_settings", None)], service)
            def checkpointing_option(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/meshing_workflow/checkpointing_option").execute(*args, **kwargs)
            def save_checkpoint_files(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/meshing_workflow/save_checkpoint_files").execute(*args, **kwargs)
            def temp_folder(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/meshing_workflow/temp_folder").execute(*args, **kwargs)
            def templates_folder(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/meshing_workflow/templates_folder").execute(*args, **kwargs)
            def verbosity(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/meshing_workflow/verbosity").execute(*args, **kwargs)

            class draw_settings(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def auto_draw(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/meshing_workflow/draw_settings/auto_draw").execute(*args, **kwargs)
                def face_zone_limit(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/meshing_workflow/draw_settings/face_zone_limit").execute(*args, **kwargs)
                def facet_limit(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/meshing_workflow/draw_settings/facet_limit").execute(*args, **kwargs)

        class navigation(metaclass=PyMenuMeta):
            """
            .
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.mouse_mapping = self.__class__.mouse_mapping(path + [("mouse_mapping", None)], service)

            class mouse_mapping(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.additional = self.__class__.additional(path + [("additional", None)], service)
                    self.basic = self.__class__.basic(path + [("basic", None)], service)
                def mousemaptheme(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/navigation/mouse_mapping/mousemaptheme").execute(*args, **kwargs)

                class additional(metaclass=PyMenuMeta):
                    """
                    .
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def ctrllmbclick(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/additional/ctrllmbclick").execute(*args, **kwargs)
                    def ctrllmbdrag(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/additional/ctrllmbdrag").execute(*args, **kwargs)
                    def ctrlmmbclick(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/additional/ctrlmmbclick").execute(*args, **kwargs)
                    def ctrlmmbdrag(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/additional/ctrlmmbdrag").execute(*args, **kwargs)
                    def ctrlrmbclick(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/additional/ctrlrmbclick").execute(*args, **kwargs)
                    def ctrlrmbdrag(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/additional/ctrlrmbdrag").execute(*args, **kwargs)
                    def mouseprobe(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/additional/mouseprobe").execute(*args, **kwargs)
                    def mousewheel(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/additional/mousewheel").execute(*args, **kwargs)
                    def mousewheelsensitivity(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/additional/mousewheelsensitivity").execute(*args, **kwargs)
                    def reversewheeldirection(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/additional/reversewheeldirection").execute(*args, **kwargs)
                    def shiftlmbclick(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/additional/shiftlmbclick").execute(*args, **kwargs)
                    def shiftlmbdrag(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/additional/shiftlmbdrag").execute(*args, **kwargs)
                    def shiftmmbclick(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/additional/shiftmmbclick").execute(*args, **kwargs)
                    def shiftmmbdrag(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/additional/shiftmmbdrag").execute(*args, **kwargs)
                    def shiftrmbclick(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/additional/shiftrmbclick").execute(*args, **kwargs)
                    def shiftrmbdrag(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/additional/shiftrmbdrag").execute(*args, **kwargs)

                class basic(metaclass=PyMenuMeta):
                    """
                    .
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def lmb(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/basic/lmb").execute(*args, **kwargs)
                    def lmbclick(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/basic/lmbclick").execute(*args, **kwargs)
                    def mmb(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/basic/mmb").execute(*args, **kwargs)
                    def mmbclick(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/basic/mmbclick").execute(*args, **kwargs)
                    def rmb(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/basic/rmb").execute(*args, **kwargs)
                    def rmbclick(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/preferences/navigation/mouse_mapping/basic/rmbclick").execute(*args, **kwargs)

        class prj_app(metaclass=PyMenuMeta):
            """
            .
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def advanced_flag(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/prj_app/advanced_flag").execute(*args, **kwargs)
            def beta_flag(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/prj_app/beta_flag").execute(*args, **kwargs)
            def cffoutput(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/prj_app/cffoutput").execute(*args, **kwargs)
            def default_folder(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/prj_app/default_folder").execute(*args, **kwargs)
            def display_mesh_after_case_load(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/prj_app/display_mesh_after_case_load").execute(*args, **kwargs)
            def multi_console(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/prj_app/multi_console").execute(*args, **kwargs)
            def ncpu(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/prj_app/ncpu").execute(*args, **kwargs)
            def session_color(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/prj_app/session_color").execute(*args, **kwargs)
            def show_fluent_window(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/prj_app/show_fluent_window").execute(*args, **kwargs)
            def use_default_folder(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/prj_app/use_default_folder").execute(*args, **kwargs)
            def use_fluent_graphics(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/prj_app/use_fluent_graphics").execute(*args, **kwargs)
            def use_launcher(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/prj_app/use_launcher").execute(*args, **kwargs)

        class simulation(metaclass=PyMenuMeta):
            """
            .
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.report_definitions = self.__class__.report_definitions(path + [("report_definitions", None)], service)
            def flow_model(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/simulation/flow_model").execute(*args, **kwargs)
            def local_residual_scaling(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/simulation/local_residual_scaling").execute(*args, **kwargs)

            class report_definitions(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def automatic_plot_file(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/simulation/report_definitions/automatic_plot_file").execute(*args, **kwargs)
                def report_plot_history_data_size(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/simulation/report_definitions/report_plot_history_data_size").execute(*args, **kwargs)

        class turbo_workflow(metaclass=PyMenuMeta):
            """
            .
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.cell_zone_settings = self.__class__.cell_zone_settings(path + [("cell_zone_settings", None)], service)
                self.face_zone_settings = self.__class__.face_zone_settings(path + [("face_zone_settings", None)], service)
                self.graphics_settings = self.__class__.graphics_settings(path + [("graphics_settings", None)], service)
            def checkpointing_option(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/turbo_workflow/checkpointing_option").execute(*args, **kwargs)
            def save_checkpoint_files(self, *args, **kwargs):
                """
                .
                """
                return PyMenu(self.service, "/preferences/turbo_workflow/save_checkpoint_files").execute(*args, **kwargs)

            class cell_zone_settings(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def czsearch_order(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/turbo_workflow/cell_zone_settings/czsearch_order").execute(*args, **kwargs)
                def rotating(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/turbo_workflow/cell_zone_settings/rotating").execute(*args, **kwargs)
                def stationary(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/turbo_workflow/cell_zone_settings/stationary").execute(*args, **kwargs)

            class face_zone_settings(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def blade_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/turbo_workflow/face_zone_settings/blade_region").execute(*args, **kwargs)
                def fzsearch_order(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/turbo_workflow/face_zone_settings/fzsearch_order").execute(*args, **kwargs)
                def hub_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/turbo_workflow/face_zone_settings/hub_region").execute(*args, **kwargs)
                def inlet_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/turbo_workflow/face_zone_settings/inlet_region").execute(*args, **kwargs)
                def interior_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/turbo_workflow/face_zone_settings/interior_region").execute(*args, **kwargs)
                def outlet_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/turbo_workflow/face_zone_settings/outlet_region").execute(*args, **kwargs)
                def periodic1_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/turbo_workflow/face_zone_settings/periodic1_region").execute(*args, **kwargs)
                def periodic2_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/turbo_workflow/face_zone_settings/periodic2_region").execute(*args, **kwargs)
                def shroud_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/turbo_workflow/face_zone_settings/shroud_region").execute(*args, **kwargs)
                def symmetry_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/turbo_workflow/face_zone_settings/symmetry_region").execute(*args, **kwargs)
                def tip1_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/turbo_workflow/face_zone_settings/tip1_region").execute(*args, **kwargs)
                def tip2_region(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/turbo_workflow/face_zone_settings/tip2_region").execute(*args, **kwargs)

            class graphics_settings(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def auto_draw(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/preferences/turbo_workflow/graphics_settings/auto_draw").execute(*args, **kwargs)

    class report(metaclass=PyMenuMeta):
        """
        Enter the report menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
            self.dpm_histogram = self.__class__.dpm_histogram(path + [("dpm_histogram", None)], service)
            self.fluxes = self.__class__.fluxes(path + [("fluxes", None)], service)
            self.forces = self.__class__.forces(path + [("forces", None)], service)
            self.reference_values = self.__class__.reference_values(path + [("reference_values", None)], service)
            self.surface_integrals = self.__class__.surface_integrals(path + [("surface_integrals", None)], service)
            self.volume_integrals = self.__class__.volume_integrals(path + [("volume_integrals", None)], service)
            self.modified_setting = self.__class__.modified_setting(path + [("modified_setting", None)], service)
            self.population_balance = self.__class__.population_balance(path + [("population_balance", None)], service)
            self.heat_exchanger = self.__class__.heat_exchanger(path + [("heat_exchanger", None)], service)
            self.system = self.__class__.system(path + [("system", None)], service)
            self.simulation_reports = self.__class__.simulation_reports(path + [("simulation_reports", None)], service)
        def aero_optical_distortions(self, *args, **kwargs):
            """
            Optics report menu.
            """
            return PyMenu(self.service, "/report/aero_optical_distortions").execute(*args, **kwargs)
        def dpm_summary(self, *args, **kwargs):
            """
            Print discrete phase summary report of particle fates.
            """
            return PyMenu(self.service, "/report/dpm_summary").execute(*args, **kwargs)
        def dpm_extended_summary(self, *args, **kwargs):
            """
            Print extended discrete phase summary report of particle fates, with options.
            """
            return PyMenu(self.service, "/report/dpm_extended_summary").execute(*args, **kwargs)
        def dpm_zone_summaries_per_injection(self, *args, **kwargs):
            """
            Enable per-injection zone DPM summaries.
            """
            return PyMenu(self.service, "/report/dpm_zone_summaries_per_injection").execute(*args, **kwargs)
        def dpm_sample(self, *args, **kwargs):
            """
            Sample trajectories at boundaries and lines/planes.
            """
            return PyMenu(self.service, "/report/dpm_sample").execute(*args, **kwargs)
        def dpm_sample_output_udf(self, *args, **kwargs):
            """
            Set the DPM sampling output UDF.
            """
            return PyMenu(self.service, "/report/dpm_sample_output_udf").execute(*args, **kwargs)
        def dpm_sample_sort_file(self, *args, **kwargs):
            """
            Enable writing of sorted DPM sample files.
            """
            return PyMenu(self.service, "/report/dpm_sample_sort_file").execute(*args, **kwargs)
        def particle_summary(self, *args, **kwargs):
            """
            Print summary report for all current particles.
            """
            return PyMenu(self.service, "/report/particle_summary").execute(*args, **kwargs)
        def path_line_summary(self, *args, **kwargs):
            """
            Print path-line-summary report.
            """
            return PyMenu(self.service, "/report/path_line_summary").execute(*args, **kwargs)
        def print_histogram(self, *args, **kwargs):
            """
            Print a histogram of a scalar quantity.
            """
            return PyMenu(self.service, "/report/print_histogram").execute(*args, **kwargs)
        def write_histogram(self, *args, **kwargs):
            """
            Write a histogram of a scalar quantity to a file.
            """
            return PyMenu(self.service, "/report/write_histogram").execute(*args, **kwargs)
        def projected_surface_area(self, *args, **kwargs):
            """
            Print total area of the projection of a group of surfaces to a plane.
            """
            return PyMenu(self.service, "/report/projected_surface_area").execute(*args, **kwargs)
        def species_mass_flow(self, *args, **kwargs):
            """
            Print list of species mass flow rates at boundaries.
            """
            return PyMenu(self.service, "/report/species_mass_flow").execute(*args, **kwargs)
        def element_mass_flow(self, *args, **kwargs):
            """
            Print list of element mass flow rates at boundaries.
            """
            return PyMenu(self.service, "/report/element_mass_flow").execute(*args, **kwargs)
        def summary(self, *args, **kwargs):
            """
            Print report summary.
            """
            return PyMenu(self.service, "/report/summary").execute(*args, **kwargs)
        def uds_flow(self, *args, **kwargs):
            """
            Print list of UDS flow rate at boundaries.
            """
            return PyMenu(self.service, "/report/uds_flow").execute(*args, **kwargs)
        def mphase_summary(self, *args, **kwargs):
            """
            Multiphase Summary and Recommendations.
            """
            return PyMenu(self.service, "/report/mphase_summary").execute(*args, **kwargs)

        class dpm_histogram(metaclass=PyMenuMeta):
            """
            Enter the DPM histogram menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.set = self.__class__.set(path + [("set", None)], service)
                self.setup_reduction = self.__class__.setup_reduction(path + [("setup_reduction", None)], service)
            def compute_sample(self, *args, **kwargs):
                """
                Compute minimum/maximum of a sample variable.
                """
                return PyMenu(self.service, "/report/dpm_histogram/compute_sample").execute(*args, **kwargs)
            def delete_sample(self, *args, **kwargs):
                """
                Delete a sample from loaded sample list.
                """
                return PyMenu(self.service, "/report/dpm_histogram/delete_sample").execute(*args, **kwargs)
            def list_samples(self, *args, **kwargs):
                """
                Show all samples in loaded sample list.
                """
                return PyMenu(self.service, "/report/dpm_histogram/list_samples").execute(*args, **kwargs)
            def plot_sample(self, *args, **kwargs):
                """
                Plot a histogram of a loaded sample.
                """
                return PyMenu(self.service, "/report/dpm_histogram/plot_sample").execute(*args, **kwargs)
            def read_sample(self, *args, **kwargs):
                """
                Read a sample file and add it to the sample list.
                """
                return PyMenu(self.service, "/report/dpm_histogram/read_sample").execute(*args, **kwargs)
            def write_sample(self, *args, **kwargs):
                """
                Write a histogram of a loaded sample into a file.
                """
                return PyMenu(self.service, "/report/dpm_histogram/write_sample").execute(*args, **kwargs)
            def pick_sample_to_reduce(self, *args, **kwargs):
                """
                Pick a sample for which to first set-up and then perform the data reduction.
                """
                return PyMenu(self.service, "/report/dpm_histogram/pick_sample_to_reduce").execute(*args, **kwargs)
            def reduce_picked_sample(self, *args, **kwargs):
                """
                Reduce a sample after first picking it and setting up all data-reduction options and parameters.
                """
                return PyMenu(self.service, "/report/dpm_histogram/reduce_picked_sample").execute(*args, **kwargs)

            class set(metaclass=PyMenuMeta):
                """
                Enter the settings menu for the histogram.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def auto_range(self, *args, **kwargs):
                    """
                    Automatically compute range of sampling variable for histogram plots.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/set/auto_range").execute(*args, **kwargs)
                def correlation(self, *args, **kwargs):
                    """
                    Compute correlation of sampling variable with other variable.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/set/correlation").execute(*args, **kwargs)
                def cumulation_curve(self, *args, **kwargs):
                    """
                    Compute a cumulative curve for sampling variable or correlation variable when correlation? was specified.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/set/cumulation_curve").execute(*args, **kwargs)
                def diameter_statistics(self, *args, **kwargs):
                    """
                    Compute Rosin Rammler parameters, Sauter and other mean diameters.
                    Requires specification of diameter as sampling variable.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/set/diameter_statistics").execute(*args, **kwargs)
                def histogram_mode(self, *args, **kwargs):
                    """
                    Use bars for histogram plot or xy-style.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/set/histogram_mode").execute(*args, **kwargs)
                def minimum(self, *args, **kwargs):
                    """
                    Specify mimimum value of x-axis variable for histogram plots.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/set/minimum").execute(*args, **kwargs)
                def maximum(self, *args, **kwargs):
                    """
                    Specify maximum value of x-axis variable for histogram plots.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/set/maximum").execute(*args, **kwargs)
                def number_of_bins(self, *args, **kwargs):
                    """
                    Specify the number of bins.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/set/number_of_bins").execute(*args, **kwargs)
                def percentage(self, *args, **kwargs):
                    """
                    Use percentages of bins to be computed.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/set/percentage").execute(*args, **kwargs)
                def variable_power_3(self, *args, **kwargs):
                    """
                    Use the cubic of the cumulation variable during computation of the cumulative curve.
                    When the particle mass was not sampled, the diameter can be used instead.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/set/variable_power_3").execute(*args, **kwargs)
                def logarithmic(self, *args, **kwargs):
                    """
                    Use logarithmic scaling on the abscissa (variable axis)? -- Will not work unless all values are positive.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/set/logarithmic").execute(*args, **kwargs)
                def weighting(self, *args, **kwargs):
                    """
                    Use weighting with additional variable when sorting data into samples.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/set/weighting").execute(*args, **kwargs)

            class setup_reduction(metaclass=PyMenuMeta):
                """
                Set up the sample data reduction by specifying all relevant options and setting parameters as desired.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def use_weighting(self, *args, **kwargs):
                    """
                    Specify whether to use any weighting in the averaging that is done in each bin in the data reduction.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/setup_reduction/use_weighting").execute(*args, **kwargs)
                def weighting_variable(self, *args, **kwargs):
                    """
                    Choose the weighting variable for the averaging in each bin in the data reduction.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/setup_reduction/weighting_variable").execute(*args, **kwargs)
                def make_steady_from_unsteady_file(self, *args, **kwargs):
                    """
                    Specify whether the unsteady sample is to be reduced into a steady-state injection file.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/setup_reduction/make_steady_from_unsteady_file").execute(*args, **kwargs)
                def reset_min_and_max(self, *args, **kwargs):
                    """
                    Reset the min and max values of the range to be considered for a specific variable in the data reduction.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/setup_reduction/reset_min_and_max").execute(*args, **kwargs)
                def minimum(self, *args, **kwargs):
                    """
                    Set the minimum value of the range to be considered for a specific variable in the data reduction.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/setup_reduction/minimum").execute(*args, **kwargs)
                def maximum(self, *args, **kwargs):
                    """
                    Set the maximum value of the range to be considered for a specific variable in the data reduction.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/setup_reduction/maximum").execute(*args, **kwargs)
                def logarithmic(self, *args, **kwargs):
                    """
                    Switch on or off logarithmic scaling to be used for a specific variable in the data reduction.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/setup_reduction/logarithmic").execute(*args, **kwargs)
                def number_of_bins(self, *args, **kwargs):
                    """
                    Set the number of bins to be used for a specific variable in the data reduction.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/setup_reduction/number_of_bins").execute(*args, **kwargs)
                def all_variables_number_of_bins(self, *args, **kwargs):
                    """
                    Set the number of bins to be used for ALL variables in the data reduction.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/setup_reduction/all_variables_number_of_bins").execute(*args, **kwargs)
                def list_settings(self, *args, **kwargs):
                    """
                    List all user inputs for the sample picked for data reduction.
                    """
                    return PyMenu(self.service, "/report/dpm_histogram/setup_reduction/list_settings").execute(*args, **kwargs)

        class fluxes(metaclass=PyMenuMeta):
            """
            Flux report menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def mass_flow(self, *args, **kwargs):
                """
                Print mass flow rate at inlets and outlets.
                """
                return PyMenu(self.service, "/report/fluxes/mass_flow").execute(*args, **kwargs)
            def heat_transfer(self, *args, **kwargs):
                """
                Print heat transfer rate at boundaries.
                """
                return PyMenu(self.service, "/report/fluxes/heat_transfer").execute(*args, **kwargs)
            def heat_transfer_sensible(self, *args, **kwargs):
                """
                Print sensible heat transfer rate at boundaries.
                """
                return PyMenu(self.service, "/report/fluxes/heat_transfer_sensible").execute(*args, **kwargs)
            def rad_heat_trans(self, *args, **kwargs):
                """
                Print radiation heat transfer rate at boundaries.
                """
                return PyMenu(self.service, "/report/fluxes/rad_heat_trans").execute(*args, **kwargs)
            def film_mass_flow(self, *args, **kwargs):
                """
                Print film mass flow rate at boundaries.
                """
                return PyMenu(self.service, "/report/fluxes/film_mass_flow").execute(*args, **kwargs)
            def film_heat_transfer(self, *args, **kwargs):
                """
                Print film heat transfer rate at boundaries.
                """
                return PyMenu(self.service, "/report/fluxes/film_heat_transfer").execute(*args, **kwargs)
            def pressure_work(self, *args, **kwargs):
                """
                Print pressure work rate at moving boundaries.
                """
                return PyMenu(self.service, "/report/fluxes/pressure_work").execute(*args, **kwargs)
            def viscous_work(self, *args, **kwargs):
                """
                Print viscous work rate at boundaries.
                """
                return PyMenu(self.service, "/report/fluxes/viscous_work").execute(*args, **kwargs)

        class forces(metaclass=PyMenuMeta):
            """
            Force report menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def wall_forces(self, *args, **kwargs):
                """
                Print integrated pressure and viscous forces on wall zones.
                """
                return PyMenu(self.service, "/report/forces/wall_forces").execute(*args, **kwargs)
            def wall_moments(self, *args, **kwargs):
                """
                Print integrated pressure and viscous moments on wall zones.
                """
                return PyMenu(self.service, "/report/forces/wall_moments").execute(*args, **kwargs)
            def pressure_center(self, *args, **kwargs):
                """
                Print center of pressure on wall zones.
                """
                return PyMenu(self.service, "/report/forces/pressure_center").execute(*args, **kwargs)

        class reference_values(metaclass=PyMenuMeta):
            """
            Reference value menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.compute = self.__class__.compute(path + [("compute", None)], service)
            def area(self, *args, **kwargs):
                """
                Set reference area for normalization.
                """
                return PyMenu(self.service, "/report/reference_values/area").execute(*args, **kwargs)
            def depth(self, *args, **kwargs):
                """
                Set reference depth for volume calculation.
                """
                return PyMenu(self.service, "/report/reference_values/depth").execute(*args, **kwargs)
            def density(self, *args, **kwargs):
                """
                Set reference density for normalization.
                """
                return PyMenu(self.service, "/report/reference_values/density").execute(*args, **kwargs)
            def enthalpy(self, *args, **kwargs):
                """
                Set reference enthalpy for enthalpy damping and normalization.
                """
                return PyMenu(self.service, "/report/reference_values/enthalpy").execute(*args, **kwargs)
            def length(self, *args, **kwargs):
                """
                Set reference length for normalization.
                """
                return PyMenu(self.service, "/report/reference_values/length").execute(*args, **kwargs)
            def pressure(self, *args, **kwargs):
                """
                Set reference pressure for normalization.
                """
                return PyMenu(self.service, "/report/reference_values/pressure").execute(*args, **kwargs)
            def temperature(self, *args, **kwargs):
                """
                Set reference temperature for normalization.
                """
                return PyMenu(self.service, "/report/reference_values/temperature").execute(*args, **kwargs)
            def yplus(self, *args, **kwargs):
                """
                Set reference yplus for normalization.
                """
                return PyMenu(self.service, "/report/reference_values/yplus").execute(*args, **kwargs)
            def velocity(self, *args, **kwargs):
                """
                Set reference velocity for normalization.
                """
                return PyMenu(self.service, "/report/reference_values/velocity").execute(*args, **kwargs)
            def viscosity(self, *args, **kwargs):
                """
                Set reference viscosity for normalization.
                """
                return PyMenu(self.service, "/report/reference_values/viscosity").execute(*args, **kwargs)
            def zone(self, *args, **kwargs):
                """
                Set reference zone.
                """
                return PyMenu(self.service, "/report/reference_values/zone").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List current reference values.
                """
                return PyMenu(self.service, "/report/reference_values/list").execute(*args, **kwargs)

            class compute(metaclass=PyMenuMeta):
                """
                Enter the compute menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def axis(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/axis").execute(*args, **kwargs)
                def degassing(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/degassing").execute(*args, **kwargs)
                def dummy_entry(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/dummy_entry").execute(*args, **kwargs)
                def exhaust_fan(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/exhaust_fan").execute(*args, **kwargs)
                def fan(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/fan").execute(*args, **kwargs)
                def fluid(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/fluid").execute(*args, **kwargs)
                def geometry(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/geometry").execute(*args, **kwargs)
                def inlet_vent(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/inlet_vent").execute(*args, **kwargs)
                def intake_fan(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/intake_fan").execute(*args, **kwargs)
                def interface(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/interface").execute(*args, **kwargs)
                def interior(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/interior").execute(*args, **kwargs)
                def mass_flow_inlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/mass_flow_inlet").execute(*args, **kwargs)
                def mass_flow_outlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/mass_flow_outlet").execute(*args, **kwargs)
                def network(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/network").execute(*args, **kwargs)
                def network_end(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/network_end").execute(*args, **kwargs)
                def outflow(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/outflow").execute(*args, **kwargs)
                def outlet_vent(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/outlet_vent").execute(*args, **kwargs)
                def overset(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/overset").execute(*args, **kwargs)
                def periodic(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/periodic").execute(*args, **kwargs)
                def porous_jump(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/porous_jump").execute(*args, **kwargs)
                def pressure_far_field(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/pressure_far_field").execute(*args, **kwargs)
                def pressure_inlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/pressure_inlet").execute(*args, **kwargs)
                def pressure_outlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/pressure_outlet").execute(*args, **kwargs)
                def radiator(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/radiator").execute(*args, **kwargs)
                def rans_les_interface(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/rans_les_interface").execute(*args, **kwargs)
                def recirculation_inlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/recirculation_inlet").execute(*args, **kwargs)
                def recirculation_outlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/recirculation_outlet").execute(*args, **kwargs)
                def shadow(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/shadow").execute(*args, **kwargs)
                def solid(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/solid").execute(*args, **kwargs)
                def symmetry(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/symmetry").execute(*args, **kwargs)
                def velocity_inlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/velocity_inlet").execute(*args, **kwargs)
                def wall(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/report/reference_values/compute/wall").execute(*args, **kwargs)

        class surface_integrals(metaclass=PyMenuMeta):
            """
            Surface Integral menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def area(self, *args, **kwargs):
                """
                Print total area of surfaces.
                """
                return PyMenu(self.service, "/report/surface_integrals/area").execute(*args, **kwargs)
            def area_weighted_avg(self, *args, **kwargs):
                """
                Print area-weighted average of scalar on surfaces.
                """
                return PyMenu(self.service, "/report/surface_integrals/area_weighted_avg").execute(*args, **kwargs)
            def facet_avg(self, *args, **kwargs):
                """
                Print average of scalar at facet centroids of the surfaces.
                """
                return PyMenu(self.service, "/report/surface_integrals/facet_avg").execute(*args, **kwargs)
            def facet_max(self, *args, **kwargs):
                """
                Print maximum of scalar at facet centroids of the surfaces.
                """
                return PyMenu(self.service, "/report/surface_integrals/facet_max").execute(*args, **kwargs)
            def facet_min(self, *args, **kwargs):
                """
                Print minimum of scalar at facet centroids of the surfaces.
                """
                return PyMenu(self.service, "/report/surface_integrals/facet_min").execute(*args, **kwargs)
            def flow_rate(self, *args, **kwargs):
                """
                Print flow rate of scalar through surfaces.
                """
                return PyMenu(self.service, "/report/surface_integrals/flow_rate").execute(*args, **kwargs)
            def integral(self, *args, **kwargs):
                """
                Print integral of scalar over surfaces.
                """
                return PyMenu(self.service, "/report/surface_integrals/integral").execute(*args, **kwargs)
            def mass_flow_rate(self, *args, **kwargs):
                """
                Print mass flow rate through surfaces.
                """
                return PyMenu(self.service, "/report/surface_integrals/mass_flow_rate").execute(*args, **kwargs)
            def mass_weighted_avg(self, *args, **kwargs):
                """
                Print mass-average of scalar over surfaces.
                """
                return PyMenu(self.service, "/report/surface_integrals/mass_weighted_avg").execute(*args, **kwargs)
            def standard_deviation(self, *args, **kwargs):
                """
                Print standard deviation of scalar.
                """
                return PyMenu(self.service, "/report/surface_integrals/standard_deviation").execute(*args, **kwargs)
            def sum(self, *args, **kwargs):
                """
                Print sum of scalar at facet centroids of the surfaces.
                """
                return PyMenu(self.service, "/report/surface_integrals/sum").execute(*args, **kwargs)
            def uniformity_index_area_weighted(self, *args, **kwargs):
                """
                Print uniformity index of scalar over surfaces.
                """
                return PyMenu(self.service, "/report/surface_integrals/uniformity_index_area_weighted").execute(*args, **kwargs)
            def uniformity_index_mass_weighted(self, *args, **kwargs):
                """
                Print uniformity index of scalar over surfaces.
                """
                return PyMenu(self.service, "/report/surface_integrals/uniformity_index_mass_weighted").execute(*args, **kwargs)
            def vector_based_flux(self, *args, **kwargs):
                """
                Print custom vector based flux.
                """
                return PyMenu(self.service, "/report/surface_integrals/vector_based_flux").execute(*args, **kwargs)
            def vector_flux(self, *args, **kwargs):
                """
                Print custom vector flux.
                """
                return PyMenu(self.service, "/report/surface_integrals/vector_flux").execute(*args, **kwargs)
            def vector_weighted_average(self, *args, **kwargs):
                """
                Print custom vector weighted average.
                """
                return PyMenu(self.service, "/report/surface_integrals/vector_weighted_average").execute(*args, **kwargs)
            def vertex_avg(self, *args, **kwargs):
                """
                Print average of scalar at vertices of the surfaces.
                """
                return PyMenu(self.service, "/report/surface_integrals/vertex_avg").execute(*args, **kwargs)
            def vertex_max(self, *args, **kwargs):
                """
                Print maximkum of scalar at vertices of the surfaces.
                """
                return PyMenu(self.service, "/report/surface_integrals/vertex_max").execute(*args, **kwargs)
            def vertex_min(self, *args, **kwargs):
                """
                Print minimum of scalar at vertices of the surfaces.
                """
                return PyMenu(self.service, "/report/surface_integrals/vertex_min").execute(*args, **kwargs)
            def volume_flow_rate(self, *args, **kwargs):
                """
                Print volume flow rate through surfaces.
                """
                return PyMenu(self.service, "/report/surface_integrals/volume_flow_rate").execute(*args, **kwargs)

        class volume_integrals(metaclass=PyMenuMeta):
            """
            Volume Integral menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def mass(self, *args, **kwargs):
                """
                Print total mass of specified cell zones.
                """
                return PyMenu(self.service, "/report/volume_integrals/mass").execute(*args, **kwargs)
            def mass_avg(self, *args, **kwargs):
                """
                Print mass-average of scalar over cell zones.
                """
                return PyMenu(self.service, "/report/volume_integrals/mass_avg").execute(*args, **kwargs)
            def mass_integral(self, *args, **kwargs):
                """
                Print mass-weighted integral of scalar over cell zones.
                """
                return PyMenu(self.service, "/report/volume_integrals/mass_integral").execute(*args, **kwargs)
            def maximum(self, *args, **kwargs):
                """
                Print maximum of scalar over all cell zones.
                """
                return PyMenu(self.service, "/report/volume_integrals/maximum").execute(*args, **kwargs)
            def minimum(self, *args, **kwargs):
                """
                Print minimum of scalar over all cell zones.
                """
                return PyMenu(self.service, "/report/volume_integrals/minimum").execute(*args, **kwargs)
            def sum(self, *args, **kwargs):
                """
                Print sum of scalar over all cell zones.
                """
                return PyMenu(self.service, "/report/volume_integrals/sum").execute(*args, **kwargs)
            def twopisum(self, *args, **kwargs):
                """
                Print sum of scalar over all cell zones multiplied by 2\*Pi.
                """
                return PyMenu(self.service, "/report/volume_integrals/twopisum").execute(*args, **kwargs)
            def volume(self, *args, **kwargs):
                """
                Print total volume of specified cell zones.
                """
                return PyMenu(self.service, "/report/volume_integrals/volume").execute(*args, **kwargs)
            def volume_avg(self, *args, **kwargs):
                """
                Print volume-weighted average of scalar over cell zones.
                """
                return PyMenu(self.service, "/report/volume_integrals/volume_avg").execute(*args, **kwargs)
            def volume_integral(self, *args, **kwargs):
                """
                Print integral of scalar over cell zones.
                """
                return PyMenu(self.service, "/report/volume_integrals/volume_integral").execute(*args, **kwargs)

        class modified_setting(metaclass=PyMenuMeta):
            """
            Enter the menu for setting up the Modified Settings Summary table.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def modified_setting(self, *args, **kwargs):
                """
                Specify which settings will be checked for non-default status for generating the Modified Settings Summary table.
                """
                return PyMenu(self.service, "/report/modified_setting/modified_setting").execute(*args, **kwargs)
            def write_user_setting(self, *args, **kwargs):
                """
                Write the contents of the Modified Settings Summary table to a file.
                """
                return PyMenu(self.service, "/report/modified_setting/write_user_setting").execute(*args, **kwargs)

        class population_balance(metaclass=PyMenuMeta):
            """
            Population Balance menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def moments(self, *args, **kwargs):
                """
                Set moments for population balance.
                """
                return PyMenu(self.service, "/report/population_balance/moments").execute(*args, **kwargs)
            def number_density(self, *args, **kwargs):
                """
                Set number density functions.
                """
                return PyMenu(self.service, "/report/population_balance/number_density").execute(*args, **kwargs)

        class heat_exchanger(metaclass=PyMenuMeta):
            """
            Enter the heat exchanger menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def computed_heat_rejection(self, *args, **kwargs):
                """
                Print total heat rejection.
                """
                return PyMenu(self.service, "/report/heat_exchanger/computed_heat_rejection").execute(*args, **kwargs)
            def inlet_temperature(self, *args, **kwargs):
                """
                Print inlet temperature.
                """
                return PyMenu(self.service, "/report/heat_exchanger/inlet_temperature").execute(*args, **kwargs)
            def outlet_temperature(self, *args, **kwargs):
                """
                Print outlet temperature.
                """
                return PyMenu(self.service, "/report/heat_exchanger/outlet_temperature").execute(*args, **kwargs)
            def mass_flow_rate(self, *args, **kwargs):
                """
                Print mass flow rate.
                """
                return PyMenu(self.service, "/report/heat_exchanger/mass_flow_rate").execute(*args, **kwargs)
            def specific_heat(self, *args, **kwargs):
                """
                Print fluid's specific heat.
                """
                return PyMenu(self.service, "/report/heat_exchanger/specific_heat").execute(*args, **kwargs)

        class system(metaclass=PyMenuMeta):
            """
            Sytem menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def proc_stats(self, *args, **kwargs):
                """
                Fluent process information.
                """
                return PyMenu(self.service, "/report/system/proc_stats").execute(*args, **kwargs)
            def sys_stats(self, *args, **kwargs):
                """
                System information.
                """
                return PyMenu(self.service, "/report/system/sys_stats").execute(*args, **kwargs)
            def gpgpu_stats(self, *args, **kwargs):
                """
                GPGPU information.
                """
                return PyMenu(self.service, "/report/system/gpgpu_stats").execute(*args, **kwargs)
            def time_stats(self, *args, **kwargs):
                """
                Time usage information.
                """
                return PyMenu(self.service, "/report/system/time_stats").execute(*args, **kwargs)

        class simulation_reports(metaclass=PyMenuMeta):
            """
            Enter the simulation reports menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def list_simulation_reports(self, *args, **kwargs):
                """
                List all report names.
                """
                return PyMenu(self.service, "/report/simulation_reports/list_simulation_reports").execute(*args, **kwargs)
            def generate_simulation_report(self, *args, **kwargs):
                """
                Generate a new simulation report or regenerate an existing simulation report with the provided name.
                """
                return PyMenu(self.service, "/report/simulation_reports/generate_simulation_report").execute(*args, **kwargs)
            def view_simulation_report(self, *args, **kwargs):
                """
                View a simulation report that has already been generated. In batch mode this will print the report's URL.
                """
                return PyMenu(self.service, "/report/simulation_reports/view_simulation_report").execute(*args, **kwargs)
            def export_simulation_report_as_pdf(self, *args, **kwargs):
                """
                Export the provided simulation report as a PDF file.
                """
                return PyMenu(self.service, "/report/simulation_reports/export_simulation_report_as_pdf").execute(*args, **kwargs)
            def export_simulation_report_as_html(self, *args, **kwargs):
                """
                Export the provided simulation report as HTML.
                """
                return PyMenu(self.service, "/report/simulation_reports/export_simulation_report_as_html").execute(*args, **kwargs)
            def write_report_names_to_file(self, *args, **kwargs):
                """
                Write the list of currently generated report names to a txt file.
                """
                return PyMenu(self.service, "/report/simulation_reports/write_report_names_to_file").execute(*args, **kwargs)
            def rename_simulation_report(self, *args, **kwargs):
                """
                Rename a report which has already been generated.
                """
                return PyMenu(self.service, "/report/simulation_reports/rename_simulation_report").execute(*args, **kwargs)
            def duplicate_simulation_report(self, *args, **kwargs):
                """
                Duplicate a report and all of its settings to a new report.
                """
                return PyMenu(self.service, "/report/simulation_reports/duplicate_simulation_report").execute(*args, **kwargs)
            def reset_report_to_defaults(self, *args, **kwargs):
                """
                Reset all report settings to default for the provided simulation report.
                """
                return PyMenu(self.service, "/report/simulation_reports/reset_report_to_defaults").execute(*args, **kwargs)
            def delete_simulation_report(self, *args, **kwargs):
                """
                Delete the provided simulation report.
                """
                return PyMenu(self.service, "/report/simulation_reports/delete_simulation_report").execute(*args, **kwargs)
            def write_simulation_report_template_file(self, *args, **kwargs):
                """
                Write a JSON template file with this case's Simulation Report settings.
                """
                return PyMenu(self.service, "/report/simulation_reports/write_simulation_report_template_file").execute(*args, **kwargs)
            def read_simulation_report_template_file(self, *args, **kwargs):
                """
                Read a JSON template file with existing Simulation Report settings.
                """
                return PyMenu(self.service, "/report/simulation_reports/read_simulation_report_template_file").execute(*args, **kwargs)

    class results(metaclass=PyMenuMeta):
        """
        Enter results menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
            self.animate = self.__class__.animate(path + [("animate", None)], service)
            self.graphics = self.__class__.graphics(path + [("graphics", None)], service)
            self.plot = self.__class__.plot(path + [("plot", None)], service)
            self.report = self.__class__.report(path + [("report", None)], service)
            self.surface = self.__class__.surface(path + [("surface", None)], service)
            self.graphics_window = self.__class__.graphics_window(path + [("graphics_window", None)], service)

        class animate(metaclass=PyMenuMeta):
            """
            Enter the animation menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.playback = self.__class__.playback(path + [("playback", None)], service)

            class playback(metaclass=PyMenuMeta):
                """
                Enter animation playback menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.video = self.__class__.video(path + [("video", None)], service)
                def read(self, *args, **kwargs):
                    """
                    Read new animation from file or already-defined animations.
                    """
                    return PyMenu(self.service, "/results/animate/playback/read").execute(*args, **kwargs)
                def play(self, *args, **kwargs):
                    """
                    Play the selected animation.
                    """
                    return PyMenu(self.service, "/results/animate/playback/play").execute(*args, **kwargs)
                def write(self, *args, **kwargs):
                    """
                    Write animation sequence to the file.
                    """
                    return PyMenu(self.service, "/results/animate/playback/write").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete animation sequence.
                    """
                    return PyMenu(self.service, "/results/animate/playback/delete").execute(*args, **kwargs)
                def stored_view(self, *args, **kwargs):
                    """
                    Play the 3D animation sequence using the view stored in the sequence.
                    """
                    return PyMenu(self.service, "/results/animate/playback/stored_view").execute(*args, **kwargs)
                def set_custom_frames(self, *args, **kwargs):
                    """
                    Set custom frames start, end, skip frames for video export.
                    """
                    return PyMenu(self.service, "/results/animate/playback/set_custom_frames").execute(*args, **kwargs)

                class video(metaclass=PyMenuMeta):
                    """
                    Set options for exporting video file menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.advance_quality = self.__class__.advance_quality(path + [("advance_quality", None)], service)
                    def fps(self, *args, **kwargs):
                        """
                        Set the Frame Per Sec(FPS) for exporting video file.
                        """
                        return PyMenu(self.service, "/results/animate/playback/video/fps").execute(*args, **kwargs)
                    def format(self, *args, **kwargs):
                        """
                        Set format for exporting video file.
                        """
                        return PyMenu(self.service, "/results/animate/playback/video/format").execute(*args, **kwargs)
                    def quality(self, *args, **kwargs):
                        """
                        Set quality for exporting video file.
                        """
                        return PyMenu(self.service, "/results/animate/playback/video/quality").execute(*args, **kwargs)
                    def name(self, *args, **kwargs):
                        """
                        Exporting video file name.
                        """
                        return PyMenu(self.service, "/results/animate/playback/video/name").execute(*args, **kwargs)
                    def use_original_resolution(self, *args, **kwargs):
                        """
                        Enable original resolution.
                        """
                        return PyMenu(self.service, "/results/animate/playback/video/use_original_resolution").execute(*args, **kwargs)
                    def scale(self, *args, **kwargs):
                        """
                        Set scale by which video resolution will expand.
                        """
                        return PyMenu(self.service, "/results/animate/playback/video/scale").execute(*args, **kwargs)
                    def set_standard_resolution(self, *args, **kwargs):
                        """
                        Select from pre-defined resolution list.
                        """
                        return PyMenu(self.service, "/results/animate/playback/video/set_standard_resolution").execute(*args, **kwargs)
                    def width(self, *args, **kwargs):
                        """
                        Set the width for exporting video file.
                        """
                        return PyMenu(self.service, "/results/animate/playback/video/width").execute(*args, **kwargs)
                    def height(self, *args, **kwargs):
                        """
                        Set the height for exporting video file.
                        """
                        return PyMenu(self.service, "/results/animate/playback/video/height").execute(*args, **kwargs)

                    class advance_quality(metaclass=PyMenuMeta):
                        """
                        Advance Quality setting.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def bitrate_scale(self, *args, **kwargs):
                            """
                            Mp4 bitrate scale - Best-64000 High-32000 Medium-16000 Low-8000.
                            """
                            return PyMenu(self.service, "/results/animate/playback/video/advance_quality/bitrate_scale").execute(*args, **kwargs)
                        def enable_h264(self, *args, **kwargs):
                            """
                            H264 encoding flag.
                            """
                            return PyMenu(self.service, "/results/animate/playback/video/advance_quality/enable_h264").execute(*args, **kwargs)
                        def bitrate(self, *args, **kwargs):
                            """
                            Set video bitrate(kbits/sec) for exporting video file.
                            """
                            return PyMenu(self.service, "/results/animate/playback/video/advance_quality/bitrate").execute(*args, **kwargs)
                        def compression_method(self, *args, **kwargs):
                            """
                            Compression methode for Microsoft AVI movie.
                            """
                            return PyMenu(self.service, "/results/animate/playback/video/advance_quality/compression_method").execute(*args, **kwargs)
                        def keyframe(self, *args, **kwargs):
                            """
                            Set video keyframe rate for exporting video file.
                            """
                            return PyMenu(self.service, "/results/animate/playback/video/advance_quality/keyframe").execute(*args, **kwargs)

        class graphics(metaclass=PyMenuMeta):
            """
            Enter graphics menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.expert = self.__class__.expert(path + [("expert", None)], service)
                self.lights = self.__class__.lights(path + [("lights", None)], service)
                self.objects = self.__class__.objects(path + [("objects", None)], service)
                self.rendering_options = self.__class__.rendering_options(path + [("rendering_options", None)], service)
                self.update_scene = self.__class__.update_scene(path + [("update_scene", None)], service)
            def annotate(self, *args, **kwargs):
                """
                Add a text annotation string to the active graphics window.
                """
                return PyMenu(self.service, "/results/graphics/annotate").execute(*args, **kwargs)
            def clear_annotations(self, *args, **kwargs):
                """
                Delete all annotation text.
                """
                return PyMenu(self.service, "/results/graphics/clear_annotations").execute(*args, **kwargs)
            def color_map(self, *args, **kwargs):
                """
                Enter the color-map menu.
                """
                return PyMenu(self.service, "/results/graphics/color_map").execute(*args, **kwargs)
            def hsf_file(self, *args, **kwargs):
                """
                Display hoops stream file data to active graphics window.
                """
                return PyMenu(self.service, "/results/graphics/hsf_file").execute(*args, **kwargs)

            class expert(metaclass=PyMenuMeta):
                """
                Enter expert menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.flamelet_data = self.__class__.flamelet_data(path + [("flamelet_data", None)], service)
                    self.particle_tracks = self.__class__.particle_tracks(path + [("particle_tracks", None)], service)
                    self.path_lines = self.__class__.path_lines(path + [("path_lines", None)], service)
                    self.pdf_data = self.__class__.pdf_data(path + [("pdf_data", None)], service)
                    self.set = self.__class__.set(path + [("set", None)], service)
                def add_custom_vector(self, *args, **kwargs):
                    """
                    Add new custom vector definition.
                    """
                    return PyMenu(self.service, "/results/graphics/expert/add_custom_vector").execute(*args, **kwargs)
                def contour(self, *args, **kwargs):
                    """
                    Display contours of a flow variable.
                    """
                    return PyMenu(self.service, "/results/graphics/expert/contour").execute(*args, **kwargs)
                def display_custom_vector(self, *args, **kwargs):
                    """
                    Display custom vector.
                    """
                    return PyMenu(self.service, "/results/graphics/expert/display_custom_vector").execute(*args, **kwargs)
                def graphics_window_layout(self, *args, **kwargs):
                    """
                    Arrange the graphics window layout.
                    """
                    return PyMenu(self.service, "/results/graphics/expert/graphics_window_layout").execute(*args, **kwargs)
                def mesh(self, *args, **kwargs):
                    """
                    Display the mesh.
                    """
                    return PyMenu(self.service, "/results/graphics/expert/mesh").execute(*args, **kwargs)
                def mesh_outline(self, *args, **kwargs):
                    """
                    Display the mesh boundaries.
                    """
                    return PyMenu(self.service, "/results/graphics/expert/mesh_outline").execute(*args, **kwargs)
                def mesh_partition_boundary(self, *args, **kwargs):
                    """
                    Display mesh partition boundaries.
                    """
                    return PyMenu(self.service, "/results/graphics/expert/mesh_partition_boundary").execute(*args, **kwargs)
                def multigrid_coarsening(self, *args, **kwargs):
                    """
                    Display a coarse mesh level from the last multigrid coarsening.
                    """
                    return PyMenu(self.service, "/results/graphics/expert/multigrid_coarsening").execute(*args, **kwargs)
                def profile(self, *args, **kwargs):
                    """
                    Display profiles of a flow variable.
                    """
                    return PyMenu(self.service, "/results/graphics/expert/profile").execute(*args, **kwargs)
                def reacting_channel_curves(self, *args, **kwargs):
                    """
                    Plot/Report the reacting channel variables.
                    """
                    return PyMenu(self.service, "/results/graphics/expert/reacting_channel_curves").execute(*args, **kwargs)
                def re_render(self, *args, **kwargs):
                    """
                    Re-render the last contour, profile, or velocity vector plot
                         with updated surfaces, meshes, lights, colormap, rendering options, etc.,
                         without recalculating the contour data.
                    """
                    return PyMenu(self.service, "/results/graphics/expert/re_render").execute(*args, **kwargs)
                def re_scale(self, *args, **kwargs):
                    """
                    Re-render the last contour, profile, or velocity vector plot
                         with updated scale, surfaces, meshes, lights, colormap, rendering options, etc.,
                         without recalculating the field data.
                    """
                    return PyMenu(self.service, "/results/graphics/expert/re_scale").execute(*args, **kwargs)
                def set_list_tree_separator(self, *args, **kwargs):
                    """
                    Set the separator character for list tree.
                    """
                    return PyMenu(self.service, "/results/graphics/expert/set_list_tree_separator").execute(*args, **kwargs)
                def surface_cells(self, *args, **kwargs):
                    """
                    Draw the cells on the specified surfaces.
                    """
                    return PyMenu(self.service, "/results/graphics/expert/surface_cells").execute(*args, **kwargs)
                def surface_mesh(self, *args, **kwargs):
                    """
                    Draw the mesh defined by the specified surfaces.
                    """
                    return PyMenu(self.service, "/results/graphics/expert/surface_mesh").execute(*args, **kwargs)
                def vector(self, *args, **kwargs):
                    """
                    Display space vectors.
                    """
                    return PyMenu(self.service, "/results/graphics/expert/vector").execute(*args, **kwargs)
                def velocity_vector(self, *args, **kwargs):
                    """
                    Display velocity vectors.
                    """
                    return PyMenu(self.service, "/results/graphics/expert/velocity_vector").execute(*args, **kwargs)
                def zone_mesh(self, *args, **kwargs):
                    """
                    Draw the mesh defined by specified face zones.
                    """
                    return PyMenu(self.service, "/results/graphics/expert/zone_mesh").execute(*args, **kwargs)

                class flamelet_data(metaclass=PyMenuMeta):
                    """
                    Display flamelet data.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def draw_number_box(self, *args, **kwargs):
                        """
                        Enable/disable display of the numbers box.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/flamelet_data/draw_number_box").execute(*args, **kwargs)
                    def plot_1d_slice(self, *args, **kwargs):
                        """
                        Enable/disable plot of the 1D-slice.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/flamelet_data/plot_1d_slice").execute(*args, **kwargs)
                    def write_to_file(self, *args, **kwargs):
                        """
                        Enable/disable writing the 1D-slice to file instead of plot.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/flamelet_data/write_to_file").execute(*args, **kwargs)
                    def carpet_plot(self, *args, **kwargs):
                        """
                        Enable/disable display of carpet plot of a property.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/flamelet_data/carpet_plot").execute(*args, **kwargs)

                class particle_tracks(metaclass=PyMenuMeta):
                    """
                    Enter the particle tracks menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def particle_tracks(self, *args, **kwargs):
                        """
                        Calculate and display particle tracks from defined injections.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/particle_tracks/particle_tracks").execute(*args, **kwargs)
                    def plot_write_xy_plot(self, *args, **kwargs):
                        """
                        Plot or write XY plot of particle tracks.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/particle_tracks/plot_write_xy_plot").execute(*args, **kwargs)

                class path_lines(metaclass=PyMenuMeta):
                    """
                    Enter the pathlines menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def path_lines(self, *args, **kwargs):
                        """
                        Display pathlines from a surface.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/path_lines/path_lines").execute(*args, **kwargs)
                    def plot_write_xy_plot(self, *args, **kwargs):
                        """
                        Plot or write XY plot of pathline.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/path_lines/plot_write_xy_plot").execute(*args, **kwargs)
                    def write_to_files(self, *args, **kwargs):
                        """
                        Write Pathlines to a File.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/path_lines/write_to_files").execute(*args, **kwargs)

                class pdf_data(metaclass=PyMenuMeta):
                    """
                    Enter the PDF data menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def draw_number_box(self, *args, **kwargs):
                        """
                        Enable/disable the display of the numbers box.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/pdf_data/draw_number_box").execute(*args, **kwargs)
                    def plot_1d_slice(self, *args, **kwargs):
                        """
                        Enable/disable a plot of the 1D-slice.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/pdf_data/plot_1d_slice").execute(*args, **kwargs)
                    def write_to_file(self, *args, **kwargs):
                        """
                        Enable/disable writing the 1D-slice to file instead of plot.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/pdf_data/write_to_file").execute(*args, **kwargs)
                    def carpet_plot(self, *args, **kwargs):
                        """
                        Enable/disable the display of a carpet plot of a property.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/pdf_data/carpet_plot").execute(*args, **kwargs)

                class set(metaclass=PyMenuMeta):
                    """
                    Enter the set menu to set display parameters.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.colors = self.__class__.colors(path + [("colors", None)], service)
                        self.contours = self.__class__.contours(path + [("contours", None)], service)
                        self.picture = self.__class__.picture(path + [("picture", None)], service)
                        self.lights = self.__class__.lights(path + [("lights", None)], service)
                        self.particle_tracks = self.__class__.particle_tracks(path + [("particle_tracks", None)], service)
                        self.path_lines = self.__class__.path_lines(path + [("path_lines", None)], service)
                        self.rendering_options = self.__class__.rendering_options(path + [("rendering_options", None)], service)
                        self.titles = self.__class__.titles(path + [("titles", None)], service)
                        self.velocity_vectors = self.__class__.velocity_vectors(path + [("velocity_vectors", None)], service)
                        self.windows = self.__class__.windows(path + [("windows", None)], service)
                    def color_map(self, *args, **kwargs):
                        """
                        Enter the color-map menu.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/color_map").execute(*args, **kwargs)
                    def element_shrink(self, *args, **kwargs):
                        """
                        Set percentage to shrink elements.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/element_shrink").execute(*args, **kwargs)
                    def filled_mesh(self, *args, **kwargs):
                        """
                        Enable/disable the filled mesh option.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/filled_mesh").execute(*args, **kwargs)
                    def mesh_level(self, *args, **kwargs):
                        """
                        Set coarse mesh level to be drawn.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/mesh_level").execute(*args, **kwargs)
                    def mesh_partitions(self, *args, **kwargs):
                        """
                        Enable/disable drawing of the mesh partition boundaries.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/mesh_partitions").execute(*args, **kwargs)
                    def mesh_surfaces(self, *args, **kwargs):
                        """
                        Set surface IDs to be drawn as mesh.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/mesh_surfaces").execute(*args, **kwargs)
                    def mesh_zones(self, *args, **kwargs):
                        """
                        Set zone IDs to be drawn as mesh.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/mesh_zones").execute(*args, **kwargs)
                    def line_weight(self, *args, **kwargs):
                        """
                        Set the line-weight factor for the window.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/line_weight").execute(*args, **kwargs)
                    def marker_size(self, *args, **kwargs):
                        """
                        Set the size of markers used to represent points.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/marker_size").execute(*args, **kwargs)
                    def marker_symbol(self, *args, **kwargs):
                        """
                        Set the type of markers used to represent points.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/marker_symbol").execute(*args, **kwargs)
                    def mesh_display_configuration(self, *args, **kwargs):
                        """
                        Set mesh display configuration.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/mesh_display_configuration").execute(*args, **kwargs)
                    def mirror_zones(self, *args, **kwargs):
                        """
                        Set zones to mirror the domain about.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/mirror_zones").execute(*args, **kwargs)
                    def n_stream_func(self, *args, **kwargs):
                        """
                        Set the number of iterations used in computing stream function.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/n_stream_func").execute(*args, **kwargs)
                    def nodewt_based_interp(self, *args, **kwargs):
                        """
                        Use more accurate node-weight based interpolation for postprocessing.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/nodewt_based_interp").execute(*args, **kwargs)
                    def overlays(self, *args, **kwargs):
                        """
                        Enable/disable overlays.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/overlays").execute(*args, **kwargs)
                    def periodic_instancing(self, *args, **kwargs):
                        """
                        Set periodic instancing.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/periodic_instancing").execute(*args, **kwargs)
                    def proximity_zones(self, *args, **kwargs):
                        """
                        Set zones to be used for boundary cell distance and boundary proximity.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/proximity_zones").execute(*args, **kwargs)
                    def render_mesh(self, *args, **kwargs):
                        """
                        Enable/disable rendering the mesh on top of contours, vectors, etc.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/render_mesh").execute(*args, **kwargs)
                    def reset_graphics(self, *args, **kwargs):
                        """
                        Reset the graphics system.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/reset_graphics").execute(*args, **kwargs)
                    def zero_angle_dir(self, *args, **kwargs):
                        """
                        Set the vector having zero angular coordinates.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/zero_angle_dir").execute(*args, **kwargs)
                    def duplicate_node_display(self, *args, **kwargs):
                        """
                        Set flag to remove duplicate nodes in mesh display.
                        """
                        return PyMenu(self.service, "/results/graphics/expert/set/duplicate_node_display").execute(*args, **kwargs)

                    class colors(metaclass=PyMenuMeta):
                        """
                        Enter the color options menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.by_type = self.__class__.by_type(path + [("by_type", None)], service)
                            self.by_surface = self.__class__.by_surface(path + [("by_surface", None)], service)
                        def background(self, *args, **kwargs):
                            """
                            Set the background (window) color.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/background").execute(*args, **kwargs)
                        def color_by_type(self, *args, **kwargs):
                            """
                            Determine whether to color meshes by type or by surface (ID).
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/color_by_type").execute(*args, **kwargs)
                        def foreground(self, *args, **kwargs):
                            """
                            Set the foreground (text and window frame) color.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/foreground").execute(*args, **kwargs)
                        def far_field_faces(self, *args, **kwargs):
                            """
                            Set the color of far field faces.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/far_field_faces").execute(*args, **kwargs)
                        def inlet_faces(self, *args, **kwargs):
                            """
                            Set the color of inlet faces.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/inlet_faces").execute(*args, **kwargs)
                        def interior_faces(self, *args, **kwargs):
                            """
                            Set the color of interior faces.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/interior_faces").execute(*args, **kwargs)
                        def internal_faces(self, *args, **kwargs):
                            """
                            Set the color of internal interface faces.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/internal_faces").execute(*args, **kwargs)
                        def outlet_faces(self, *args, **kwargs):
                            """
                            Set the color of outlet faces.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/outlet_faces").execute(*args, **kwargs)
                        def overset_faces(self, *args, **kwargs):
                            """
                            Set the color of overset faces.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/overset_faces").execute(*args, **kwargs)
                        def periodic_faces(self, *args, **kwargs):
                            """
                            Set the color of periodic faces.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/periodic_faces").execute(*args, **kwargs)
                        def rans_les_interface_faces(self, *args, **kwargs):
                            """
                            Set the color of RANS/LES interface faces.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/rans_les_interface_faces").execute(*args, **kwargs)
                        def reset_user_colors(self, *args, **kwargs):
                            """
                            Reset all user colors.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/reset_user_colors").execute(*args, **kwargs)
                        def show_user_colors(self, *args, **kwargs):
                            """
                            List currently defined user colors.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/show_user_colors").execute(*args, **kwargs)
                        def symmetry_faces(self, *args, **kwargs):
                            """
                            Set the color of symmetric faces.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/symmetry_faces").execute(*args, **kwargs)
                        def axis_faces(self, *args, **kwargs):
                            """
                            Set the color of axisymmetric faces.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/axis_faces").execute(*args, **kwargs)
                        def free_surface_faces(self, *args, **kwargs):
                            """
                            Set the color of free-surface faces.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/free_surface_faces").execute(*args, **kwargs)
                        def traction_faces(self, *args, **kwargs):
                            """
                            Set the color of traction faces.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/traction_faces").execute(*args, **kwargs)
                        def user_color(self, *args, **kwargs):
                            """
                            Explicitly set color of display zone.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/user_color").execute(*args, **kwargs)
                        def wall_faces(self, *args, **kwargs):
                            """
                            Set the color of wall faces.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/wall_faces").execute(*args, **kwargs)
                        def interface_faces(self, *args, **kwargs):
                            """
                            Set the color of mesh Interfaces.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/interface_faces").execute(*args, **kwargs)
                        def list(self, *args, **kwargs):
                            """
                            List available colors.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/list").execute(*args, **kwargs)
                        def reset_colors(self, *args, **kwargs):
                            """
                            Reset individual mesh surface colors to the defaults.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/reset_colors").execute(*args, **kwargs)
                        def surface(self, *args, **kwargs):
                            """
                            Set the color of surfaces.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/surface").execute(*args, **kwargs)
                        def skip_label(self, *args, **kwargs):
                            """
                            Set the number of labels to be skipped in the colopmap scale.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/skip_label").execute(*args, **kwargs)
                        def automatic_skip(self, *args, **kwargs):
                            """
                            Determine whether to skip labels in the colopmap scale automatically.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/automatic_skip").execute(*args, **kwargs)
                        def graphics_color_theme(self, *args, **kwargs):
                            """
                            Enter the graphics color theme menu.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/colors/graphics_color_theme").execute(*args, **kwargs)

                        class by_type(metaclass=PyMenuMeta):
                            """
                            Enter the zone type color and material assignment menu.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.type_name = self.__class__.type_name(path + [("type_name", None)], service)
                            def only_list_case_boundaries(self, *args, **kwargs):
                                """
                                Only list the boundary types that are assigned in this case.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/only_list_case_boundaries").execute(*args, **kwargs)
                            def use_inherent_material_color(self, *args, **kwargs):
                                """
                                Use inherent material color for boundary zones.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/use_inherent_material_color").execute(*args, **kwargs)
                            def reset(self, *args, **kwargs):
                                """
                                To reset colors and/or materials to the defaults.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/reset").execute(*args, **kwargs)

                            class type_name(metaclass=PyMenuMeta):
                                """
                                Select the boundary type to specify colors and/or materials.
                                """
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service
                                    self.axis = self.__class__.axis(path + [("axis", None)], service)
                                    self.far_field = self.__class__.far_field(path + [("far_field", None)], service)
                                    self.free_surface = self.__class__.free_surface(path + [("free_surface", None)], service)
                                    self.inlet = self.__class__.inlet(path + [("inlet", None)], service)
                                    self.interface = self.__class__.interface(path + [("interface", None)], service)
                                    self.interior = self.__class__.interior(path + [("interior", None)], service)
                                    self.internal = self.__class__.internal(path + [("internal", None)], service)
                                    self.outlet = self.__class__.outlet(path + [("outlet", None)], service)
                                    self.overset = self.__class__.overset(path + [("overset", None)], service)
                                    self.periodic = self.__class__.periodic(path + [("periodic", None)], service)
                                    self.rans_les_interface = self.__class__.rans_les_interface(path + [("rans_les_interface", None)], service)
                                    self.surface = self.__class__.surface(path + [("surface", None)], service)
                                    self.symmetry = self.__class__.symmetry(path + [("symmetry", None)], service)
                                    self.traction = self.__class__.traction(path + [("traction", None)], service)
                                    self.wall = self.__class__.wall(path + [("wall", None)], service)

                                class axis(metaclass=PyMenuMeta):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def color(self, *args, **kwargs):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/axis/color").execute(*args, **kwargs)
                                    def material(self, *args, **kwargs):
                                        """
                                        Set a material for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/axis/material").execute(*args, **kwargs)

                                class far_field(metaclass=PyMenuMeta):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def color(self, *args, **kwargs):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/far_field/color").execute(*args, **kwargs)
                                    def material(self, *args, **kwargs):
                                        """
                                        Set a material for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/far_field/material").execute(*args, **kwargs)

                                class free_surface(metaclass=PyMenuMeta):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def color(self, *args, **kwargs):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/free_surface/color").execute(*args, **kwargs)
                                    def material(self, *args, **kwargs):
                                        """
                                        Set a material for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/free_surface/material").execute(*args, **kwargs)

                                class inlet(metaclass=PyMenuMeta):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def color(self, *args, **kwargs):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/inlet/color").execute(*args, **kwargs)
                                    def material(self, *args, **kwargs):
                                        """
                                        Set a material for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/inlet/material").execute(*args, **kwargs)

                                class interface(metaclass=PyMenuMeta):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def color(self, *args, **kwargs):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/interface/color").execute(*args, **kwargs)
                                    def material(self, *args, **kwargs):
                                        """
                                        Set a material for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/interface/material").execute(*args, **kwargs)

                                class interior(metaclass=PyMenuMeta):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def color(self, *args, **kwargs):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/interior/color").execute(*args, **kwargs)
                                    def material(self, *args, **kwargs):
                                        """
                                        Set a material for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/interior/material").execute(*args, **kwargs)

                                class internal(metaclass=PyMenuMeta):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def color(self, *args, **kwargs):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/internal/color").execute(*args, **kwargs)
                                    def material(self, *args, **kwargs):
                                        """
                                        Set a material for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/internal/material").execute(*args, **kwargs)

                                class outlet(metaclass=PyMenuMeta):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def color(self, *args, **kwargs):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/outlet/color").execute(*args, **kwargs)
                                    def material(self, *args, **kwargs):
                                        """
                                        Set a material for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/outlet/material").execute(*args, **kwargs)

                                class overset(metaclass=PyMenuMeta):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def color(self, *args, **kwargs):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/overset/color").execute(*args, **kwargs)
                                    def material(self, *args, **kwargs):
                                        """
                                        Set a material for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/overset/material").execute(*args, **kwargs)

                                class periodic(metaclass=PyMenuMeta):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def color(self, *args, **kwargs):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/periodic/color").execute(*args, **kwargs)
                                    def material(self, *args, **kwargs):
                                        """
                                        Set a material for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/periodic/material").execute(*args, **kwargs)

                                class rans_les_interface(metaclass=PyMenuMeta):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def color(self, *args, **kwargs):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/rans_les_interface/color").execute(*args, **kwargs)
                                    def material(self, *args, **kwargs):
                                        """
                                        Set a material for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/rans_les_interface/material").execute(*args, **kwargs)

                                class surface(metaclass=PyMenuMeta):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def color(self, *args, **kwargs):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/surface/color").execute(*args, **kwargs)
                                    def material(self, *args, **kwargs):
                                        """
                                        Set a material for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/surface/material").execute(*args, **kwargs)

                                class symmetry(metaclass=PyMenuMeta):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def color(self, *args, **kwargs):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/symmetry/color").execute(*args, **kwargs)
                                    def material(self, *args, **kwargs):
                                        """
                                        Set a material for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/symmetry/material").execute(*args, **kwargs)

                                class traction(metaclass=PyMenuMeta):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def color(self, *args, **kwargs):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/traction/color").execute(*args, **kwargs)
                                    def material(self, *args, **kwargs):
                                        """
                                        Set a material for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/traction/material").execute(*args, **kwargs)

                                class wall(metaclass=PyMenuMeta):
                                    """
                                    Set the material and/or color for the selected boundary type.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def color(self, *args, **kwargs):
                                        """
                                        Set a color for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/wall/color").execute(*args, **kwargs)
                                    def material(self, *args, **kwargs):
                                        """
                                        Set a material for the selected boundary type.
                                        """
                                        return PyMenu(self.service, "/results/graphics/expert/set/colors/by_type/type_name/wall/material").execute(*args, **kwargs)

                        class by_surface(metaclass=PyMenuMeta):
                            """
                            Enter the surface(s) color and material assignment menu.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def surfaces(self, *args, **kwargs):
                                """
                                Select the surface(s) to specify colors and/or materials.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/colors/by_surface/surfaces").execute(*args, **kwargs)
                            def use_inherent_material_color(self, *args, **kwargs):
                                """
                                Use inherent material color for surfaces.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/colors/by_surface/use_inherent_material_color").execute(*args, **kwargs)
                            def reset(self, *args, **kwargs):
                                """
                                To reset colors and/or materials to the defaults.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/colors/by_surface/reset").execute(*args, **kwargs)
                            def list_surfaces_by_color(self, *args, **kwargs):
                                """
                                To list the surfaces by its color.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/colors/by_surface/list_surfaces_by_color").execute(*args, **kwargs)
                            def list_surfaces_by_material(self, *args, **kwargs):
                                """
                                To list the surfaces by its material.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/colors/by_surface/list_surfaces_by_material").execute(*args, **kwargs)

                    class contours(metaclass=PyMenuMeta):
                        """
                        Enter the contour options menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def auto_range(self, *args, **kwargs):
                            """
                            Enable/disable auto-computation of range for contours.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/contours/auto_range").execute(*args, **kwargs)
                        def clip_to_range(self, *args, **kwargs):
                            """
                            Enable/disable the clip to range option for filled contours.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/contours/clip_to_range").execute(*args, **kwargs)
                        def surfaces(self, *args, **kwargs):
                            """
                            Set surfaces to be contoured.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/contours/surfaces").execute(*args, **kwargs)
                        def filled_contours(self, *args, **kwargs):
                            """
                            Enable/disable the filled contour option.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/contours/filled_contours").execute(*args, **kwargs)
                        def global_range(self, *args, **kwargs):
                            """
                            Enable/disable the global range for contours option.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/contours/global_range").execute(*args, **kwargs)
                        def line_contours(self, *args, **kwargs):
                            """
                            Enable/disable the filled contour option.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/contours/line_contours").execute(*args, **kwargs)
                        def log_scale(self, *args, **kwargs):
                            """
                            Enable/disable the use of a log scale.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/contours/log_scale").execute(*args, **kwargs)
                        def n_contour(self, *args, **kwargs):
                            """
                            Set the number of contour levels.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/contours/n_contour").execute(*args, **kwargs)
                        def node_values(self, *args, **kwargs):
                            """
                            Enable/disable the plot of node values.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/contours/node_values").execute(*args, **kwargs)
                        def render_mesh(self, *args, **kwargs):
                            """
                            Determine whether or not to render the mesh on top of contours, vectors, etc.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/contours/render_mesh").execute(*args, **kwargs)
                        def coloring(self, *args, **kwargs):
                            """
                            Select coloring option.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/contours/coloring").execute(*args, **kwargs)

                    class picture(metaclass=PyMenuMeta):
                        """
                        Enter the hardcopy/save-picture options menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.color_mode = self.__class__.color_mode(path + [("color_mode", None)], service)
                            self.driver = self.__class__.driver(path + [("driver", None)], service)
                        def invert_background(self, *args, **kwargs):
                            """
                            Use a white background when the picture is saved.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/picture/invert_background").execute(*args, **kwargs)
                        def landscape(self, *args, **kwargs):
                            """
                            Plot hardcopies in landscape or portrait orientation.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/picture/landscape").execute(*args, **kwargs)
                        def preview(self, *args, **kwargs):
                            """
                            Display a preview image of a hardcopy.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/picture/preview").execute(*args, **kwargs)
                        def x_resolution(self, *args, **kwargs):
                            """
                            Set the width of raster-formatted images in pixels (0 implies current window size).
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/picture/x_resolution").execute(*args, **kwargs)
                        def y_resolution(self, *args, **kwargs):
                            """
                            Set the height of raster-formatted images in pixels (0 implies current window size).
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/picture/y_resolution").execute(*args, **kwargs)
                        def dpi(self, *args, **kwargs):
                            """
                            Set the DPI for EPS and Postscript files, specifies the resolution in dots per inch (DPI) instead of setting the width and height.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/picture/dpi").execute(*args, **kwargs)
                        def use_window_resolution(self, *args, **kwargs):
                            """
                            Use the currently active window's resolution for hardcopy (ignores the x-resolution and y-resolution in this case).
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/picture/use_window_resolution").execute(*args, **kwargs)
                        def set_standard_resolution(self, *args, **kwargs):
                            """
                            Select from pre-defined resolution list.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/picture/set_standard_resolution").execute(*args, **kwargs)
                        def jpeg_hardcopy_quality(self, *args, **kwargs):
                            """
                            To set jpeg hardcopy quality.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/picture/jpeg_hardcopy_quality").execute(*args, **kwargs)

                        class color_mode(metaclass=PyMenuMeta):
                            """
                            Enter the hardcopy color mode menu.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def color(self, *args, **kwargs):
                                """
                                Plot hardcopies in color.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/picture/color_mode/color").execute(*args, **kwargs)
                            def gray_scale(self, *args, **kwargs):
                                """
                                Convert color to grayscale for hardcopy.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/picture/color_mode/gray_scale").execute(*args, **kwargs)
                            def mono_chrome(self, *args, **kwargs):
                                """
                                Convert color to monochrome (black and white) for hardcopy.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/picture/color_mode/mono_chrome").execute(*args, **kwargs)
                            def list(self, *args, **kwargs):
                                """
                                Display the current hardcopy color mode.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/picture/color_mode/list").execute(*args, **kwargs)

                        class driver(metaclass=PyMenuMeta):
                            """
                            Enter the set hardcopy driver menu.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.post_format = self.__class__.post_format(path + [("post_format", None)], service)
                            def dump_window(self, *args, **kwargs):
                                """
                                Set the command used to dump the graphics window to a file.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/picture/driver/dump_window").execute(*args, **kwargs)
                            def eps(self, *args, **kwargs):
                                """
                                Produce encapsulated PostScript (EPS) output for hardcopies.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/picture/driver/eps").execute(*args, **kwargs)
                            def jpeg(self, *args, **kwargs):
                                """
                                Produce JPEG output for hardcopies.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/picture/driver/jpeg").execute(*args, **kwargs)
                            def post_script(self, *args, **kwargs):
                                """
                                Produce PostScript output for hardcopies.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/picture/driver/post_script").execute(*args, **kwargs)
                            def ppm(self, *args, **kwargs):
                                """
                                Produce PPM output for hardcopies.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/picture/driver/ppm").execute(*args, **kwargs)
                            def tiff(self, *args, **kwargs):
                                """
                                Use TIFF output for hardcopies.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/picture/driver/tiff").execute(*args, **kwargs)
                            def png(self, *args, **kwargs):
                                """
                                Use PNG output for hardcopies.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/picture/driver/png").execute(*args, **kwargs)
                            def hsf(self, *args, **kwargs):
                                """
                                Use HSF output for hardcopies.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/picture/driver/hsf").execute(*args, **kwargs)
                            def avz(self, *args, **kwargs):
                                """
                                Use AVZ output for hardcopies.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/picture/driver/avz").execute(*args, **kwargs)
                            def glb(self, *args, **kwargs):
                                """
                                Use GLB output for hardcopies.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/picture/driver/glb").execute(*args, **kwargs)
                            def vrml(self, *args, **kwargs):
                                """
                                Use VRML output for hardcopies.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/picture/driver/vrml").execute(*args, **kwargs)
                            def list(self, *args, **kwargs):
                                """
                                List the current hardcopy driver.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/picture/driver/list").execute(*args, **kwargs)
                            def options(self, *args, **kwargs):
                                """
                                Set the hardcopy options. Available options are:
                                \\n               	"no gamma correction", disables gamma correction of colors,
                                \\n               	"physical size = (width,height)", where width and height
                                          are the actual measurements of the printable area of the page
                                          in centimeters.
                                \\n               	"subscreen = (left,right,bottom,top)", where left,right,
                                          bottom, and top are numbers in [-1,1] describing a subwindow on
                                          the page in which to place the hardcopy.
                                
                                \\n          The options may be combined by separating them with commas.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/picture/driver/options").execute(*args, **kwargs)

                            class post_format(metaclass=PyMenuMeta):
                                """
                                Enter the PostScript driver format menu.
                                """
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service
                                def fast_raster(self, *args, **kwargs):
                                    """
                                    Use the new raster format.
                                    """
                                    return PyMenu(self.service, "/results/graphics/expert/set/picture/driver/post_format/fast_raster").execute(*args, **kwargs)
                                def raster(self, *args, **kwargs):
                                    """
                                    Use the original raster format.
                                    """
                                    return PyMenu(self.service, "/results/graphics/expert/set/picture/driver/post_format/raster").execute(*args, **kwargs)
                                def rle_raster(self, *args, **kwargs):
                                    """
                                    Use the run-length encoded raster format.
                                    """
                                    return PyMenu(self.service, "/results/graphics/expert/set/picture/driver/post_format/rle_raster").execute(*args, **kwargs)
                                def vector(self, *args, **kwargs):
                                    """
                                    Use vector format.
                                    """
                                    return PyMenu(self.service, "/results/graphics/expert/set/picture/driver/post_format/vector").execute(*args, **kwargs)

                    class lights(metaclass=PyMenuMeta):
                        """
                        Enter the lights menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.lighting_interpolation = self.__class__.lighting_interpolation(path + [("lighting_interpolation", None)], service)
                        def lights_on(self, *args, **kwargs):
                            """
                            Turn all active lighting on/off.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/lights/lights_on").execute(*args, **kwargs)
                        def set_ambient_color(self, *args, **kwargs):
                            """
                            Set the ambient light color for the scene.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/lights/set_ambient_color").execute(*args, **kwargs)
                        def set_light(self, *args, **kwargs):
                            """
                            Add or modify a directional, colored light.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/lights/set_light").execute(*args, **kwargs)
                        def headlight_on(self, *args, **kwargs):
                            """
                            Turn the light that moves with the camera on or off.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/lights/headlight_on").execute(*args, **kwargs)

                        class lighting_interpolation(metaclass=PyMenuMeta):
                            """
                            Set lighting interpolation method.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def automatic(self, *args, **kwargs):
                                """
                                Choose Automatic to automatically select the best lighting method for a given graphics object.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/lights/lighting_interpolation/automatic").execute(*args, **kwargs)
                            def flat(self, *args, **kwargs):
                                """
                                Use flat shading for meshes and polygons.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/lights/lighting_interpolation/flat").execute(*args, **kwargs)
                            def gouraud(self, *args, **kwargs):
                                """
                                Use Gouraud shading to calculate the color at each vertex of a polygon and interpolate it in the interior.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/lights/lighting_interpolation/gouraud").execute(*args, **kwargs)
                            def phong(self, *args, **kwargs):
                                """
                                Use Phong shading to interpolate the normals for each pixel of a polygon and compute a color at every pixel.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/lights/lighting_interpolation/phong").execute(*args, **kwargs)

                    class particle_tracks(metaclass=PyMenuMeta):
                        """
                        Enter the particle-tracks menu to set parameters for display of particle tracks.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.sphere_settings = self.__class__.sphere_settings(path + [("sphere_settings", None)], service)
                            self.vector_settings = self.__class__.vector_settings(path + [("vector_settings", None)], service)
                            self.filter_settings = self.__class__.filter_settings(path + [("filter_settings", None)], service)
                        def display(self, *args, **kwargs):
                            """
                            Determine whether particle tracks will be displayed or only tracked.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/display").execute(*args, **kwargs)
                        def history_filename(self, *args, **kwargs):
                            """
                            Specify the name of the particle history file.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/history_filename").execute(*args, **kwargs)
                        def report_to(self, *args, **kwargs):
                            """
                            Specify the destination for the report (console, file, none).
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/report_to").execute(*args, **kwargs)
                        def report_type(self, *args, **kwargs):
                            """
                            Set the report type for particle tracks.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/report_type").execute(*args, **kwargs)
                        def report_variables(self, *args, **kwargs):
                            """
                            Set the report variables.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/report_variables").execute(*args, **kwargs)
                        def report_default_variables(self, *args, **kwargs):
                            """
                            Set the report variables to default.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/report_default_variables").execute(*args, **kwargs)
                        def track_single_particle_stream(self, *args, **kwargs):
                            """
                            Specify the stream ID to be tracked.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/track_single_particle_stream").execute(*args, **kwargs)
                        def arrow_scale(self, *args, **kwargs):
                            """
                            Set the scale factor for arrows drawn on particle tracks.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/arrow_scale").execute(*args, **kwargs)
                        def arrow_space(self, *args, **kwargs):
                            """
                            Set the spacing factor for arrows drawn on particle tracks.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/arrow_space").execute(*args, **kwargs)
                        def coarsen_factor(self, *args, **kwargs):
                            """
                            Set the particle tracks coarsening factor.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/coarsen_factor").execute(*args, **kwargs)
                        def line_width(self, *args, **kwargs):
                            """
                            Set the width for particle track.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/line_width").execute(*args, **kwargs)
                        def marker_size(self, *args, **kwargs):
                            """
                            Set the marker size for particle drawing.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/marker_size").execute(*args, **kwargs)
                        def radius(self, *args, **kwargs):
                            """
                            Set the radius for particle track (ribbons/cylinder only) cross-section.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/radius").execute(*args, **kwargs)
                        def style(self, *args, **kwargs):
                            """
                            Set the display style for particle track (line/ribbon/cylinder/sphere).
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/style").execute(*args, **kwargs)
                        def twist_factor(self, *args, **kwargs):
                            """
                            Set the scale factor for twisting (ribbons only).
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/twist_factor").execute(*args, **kwargs)
                        def sphere_attrib(self, *args, **kwargs):
                            """
                            Specify size and number of slices to be used in drawing spheres.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/sphere_attrib").execute(*args, **kwargs)
                        def particle_skip(self, *args, **kwargs):
                            """
                            Specify how many particle tracks should be displayed.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/particle_skip").execute(*args, **kwargs)

                        class sphere_settings(metaclass=PyMenuMeta):
                            """
                            Provide sphere specific input.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def vary_diameter(self, *args, **kwargs):
                                """
                                Specify whether the spheres can vary with another variable.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/sphere_settings/vary_diameter").execute(*args, **kwargs)
                            def diameter(self, *args, **kwargs):
                                """
                                Diameter of the spheres when vary-diameter? is disabled.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/sphere_settings/diameter").execute(*args, **kwargs)
                            def auto_range(self, *args, **kwargs):
                                """
                                Specify whether displayed spheres should include auto range of variable to size spheres.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/sphere_settings/auto_range").execute(*args, **kwargs)
                            def minimum(self, *args, **kwargs):
                                """
                                Set the minimum value of the sphere to be displayed.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/sphere_settings/minimum").execute(*args, **kwargs)
                            def maximum(self, *args, **kwargs):
                                """
                                Set the maximum value of the sphere to be displayed.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/sphere_settings/maximum").execute(*args, **kwargs)
                            def smooth_parameter(self, *args, **kwargs):
                                """
                                Specify number of slices to be used in drawing spheres.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/sphere_settings/smooth_parameter").execute(*args, **kwargs)
                            def scale_factor(self, *args, **kwargs):
                                """
                                Specify a scale factor to enlarge/reduce the size of spheres.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/sphere_settings/scale_factor").execute(*args, **kwargs)
                            def size_variable(self, *args, **kwargs):
                                """
                                Select a particle variable to size the spheres.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/sphere_settings/size_variable").execute(*args, **kwargs)

                        class vector_settings(metaclass=PyMenuMeta):
                            """
                            Set vector specific input.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def style(self, *args, **kwargs):
                                """
                                Enable and set the display style for particle vectors (none/vector/centered-vector/centered-cylinder).
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/vector_settings/style").execute(*args, **kwargs)
                            def vector_length(self, *args, **kwargs):
                                """
                                Specify the length of constant vectors.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/vector_settings/vector_length").execute(*args, **kwargs)
                            def vector_length_variable(self, *args, **kwargs):
                                """
                                Select a particle variable to specify the length of vectors.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/vector_settings/vector_length_variable").execute(*args, **kwargs)
                            def scale_factor(self, *args, **kwargs):
                                """
                                Specify a scale factor to enlarge/reduce the length of vectors.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/vector_settings/scale_factor").execute(*args, **kwargs)
                            def length_variable(self, *args, **kwargs):
                                """
                                Specify whether the displayed vectors have length varying with another variable.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/vector_settings/length_variable").execute(*args, **kwargs)
                            def length_to_head_ratio(self, *args, **kwargs):
                                """
                                Specify ratio of length to head for vectors and length to diameter for cylinders.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/vector_settings/length_to_head_ratio").execute(*args, **kwargs)
                            def constant_color(self, *args, **kwargs):
                                """
                                Specify a constant color for the vectors.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/vector_settings/constant_color").execute(*args, **kwargs)
                            def color_variable(self, *args, **kwargs):
                                """
                                Specify whether the vectors should be colored by variable specified in /display/particle-track/particle-track (if false use a constant color).
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/vector_settings/color_variable").execute(*args, **kwargs)
                            def vector_variable(self, *args, **kwargs):
                                """
                                Select a particle vector function to specify vector direction.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/vector_settings/vector_variable").execute(*args, **kwargs)

                        class filter_settings(metaclass=PyMenuMeta):
                            """
                            Set filter for particle display.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def enable_filtering(self, *args, **kwargs):
                                """
                                Specify whether particle display is filtered.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/filter_settings/enable_filtering").execute(*args, **kwargs)
                            def inside(self, *args, **kwargs):
                                """
                                Specify whether filter variable needs to be inside min/max to be displayed (else outside min/max).
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/filter_settings/inside").execute(*args, **kwargs)
                            def filter_variable(self, *args, **kwargs):
                                """
                                Select a variable used for filtering of particles.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/filter_settings/filter_variable").execute(*args, **kwargs)
                            def minimum(self, *args, **kwargs):
                                """
                                Specify the lower bound for the filter variable.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/filter_settings/minimum").execute(*args, **kwargs)
                            def maximum(self, *args, **kwargs):
                                """
                                Specify the upper bound for the filter variable.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/particle_tracks/filter_settings/maximum").execute(*args, **kwargs)

                    class path_lines(metaclass=PyMenuMeta):
                        """
                        Enter the path-lines menu to set parameters for the display of pathlines.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def arrow_scale(self, *args, **kwargs):
                            """
                            Set the scale factor for arrows drawn on pathlines.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/path_lines/arrow_scale").execute(*args, **kwargs)
                        def arrow_space(self, *args, **kwargs):
                            """
                            Set the spacing factor for arrows drawn on pathlines.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/path_lines/arrow_space").execute(*args, **kwargs)
                        def display_steps(self, *args, **kwargs):
                            """
                            Set the display stepping for pathlines.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/path_lines/display_steps").execute(*args, **kwargs)
                        def error_control(self, *args, **kwargs):
                            """
                            Set error control during pathline computation.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/path_lines/error_control").execute(*args, **kwargs)
                        def line_width(self, *args, **kwargs):
                            """
                            Set the width for pathlines.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/path_lines/line_width").execute(*args, **kwargs)
                        def marker_size(self, *args, **kwargs):
                            """
                            Set the marker size for particle drawing.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/path_lines/marker_size").execute(*args, **kwargs)
                        def maximum_steps(self, *args, **kwargs):
                            """
                            Set the maximum number of steps to take for pathlines.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/path_lines/maximum_steps").execute(*args, **kwargs)
                        def maximum_error(self, *args, **kwargs):
                            """
                            Set the maximum error allowed while computing the pathlines.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/path_lines/maximum_error").execute(*args, **kwargs)
                        def radius(self, *args, **kwargs):
                            """
                            Set the radius for pathline (ribbons/cylinder only) cross-section.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/path_lines/radius").execute(*args, **kwargs)
                        def relative_pathlines(self, *args, **kwargs):
                            """
                            Enable/disable the tracking of pathlines in a relative coordinate system.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/path_lines/relative_pathlines").execute(*args, **kwargs)
                        def style(self, *args, **kwargs):
                            """
                            Set display style for pathlines (line/ribbon/cylinder).
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/path_lines/style").execute(*args, **kwargs)
                        def twist_factor(self, *args, **kwargs):
                            """
                            Set the scale factor for twisting (ribbons only).
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/path_lines/twist_factor").execute(*args, **kwargs)
                        def step_size(self, *args, **kwargs):
                            """
                            Set the step length between particle positions for path-lines.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/path_lines/step_size").execute(*args, **kwargs)
                        def reverse(self, *args, **kwargs):
                            """
                            Enable/disable the direction of path tracking.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/path_lines/reverse").execute(*args, **kwargs)
                        def sphere_attrib(self, *args, **kwargs):
                            """
                            Specify size and no. of slices to be used in drawing sphere for sphere-style.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/path_lines/sphere_attrib").execute(*args, **kwargs)
                        def track_in_phase(self, *args, **kwargs):
                            """
                            Assign phase to display pathlines in.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/path_lines/track_in_phase").execute(*args, **kwargs)

                    class rendering_options(metaclass=PyMenuMeta):
                        """
                        Enter the rendering options menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def auto_spin(self, *args, **kwargs):
                            """
                            Enable/disable mouse view rotations to continue to spin the display after the button is released.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/rendering_options/auto_spin").execute(*args, **kwargs)
                        def device_info(self, *args, **kwargs):
                            """
                            List information for the graphics device.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/rendering_options/device_info").execute(*args, **kwargs)
                        def double_buffering(self, *args, **kwargs):
                            """
                            Enable/disable double-buffering.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/rendering_options/double_buffering").execute(*args, **kwargs)
                        def driver(self, *args, **kwargs):
                            """
                            Change the current graphics driver.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/rendering_options/driver").execute(*args, **kwargs)
                        def hidden_surfaces(self, *args, **kwargs):
                            """
                            Enable/disable hidden surface removal.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/rendering_options/hidden_surfaces").execute(*args, **kwargs)
                        def hidden_surface_method(self, *args, **kwargs):
                            """
                            Specify the method to perform hidden line and hidden surface rendering.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/rendering_options/hidden_surface_method").execute(*args, **kwargs)
                        def outer_face_cull(self, *args, **kwargs):
                            """
                            Enable/disable discarding outer faces during display.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/rendering_options/outer_face_cull").execute(*args, **kwargs)
                        def surface_edge_visibility(self, *args, **kwargs):
                            """
                            Set edge visibility flags for surfaces.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/rendering_options/surface_edge_visibility").execute(*args, **kwargs)
                        def animation_option(self, *args, **kwargs):
                            """
                            Using Wireframe / All option during animation.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/rendering_options/animation_option").execute(*args, **kwargs)
                        def color_map_alignment(self, *args, **kwargs):
                            """
                            Set the color bar alignment.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/rendering_options/color_map_alignment").execute(*args, **kwargs)
                        def help_text_color(self, *args, **kwargs):
                            """
                            Set the color of screen help text.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/rendering_options/help_text_color").execute(*args, **kwargs)
                        def face_displacement(self, *args, **kwargs):
                            """
                            Set face displacement value in Z-buffer units along the Camera Z-axis.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/rendering_options/face_displacement").execute(*args, **kwargs)
                        def set_rendering_options(self, *args, **kwargs):
                            """
                            Set the rendering options.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/rendering_options/set_rendering_options").execute(*args, **kwargs)
                        def show_colormap(self, *args, **kwargs):
                            """
                            Enable/Disable colormap.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/rendering_options/show_colormap").execute(*args, **kwargs)

                    class titles(metaclass=PyMenuMeta):
                        """
                        Set problem title.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def left_top(self, *args, **kwargs):
                            """
                            Set the title text for left top in title segment.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/titles/left_top").execute(*args, **kwargs)
                        def left_bottom(self, *args, **kwargs):
                            """
                            Set the title text for left bottom in title segment.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/titles/left_bottom").execute(*args, **kwargs)
                        def right_top(self, *args, **kwargs):
                            """
                            Set the title text for right top in title segment.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/titles/right_top").execute(*args, **kwargs)
                        def right_middle(self, *args, **kwargs):
                            """
                            Set the title text for right middle in title segment.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/titles/right_middle").execute(*args, **kwargs)
                        def right_bottom(self, *args, **kwargs):
                            """
                            Set the title text for right bottom in title segment.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/titles/right_bottom").execute(*args, **kwargs)

                    class velocity_vectors(metaclass=PyMenuMeta):
                        """
                        Enter the menu to set parameters for display of velocity vectors.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def auto_scale(self, *args, **kwargs):
                            """
                            Enable/disable auto-scale of all vectors so that vector overlap is minimal.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/velocity_vectors/auto_scale").execute(*args, **kwargs)
                        def color(self, *args, **kwargs):
                            """
                            Set the color used for all vectors. Set color to the null string to use the color map.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/velocity_vectors/color").execute(*args, **kwargs)
                        def component_x(self, *args, **kwargs):
                            """
                            Enable/disable use of x-component of vectors.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/velocity_vectors/component_x").execute(*args, **kwargs)
                        def component_y(self, *args, **kwargs):
                            """
                            Enable/disable use of y-component of vectors.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/velocity_vectors/component_y").execute(*args, **kwargs)
                        def component_z(self, *args, **kwargs):
                            """
                            Enable/disable use of z-component of vectors.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/velocity_vectors/component_z").execute(*args, **kwargs)
                        def constant_length(self, *args, **kwargs):
                            """
                            Enable/disable setting all vectors to have the same length.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/velocity_vectors/constant_length").execute(*args, **kwargs)
                        def color_levels(self, *args, **kwargs):
                            """
                            Set the number of colors used from the color map.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/velocity_vectors/color_levels").execute(*args, **kwargs)
                        def global_range(self, *args, **kwargs):
                            """
                            Enable/disable the global range for vectors option.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/velocity_vectors/global_range").execute(*args, **kwargs)
                        def in_plane(self, *args, **kwargs):
                            """
                            Toggle the display of in-plane velocity vectors.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/velocity_vectors/in_plane").execute(*args, **kwargs)
                        def log_scale(self, *args, **kwargs):
                            """
                            Enable/disable the use of a log scale.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/velocity_vectors/log_scale").execute(*args, **kwargs)
                        def node_values(self, *args, **kwargs):
                            """
                            Enable/disable plotting node values. Cell values will be plotted if "no".
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/velocity_vectors/node_values").execute(*args, **kwargs)
                        def relative(self, *args, **kwargs):
                            """
                            Enable/disable the display of relative velocity vectors.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/velocity_vectors/relative").execute(*args, **kwargs)
                        def render_mesh(self, *args, **kwargs):
                            """
                            Enable/disable rendering the mseh on top of contours, vectors, etc.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/velocity_vectors/render_mesh").execute(*args, **kwargs)
                        def scale(self, *args, **kwargs):
                            """
                            Set the value by which the vector length will be scaled.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/velocity_vectors/scale").execute(*args, **kwargs)
                        def scale_head(self, *args, **kwargs):
                            """
                            Set the value by which the vector head will be scaled.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/velocity_vectors/scale_head").execute(*args, **kwargs)
                        def style(self, *args, **kwargs):
                            """
                            Set the style with which the vectors will be drawn.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/velocity_vectors/style").execute(*args, **kwargs)
                        def surfaces(self, *args, **kwargs):
                            """
                            Set surfaces on which vectors are drawn.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/velocity_vectors/surfaces").execute(*args, **kwargs)

                    class windows(metaclass=PyMenuMeta):
                        """
                        Enter the window options menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.axes = self.__class__.axes(path + [("axes", None)], service)
                            self.main = self.__class__.main(path + [("main", None)], service)
                            self.scale = self.__class__.scale(path + [("scale", None)], service)
                            self.text = self.__class__.text(path + [("text", None)], service)
                            self.video = self.__class__.video(path + [("video", None)], service)
                            self.xy = self.__class__.xy(path + [("xy", None)], service)
                        def aspect_ratio(self, *args, **kwargs):
                            """
                            Set the aspect ratio of the active window.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/windows/aspect_ratio").execute(*args, **kwargs)
                        def logo(self, *args, **kwargs):
                            """
                            Enable/disable visibility of the logo in graphics window.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/windows/logo").execute(*args, **kwargs)
                        def ruler(self, *args, **kwargs):
                            """
                            Enable/disable ruler visibility.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/windows/ruler").execute(*args, **kwargs)
                        def logo_color(self, *args, **kwargs):
                            """
                            Set logo color to white/black.
                            """
                            return PyMenu(self.service, "/results/graphics/expert/set/windows/logo_color").execute(*args, **kwargs)

                        class axes(metaclass=PyMenuMeta):
                            """
                            Enter the axes window options menu.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def border(self, *args, **kwargs):
                                """
                                Enable/disable drawing of a border around the axes window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/axes/border").execute(*args, **kwargs)
                            def bottom(self, *args, **kwargs):
                                """
                                Set the bottom boundary of the axes window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/axes/bottom").execute(*args, **kwargs)
                            def clear(self, *args, **kwargs):
                                """
                                Set the transparency of the axes window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/axes/clear").execute(*args, **kwargs)
                            def right(self, *args, **kwargs):
                                """
                                Set the right boundary of the axes window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/axes/right").execute(*args, **kwargs)
                            def visible(self, *args, **kwargs):
                                """
                                Enable/disable axes visibility.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/axes/visible").execute(*args, **kwargs)

                        class main(metaclass=PyMenuMeta):
                            """
                            Enter the main view window options menu.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def border(self, *args, **kwargs):
                                """
                                Enable/disable drawing of borders around the main viewing window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/main/border").execute(*args, **kwargs)
                            def bottom(self, *args, **kwargs):
                                """
                                Set the bottom boundary of the main viewing window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/main/bottom").execute(*args, **kwargs)
                            def left(self, *args, **kwargs):
                                """
                                Set the left boundary of the main viewing window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/main/left").execute(*args, **kwargs)
                            def right(self, *args, **kwargs):
                                """
                                Set the right boundary of the main viewing window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/main/right").execute(*args, **kwargs)
                            def top(self, *args, **kwargs):
                                """
                                Set the top boundary of the main viewing window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/main/top").execute(*args, **kwargs)
                            def visible(self, *args, **kwargs):
                                """
                                Enable/disable visibility of the main viewing window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/main/visible").execute(*args, **kwargs)

                        class scale(metaclass=PyMenuMeta):
                            """
                            Enter the color scale window options menu.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def border(self, *args, **kwargs):
                                """
                                Enable/disable drawing of borders around the color scale window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/scale/border").execute(*args, **kwargs)
                            def bottom(self, *args, **kwargs):
                                """
                                Set the bottom boundary of the color scale window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/scale/bottom").execute(*args, **kwargs)
                            def clear(self, *args, **kwargs):
                                """
                                Set the transparency of the scale window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/scale/clear").execute(*args, **kwargs)
                            def format(self, *args, **kwargs):
                                """
                                Set the number format of the color scale window (e.g. %0.2e).
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/scale/format").execute(*args, **kwargs)
                            def font_size(self, *args, **kwargs):
                                """
                                Set the font size of the color scale window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/scale/font_size").execute(*args, **kwargs)
                            def left(self, *args, **kwargs):
                                """
                                Set the left boundary of the color scale window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/scale/left").execute(*args, **kwargs)
                            def margin(self, *args, **kwargs):
                                """
                                Set the margin of the color scale window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/scale/margin").execute(*args, **kwargs)
                            def right(self, *args, **kwargs):
                                """
                                Set the right boundary of the color scale window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/scale/right").execute(*args, **kwargs)
                            def top(self, *args, **kwargs):
                                """
                                Set the top boundary of the color scale window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/scale/top").execute(*args, **kwargs)
                            def visible(self, *args, **kwargs):
                                """
                                Enable/disable visibility of the color scale window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/scale/visible").execute(*args, **kwargs)
                            def alignment(self, *args, **kwargs):
                                """
                                Set colormap to bottom/left/top/right.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/scale/alignment").execute(*args, **kwargs)

                        class text(metaclass=PyMenuMeta):
                            """
                            Enter the text window options menu.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def application(self, *args, **kwargs):
                                """
                                Enable/disable the application name in the picture.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/text/application").execute(*args, **kwargs)
                            def border(self, *args, **kwargs):
                                """
                                Enable/disable drawing of borders around the text window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/text/border").execute(*args, **kwargs)
                            def bottom(self, *args, **kwargs):
                                """
                                Set the bottom boundary of the text window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/text/bottom").execute(*args, **kwargs)
                            def clear(self, *args, **kwargs):
                                """
                                Enable/disable text window transparency.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/text/clear").execute(*args, **kwargs)
                            def company(self, *args, **kwargs):
                                """
                                Enable/disable the company name in the picture.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/text/company").execute(*args, **kwargs)
                            def date(self, *args, **kwargs):
                                """
                                Enable/disable the date in the picture.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/text/date").execute(*args, **kwargs)
                            def left(self, *args, **kwargs):
                                """
                                Set the left boundary of the text window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/text/left").execute(*args, **kwargs)
                            def right(self, *args, **kwargs):
                                """
                                Set the right boundary of the text window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/text/right").execute(*args, **kwargs)
                            def top(self, *args, **kwargs):
                                """
                                Set the top boundary of the text window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/text/top").execute(*args, **kwargs)
                            def visible(self, *args, **kwargs):
                                """
                                Enable/disable text window transparency.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/text/visible").execute(*args, **kwargs)

                        class video(metaclass=PyMenuMeta):
                            """
                            Enter the video window options menu.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def background(self, *args, **kwargs):
                                """
                                Set the background color in the video picture.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/video/background").execute(*args, **kwargs)
                            def color_filter(self, *args, **kwargs):
                                """
                                Set the color filter options for the picture.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/video/color_filter").execute(*args, **kwargs)
                            def foreground(self, *args, **kwargs):
                                """
                                Set the foreground color in the video picture.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/video/foreground").execute(*args, **kwargs)
                            def on(self, *args, **kwargs):
                                """
                                Enable/disable video picture settings.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/video/on").execute(*args, **kwargs)
                            def pixel_size(self, *args, **kwargs):
                                """
                                Set the window size in pixels.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/video/pixel_size").execute(*args, **kwargs)

                        class xy(metaclass=PyMenuMeta):
                            """
                            Enter the X-Y plot window options menu.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def border(self, *args, **kwargs):
                                """
                                Enable/disable drawing of a border around the X-Y plotter window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/xy/border").execute(*args, **kwargs)
                            def bottom(self, *args, **kwargs):
                                """
                                Set the bottom boundary of the X-Y plotter window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/xy/bottom").execute(*args, **kwargs)
                            def left(self, *args, **kwargs):
                                """
                                Set the left boundary of the X-Y plotter window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/xy/left").execute(*args, **kwargs)
                            def right(self, *args, **kwargs):
                                """
                                Set the right boundary of the X-Y plotter window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/xy/right").execute(*args, **kwargs)
                            def top(self, *args, **kwargs):
                                """
                                Set the top boundary of the X-Y plotter window.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/xy/top").execute(*args, **kwargs)
                            def visible(self, *args, **kwargs):
                                """
                                Enable/disable X-Y plotter window visibility.
                                """
                                return PyMenu(self.service, "/results/graphics/expert/set/windows/xy/visible").execute(*args, **kwargs)

            class lights(metaclass=PyMenuMeta):
                """
                Enter the lights menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.lighting_interpolation = self.__class__.lighting_interpolation(path + [("lighting_interpolation", None)], service)
                def lights_on(self, *args, **kwargs):
                    """
                    Turn all active lighting on/off.
                    """
                    return PyMenu(self.service, "/results/graphics/lights/lights_on").execute(*args, **kwargs)
                def set_ambient_color(self, *args, **kwargs):
                    """
                    Set the ambient light color for the scene.
                    """
                    return PyMenu(self.service, "/results/graphics/lights/set_ambient_color").execute(*args, **kwargs)
                def set_light(self, *args, **kwargs):
                    """
                    Add or modify a directional, colored light.
                    """
                    return PyMenu(self.service, "/results/graphics/lights/set_light").execute(*args, **kwargs)
                def headlight_on(self, *args, **kwargs):
                    """
                    Turn the light that moves with the camera on or off.
                    """
                    return PyMenu(self.service, "/results/graphics/lights/headlight_on").execute(*args, **kwargs)

                class lighting_interpolation(metaclass=PyMenuMeta):
                    """
                    Set lighting interpolation method.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def automatic(self, *args, **kwargs):
                        """
                        Choose Automatic to automatically select the best lighting method for a given graphics object.
                        """
                        return PyMenu(self.service, "/results/graphics/lights/lighting_interpolation/automatic").execute(*args, **kwargs)
                    def flat(self, *args, **kwargs):
                        """
                        Use flat shading for meshes and polygons.
                        """
                        return PyMenu(self.service, "/results/graphics/lights/lighting_interpolation/flat").execute(*args, **kwargs)
                    def gouraud(self, *args, **kwargs):
                        """
                        Use Gouraud shading to calculate the color at each vertex of a polygon and interpolate it in the interior.
                        """
                        return PyMenu(self.service, "/results/graphics/lights/lighting_interpolation/gouraud").execute(*args, **kwargs)
                    def phong(self, *args, **kwargs):
                        """
                        Use Phong shading to interpolate the normals for each pixel of a polygon and compute a color at every pixel.
                        """
                        return PyMenu(self.service, "/results/graphics/lights/lighting_interpolation/phong").execute(*args, **kwargs)

            class objects(metaclass=PyMenuMeta):
                """
                Enter to add, edit, delete or display graphics objects.
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.xy_plot = self.__class__.xy_plot(path + [("xy_plot", None)], None, service)
                    self.mesh = self.__class__.mesh(path + [("mesh", None)], None, service)
                    self.contour = self.__class__.contour(path + [("contour", None)], None, service)
                    self.vector = self.__class__.vector(path + [("vector", None)], None, service)
                    self.pathlines = self.__class__.pathlines(path + [("pathlines", None)], None, service)
                    self.particle_tracks = self.__class__.particle_tracks(path + [("particle_tracks", None)], None, service)
                    self.scene = self.__class__.scene(path + [("scene", None)], None, service)
                def create(self, *args, **kwargs):
                    """
                    Create new graphics object.
                    """
                    return PyMenu(self.service, "/results/graphics/objects/create").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit graphics object.
                    """
                    return PyMenu(self.service, "/results/graphics/objects/edit").execute(*args, **kwargs)
                def copy(self, *args, **kwargs):
                    """
                    Copy graphics object.
                    """
                    return PyMenu(self.service, "/results/graphics/objects/copy").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete graphics object.
                    """
                    return PyMenu(self.service, "/results/graphics/objects/delete").execute(*args, **kwargs)
                def display(self, *args, **kwargs):
                    """
                    Display graphics object.
                    """
                    return PyMenu(self.service, "/results/graphics/objects/display").execute(*args, **kwargs)
                def add_to_graphics(self, *args, **kwargs):
                    """
                    Add graphics object to existing graphics.
                    """
                    return PyMenu(self.service, "/results/graphics/objects/add_to_graphics").execute(*args, **kwargs)

                class xy_plot(metaclass=PyNamedObjectMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.name = self.__class__.name(path + [("name", None)], service)
                        self.uid = self.__class__.uid(path + [("uid", None)], service)
                        self.options = self.__class__.options(path + [("options", None)], service)
                        self.plot_direction = self.__class__.plot_direction(path + [("plot_direction", None)], service)
                        self.x_axis_function = self.__class__.x_axis_function(path + [("x_axis_function", None)], service)
                        self.y_axis_function = self.__class__.y_axis_function(path + [("y_axis_function", None)], service)
                        self.surfaces_list = self.__class__.surfaces_list(path + [("surfaces_list", None)], service)
                        self.physics = self.__class__.physics(path + [("physics", None)], service)
                        self.geometry = self.__class__.geometry(path + [("geometry", None)], service)
                        self.surfaces = self.__class__.surfaces(path + [("surfaces", None)], service)

                    class name(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class uid(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class options(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.node_values = self.__class__.node_values(path + [("node_values", None)], service)
                            self.position_on_x_axis = self.__class__.position_on_x_axis(path + [("position_on_x_axis", None)], service)
                            self.position_on_y_axis = self.__class__.position_on_y_axis(path + [("position_on_y_axis", None)], service)

                        class node_values(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class position_on_x_axis(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class position_on_y_axis(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class plot_direction(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.direction_vector = self.__class__.direction_vector(path + [("direction_vector", None)], service)
                            self.curve_length = self.__class__.curve_length(path + [("curve_length", None)], service)

                        class direction_vector(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.x_component = self.__class__.x_component(path + [("x_component", None)], service)
                                self.y_component = self.__class__.y_component(path + [("y_component", None)], service)
                                self.z_component = self.__class__.z_component(path + [("z_component", None)], service)

                            class x_component(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class y_component(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class z_component(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                        class curve_length(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.default = self.__class__.default(path + [("default", None)], service)
                                self.reverse = self.__class__.reverse(path + [("reverse", None)], service)

                            class default(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class reverse(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                    class x_axis_function(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class y_axis_function(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class surfaces_list(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class physics(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class geometry(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class surfaces(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class mesh(metaclass=PyNamedObjectMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.name = self.__class__.name(path + [("name", None)], service)
                        self.options = self.__class__.options(path + [("options", None)], service)
                        self.edge_type = self.__class__.edge_type(path + [("edge_type", None)], service)
                        self.shrink_factor = self.__class__.shrink_factor(path + [("shrink_factor", None)], service)
                        self.surfaces_list = self.__class__.surfaces_list(path + [("surfaces_list", None)], service)
                        self.coloring = self.__class__.coloring(path + [("coloring", None)], service)
                        self.display_state_name = self.__class__.display_state_name(path + [("display_state_name", None)], service)
                        self.physics = self.__class__.physics(path + [("physics", None)], service)
                        self.geometry = self.__class__.geometry(path + [("geometry", None)], service)
                        self.surfaces = self.__class__.surfaces(path + [("surfaces", None)], service)

                    class name(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class options(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.nodes = self.__class__.nodes(path + [("nodes", None)], service)
                            self.edges = self.__class__.edges(path + [("edges", None)], service)
                            self.faces = self.__class__.faces(path + [("faces", None)], service)
                            self.partitions = self.__class__.partitions(path + [("partitions", None)], service)
                            self.overset = self.__class__.overset(path + [("overset", None)], service)
                            self.gap = self.__class__.gap(path + [("gap", None)], service)

                        class nodes(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class edges(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class faces(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class partitions(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class overset(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class gap(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class edge_type(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.all = self.__class__.all(path + [("all", None)], service)
                            self.feature = self.__class__.feature(path + [("feature", None)], service)
                            self.outline = self.__class__.outline(path + [("outline", None)], service)

                        class all(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class feature(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.feature_angle = self.__class__.feature_angle(path + [("feature_angle", None)], service)

                            class feature_angle(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                        class outline(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class shrink_factor(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class surfaces_list(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class coloring(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.automatic = self.__class__.automatic(path + [("automatic", None)], service)
                            self.manual = self.__class__.manual(path + [("manual", None)], service)

                        class automatic(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.type = self.__class__.type(path + [("type", None)], service)
                                self.id = self.__class__.id(path + [("id", None)], service)
                                self.normal = self.__class__.normal(path + [("normal", None)], service)
                                self.partition = self.__class__.partition(path + [("partition", None)], service)

                            class type(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class id(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class normal(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class partition(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                        class manual(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.faces = self.__class__.faces(path + [("faces", None)], service)
                                self.edges = self.__class__.edges(path + [("edges", None)], service)
                                self.nodes = self.__class__.nodes(path + [("nodes", None)], service)
                                self.material_color = self.__class__.material_color(path + [("material_color", None)], service)

                            class faces(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class edges(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class nodes(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class material_color(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                    class display_state_name(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class physics(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class geometry(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class surfaces(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class contour(metaclass=PyNamedObjectMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.name = self.__class__.name(path + [("name", None)], service)
                        self.field = self.__class__.field(path + [("field", None)], service)
                        self.filled = self.__class__.filled(path + [("filled", None)], service)
                        self.boundary_values = self.__class__.boundary_values(path + [("boundary_values", None)], service)
                        self.contour_lines = self.__class__.contour_lines(path + [("contour_lines", None)], service)
                        self.node_values = self.__class__.node_values(path + [("node_values", None)], service)
                        self.surfaces_list = self.__class__.surfaces_list(path + [("surfaces_list", None)], service)
                        self.range_option = self.__class__.range_option(path + [("range_option", None)], service)
                        self.coloring = self.__class__.coloring(path + [("coloring", None)], service)
                        self.color_map = self.__class__.color_map(path + [("color_map", None)], service)
                        self.draw_mesh = self.__class__.draw_mesh(path + [("draw_mesh", None)], service)
                        self.mesh_object = self.__class__.mesh_object(path + [("mesh_object", None)], service)
                        self.display_state_name = self.__class__.display_state_name(path + [("display_state_name", None)], service)
                        self.physics = self.__class__.physics(path + [("physics", None)], service)
                        self.geometry = self.__class__.geometry(path + [("geometry", None)], service)
                        self.surfaces = self.__class__.surfaces(path + [("surfaces", None)], service)

                    class name(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class field(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class filled(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class boundary_values(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class contour_lines(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class node_values(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class surfaces_list(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class range_option(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.auto_range_on = self.__class__.auto_range_on(path + [("auto_range_on", None)], service)
                            self.auto_range_off = self.__class__.auto_range_off(path + [("auto_range_off", None)], service)

                        class auto_range_on(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.global_range = self.__class__.global_range(path + [("global_range", None)], service)

                            class global_range(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                        class auto_range_off(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.clip_to_range = self.__class__.clip_to_range(path + [("clip_to_range", None)], service)
                                self.minimum = self.__class__.minimum(path + [("minimum", None)], service)
                                self.maximum = self.__class__.maximum(path + [("maximum", None)], service)

                            class clip_to_range(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class minimum(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class maximum(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                    class coloring(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.smooth = self.__class__.smooth(path + [("smooth", None)], service)
                            self.banded = self.__class__.banded(path + [("banded", None)], service)

                        class smooth(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class banded(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class color_map(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.visible = self.__class__.visible(path + [("visible", None)], service)
                            self.size = self.__class__.size(path + [("size", None)], service)
                            self.color = self.__class__.color(path + [("color", None)], service)
                            self.log_scale = self.__class__.log_scale(path + [("log_scale", None)], service)
                            self.format = self.__class__.format(path + [("format", None)], service)
                            self.user_skip = self.__class__.user_skip(path + [("user_skip", None)], service)
                            self.show_all = self.__class__.show_all(path + [("show_all", None)], service)
                            self.position = self.__class__.position(path + [("position", None)], service)
                            self.font_name = self.__class__.font_name(path + [("font_name", None)], service)
                            self.font_automatic = self.__class__.font_automatic(path + [("font_automatic", None)], service)
                            self.font_size = self.__class__.font_size(path + [("font_size", None)], service)
                            self.length = self.__class__.length(path + [("length", None)], service)
                            self.width = self.__class__.width(path + [("width", None)], service)

                        class visible(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class size(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class color(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class log_scale(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class format(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class user_skip(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class show_all(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class position(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class font_name(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class font_automatic(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class font_size(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class length(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class width(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class draw_mesh(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class mesh_object(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class display_state_name(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class physics(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class geometry(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class surfaces(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class vector(metaclass=PyNamedObjectMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.name = self.__class__.name(path + [("name", None)], service)
                        self.field = self.__class__.field(path + [("field", None)], service)
                        self.vector_field = self.__class__.vector_field(path + [("vector_field", None)], service)
                        self.surfaces_list = self.__class__.surfaces_list(path + [("surfaces_list", None)], service)
                        self.scale = self.__class__.scale(path + [("scale", None)], service)
                        self.style = self.__class__.style(path + [("style", None)], service)
                        self.skip = self.__class__.skip(path + [("skip", None)], service)
                        self.vector_opt = self.__class__.vector_opt(path + [("vector_opt", None)], service)
                        self.range_option = self.__class__.range_option(path + [("range_option", None)], service)
                        self.color_map = self.__class__.color_map(path + [("color_map", None)], service)
                        self.draw_mesh = self.__class__.draw_mesh(path + [("draw_mesh", None)], service)
                        self.mesh_object = self.__class__.mesh_object(path + [("mesh_object", None)], service)
                        self.display_state_name = self.__class__.display_state_name(path + [("display_state_name", None)], service)
                        self.physics = self.__class__.physics(path + [("physics", None)], service)
                        self.geometry = self.__class__.geometry(path + [("geometry", None)], service)
                        self.surfaces = self.__class__.surfaces(path + [("surfaces", None)], service)

                    class name(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class field(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class vector_field(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class surfaces_list(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class scale(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.auto_scale = self.__class__.auto_scale(path + [("auto_scale", None)], service)
                            self.scale_f = self.__class__.scale_f(path + [("scale_f", None)], service)

                        class auto_scale(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class scale_f(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class style(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class skip(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class vector_opt(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.in_plane = self.__class__.in_plane(path + [("in_plane", None)], service)
                            self.fixed_length = self.__class__.fixed_length(path + [("fixed_length", None)], service)
                            self.x_comp = self.__class__.x_comp(path + [("x_comp", None)], service)
                            self.y_comp = self.__class__.y_comp(path + [("y_comp", None)], service)
                            self.z_comp = self.__class__.z_comp(path + [("z_comp", None)], service)
                            self.scale_head = self.__class__.scale_head(path + [("scale_head", None)], service)
                            self.color = self.__class__.color(path + [("color", None)], service)

                        class in_plane(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class fixed_length(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class x_comp(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class y_comp(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class z_comp(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class scale_head(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class color(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class range_option(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.auto_range_on = self.__class__.auto_range_on(path + [("auto_range_on", None)], service)
                            self.auto_range_off = self.__class__.auto_range_off(path + [("auto_range_off", None)], service)

                        class auto_range_on(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.global_range = self.__class__.global_range(path + [("global_range", None)], service)

                            class global_range(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                        class auto_range_off(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.clip_to_range = self.__class__.clip_to_range(path + [("clip_to_range", None)], service)
                                self.minimum = self.__class__.minimum(path + [("minimum", None)], service)
                                self.maximum = self.__class__.maximum(path + [("maximum", None)], service)

                            class clip_to_range(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class minimum(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class maximum(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                    class color_map(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.visible = self.__class__.visible(path + [("visible", None)], service)
                            self.size = self.__class__.size(path + [("size", None)], service)
                            self.color = self.__class__.color(path + [("color", None)], service)
                            self.log_scale = self.__class__.log_scale(path + [("log_scale", None)], service)
                            self.format = self.__class__.format(path + [("format", None)], service)
                            self.user_skip = self.__class__.user_skip(path + [("user_skip", None)], service)
                            self.show_all = self.__class__.show_all(path + [("show_all", None)], service)
                            self.position = self.__class__.position(path + [("position", None)], service)
                            self.font_name = self.__class__.font_name(path + [("font_name", None)], service)
                            self.font_automatic = self.__class__.font_automatic(path + [("font_automatic", None)], service)
                            self.font_size = self.__class__.font_size(path + [("font_size", None)], service)
                            self.length = self.__class__.length(path + [("length", None)], service)
                            self.width = self.__class__.width(path + [("width", None)], service)

                        class visible(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class size(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class color(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class log_scale(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class format(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class user_skip(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class show_all(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class position(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class font_name(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class font_automatic(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class font_size(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class length(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class width(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class draw_mesh(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class mesh_object(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class display_state_name(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class physics(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class geometry(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class surfaces(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class pathlines(metaclass=PyNamedObjectMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.name = self.__class__.name(path + [("name", None)], service)
                        self.uid = self.__class__.uid(path + [("uid", None)], service)
                        self.options = self.__class__.options(path + [("options", None)], service)
                        self.range = self.__class__.range(path + [("range", None)], service)
                        self.style_attribute = self.__class__.style_attribute(path + [("style_attribute", None)], service)
                        self.accuracy_control = self.__class__.accuracy_control(path + [("accuracy_control", None)], service)
                        self.plot = self.__class__.plot(path + [("plot", None)], service)
                        self.step = self.__class__.step(path + [("step", None)], service)
                        self.skip = self.__class__.skip(path + [("skip", None)], service)
                        self.coarsen = self.__class__.coarsen(path + [("coarsen", None)], service)
                        self.onzone = self.__class__.onzone(path + [("onzone", None)], service)
                        self.field = self.__class__.field(path + [("field", None)], service)
                        self.surfaces_list = self.__class__.surfaces_list(path + [("surfaces_list", None)], service)
                        self.velocity_domain = self.__class__.velocity_domain(path + [("velocity_domain", None)], service)
                        self.color_map = self.__class__.color_map(path + [("color_map", None)], service)
                        self.draw_mesh = self.__class__.draw_mesh(path + [("draw_mesh", None)], service)
                        self.mesh_object = self.__class__.mesh_object(path + [("mesh_object", None)], service)
                        self.display_state_name = self.__class__.display_state_name(path + [("display_state_name", None)], service)
                        self.physics = self.__class__.physics(path + [("physics", None)], service)
                        self.geometry = self.__class__.geometry(path + [("geometry", None)], service)
                        self.surfaces = self.__class__.surfaces(path + [("surfaces", None)], service)

                    class name(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class uid(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class options(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.oil_flow = self.__class__.oil_flow(path + [("oil_flow", None)], service)
                            self.reverse = self.__class__.reverse(path + [("reverse", None)], service)
                            self.node_values = self.__class__.node_values(path + [("node_values", None)], service)
                            self.relative = self.__class__.relative(path + [("relative", None)], service)

                        class oil_flow(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class reverse(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class node_values(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class relative(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class range(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.auto_range = self.__class__.auto_range(path + [("auto_range", None)], service)
                            self.clip_to_range = self.__class__.clip_to_range(path + [("clip_to_range", None)], service)

                        class auto_range(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class clip_to_range(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.min_value = self.__class__.min_value(path + [("min_value", None)], service)
                                self.max_value = self.__class__.max_value(path + [("max_value", None)], service)

                            class min_value(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class max_value(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                    class style_attribute(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.style = self.__class__.style(path + [("style", None)], service)
                            self.line_width = self.__class__.line_width(path + [("line_width", None)], service)
                            self.arrow_space = self.__class__.arrow_space(path + [("arrow_space", None)], service)
                            self.arrow_scale = self.__class__.arrow_scale(path + [("arrow_scale", None)], service)
                            self.marker_size = self.__class__.marker_size(path + [("marker_size", None)], service)
                            self.sphere_size = self.__class__.sphere_size(path + [("sphere_size", None)], service)
                            self.sphere_lod = self.__class__.sphere_lod(path + [("sphere_lod", None)], service)
                            self.radius = self.__class__.radius(path + [("radius", None)], service)
                            self.ribbon = self.__class__.ribbon(path + [("ribbon", None)], service)

                        class style(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class line_width(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class arrow_space(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class arrow_scale(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class marker_size(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class sphere_size(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class sphere_lod(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class radius(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class ribbon(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.field = self.__class__.field(path + [("field", None)], service)
                                self.scalefactor = self.__class__.scalefactor(path + [("scalefactor", None)], service)

                            class field(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class scalefactor(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                    class accuracy_control(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.step_size = self.__class__.step_size(path + [("step_size", None)], service)
                            self.tolerance = self.__class__.tolerance(path + [("tolerance", None)], service)

                        class step_size(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class tolerance(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class plot(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.x_axis_function = self.__class__.x_axis_function(path + [("x_axis_function", None)], service)
                            self.enabled = self.__class__.enabled(path + [("enabled", None)], service)

                        class x_axis_function(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class enabled(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class step(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class skip(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class coarsen(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class onzone(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class field(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class surfaces_list(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class velocity_domain(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class color_map(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.visible = self.__class__.visible(path + [("visible", None)], service)
                            self.size = self.__class__.size(path + [("size", None)], service)
                            self.color = self.__class__.color(path + [("color", None)], service)
                            self.log_scale = self.__class__.log_scale(path + [("log_scale", None)], service)
                            self.format = self.__class__.format(path + [("format", None)], service)
                            self.user_skip = self.__class__.user_skip(path + [("user_skip", None)], service)
                            self.show_all = self.__class__.show_all(path + [("show_all", None)], service)
                            self.position = self.__class__.position(path + [("position", None)], service)
                            self.font_name = self.__class__.font_name(path + [("font_name", None)], service)
                            self.font_automatic = self.__class__.font_automatic(path + [("font_automatic", None)], service)
                            self.font_size = self.__class__.font_size(path + [("font_size", None)], service)
                            self.length = self.__class__.length(path + [("length", None)], service)
                            self.width = self.__class__.width(path + [("width", None)], service)

                        class visible(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class size(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class color(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class log_scale(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class format(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class user_skip(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class show_all(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class position(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class font_name(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class font_automatic(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class font_size(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class length(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class width(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class draw_mesh(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class mesh_object(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class display_state_name(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class physics(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class geometry(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class surfaces(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class particle_tracks(metaclass=PyNamedObjectMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.name = self.__class__.name(path + [("name", None)], service)
                        self.uid = self.__class__.uid(path + [("uid", None)], service)
                        self.options = self.__class__.options(path + [("options", None)], service)
                        self.filter_settings = self.__class__.filter_settings(path + [("filter_settings", None)], service)
                        self.range = self.__class__.range(path + [("range", None)], service)
                        self.style_attribute = self.__class__.style_attribute(path + [("style_attribute", None)], service)
                        self.vector_settings = self.__class__.vector_settings(path + [("vector_settings", None)], service)
                        self.plot = self.__class__.plot(path + [("plot", None)], service)
                        self.track_single_particle_stream = self.__class__.track_single_particle_stream(path + [("track_single_particle_stream", None)], service)
                        self.skip = self.__class__.skip(path + [("skip", None)], service)
                        self.coarsen = self.__class__.coarsen(path + [("coarsen", None)], service)
                        self.field = self.__class__.field(path + [("field", None)], service)
                        self.injections_list = self.__class__.injections_list(path + [("injections_list", None)], service)
                        self.free_stream_particles = self.__class__.free_stream_particles(path + [("free_stream_particles", None)], service)
                        self.wall_film_particles = self.__class__.wall_film_particles(path + [("wall_film_particles", None)], service)
                        self.track_pdf_particles = self.__class__.track_pdf_particles(path + [("track_pdf_particles", None)], service)
                        self.color_map = self.__class__.color_map(path + [("color_map", None)], service)
                        self.draw_mesh = self.__class__.draw_mesh(path + [("draw_mesh", None)], service)
                        self.mesh_object = self.__class__.mesh_object(path + [("mesh_object", None)], service)
                        self.display_state_name = self.__class__.display_state_name(path + [("display_state_name", None)], service)

                    class name(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class uid(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class options(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.node_values = self.__class__.node_values(path + [("node_values", None)], service)

                        class node_values(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class filter_settings(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.field = self.__class__.field(path + [("field", None)], service)
                            self.options = self.__class__.options(path + [("options", None)], service)
                            self.enabled = self.__class__.enabled(path + [("enabled", None)], service)
                            self.filter_minimum = self.__class__.filter_minimum(path + [("filter_minimum", None)], service)
                            self.filter_maximum = self.__class__.filter_maximum(path + [("filter_maximum", None)], service)

                        class field(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class options(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.inside = self.__class__.inside(path + [("inside", None)], service)
                                self.outside = self.__class__.outside(path + [("outside", None)], service)

                            class inside(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class outside(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                        class enabled(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class filter_minimum(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class filter_maximum(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class range(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.auto_range = self.__class__.auto_range(path + [("auto_range", None)], service)
                            self.clip_to_range = self.__class__.clip_to_range(path + [("clip_to_range", None)], service)

                        class auto_range(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class clip_to_range(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.min_value = self.__class__.min_value(path + [("min_value", None)], service)
                                self.max_value = self.__class__.max_value(path + [("max_value", None)], service)

                            class min_value(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class max_value(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                    class style_attribute(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.style = self.__class__.style(path + [("style", None)], service)
                            self.line_width = self.__class__.line_width(path + [("line_width", None)], service)
                            self.arrow_space = self.__class__.arrow_space(path + [("arrow_space", None)], service)
                            self.arrow_scale = self.__class__.arrow_scale(path + [("arrow_scale", None)], service)
                            self.marker_size = self.__class__.marker_size(path + [("marker_size", None)], service)
                            self.sphere_size = self.__class__.sphere_size(path + [("sphere_size", None)], service)
                            self.sphere_lod = self.__class__.sphere_lod(path + [("sphere_lod", None)], service)
                            self.radius = self.__class__.radius(path + [("radius", None)], service)
                            self.ribbon_settings = self.__class__.ribbon_settings(path + [("ribbon_settings", None)], service)
                            self.sphere_settings = self.__class__.sphere_settings(path + [("sphere_settings", None)], service)

                        class style(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class line_width(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class arrow_space(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class arrow_scale(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class marker_size(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class sphere_size(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class sphere_lod(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class radius(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class ribbon_settings(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.field = self.__class__.field(path + [("field", None)], service)
                                self.scalefactor = self.__class__.scalefactor(path + [("scalefactor", None)], service)

                            class field(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class scalefactor(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                        class sphere_settings(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.scale = self.__class__.scale(path + [("scale", None)], service)
                                self.sphere_lod = self.__class__.sphere_lod(path + [("sphere_lod", None)], service)
                                self.options = self.__class__.options(path + [("options", None)], service)

                            class scale(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class sphere_lod(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class options(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service
                                    self.constant = self.__class__.constant(path + [("constant", None)], service)
                                    self.variable = self.__class__.variable(path + [("variable", None)], service)

                                class constant(metaclass=PyMenuMeta):
                                    """
                                    """
                                    is_extended_tui = True
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                        self.diameter = self.__class__.diameter(path + [("diameter", None)], service)

                                    class diameter(metaclass=PyMenuMeta):
                                        """
                                        """
                                        is_extended_tui = True
                                        def __init__(self, path, service):
                                            self.path = path
                                            self.service = service

                                class variable(metaclass=PyMenuMeta):
                                    """
                                    """
                                    is_extended_tui = True
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                        self.size_by = self.__class__.size_by(path + [("size_by", None)], service)
                                        self.range = self.__class__.range(path + [("range", None)], service)

                                    class size_by(metaclass=PyMenuMeta):
                                        """
                                        """
                                        is_extended_tui = True
                                        def __init__(self, path, service):
                                            self.path = path
                                            self.service = service

                                    class range(metaclass=PyMenuMeta):
                                        """
                                        """
                                        is_extended_tui = True
                                        def __init__(self, path, service):
                                            self.path = path
                                            self.service = service
                                            self.auto_range = self.__class__.auto_range(path + [("auto_range", None)], service)
                                            self.clip_to_range = self.__class__.clip_to_range(path + [("clip_to_range", None)], service)

                                        class auto_range(metaclass=PyMenuMeta):
                                            """
                                            """
                                            is_extended_tui = True
                                            def __init__(self, path, service):
                                                self.path = path
                                                self.service = service

                                        class clip_to_range(metaclass=PyMenuMeta):
                                            """
                                            """
                                            is_extended_tui = True
                                            def __init__(self, path, service):
                                                self.path = path
                                                self.service = service
                                                self.min_value = self.__class__.min_value(path + [("min_value", None)], service)
                                                self.max_value = self.__class__.max_value(path + [("max_value", None)], service)

                                            class min_value(metaclass=PyMenuMeta):
                                                """
                                                """
                                                is_extended_tui = True
                                                def __init__(self, path, service):
                                                    self.path = path
                                                    self.service = service

                                            class max_value(metaclass=PyMenuMeta):
                                                """
                                                """
                                                is_extended_tui = True
                                                def __init__(self, path, service):
                                                    self.path = path
                                                    self.service = service

                    class vector_settings(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.style = self.__class__.style(path + [("style", None)], service)
                            self.vector_length = self.__class__.vector_length(path + [("vector_length", None)], service)
                            self.constant_color = self.__class__.constant_color(path + [("constant_color", None)], service)
                            self.vector_of = self.__class__.vector_of(path + [("vector_of", None)], service)
                            self.scale = self.__class__.scale(path + [("scale", None)], service)
                            self.length_to_head_ratio = self.__class__.length_to_head_ratio(path + [("length_to_head_ratio", None)], service)

                        class style(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class vector_length(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.constant_length = self.__class__.constant_length(path + [("constant_length", None)], service)
                                self.variable_length = self.__class__.variable_length(path + [("variable_length", None)], service)

                            class constant_length(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class variable_length(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                        class constant_color(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.enabled = self.__class__.enabled(path + [("enabled", None)], service)
                                self.color = self.__class__.color(path + [("color", None)], service)

                            class enabled(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                            class color(metaclass=PyMenuMeta):
                                """
                                """
                                is_extended_tui = True
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service

                        class vector_of(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class scale(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class length_to_head_ratio(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class plot(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.x_axis_function = self.__class__.x_axis_function(path + [("x_axis_function", None)], service)
                            self.enabled = self.__class__.enabled(path + [("enabled", None)], service)

                        class x_axis_function(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class enabled(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class track_single_particle_stream(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.enabled = self.__class__.enabled(path + [("enabled", None)], service)
                            self.stream_id = self.__class__.stream_id(path + [("stream_id", None)], service)

                        class enabled(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class stream_id(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class skip(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class coarsen(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class field(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class injections_list(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class free_stream_particles(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class wall_film_particles(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class track_pdf_particles(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class color_map(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.visible = self.__class__.visible(path + [("visible", None)], service)
                            self.size = self.__class__.size(path + [("size", None)], service)
                            self.color = self.__class__.color(path + [("color", None)], service)
                            self.log_scale = self.__class__.log_scale(path + [("log_scale", None)], service)
                            self.format = self.__class__.format(path + [("format", None)], service)
                            self.user_skip = self.__class__.user_skip(path + [("user_skip", None)], service)
                            self.show_all = self.__class__.show_all(path + [("show_all", None)], service)
                            self.position = self.__class__.position(path + [("position", None)], service)
                            self.font_name = self.__class__.font_name(path + [("font_name", None)], service)
                            self.font_automatic = self.__class__.font_automatic(path + [("font_automatic", None)], service)
                            self.font_size = self.__class__.font_size(path + [("font_size", None)], service)
                            self.length = self.__class__.length(path + [("length", None)], service)
                            self.width = self.__class__.width(path + [("width", None)], service)

                        class visible(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class size(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class color(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class log_scale(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class format(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class user_skip(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class show_all(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class position(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class font_name(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class font_automatic(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class font_size(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class length(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                        class width(metaclass=PyMenuMeta):
                            """
                            """
                            is_extended_tui = True
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service

                    class draw_mesh(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class mesh_object(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class display_state_name(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                class scene(metaclass=PyNamedObjectMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.name = self.__class__.name(path + [("name", None)], service)
                        self.title = self.__class__.title(path + [("title", None)], service)
                        self.temporary = self.__class__.temporary(path + [("temporary", None)], service)
                        self.display_state_name = self.__class__.display_state_name(path + [("display_state_name", None)], service)

                    class name(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class title(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class temporary(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

                    class display_state_name(metaclass=PyMenuMeta):
                        """
                        """
                        is_extended_tui = True
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service

            class rendering_options(metaclass=PyMenuMeta):
                """
                Enter the rendering options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def auto_spin(self, *args, **kwargs):
                    """
                    Enable/disable mouse view rotations to continue to spin the display after the button is released.
                    """
                    return PyMenu(self.service, "/results/graphics/rendering_options/auto_spin").execute(*args, **kwargs)
                def device_info(self, *args, **kwargs):
                    """
                    List information for the graphics device.
                    """
                    return PyMenu(self.service, "/results/graphics/rendering_options/device_info").execute(*args, **kwargs)
                def double_buffering(self, *args, **kwargs):
                    """
                    Enable/disable double-buffering.
                    """
                    return PyMenu(self.service, "/results/graphics/rendering_options/double_buffering").execute(*args, **kwargs)
                def driver(self, *args, **kwargs):
                    """
                    Change the current graphics driver.
                    """
                    return PyMenu(self.service, "/results/graphics/rendering_options/driver").execute(*args, **kwargs)
                def hidden_surfaces(self, *args, **kwargs):
                    """
                    Enable/disable hidden surface removal.
                    """
                    return PyMenu(self.service, "/results/graphics/rendering_options/hidden_surfaces").execute(*args, **kwargs)
                def hidden_surface_method(self, *args, **kwargs):
                    """
                    Specify the method to perform hidden line and hidden surface rendering.
                    """
                    return PyMenu(self.service, "/results/graphics/rendering_options/hidden_surface_method").execute(*args, **kwargs)
                def outer_face_cull(self, *args, **kwargs):
                    """
                    Enable/disable discarding outer faces during display.
                    """
                    return PyMenu(self.service, "/results/graphics/rendering_options/outer_face_cull").execute(*args, **kwargs)
                def surface_edge_visibility(self, *args, **kwargs):
                    """
                    Set edge visibility flags for surfaces.
                    """
                    return PyMenu(self.service, "/results/graphics/rendering_options/surface_edge_visibility").execute(*args, **kwargs)
                def animation_option(self, *args, **kwargs):
                    """
                    Using Wireframe / All option during animation.
                    """
                    return PyMenu(self.service, "/results/graphics/rendering_options/animation_option").execute(*args, **kwargs)
                def color_map_alignment(self, *args, **kwargs):
                    """
                    Set the color bar alignment.
                    """
                    return PyMenu(self.service, "/results/graphics/rendering_options/color_map_alignment").execute(*args, **kwargs)
                def help_text_color(self, *args, **kwargs):
                    """
                    Set the color of screen help text.
                    """
                    return PyMenu(self.service, "/results/graphics/rendering_options/help_text_color").execute(*args, **kwargs)
                def face_displacement(self, *args, **kwargs):
                    """
                    Set face displacement value in Z-buffer units along the Camera Z-axis.
                    """
                    return PyMenu(self.service, "/results/graphics/rendering_options/face_displacement").execute(*args, **kwargs)
                def set_rendering_options(self, *args, **kwargs):
                    """
                    Set the rendering options.
                    """
                    return PyMenu(self.service, "/results/graphics/rendering_options/set_rendering_options").execute(*args, **kwargs)
                def show_colormap(self, *args, **kwargs):
                    """
                    Enable/Disable colormap.
                    """
                    return PyMenu(self.service, "/results/graphics/rendering_options/show_colormap").execute(*args, **kwargs)

            class update_scene(metaclass=PyMenuMeta):
                """
                Enter the scene options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def select_geometry(self, *args, **kwargs):
                    """
                    Select geometry to be updated.
                    """
                    return PyMenu(self.service, "/results/graphics/update_scene/select_geometry").execute(*args, **kwargs)
                def overlays(self, *args, **kwargs):
                    """
                    Enable/disable the overlays option.
                    """
                    return PyMenu(self.service, "/results/graphics/update_scene/overlays").execute(*args, **kwargs)
                def draw_frame(self, *args, **kwargs):
                    """
                    Enable/disable drawing of the bounding frame.
                    """
                    return PyMenu(self.service, "/results/graphics/update_scene/draw_frame").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete selected geometries.
                    """
                    return PyMenu(self.service, "/results/graphics/update_scene/delete").execute(*args, **kwargs)
                def display(self, *args, **kwargs):
                    """
                    Display selected geometries.
                    """
                    return PyMenu(self.service, "/results/graphics/update_scene/display").execute(*args, **kwargs)
                def transform(self, *args, **kwargs):
                    """
                    Apply transformation matrix on selected geometries.
                    """
                    return PyMenu(self.service, "/results/graphics/update_scene/transform").execute(*args, **kwargs)
                def pathline(self, *args, **kwargs):
                    """
                    Change pathline attributes.
                    """
                    return PyMenu(self.service, "/results/graphics/update_scene/pathline").execute(*args, **kwargs)
                def iso_sweep(self, *args, **kwargs):
                    """
                    Change iso-sweep values.
                    """
                    return PyMenu(self.service, "/results/graphics/update_scene/iso_sweep").execute(*args, **kwargs)
                def time(self, *args, **kwargs):
                    """
                    Change time-step value.
                    """
                    return PyMenu(self.service, "/results/graphics/update_scene/time").execute(*args, **kwargs)
                def set_frame(self, *args, **kwargs):
                    """
                    Change frame options.
                    """
                    return PyMenu(self.service, "/results/graphics/update_scene/set_frame").execute(*args, **kwargs)

        class plot(metaclass=PyMenuMeta):
            """
            Enter the XY plot menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.ansys_sound_analysis = self.__class__.ansys_sound_analysis(path + [("ansys_sound_analysis", None)], service)
                self.cumulative_plot = self.__class__.cumulative_plot(path + [("cumulative_plot", None)], service)
                self.flamelet_curves = self.__class__.flamelet_curves(path + [("flamelet_curves", None)], service)
            def circum_avg_axial(self, *args, **kwargs):
                """
                Compute iso-axial band surfaces and plot data vs axial coordinate on them.
                """
                return PyMenu(self.service, "/results/plot/circum_avg_axial").execute(*args, **kwargs)
            def circum_avg_radial(self, *args, **kwargs):
                """
                Compute iso-radial band surfaces and plot data vs radius on them.
                """
                return PyMenu(self.service, "/results/plot/circum_avg_radial").execute(*args, **kwargs)
            def change_fft_ref_pressure(self, *args, **kwargs):
                """
                Change acoustic reference pressure.
                """
                return PyMenu(self.service, "/results/plot/change_fft_ref_pressure").execute(*args, **kwargs)
            def fft(self, *args, **kwargs):
                """
                Plot FFT of file data.
                """
                return PyMenu(self.service, "/results/plot/fft").execute(*args, **kwargs)
            def fft_set(self, *args, **kwargs):
                """
                Enter the menu to set histogram plot parameters.
                """
                return PyMenu(self.service, "/results/plot/fft_set").execute(*args, **kwargs)
            def file(self, *args, **kwargs):
                """
                Plot data from file.
                """
                return PyMenu(self.service, "/results/plot/file").execute(*args, **kwargs)
            def datasources(self, *args, **kwargs):
                """
                Enter the menu to set data sources.
                """
                return PyMenu(self.service, "/results/plot/datasources").execute(*args, **kwargs)
            def display_profile_data(self, *args, **kwargs):
                """
                Plot profile data.
                """
                return PyMenu(self.service, "/results/plot/display_profile_data").execute(*args, **kwargs)
            def file_list(self, *args, **kwargs):
                """
                Plot data from multiple files.
                """
                return PyMenu(self.service, "/results/plot/file_list").execute(*args, **kwargs)
            def file_set(self, *args, **kwargs):
                """
                Enter the menu to set file plot parameters.
                """
                return PyMenu(self.service, "/results/plot/file_set").execute(*args, **kwargs)
            def histogram(self, *args, **kwargs):
                """
                Plot a histogram of a specified scalar quantity.
                """
                return PyMenu(self.service, "/results/plot/histogram").execute(*args, **kwargs)
            def histogram_set(self, *args, **kwargs):
                """
                Enter the menu to set histogram plot parameters.
                """
                return PyMenu(self.service, "/results/plot/histogram_set").execute(*args, **kwargs)
            def plot(self, *args, **kwargs):
                """
                Plot solution on surfaces.
                """
                return PyMenu(self.service, "/results/plot/plot").execute(*args, **kwargs)
            def plot_direction(self, *args, **kwargs):
                """
                Set plot direction for xy plot.
                """
                return PyMenu(self.service, "/results/plot/plot_direction").execute(*args, **kwargs)
            def residuals(self, *args, **kwargs):
                """
                Plot equation residual history.
                """
                return PyMenu(self.service, "/results/plot/residuals").execute(*args, **kwargs)
            def residuals_set(self, *args, **kwargs):
                """
                Enter the menu to set residual plot parameters.
                """
                return PyMenu(self.service, "/results/plot/residuals_set").execute(*args, **kwargs)
            def solution(self, *args, **kwargs):
                """
                Plot solution on surfaces and/or zones.
                """
                return PyMenu(self.service, "/results/plot/solution").execute(*args, **kwargs)
            def solution_set(self, *args, **kwargs):
                """
                Enter the menu to set solution plot parameters.
                """
                return PyMenu(self.service, "/results/plot/solution_set").execute(*args, **kwargs)
            def set_boundary_val_off(self, *args, **kwargs):
                """
                Set boundary value off when node values off for XY/Solution Plot.
                       
                 Note: This setting is valid for current Fluent session only.
                """
                return PyMenu(self.service, "/results/plot/set_boundary_val_off").execute(*args, **kwargs)
            def label_alignment(self, *args, **kwargs):
                """
                Set the alignment of xy plot label to horizontal or axis aligned.
                """
                return PyMenu(self.service, "/results/plot/label_alignment").execute(*args, **kwargs)

            class ansys_sound_analysis(metaclass=PyMenuMeta):
                """
                Ansys Sound analysis and specification.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def write_files(self, *args, **kwargs):
                    """
                    Write Ansys Sound out files.
                    """
                    return PyMenu(self.service, "/results/plot/ansys_sound_analysis/write_files").execute(*args, **kwargs)
                def print_indicators(self, *args, **kwargs):
                    """
                    Print Ansys Sound indicators.
                    """
                    return PyMenu(self.service, "/results/plot/ansys_sound_analysis/print_indicators").execute(*args, **kwargs)

            class cumulative_plot(metaclass=PyMenuMeta):
                """
                Plot Cumulative Force and Moments.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def add(self, *args, **kwargs):
                    """
                    Add a new object.
                    """
                    return PyMenu(self.service, "/results/plot/cumulative_plot/add").execute(*args, **kwargs)
                def axes(self, *args, **kwargs):
                    """
                    Set axes options of an object.
                    """
                    return PyMenu(self.service, "/results/plot/cumulative_plot/axes").execute(*args, **kwargs)
                def curves(self, *args, **kwargs):
                    """
                    Set curves options of an object.
                    """
                    return PyMenu(self.service, "/results/plot/cumulative_plot/curves").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit an object.
                    """
                    return PyMenu(self.service, "/results/plot/cumulative_plot/edit").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete an object.
                    """
                    return PyMenu(self.service, "/results/plot/cumulative_plot/delete").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    List objects.
                    """
                    return PyMenu(self.service, "/results/plot/cumulative_plot/list").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    List properties of an object.
                    """
                    return PyMenu(self.service, "/results/plot/cumulative_plot/list_properties").execute(*args, **kwargs)
                def plot(self, *args, **kwargs):
                    """
                    Plot the Cumulative Forces/Moments.
                    """
                    return PyMenu(self.service, "/results/plot/cumulative_plot/plot").execute(*args, **kwargs)
                def print(self, *args, **kwargs):
                    """
                    Print the Cumulative Forces/Moments.
                    """
                    return PyMenu(self.service, "/results/plot/cumulative_plot/print").execute(*args, **kwargs)
                def write(self, *args, **kwargs):
                    """
                    Write the Cumulative Forces/Moments.
                    """
                    return PyMenu(self.service, "/results/plot/cumulative_plot/write").execute(*args, **kwargs)

            class flamelet_curves(metaclass=PyMenuMeta):
                """
                Plot flamelet curves.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def write_to_file(self, *args, **kwargs):
                    """
                    Write curve to a file instead of plot.
                    """
                    return PyMenu(self.service, "/results/plot/flamelet_curves/write_to_file").execute(*args, **kwargs)
                def plot_curves(self, *args, **kwargs):
                    """
                    Plot of a property.
                    """
                    return PyMenu(self.service, "/results/plot/flamelet_curves/plot_curves").execute(*args, **kwargs)

        class report(metaclass=PyMenuMeta):
            """
            Enter the report menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.dpm_histogram = self.__class__.dpm_histogram(path + [("dpm_histogram", None)], service)
                self.fluxes = self.__class__.fluxes(path + [("fluxes", None)], service)
                self.forces = self.__class__.forces(path + [("forces", None)], service)
                self.reference_values = self.__class__.reference_values(path + [("reference_values", None)], service)
                self.surface_integrals = self.__class__.surface_integrals(path + [("surface_integrals", None)], service)
                self.volume_integrals = self.__class__.volume_integrals(path + [("volume_integrals", None)], service)
                self.modified_setting = self.__class__.modified_setting(path + [("modified_setting", None)], service)
                self.population_balance = self.__class__.population_balance(path + [("population_balance", None)], service)
                self.heat_exchanger = self.__class__.heat_exchanger(path + [("heat_exchanger", None)], service)
                self.system = self.__class__.system(path + [("system", None)], service)
                self.simulation_reports = self.__class__.simulation_reports(path + [("simulation_reports", None)], service)
            def aero_optical_distortions(self, *args, **kwargs):
                """
                Optics report menu.
                """
                return PyMenu(self.service, "/results/report/aero_optical_distortions").execute(*args, **kwargs)
            def dpm_summary(self, *args, **kwargs):
                """
                Print discrete phase summary report of particle fates.
                """
                return PyMenu(self.service, "/results/report/dpm_summary").execute(*args, **kwargs)
            def dpm_extended_summary(self, *args, **kwargs):
                """
                Print extended discrete phase summary report of particle fates, with options.
                """
                return PyMenu(self.service, "/results/report/dpm_extended_summary").execute(*args, **kwargs)
            def dpm_zone_summaries_per_injection(self, *args, **kwargs):
                """
                Enable per-injection zone DPM summaries.
                """
                return PyMenu(self.service, "/results/report/dpm_zone_summaries_per_injection").execute(*args, **kwargs)
            def dpm_sample(self, *args, **kwargs):
                """
                Sample trajectories at boundaries and lines/planes.
                """
                return PyMenu(self.service, "/results/report/dpm_sample").execute(*args, **kwargs)
            def dpm_sample_output_udf(self, *args, **kwargs):
                """
                Set the DPM sampling output UDF.
                """
                return PyMenu(self.service, "/results/report/dpm_sample_output_udf").execute(*args, **kwargs)
            def dpm_sample_sort_file(self, *args, **kwargs):
                """
                Enable writing of sorted DPM sample files.
                """
                return PyMenu(self.service, "/results/report/dpm_sample_sort_file").execute(*args, **kwargs)
            def particle_summary(self, *args, **kwargs):
                """
                Print summary report for all current particles.
                """
                return PyMenu(self.service, "/results/report/particle_summary").execute(*args, **kwargs)
            def path_line_summary(self, *args, **kwargs):
                """
                Print path-line-summary report.
                """
                return PyMenu(self.service, "/results/report/path_line_summary").execute(*args, **kwargs)
            def print_histogram(self, *args, **kwargs):
                """
                Print a histogram of a scalar quantity.
                """
                return PyMenu(self.service, "/results/report/print_histogram").execute(*args, **kwargs)
            def write_histogram(self, *args, **kwargs):
                """
                Write a histogram of a scalar quantity to a file.
                """
                return PyMenu(self.service, "/results/report/write_histogram").execute(*args, **kwargs)
            def projected_surface_area(self, *args, **kwargs):
                """
                Print total area of the projection of a group of surfaces to a plane.
                """
                return PyMenu(self.service, "/results/report/projected_surface_area").execute(*args, **kwargs)
            def species_mass_flow(self, *args, **kwargs):
                """
                Print list of species mass flow rates at boundaries.
                """
                return PyMenu(self.service, "/results/report/species_mass_flow").execute(*args, **kwargs)
            def element_mass_flow(self, *args, **kwargs):
                """
                Print list of element mass flow rates at boundaries.
                """
                return PyMenu(self.service, "/results/report/element_mass_flow").execute(*args, **kwargs)
            def summary(self, *args, **kwargs):
                """
                Print report summary.
                """
                return PyMenu(self.service, "/results/report/summary").execute(*args, **kwargs)
            def uds_flow(self, *args, **kwargs):
                """
                Print list of UDS flow rate at boundaries.
                """
                return PyMenu(self.service, "/results/report/uds_flow").execute(*args, **kwargs)
            def mphase_summary(self, *args, **kwargs):
                """
                Multiphase Summary and Recommendations.
                """
                return PyMenu(self.service, "/results/report/mphase_summary").execute(*args, **kwargs)

            class dpm_histogram(metaclass=PyMenuMeta):
                """
                Enter the DPM histogram menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.set = self.__class__.set(path + [("set", None)], service)
                    self.setup_reduction = self.__class__.setup_reduction(path + [("setup_reduction", None)], service)
                def compute_sample(self, *args, **kwargs):
                    """
                    Compute minimum/maximum of a sample variable.
                    """
                    return PyMenu(self.service, "/results/report/dpm_histogram/compute_sample").execute(*args, **kwargs)
                def delete_sample(self, *args, **kwargs):
                    """
                    Delete a sample from loaded sample list.
                    """
                    return PyMenu(self.service, "/results/report/dpm_histogram/delete_sample").execute(*args, **kwargs)
                def list_samples(self, *args, **kwargs):
                    """
                    Show all samples in loaded sample list.
                    """
                    return PyMenu(self.service, "/results/report/dpm_histogram/list_samples").execute(*args, **kwargs)
                def plot_sample(self, *args, **kwargs):
                    """
                    Plot a histogram of a loaded sample.
                    """
                    return PyMenu(self.service, "/results/report/dpm_histogram/plot_sample").execute(*args, **kwargs)
                def read_sample(self, *args, **kwargs):
                    """
                    Read a sample file and add it to the sample list.
                    """
                    return PyMenu(self.service, "/results/report/dpm_histogram/read_sample").execute(*args, **kwargs)
                def write_sample(self, *args, **kwargs):
                    """
                    Write a histogram of a loaded sample into a file.
                    """
                    return PyMenu(self.service, "/results/report/dpm_histogram/write_sample").execute(*args, **kwargs)
                def pick_sample_to_reduce(self, *args, **kwargs):
                    """
                    Pick a sample for which to first set-up and then perform the data reduction.
                    """
                    return PyMenu(self.service, "/results/report/dpm_histogram/pick_sample_to_reduce").execute(*args, **kwargs)
                def reduce_picked_sample(self, *args, **kwargs):
                    """
                    Reduce a sample after first picking it and setting up all data-reduction options and parameters.
                    """
                    return PyMenu(self.service, "/results/report/dpm_histogram/reduce_picked_sample").execute(*args, **kwargs)

                class set(metaclass=PyMenuMeta):
                    """
                    Enter the settings menu for the histogram.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def auto_range(self, *args, **kwargs):
                        """
                        Automatically compute range of sampling variable for histogram plots.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/set/auto_range").execute(*args, **kwargs)
                    def correlation(self, *args, **kwargs):
                        """
                        Compute correlation of sampling variable with other variable.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/set/correlation").execute(*args, **kwargs)
                    def cumulation_curve(self, *args, **kwargs):
                        """
                        Compute a cumulative curve for sampling variable or correlation variable when correlation? was specified.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/set/cumulation_curve").execute(*args, **kwargs)
                    def diameter_statistics(self, *args, **kwargs):
                        """
                        Compute Rosin Rammler parameters, Sauter and other mean diameters.
                        Requires specification of diameter as sampling variable.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/set/diameter_statistics").execute(*args, **kwargs)
                    def histogram_mode(self, *args, **kwargs):
                        """
                        Use bars for histogram plot or xy-style.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/set/histogram_mode").execute(*args, **kwargs)
                    def minimum(self, *args, **kwargs):
                        """
                        Specify mimimum value of x-axis variable for histogram plots.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/set/minimum").execute(*args, **kwargs)
                    def maximum(self, *args, **kwargs):
                        """
                        Specify maximum value of x-axis variable for histogram plots.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/set/maximum").execute(*args, **kwargs)
                    def number_of_bins(self, *args, **kwargs):
                        """
                        Specify the number of bins.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/set/number_of_bins").execute(*args, **kwargs)
                    def percentage(self, *args, **kwargs):
                        """
                        Use percentages of bins to be computed.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/set/percentage").execute(*args, **kwargs)
                    def variable_power_3(self, *args, **kwargs):
                        """
                        Use the cubic of the cumulation variable during computation of the cumulative curve.
                        When the particle mass was not sampled, the diameter can be used instead.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/set/variable_power_3").execute(*args, **kwargs)
                    def logarithmic(self, *args, **kwargs):
                        """
                        Use logarithmic scaling on the abscissa (variable axis)? -- Will not work unless all values are positive.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/set/logarithmic").execute(*args, **kwargs)
                    def weighting(self, *args, **kwargs):
                        """
                        Use weighting with additional variable when sorting data into samples.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/set/weighting").execute(*args, **kwargs)

                class setup_reduction(metaclass=PyMenuMeta):
                    """
                    Set up the sample data reduction by specifying all relevant options and setting parameters as desired.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def use_weighting(self, *args, **kwargs):
                        """
                        Specify whether to use any weighting in the averaging that is done in each bin in the data reduction.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/setup_reduction/use_weighting").execute(*args, **kwargs)
                    def weighting_variable(self, *args, **kwargs):
                        """
                        Choose the weighting variable for the averaging in each bin in the data reduction.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/setup_reduction/weighting_variable").execute(*args, **kwargs)
                    def make_steady_from_unsteady_file(self, *args, **kwargs):
                        """
                        Specify whether the unsteady sample is to be reduced into a steady-state injection file.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/setup_reduction/make_steady_from_unsteady_file").execute(*args, **kwargs)
                    def reset_min_and_max(self, *args, **kwargs):
                        """
                        Reset the min and max values of the range to be considered for a specific variable in the data reduction.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/setup_reduction/reset_min_and_max").execute(*args, **kwargs)
                    def minimum(self, *args, **kwargs):
                        """
                        Set the minimum value of the range to be considered for a specific variable in the data reduction.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/setup_reduction/minimum").execute(*args, **kwargs)
                    def maximum(self, *args, **kwargs):
                        """
                        Set the maximum value of the range to be considered for a specific variable in the data reduction.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/setup_reduction/maximum").execute(*args, **kwargs)
                    def logarithmic(self, *args, **kwargs):
                        """
                        Switch on or off logarithmic scaling to be used for a specific variable in the data reduction.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/setup_reduction/logarithmic").execute(*args, **kwargs)
                    def number_of_bins(self, *args, **kwargs):
                        """
                        Set the number of bins to be used for a specific variable in the data reduction.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/setup_reduction/number_of_bins").execute(*args, **kwargs)
                    def all_variables_number_of_bins(self, *args, **kwargs):
                        """
                        Set the number of bins to be used for ALL variables in the data reduction.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/setup_reduction/all_variables_number_of_bins").execute(*args, **kwargs)
                    def list_settings(self, *args, **kwargs):
                        """
                        List all user inputs for the sample picked for data reduction.
                        """
                        return PyMenu(self.service, "/results/report/dpm_histogram/setup_reduction/list_settings").execute(*args, **kwargs)

            class fluxes(metaclass=PyMenuMeta):
                """
                Flux report menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def mass_flow(self, *args, **kwargs):
                    """
                    Print mass flow rate at inlets and outlets.
                    """
                    return PyMenu(self.service, "/results/report/fluxes/mass_flow").execute(*args, **kwargs)
                def heat_transfer(self, *args, **kwargs):
                    """
                    Print heat transfer rate at boundaries.
                    """
                    return PyMenu(self.service, "/results/report/fluxes/heat_transfer").execute(*args, **kwargs)
                def heat_transfer_sensible(self, *args, **kwargs):
                    """
                    Print sensible heat transfer rate at boundaries.
                    """
                    return PyMenu(self.service, "/results/report/fluxes/heat_transfer_sensible").execute(*args, **kwargs)
                def rad_heat_trans(self, *args, **kwargs):
                    """
                    Print radiation heat transfer rate at boundaries.
                    """
                    return PyMenu(self.service, "/results/report/fluxes/rad_heat_trans").execute(*args, **kwargs)
                def film_mass_flow(self, *args, **kwargs):
                    """
                    Print film mass flow rate at boundaries.
                    """
                    return PyMenu(self.service, "/results/report/fluxes/film_mass_flow").execute(*args, **kwargs)
                def film_heat_transfer(self, *args, **kwargs):
                    """
                    Print film heat transfer rate at boundaries.
                    """
                    return PyMenu(self.service, "/results/report/fluxes/film_heat_transfer").execute(*args, **kwargs)
                def pressure_work(self, *args, **kwargs):
                    """
                    Print pressure work rate at moving boundaries.
                    """
                    return PyMenu(self.service, "/results/report/fluxes/pressure_work").execute(*args, **kwargs)
                def viscous_work(self, *args, **kwargs):
                    """
                    Print viscous work rate at boundaries.
                    """
                    return PyMenu(self.service, "/results/report/fluxes/viscous_work").execute(*args, **kwargs)

            class forces(metaclass=PyMenuMeta):
                """
                Force report menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def wall_forces(self, *args, **kwargs):
                    """
                    Print integrated pressure and viscous forces on wall zones.
                    """
                    return PyMenu(self.service, "/results/report/forces/wall_forces").execute(*args, **kwargs)
                def wall_moments(self, *args, **kwargs):
                    """
                    Print integrated pressure and viscous moments on wall zones.
                    """
                    return PyMenu(self.service, "/results/report/forces/wall_moments").execute(*args, **kwargs)
                def pressure_center(self, *args, **kwargs):
                    """
                    Print center of pressure on wall zones.
                    """
                    return PyMenu(self.service, "/results/report/forces/pressure_center").execute(*args, **kwargs)

            class reference_values(metaclass=PyMenuMeta):
                """
                Reference value menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.compute = self.__class__.compute(path + [("compute", None)], service)
                def area(self, *args, **kwargs):
                    """
                    Set reference area for normalization.
                    """
                    return PyMenu(self.service, "/results/report/reference_values/area").execute(*args, **kwargs)
                def depth(self, *args, **kwargs):
                    """
                    Set reference depth for volume calculation.
                    """
                    return PyMenu(self.service, "/results/report/reference_values/depth").execute(*args, **kwargs)
                def density(self, *args, **kwargs):
                    """
                    Set reference density for normalization.
                    """
                    return PyMenu(self.service, "/results/report/reference_values/density").execute(*args, **kwargs)
                def enthalpy(self, *args, **kwargs):
                    """
                    Set reference enthalpy for enthalpy damping and normalization.
                    """
                    return PyMenu(self.service, "/results/report/reference_values/enthalpy").execute(*args, **kwargs)
                def length(self, *args, **kwargs):
                    """
                    Set reference length for normalization.
                    """
                    return PyMenu(self.service, "/results/report/reference_values/length").execute(*args, **kwargs)
                def pressure(self, *args, **kwargs):
                    """
                    Set reference pressure for normalization.
                    """
                    return PyMenu(self.service, "/results/report/reference_values/pressure").execute(*args, **kwargs)
                def temperature(self, *args, **kwargs):
                    """
                    Set reference temperature for normalization.
                    """
                    return PyMenu(self.service, "/results/report/reference_values/temperature").execute(*args, **kwargs)
                def yplus(self, *args, **kwargs):
                    """
                    Set reference yplus for normalization.
                    """
                    return PyMenu(self.service, "/results/report/reference_values/yplus").execute(*args, **kwargs)
                def velocity(self, *args, **kwargs):
                    """
                    Set reference velocity for normalization.
                    """
                    return PyMenu(self.service, "/results/report/reference_values/velocity").execute(*args, **kwargs)
                def viscosity(self, *args, **kwargs):
                    """
                    Set reference viscosity for normalization.
                    """
                    return PyMenu(self.service, "/results/report/reference_values/viscosity").execute(*args, **kwargs)
                def zone(self, *args, **kwargs):
                    """
                    Set reference zone.
                    """
                    return PyMenu(self.service, "/results/report/reference_values/zone").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    List current reference values.
                    """
                    return PyMenu(self.service, "/results/report/reference_values/list").execute(*args, **kwargs)

                class compute(metaclass=PyMenuMeta):
                    """
                    Enter the compute menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def axis(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/axis").execute(*args, **kwargs)
                    def degassing(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/degassing").execute(*args, **kwargs)
                    def dummy_entry(self, *args, **kwargs):
                        """
                        .
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/dummy_entry").execute(*args, **kwargs)
                    def exhaust_fan(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/exhaust_fan").execute(*args, **kwargs)
                    def fan(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/fan").execute(*args, **kwargs)
                    def fluid(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/fluid").execute(*args, **kwargs)
                    def geometry(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/geometry").execute(*args, **kwargs)
                    def inlet_vent(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/inlet_vent").execute(*args, **kwargs)
                    def intake_fan(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/intake_fan").execute(*args, **kwargs)
                    def interface(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/interface").execute(*args, **kwargs)
                    def interior(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/interior").execute(*args, **kwargs)
                    def mass_flow_inlet(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/mass_flow_inlet").execute(*args, **kwargs)
                    def mass_flow_outlet(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/mass_flow_outlet").execute(*args, **kwargs)
                    def network(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/network").execute(*args, **kwargs)
                    def network_end(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/network_end").execute(*args, **kwargs)
                    def outflow(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/outflow").execute(*args, **kwargs)
                    def outlet_vent(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/outlet_vent").execute(*args, **kwargs)
                    def overset(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/overset").execute(*args, **kwargs)
                    def periodic(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/periodic").execute(*args, **kwargs)
                    def porous_jump(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/porous_jump").execute(*args, **kwargs)
                    def pressure_far_field(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/pressure_far_field").execute(*args, **kwargs)
                    def pressure_inlet(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/pressure_inlet").execute(*args, **kwargs)
                    def pressure_outlet(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/pressure_outlet").execute(*args, **kwargs)
                    def radiator(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/radiator").execute(*args, **kwargs)
                    def rans_les_interface(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/rans_les_interface").execute(*args, **kwargs)
                    def recirculation_inlet(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/recirculation_inlet").execute(*args, **kwargs)
                    def recirculation_outlet(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/recirculation_outlet").execute(*args, **kwargs)
                    def shadow(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/shadow").execute(*args, **kwargs)
                    def solid(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/solid").execute(*args, **kwargs)
                    def symmetry(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/symmetry").execute(*args, **kwargs)
                    def velocity_inlet(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/velocity_inlet").execute(*args, **kwargs)
                    def wall(self, *args, **kwargs):
                        """
                        Compute reference values from a zone of this type.
                        """
                        return PyMenu(self.service, "/results/report/reference_values/compute/wall").execute(*args, **kwargs)

            class surface_integrals(metaclass=PyMenuMeta):
                """
                Surface Integral menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def area(self, *args, **kwargs):
                    """
                    Print total area of surfaces.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/area").execute(*args, **kwargs)
                def area_weighted_avg(self, *args, **kwargs):
                    """
                    Print area-weighted average of scalar on surfaces.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/area_weighted_avg").execute(*args, **kwargs)
                def facet_avg(self, *args, **kwargs):
                    """
                    Print average of scalar at facet centroids of the surfaces.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/facet_avg").execute(*args, **kwargs)
                def facet_max(self, *args, **kwargs):
                    """
                    Print maximum of scalar at facet centroids of the surfaces.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/facet_max").execute(*args, **kwargs)
                def facet_min(self, *args, **kwargs):
                    """
                    Print minimum of scalar at facet centroids of the surfaces.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/facet_min").execute(*args, **kwargs)
                def flow_rate(self, *args, **kwargs):
                    """
                    Print flow rate of scalar through surfaces.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/flow_rate").execute(*args, **kwargs)
                def integral(self, *args, **kwargs):
                    """
                    Print integral of scalar over surfaces.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/integral").execute(*args, **kwargs)
                def mass_flow_rate(self, *args, **kwargs):
                    """
                    Print mass flow rate through surfaces.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/mass_flow_rate").execute(*args, **kwargs)
                def mass_weighted_avg(self, *args, **kwargs):
                    """
                    Print mass-average of scalar over surfaces.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/mass_weighted_avg").execute(*args, **kwargs)
                def standard_deviation(self, *args, **kwargs):
                    """
                    Print standard deviation of scalar.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/standard_deviation").execute(*args, **kwargs)
                def sum(self, *args, **kwargs):
                    """
                    Print sum of scalar at facet centroids of the surfaces.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/sum").execute(*args, **kwargs)
                def uniformity_index_area_weighted(self, *args, **kwargs):
                    """
                    Print uniformity index of scalar over surfaces.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/uniformity_index_area_weighted").execute(*args, **kwargs)
                def uniformity_index_mass_weighted(self, *args, **kwargs):
                    """
                    Print uniformity index of scalar over surfaces.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/uniformity_index_mass_weighted").execute(*args, **kwargs)
                def vector_based_flux(self, *args, **kwargs):
                    """
                    Print custom vector based flux.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/vector_based_flux").execute(*args, **kwargs)
                def vector_flux(self, *args, **kwargs):
                    """
                    Print custom vector flux.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/vector_flux").execute(*args, **kwargs)
                def vector_weighted_average(self, *args, **kwargs):
                    """
                    Print custom vector weighted average.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/vector_weighted_average").execute(*args, **kwargs)
                def vertex_avg(self, *args, **kwargs):
                    """
                    Print average of scalar at vertices of the surfaces.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/vertex_avg").execute(*args, **kwargs)
                def vertex_max(self, *args, **kwargs):
                    """
                    Print maximkum of scalar at vertices of the surfaces.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/vertex_max").execute(*args, **kwargs)
                def vertex_min(self, *args, **kwargs):
                    """
                    Print minimum of scalar at vertices of the surfaces.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/vertex_min").execute(*args, **kwargs)
                def volume_flow_rate(self, *args, **kwargs):
                    """
                    Print volume flow rate through surfaces.
                    """
                    return PyMenu(self.service, "/results/report/surface_integrals/volume_flow_rate").execute(*args, **kwargs)

            class volume_integrals(metaclass=PyMenuMeta):
                """
                Volume Integral menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def mass(self, *args, **kwargs):
                    """
                    Print total mass of specified cell zones.
                    """
                    return PyMenu(self.service, "/results/report/volume_integrals/mass").execute(*args, **kwargs)
                def mass_avg(self, *args, **kwargs):
                    """
                    Print mass-average of scalar over cell zones.
                    """
                    return PyMenu(self.service, "/results/report/volume_integrals/mass_avg").execute(*args, **kwargs)
                def mass_integral(self, *args, **kwargs):
                    """
                    Print mass-weighted integral of scalar over cell zones.
                    """
                    return PyMenu(self.service, "/results/report/volume_integrals/mass_integral").execute(*args, **kwargs)
                def maximum(self, *args, **kwargs):
                    """
                    Print maximum of scalar over all cell zones.
                    """
                    return PyMenu(self.service, "/results/report/volume_integrals/maximum").execute(*args, **kwargs)
                def minimum(self, *args, **kwargs):
                    """
                    Print minimum of scalar over all cell zones.
                    """
                    return PyMenu(self.service, "/results/report/volume_integrals/minimum").execute(*args, **kwargs)
                def sum(self, *args, **kwargs):
                    """
                    Print sum of scalar over all cell zones.
                    """
                    return PyMenu(self.service, "/results/report/volume_integrals/sum").execute(*args, **kwargs)
                def twopisum(self, *args, **kwargs):
                    """
                    Print sum of scalar over all cell zones multiplied by 2\*Pi.
                    """
                    return PyMenu(self.service, "/results/report/volume_integrals/twopisum").execute(*args, **kwargs)
                def volume(self, *args, **kwargs):
                    """
                    Print total volume of specified cell zones.
                    """
                    return PyMenu(self.service, "/results/report/volume_integrals/volume").execute(*args, **kwargs)
                def volume_avg(self, *args, **kwargs):
                    """
                    Print volume-weighted average of scalar over cell zones.
                    """
                    return PyMenu(self.service, "/results/report/volume_integrals/volume_avg").execute(*args, **kwargs)
                def volume_integral(self, *args, **kwargs):
                    """
                    Print integral of scalar over cell zones.
                    """
                    return PyMenu(self.service, "/results/report/volume_integrals/volume_integral").execute(*args, **kwargs)

            class modified_setting(metaclass=PyMenuMeta):
                """
                Enter the menu for setting up the Modified Settings Summary table.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def modified_setting(self, *args, **kwargs):
                    """
                    Specify which settings will be checked for non-default status for generating the Modified Settings Summary table.
                    """
                    return PyMenu(self.service, "/results/report/modified_setting/modified_setting").execute(*args, **kwargs)
                def write_user_setting(self, *args, **kwargs):
                    """
                    Write the contents of the Modified Settings Summary table to a file.
                    """
                    return PyMenu(self.service, "/results/report/modified_setting/write_user_setting").execute(*args, **kwargs)

            class population_balance(metaclass=PyMenuMeta):
                """
                Population Balance menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def moments(self, *args, **kwargs):
                    """
                    Set moments for population balance.
                    """
                    return PyMenu(self.service, "/results/report/population_balance/moments").execute(*args, **kwargs)
                def number_density(self, *args, **kwargs):
                    """
                    Set number density functions.
                    """
                    return PyMenu(self.service, "/results/report/population_balance/number_density").execute(*args, **kwargs)

            class heat_exchanger(metaclass=PyMenuMeta):
                """
                Enter the heat exchanger menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def computed_heat_rejection(self, *args, **kwargs):
                    """
                    Print total heat rejection.
                    """
                    return PyMenu(self.service, "/results/report/heat_exchanger/computed_heat_rejection").execute(*args, **kwargs)
                def inlet_temperature(self, *args, **kwargs):
                    """
                    Print inlet temperature.
                    """
                    return PyMenu(self.service, "/results/report/heat_exchanger/inlet_temperature").execute(*args, **kwargs)
                def outlet_temperature(self, *args, **kwargs):
                    """
                    Print outlet temperature.
                    """
                    return PyMenu(self.service, "/results/report/heat_exchanger/outlet_temperature").execute(*args, **kwargs)
                def mass_flow_rate(self, *args, **kwargs):
                    """
                    Print mass flow rate.
                    """
                    return PyMenu(self.service, "/results/report/heat_exchanger/mass_flow_rate").execute(*args, **kwargs)
                def specific_heat(self, *args, **kwargs):
                    """
                    Print fluid's specific heat.
                    """
                    return PyMenu(self.service, "/results/report/heat_exchanger/specific_heat").execute(*args, **kwargs)

            class system(metaclass=PyMenuMeta):
                """
                Sytem menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def proc_stats(self, *args, **kwargs):
                    """
                    Fluent process information.
                    """
                    return PyMenu(self.service, "/results/report/system/proc_stats").execute(*args, **kwargs)
                def sys_stats(self, *args, **kwargs):
                    """
                    System information.
                    """
                    return PyMenu(self.service, "/results/report/system/sys_stats").execute(*args, **kwargs)
                def gpgpu_stats(self, *args, **kwargs):
                    """
                    GPGPU information.
                    """
                    return PyMenu(self.service, "/results/report/system/gpgpu_stats").execute(*args, **kwargs)
                def time_stats(self, *args, **kwargs):
                    """
                    Time usage information.
                    """
                    return PyMenu(self.service, "/results/report/system/time_stats").execute(*args, **kwargs)

            class simulation_reports(metaclass=PyMenuMeta):
                """
                Enter the simulation reports menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def list_simulation_reports(self, *args, **kwargs):
                    """
                    List all report names.
                    """
                    return PyMenu(self.service, "/results/report/simulation_reports/list_simulation_reports").execute(*args, **kwargs)
                def generate_simulation_report(self, *args, **kwargs):
                    """
                    Generate a new simulation report or regenerate an existing simulation report with the provided name.
                    """
                    return PyMenu(self.service, "/results/report/simulation_reports/generate_simulation_report").execute(*args, **kwargs)
                def view_simulation_report(self, *args, **kwargs):
                    """
                    View a simulation report that has already been generated. In batch mode this will print the report's URL.
                    """
                    return PyMenu(self.service, "/results/report/simulation_reports/view_simulation_report").execute(*args, **kwargs)
                def export_simulation_report_as_pdf(self, *args, **kwargs):
                    """
                    Export the provided simulation report as a PDF file.
                    """
                    return PyMenu(self.service, "/results/report/simulation_reports/export_simulation_report_as_pdf").execute(*args, **kwargs)
                def export_simulation_report_as_html(self, *args, **kwargs):
                    """
                    Export the provided simulation report as HTML.
                    """
                    return PyMenu(self.service, "/results/report/simulation_reports/export_simulation_report_as_html").execute(*args, **kwargs)
                def write_report_names_to_file(self, *args, **kwargs):
                    """
                    Write the list of currently generated report names to a txt file.
                    """
                    return PyMenu(self.service, "/results/report/simulation_reports/write_report_names_to_file").execute(*args, **kwargs)
                def rename_simulation_report(self, *args, **kwargs):
                    """
                    Rename a report which has already been generated.
                    """
                    return PyMenu(self.service, "/results/report/simulation_reports/rename_simulation_report").execute(*args, **kwargs)
                def duplicate_simulation_report(self, *args, **kwargs):
                    """
                    Duplicate a report and all of its settings to a new report.
                    """
                    return PyMenu(self.service, "/results/report/simulation_reports/duplicate_simulation_report").execute(*args, **kwargs)
                def reset_report_to_defaults(self, *args, **kwargs):
                    """
                    Reset all report settings to default for the provided simulation report.
                    """
                    return PyMenu(self.service, "/results/report/simulation_reports/reset_report_to_defaults").execute(*args, **kwargs)
                def delete_simulation_report(self, *args, **kwargs):
                    """
                    Delete the provided simulation report.
                    """
                    return PyMenu(self.service, "/results/report/simulation_reports/delete_simulation_report").execute(*args, **kwargs)
                def write_simulation_report_template_file(self, *args, **kwargs):
                    """
                    Write a JSON template file with this case's Simulation Report settings.
                    """
                    return PyMenu(self.service, "/results/report/simulation_reports/write_simulation_report_template_file").execute(*args, **kwargs)
                def read_simulation_report_template_file(self, *args, **kwargs):
                    """
                    Read a JSON template file with existing Simulation Report settings.
                    """
                    return PyMenu(self.service, "/results/report/simulation_reports/read_simulation_report_template_file").execute(*args, **kwargs)

        class surface(metaclass=PyMenuMeta):
            """
            Enter the data surface manipulation menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.post_processing_volume = self.__class__.post_processing_volume(path + [("post_processing_volume", None)], service)
                self.query = self.__class__.query(path + [("query", None)], service)
            def circle_slice(self, *args, **kwargs):
                """
                Extract a circular slice.
                """
                return PyMenu(self.service, "/results/surface/circle_slice").execute(*args, **kwargs)
            def delete_surface(self, *args, **kwargs):
                """
                Remove a defined data surface.
                """
                return PyMenu(self.service, "/results/surface/delete_surface").execute(*args, **kwargs)
            def group_surfaces(self, *args, **kwargs):
                """
                Group a set of surfaces.
                """
                return PyMenu(self.service, "/results/surface/group_surfaces").execute(*args, **kwargs)
            def ungroup_surface(self, *args, **kwargs):
                """
                Ungroup the surface(if grouped).
                """
                return PyMenu(self.service, "/results/surface/ungroup_surface").execute(*args, **kwargs)
            def iso_clip(self, *args, **kwargs):
                """
                Clip a data surface (surface, curve, or point) between two iso-values.
                """
                return PyMenu(self.service, "/results/surface/iso_clip").execute(*args, **kwargs)
            def iso_surface(self, *args, **kwargs):
                """
                Extract an iso-surface (surface, curve, or point) from the curent data field.
                """
                return PyMenu(self.service, "/results/surface/iso_surface").execute(*args, **kwargs)
            def expression_volume(self, *args, **kwargs):
                """
                Create volume with boolean expression.
                """
                return PyMenu(self.service, "/results/surface/expression_volume").execute(*args, **kwargs)
            def multiple_iso_surfaces(self, *args, **kwargs):
                """
                Create multiple iso-surfaces from the data field at specified spacing.
                """
                return PyMenu(self.service, "/results/surface/multiple_iso_surfaces").execute(*args, **kwargs)
            def line_slice(self, *args, **kwargs):
                """
                Extract a linear slice.
                """
                return PyMenu(self.service, "/results/surface/line_slice").execute(*args, **kwargs)
            def line_surface(self, *args, **kwargs):
                """
                Define a "line" surface by specifying the two endpoint coordinates.
                """
                return PyMenu(self.service, "/results/surface/line_surface").execute(*args, **kwargs)
            def list_surfaces(self, *args, **kwargs):
                """
                List the number of facets in the defined surfaces.
                """
                return PyMenu(self.service, "/results/surface/list_surfaces").execute(*args, **kwargs)
            def mouse_line(self, *args, **kwargs):
                """
                Define a line surface using the mouse to select two points.
                """
                return PyMenu(self.service, "/results/surface/mouse_line").execute(*args, **kwargs)
            def mouse_plane(self, *args, **kwargs):
                """
                Define a plane surface using the mouse to select three points.
                """
                return PyMenu(self.service, "/results/surface/mouse_plane").execute(*args, **kwargs)
            def mouse_rake(self, *args, **kwargs):
                """
                Define a "rake" surface using the mouse to select the end points.
                """
                return PyMenu(self.service, "/results/surface/mouse_rake").execute(*args, **kwargs)
            def partition_surface(self, *args, **kwargs):
                """
                Define a data surface on mesh faces on the partition boundary.
                """
                return PyMenu(self.service, "/results/surface/partition_surface").execute(*args, **kwargs)
            def plane(self, *args, **kwargs):
                """
                Create a plane given 3 points bounded by the domain.
                """
                return PyMenu(self.service, "/results/surface/plane").execute(*args, **kwargs)
            def plane_surface(self, *args, **kwargs):
                """
                Create a plane from a coordinate plane, point and normal, or three points.
                """
                return PyMenu(self.service, "/results/surface/plane_surface").execute(*args, **kwargs)
            def multiple_plane_surfaces(self, *args, **kwargs):
                """
                Create multiple plane surfaces at specified spacing.
                """
                return PyMenu(self.service, "/results/surface/multiple_plane_surfaces").execute(*args, **kwargs)
            def plane_slice(self, *args, **kwargs):
                """
                Extract a planar slice.
                """
                return PyMenu(self.service, "/results/surface/plane_slice").execute(*args, **kwargs)
            def point_array(self, *args, **kwargs):
                """
                Extract a rectangular array of data points.
                """
                return PyMenu(self.service, "/results/surface/point_array").execute(*args, **kwargs)
            def point_surface(self, *args, **kwargs):
                """
                Define a "point" surface by specifying the coordinates.
                """
                return PyMenu(self.service, "/results/surface/point_surface").execute(*args, **kwargs)
            def structural_point_surface(self, *args, **kwargs):
                """
                Define a "structural point" surface by specifying the coordinates.
                """
                return PyMenu(self.service, "/results/surface/structural_point_surface").execute(*args, **kwargs)
            def quadric_slice(self, *args, **kwargs):
                """
                Extract a quadric slice.
                """
                return PyMenu(self.service, "/results/surface/quadric_slice").execute(*args, **kwargs)
            def rake_surface(self, *args, **kwargs):
                """
                Define a "rake" surface by specifying the end points.
                """
                return PyMenu(self.service, "/results/surface/rake_surface").execute(*args, **kwargs)
            def rename_surface(self, *args, **kwargs):
                """
                Rename a defined data surface.
                """
                return PyMenu(self.service, "/results/surface/rename_surface").execute(*args, **kwargs)
            def sphere_slice(self, *args, **kwargs):
                """
                Extract a spherical slice.
                """
                return PyMenu(self.service, "/results/surface/sphere_slice").execute(*args, **kwargs)
            def ellipsoid_slice(self, *args, **kwargs):
                """
                Extract a ellipsoid slice.
                """
                return PyMenu(self.service, "/results/surface/ellipsoid_slice").execute(*args, **kwargs)
            def cone_slice(self, *args, **kwargs):
                """
                Extract a cone slice.
                """
                return PyMenu(self.service, "/results/surface/cone_slice").execute(*args, **kwargs)
            def surface_cells(self, *args, **kwargs):
                """
                Extract all cells intersected by a data surface.
                """
                return PyMenu(self.service, "/results/surface/surface_cells").execute(*args, **kwargs)
            def transform_surface(self, *args, **kwargs):
                """
                Transform surface.
                """
                return PyMenu(self.service, "/results/surface/transform_surface").execute(*args, **kwargs)
            def create_imprint_surface(self, *args, **kwargs):
                """
                Imprint surface.
                """
                return PyMenu(self.service, "/results/surface/create_imprint_surface").execute(*args, **kwargs)
            def zone_surface(self, *args, **kwargs):
                """
                Define a data surface on a mesh zone.
                """
                return PyMenu(self.service, "/results/surface/zone_surface").execute(*args, **kwargs)
            def reset_zone_surfaces(self, *args, **kwargs):
                """
                Reset case surface list.
                """
                return PyMenu(self.service, "/results/surface/reset_zone_surfaces").execute(*args, **kwargs)
            def multiple_zone_surfaces(self, *args, **kwargs):
                """
                Create multiple data surfaces at a time.
                """
                return PyMenu(self.service, "/results/surface/multiple_zone_surfaces").execute(*args, **kwargs)
            def edit_surface(self, *args, **kwargs):
                """
                Edit a defined data surface.
                """
                return PyMenu(self.service, "/results/surface/edit_surface").execute(*args, **kwargs)

            class post_processing_volume(metaclass=PyMenuMeta):
                """
                Enter post-processing volume menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def create_from_file(self, *args, **kwargs):
                    """
                    Read post-processing mesh from file.
                    """
                    return PyMenu(self.service, "/results/surface/post_processing_volume/create_from_file").execute(*args, **kwargs)
                def create_octree(self, *args, **kwargs):
                    """
                    Create post-processing octree mesh based on current case.
                    """
                    return PyMenu(self.service, "/results/surface/post_processing_volume/create_octree").execute(*args, **kwargs)

            class query(metaclass=PyMenuMeta):
                """
                Enter surface query menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def delete_query(self, *args, **kwargs):
                    """
                    Delete saved query.
                    """
                    return PyMenu(self.service, "/results/surface/query/delete_query").execute(*args, **kwargs)
                def list_surfaces(self, *args, **kwargs):
                    """
                    List surfaces.
                    """
                    return PyMenu(self.service, "/results/surface/query/list_surfaces").execute(*args, **kwargs)
                def named_surface_list(self, *args, **kwargs):
                    """
                    Create named list of surfaces.
                    """
                    return PyMenu(self.service, "/results/surface/query/named_surface_list").execute(*args, **kwargs)
                def list_named_selection(self, *args, **kwargs):
                    """
                    List named selection of surface type.
                    """
                    return PyMenu(self.service, "/results/surface/query/list_named_selection").execute(*args, **kwargs)
                def list_queries(self, *args, **kwargs):
                    """
                    List all saved queries.
                    """
                    return PyMenu(self.service, "/results/surface/query/list_queries").execute(*args, **kwargs)

        class graphics_window(metaclass=PyMenuMeta):
            """
            Enter graphics window menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.embedded_windows = self.__class__.embedded_windows(path + [("embedded_windows", None)], service)
                self.picture = self.__class__.picture(path + [("picture", None)], service)
                self.windows = self.__class__.windows(path + [("windows", None)], service)
                self.titles = self.__class__.titles(path + [("titles", None)], service)
                self.views = self.__class__.views(path + [("views", None)], service)
                self.display_states = self.__class__.display_states(path + [("display_states", None)], service)
                self.view_sync = self.__class__.view_sync(path + [("view_sync", None)], service)
            def close_window(self, *args, **kwargs):
                """
                Close a user graphics window.
                """
                return PyMenu(self.service, "/results/graphics_window/close_window").execute(*args, **kwargs)
            def close_window_by_name(self, *args, **kwargs):
                """
                Close a reserved graphics window by its name.
                """
                return PyMenu(self.service, "/results/graphics_window/close_window_by_name").execute(*args, **kwargs)
            def open_window(self, *args, **kwargs):
                """
                Open a user graphics window.
                """
                return PyMenu(self.service, "/results/graphics_window/open_window").execute(*args, **kwargs)
            def save_picture(self, *args, **kwargs):
                """
                Generate a "hardcopy" of the active window.
                """
                return PyMenu(self.service, "/results/graphics_window/save_picture").execute(*args, **kwargs)
            def set_window(self, *args, **kwargs):
                """
                Set a user graphics window to be the active window.
                """
                return PyMenu(self.service, "/results/graphics_window/set_window").execute(*args, **kwargs)
            def set_window_by_name(self, *args, **kwargs):
                """
                Set a reserved graphics window to be the active window by its name.
                """
                return PyMenu(self.service, "/results/graphics_window/set_window_by_name").execute(*args, **kwargs)
            def update_layout(self, *args, **kwargs):
                """
                Update the fluent layout.
                """
                return PyMenu(self.service, "/results/graphics_window/update_layout").execute(*args, **kwargs)

            class embedded_windows(metaclass=PyMenuMeta):
                """
                Enter to embed, close, move-out embedded windows.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def close(self, *args, **kwargs):
                    """
                    Close an embedded window.
                    """
                    return PyMenu(self.service, "/results/graphics_window/embedded_windows/close").execute(*args, **kwargs)
                def close_all(self, *args, **kwargs):
                    """
                    Close all embedded windows for given parent window.
                    """
                    return PyMenu(self.service, "/results/graphics_window/embedded_windows/close_all").execute(*args, **kwargs)
                def embed_in(self, *args, **kwargs):
                    """
                    Embed Window into another window.
                    """
                    return PyMenu(self.service, "/results/graphics_window/embedded_windows/embed_in").execute(*args, **kwargs)
                def move_out(self, *args, **kwargs):
                    """
                    Move out an embedded window.
                    """
                    return PyMenu(self.service, "/results/graphics_window/embedded_windows/move_out").execute(*args, **kwargs)
                def move_out_all(self, *args, **kwargs):
                    """
                    Move out all embedded windows for given parent window.
                    """
                    return PyMenu(self.service, "/results/graphics_window/embedded_windows/move_out_all").execute(*args, **kwargs)

            class picture(metaclass=PyMenuMeta):
                """
                Enter the hardcopy/save-picture options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.color_mode = self.__class__.color_mode(path + [("color_mode", None)], service)
                    self.driver = self.__class__.driver(path + [("driver", None)], service)
                def invert_background(self, *args, **kwargs):
                    """
                    Use a white background when the picture is saved.
                    """
                    return PyMenu(self.service, "/results/graphics_window/picture/invert_background").execute(*args, **kwargs)
                def landscape(self, *args, **kwargs):
                    """
                    Plot hardcopies in landscape or portrait orientation.
                    """
                    return PyMenu(self.service, "/results/graphics_window/picture/landscape").execute(*args, **kwargs)
                def preview(self, *args, **kwargs):
                    """
                    Display a preview image of a hardcopy.
                    """
                    return PyMenu(self.service, "/results/graphics_window/picture/preview").execute(*args, **kwargs)
                def x_resolution(self, *args, **kwargs):
                    """
                    Set the width of raster-formatted images in pixels (0 implies current window size).
                    """
                    return PyMenu(self.service, "/results/graphics_window/picture/x_resolution").execute(*args, **kwargs)
                def y_resolution(self, *args, **kwargs):
                    """
                    Set the height of raster-formatted images in pixels (0 implies current window size).
                    """
                    return PyMenu(self.service, "/results/graphics_window/picture/y_resolution").execute(*args, **kwargs)
                def dpi(self, *args, **kwargs):
                    """
                    Set the DPI for EPS and Postscript files, specifies the resolution in dots per inch (DPI) instead of setting the width and height.
                    """
                    return PyMenu(self.service, "/results/graphics_window/picture/dpi").execute(*args, **kwargs)
                def use_window_resolution(self, *args, **kwargs):
                    """
                    Use the currently active window's resolution for hardcopy (ignores the x-resolution and y-resolution in this case).
                    """
                    return PyMenu(self.service, "/results/graphics_window/picture/use_window_resolution").execute(*args, **kwargs)
                def set_standard_resolution(self, *args, **kwargs):
                    """
                    Select from pre-defined resolution list.
                    """
                    return PyMenu(self.service, "/results/graphics_window/picture/set_standard_resolution").execute(*args, **kwargs)
                def jpeg_hardcopy_quality(self, *args, **kwargs):
                    """
                    To set jpeg hardcopy quality.
                    """
                    return PyMenu(self.service, "/results/graphics_window/picture/jpeg_hardcopy_quality").execute(*args, **kwargs)

                class color_mode(metaclass=PyMenuMeta):
                    """
                    Enter the hardcopy color mode menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def color(self, *args, **kwargs):
                        """
                        Plot hardcopies in color.
                        """
                        return PyMenu(self.service, "/results/graphics_window/picture/color_mode/color").execute(*args, **kwargs)
                    def gray_scale(self, *args, **kwargs):
                        """
                        Convert color to grayscale for hardcopy.
                        """
                        return PyMenu(self.service, "/results/graphics_window/picture/color_mode/gray_scale").execute(*args, **kwargs)
                    def mono_chrome(self, *args, **kwargs):
                        """
                        Convert color to monochrome (black and white) for hardcopy.
                        """
                        return PyMenu(self.service, "/results/graphics_window/picture/color_mode/mono_chrome").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        Display the current hardcopy color mode.
                        """
                        return PyMenu(self.service, "/results/graphics_window/picture/color_mode/list").execute(*args, **kwargs)

                class driver(metaclass=PyMenuMeta):
                    """
                    Enter the set hardcopy driver menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.post_format = self.__class__.post_format(path + [("post_format", None)], service)
                    def dump_window(self, *args, **kwargs):
                        """
                        Set the command used to dump the graphics window to a file.
                        """
                        return PyMenu(self.service, "/results/graphics_window/picture/driver/dump_window").execute(*args, **kwargs)
                    def eps(self, *args, **kwargs):
                        """
                        Produce encapsulated PostScript (EPS) output for hardcopies.
                        """
                        return PyMenu(self.service, "/results/graphics_window/picture/driver/eps").execute(*args, **kwargs)
                    def jpeg(self, *args, **kwargs):
                        """
                        Produce JPEG output for hardcopies.
                        """
                        return PyMenu(self.service, "/results/graphics_window/picture/driver/jpeg").execute(*args, **kwargs)
                    def post_script(self, *args, **kwargs):
                        """
                        Produce PostScript output for hardcopies.
                        """
                        return PyMenu(self.service, "/results/graphics_window/picture/driver/post_script").execute(*args, **kwargs)
                    def ppm(self, *args, **kwargs):
                        """
                        Produce PPM output for hardcopies.
                        """
                        return PyMenu(self.service, "/results/graphics_window/picture/driver/ppm").execute(*args, **kwargs)
                    def tiff(self, *args, **kwargs):
                        """
                        Use TIFF output for hardcopies.
                        """
                        return PyMenu(self.service, "/results/graphics_window/picture/driver/tiff").execute(*args, **kwargs)
                    def png(self, *args, **kwargs):
                        """
                        Use PNG output for hardcopies.
                        """
                        return PyMenu(self.service, "/results/graphics_window/picture/driver/png").execute(*args, **kwargs)
                    def hsf(self, *args, **kwargs):
                        """
                        Use HSF output for hardcopies.
                        """
                        return PyMenu(self.service, "/results/graphics_window/picture/driver/hsf").execute(*args, **kwargs)
                    def avz(self, *args, **kwargs):
                        """
                        Use AVZ output for hardcopies.
                        """
                        return PyMenu(self.service, "/results/graphics_window/picture/driver/avz").execute(*args, **kwargs)
                    def glb(self, *args, **kwargs):
                        """
                        Use GLB output for hardcopies.
                        """
                        return PyMenu(self.service, "/results/graphics_window/picture/driver/glb").execute(*args, **kwargs)
                    def vrml(self, *args, **kwargs):
                        """
                        Use VRML output for hardcopies.
                        """
                        return PyMenu(self.service, "/results/graphics_window/picture/driver/vrml").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        List the current hardcopy driver.
                        """
                        return PyMenu(self.service, "/results/graphics_window/picture/driver/list").execute(*args, **kwargs)
                    def options(self, *args, **kwargs):
                        """
                        Set the hardcopy options. Available options are:
                        \\n               	"no gamma correction", disables gamma correction of colors,
                        \\n               	"physical size = (width,height)", where width and height
                                  are the actual measurements of the printable area of the page
                                  in centimeters.
                        \\n               	"subscreen = (left,right,bottom,top)", where left,right,
                                  bottom, and top are numbers in [-1,1] describing a subwindow on
                                  the page in which to place the hardcopy.
                        
                        \\n          The options may be combined by separating them with commas.
                        """
                        return PyMenu(self.service, "/results/graphics_window/picture/driver/options").execute(*args, **kwargs)

                    class post_format(metaclass=PyMenuMeta):
                        """
                        Enter the PostScript driver format menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def fast_raster(self, *args, **kwargs):
                            """
                            Use the new raster format.
                            """
                            return PyMenu(self.service, "/results/graphics_window/picture/driver/post_format/fast_raster").execute(*args, **kwargs)
                        def raster(self, *args, **kwargs):
                            """
                            Use the original raster format.
                            """
                            return PyMenu(self.service, "/results/graphics_window/picture/driver/post_format/raster").execute(*args, **kwargs)
                        def rle_raster(self, *args, **kwargs):
                            """
                            Use the run-length encoded raster format.
                            """
                            return PyMenu(self.service, "/results/graphics_window/picture/driver/post_format/rle_raster").execute(*args, **kwargs)
                        def vector(self, *args, **kwargs):
                            """
                            Use vector format.
                            """
                            return PyMenu(self.service, "/results/graphics_window/picture/driver/post_format/vector").execute(*args, **kwargs)

            class windows(metaclass=PyMenuMeta):
                """
                Enter the window options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.axes = self.__class__.axes(path + [("axes", None)], service)
                    self.main = self.__class__.main(path + [("main", None)], service)
                    self.scale = self.__class__.scale(path + [("scale", None)], service)
                    self.text = self.__class__.text(path + [("text", None)], service)
                    self.video = self.__class__.video(path + [("video", None)], service)
                    self.xy = self.__class__.xy(path + [("xy", None)], service)
                def aspect_ratio(self, *args, **kwargs):
                    """
                    Set the aspect ratio of the active window.
                    """
                    return PyMenu(self.service, "/results/graphics_window/windows/aspect_ratio").execute(*args, **kwargs)
                def logo(self, *args, **kwargs):
                    """
                    Enable/disable visibility of the logo in graphics window.
                    """
                    return PyMenu(self.service, "/results/graphics_window/windows/logo").execute(*args, **kwargs)
                def ruler(self, *args, **kwargs):
                    """
                    Enable/disable ruler visibility.
                    """
                    return PyMenu(self.service, "/results/graphics_window/windows/ruler").execute(*args, **kwargs)
                def logo_color(self, *args, **kwargs):
                    """
                    Set logo color to white/black.
                    """
                    return PyMenu(self.service, "/results/graphics_window/windows/logo_color").execute(*args, **kwargs)

                class axes(metaclass=PyMenuMeta):
                    """
                    Enter the axes window options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def border(self, *args, **kwargs):
                        """
                        Enable/disable drawing of a border around the axes window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/axes/border").execute(*args, **kwargs)
                    def bottom(self, *args, **kwargs):
                        """
                        Set the bottom boundary of the axes window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/axes/bottom").execute(*args, **kwargs)
                    def clear(self, *args, **kwargs):
                        """
                        Set the transparency of the axes window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/axes/clear").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        Set the right boundary of the axes window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/axes/right").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        Enable/disable axes visibility.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/axes/visible").execute(*args, **kwargs)

                class main(metaclass=PyMenuMeta):
                    """
                    Enter the main view window options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def border(self, *args, **kwargs):
                        """
                        Enable/disable drawing of borders around the main viewing window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/main/border").execute(*args, **kwargs)
                    def bottom(self, *args, **kwargs):
                        """
                        Set the bottom boundary of the main viewing window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/main/bottom").execute(*args, **kwargs)
                    def left(self, *args, **kwargs):
                        """
                        Set the left boundary of the main viewing window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/main/left").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        Set the right boundary of the main viewing window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/main/right").execute(*args, **kwargs)
                    def top(self, *args, **kwargs):
                        """
                        Set the top boundary of the main viewing window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/main/top").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        Enable/disable visibility of the main viewing window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/main/visible").execute(*args, **kwargs)

                class scale(metaclass=PyMenuMeta):
                    """
                    Enter the color scale window options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def border(self, *args, **kwargs):
                        """
                        Enable/disable drawing of borders around the color scale window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/scale/border").execute(*args, **kwargs)
                    def bottom(self, *args, **kwargs):
                        """
                        Set the bottom boundary of the color scale window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/scale/bottom").execute(*args, **kwargs)
                    def clear(self, *args, **kwargs):
                        """
                        Set the transparency of the scale window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/scale/clear").execute(*args, **kwargs)
                    def format(self, *args, **kwargs):
                        """
                        Set the number format of the color scale window (e.g. %0.2e).
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/scale/format").execute(*args, **kwargs)
                    def font_size(self, *args, **kwargs):
                        """
                        Set the font size of the color scale window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/scale/font_size").execute(*args, **kwargs)
                    def left(self, *args, **kwargs):
                        """
                        Set the left boundary of the color scale window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/scale/left").execute(*args, **kwargs)
                    def margin(self, *args, **kwargs):
                        """
                        Set the margin of the color scale window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/scale/margin").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        Set the right boundary of the color scale window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/scale/right").execute(*args, **kwargs)
                    def top(self, *args, **kwargs):
                        """
                        Set the top boundary of the color scale window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/scale/top").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        Enable/disable visibility of the color scale window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/scale/visible").execute(*args, **kwargs)
                    def alignment(self, *args, **kwargs):
                        """
                        Set colormap to bottom/left/top/right.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/scale/alignment").execute(*args, **kwargs)

                class text(metaclass=PyMenuMeta):
                    """
                    Enter the text window options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def application(self, *args, **kwargs):
                        """
                        Enable/disable the application name in the picture.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/text/application").execute(*args, **kwargs)
                    def border(self, *args, **kwargs):
                        """
                        Enable/disable drawing of borders around the text window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/text/border").execute(*args, **kwargs)
                    def bottom(self, *args, **kwargs):
                        """
                        Set the bottom boundary of the text window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/text/bottom").execute(*args, **kwargs)
                    def clear(self, *args, **kwargs):
                        """
                        Enable/disable text window transparency.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/text/clear").execute(*args, **kwargs)
                    def company(self, *args, **kwargs):
                        """
                        Enable/disable the company name in the picture.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/text/company").execute(*args, **kwargs)
                    def date(self, *args, **kwargs):
                        """
                        Enable/disable the date in the picture.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/text/date").execute(*args, **kwargs)
                    def left(self, *args, **kwargs):
                        """
                        Set the left boundary of the text window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/text/left").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        Set the right boundary of the text window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/text/right").execute(*args, **kwargs)
                    def top(self, *args, **kwargs):
                        """
                        Set the top boundary of the text window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/text/top").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        Enable/disable text window transparency.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/text/visible").execute(*args, **kwargs)

                class video(metaclass=PyMenuMeta):
                    """
                    Enter the video window options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def background(self, *args, **kwargs):
                        """
                        Set the background color in the video picture.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/video/background").execute(*args, **kwargs)
                    def color_filter(self, *args, **kwargs):
                        """
                        Set the color filter options for the picture.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/video/color_filter").execute(*args, **kwargs)
                    def foreground(self, *args, **kwargs):
                        """
                        Set the foreground color in the video picture.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/video/foreground").execute(*args, **kwargs)
                    def on(self, *args, **kwargs):
                        """
                        Enable/disable video picture settings.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/video/on").execute(*args, **kwargs)
                    def pixel_size(self, *args, **kwargs):
                        """
                        Set the window size in pixels.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/video/pixel_size").execute(*args, **kwargs)

                class xy(metaclass=PyMenuMeta):
                    """
                    Enter the X-Y plot window options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def border(self, *args, **kwargs):
                        """
                        Enable/disable drawing of a border around the X-Y plotter window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/xy/border").execute(*args, **kwargs)
                    def bottom(self, *args, **kwargs):
                        """
                        Set the bottom boundary of the X-Y plotter window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/xy/bottom").execute(*args, **kwargs)
                    def left(self, *args, **kwargs):
                        """
                        Set the left boundary of the X-Y plotter window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/xy/left").execute(*args, **kwargs)
                    def right(self, *args, **kwargs):
                        """
                        Set the right boundary of the X-Y plotter window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/xy/right").execute(*args, **kwargs)
                    def top(self, *args, **kwargs):
                        """
                        Set the top boundary of the X-Y plotter window.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/xy/top").execute(*args, **kwargs)
                    def visible(self, *args, **kwargs):
                        """
                        Enable/disable X-Y plotter window visibility.
                        """
                        return PyMenu(self.service, "/results/graphics_window/windows/xy/visible").execute(*args, **kwargs)

            class titles(metaclass=PyMenuMeta):
                """
                Set problem title.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def left_top(self, *args, **kwargs):
                    """
                    Set the title text for left top in title segment.
                    """
                    return PyMenu(self.service, "/results/graphics_window/titles/left_top").execute(*args, **kwargs)
                def left_bottom(self, *args, **kwargs):
                    """
                    Set the title text for left bottom in title segment.
                    """
                    return PyMenu(self.service, "/results/graphics_window/titles/left_bottom").execute(*args, **kwargs)
                def right_top(self, *args, **kwargs):
                    """
                    Set the title text for right top in title segment.
                    """
                    return PyMenu(self.service, "/results/graphics_window/titles/right_top").execute(*args, **kwargs)
                def right_middle(self, *args, **kwargs):
                    """
                    Set the title text for right middle in title segment.
                    """
                    return PyMenu(self.service, "/results/graphics_window/titles/right_middle").execute(*args, **kwargs)
                def right_bottom(self, *args, **kwargs):
                    """
                    Set the title text for right bottom in title segment.
                    """
                    return PyMenu(self.service, "/results/graphics_window/titles/right_bottom").execute(*args, **kwargs)

            class views(metaclass=PyMenuMeta):
                """
                Enter the view manipulation menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.camera = self.__class__.camera(path + [("camera", None)], service)
                def auto_scale(self, *args, **kwargs):
                    """
                    Scale and center the current scene.
                    """
                    return PyMenu(self.service, "/results/graphics_window/views/auto_scale").execute(*args, **kwargs)
                def default_view(self, *args, **kwargs):
                    """
                    Reset view to front and center.
                    """
                    return PyMenu(self.service, "/results/graphics_window/views/default_view").execute(*args, **kwargs)
                def delete_view(self, *args, **kwargs):
                    """
                    Remove a view from the list.
                    """
                    return PyMenu(self.service, "/results/graphics_window/views/delete_view").execute(*args, **kwargs)
                def last_view(self, *args, **kwargs):
                    """
                    Return to the camera position before the last manipulation.
                    """
                    return PyMenu(self.service, "/results/graphics_window/views/last_view").execute(*args, **kwargs)
                def next_view(self, *args, **kwargs):
                    """
                    Return to the camera position after the current position in the stack.
                    """
                    return PyMenu(self.service, "/results/graphics_window/views/next_view").execute(*args, **kwargs)
                def list_views(self, *args, **kwargs):
                    """
                    List predefined and saved views.
                    """
                    return PyMenu(self.service, "/results/graphics_window/views/list_views").execute(*args, **kwargs)
                def restore_view(self, *args, **kwargs):
                    """
                    Use a saved view.
                    """
                    return PyMenu(self.service, "/results/graphics_window/views/restore_view").execute(*args, **kwargs)
                def read_views(self, *args, **kwargs):
                    """
                    Read views from a view file.
                    """
                    return PyMenu(self.service, "/results/graphics_window/views/read_views").execute(*args, **kwargs)
                def save_view(self, *args, **kwargs):
                    """
                    Save the current view to the view list.
                    """
                    return PyMenu(self.service, "/results/graphics_window/views/save_view").execute(*args, **kwargs)
                def write_views(self, *args, **kwargs):
                    """
                    Write selected views to a view file.
                    """
                    return PyMenu(self.service, "/results/graphics_window/views/write_views").execute(*args, **kwargs)

                class camera(metaclass=PyMenuMeta):
                    """
                    Enter the camera menu to modify the current viewing parameters.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def dolly_camera(self, *args, **kwargs):
                        """
                        Adjust the camera position and target.
                        """
                        return PyMenu(self.service, "/results/graphics_window/views/camera/dolly_camera").execute(*args, **kwargs)
                    def field(self, *args, **kwargs):
                        """
                        Set the field of view (width and height).
                        """
                        return PyMenu(self.service, "/results/graphics_window/views/camera/field").execute(*args, **kwargs)
                    def orbit_camera(self, *args, **kwargs):
                        """
                        Adjust the camera position without modifying the target.
                        """
                        return PyMenu(self.service, "/results/graphics_window/views/camera/orbit_camera").execute(*args, **kwargs)
                    def pan_camera(self, *args, **kwargs):
                        """
                        Adjust the camera target without modifying the position.
                        """
                        return PyMenu(self.service, "/results/graphics_window/views/camera/pan_camera").execute(*args, **kwargs)
                    def position(self, *args, **kwargs):
                        """
                        Set the camera position.
                        """
                        return PyMenu(self.service, "/results/graphics_window/views/camera/position").execute(*args, **kwargs)
                    def projection(self, *args, **kwargs):
                        """
                        Set the camera projection type.
                        """
                        return PyMenu(self.service, "/results/graphics_window/views/camera/projection").execute(*args, **kwargs)
                    def roll_camera(self, *args, **kwargs):
                        """
                        Adjust the camera up-vector.
                        """
                        return PyMenu(self.service, "/results/graphics_window/views/camera/roll_camera").execute(*args, **kwargs)
                    def target(self, *args, **kwargs):
                        """
                        Set the point to be the center of the camera view.
                        """
                        return PyMenu(self.service, "/results/graphics_window/views/camera/target").execute(*args, **kwargs)
                    def up_vector(self, *args, **kwargs):
                        """
                        Set the camera up-vector.
                        """
                        return PyMenu(self.service, "/results/graphics_window/views/camera/up_vector").execute(*args, **kwargs)
                    def zoom_camera(self, *args, **kwargs):
                        """
                        Adjust the camera field of view.
                        """
                        return PyMenu(self.service, "/results/graphics_window/views/camera/zoom_camera").execute(*args, **kwargs)

            class display_states(metaclass=PyMenuMeta):
                """
                Enter the display state manipulation menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def list(self, *args, **kwargs):
                    """
                    Print the names of the available display states to the console.
                    """
                    return PyMenu(self.service, "/results/graphics_window/display_states/list").execute(*args, **kwargs)
                def apply(self, *args, **kwargs):
                    """
                    Apply a display state to the active window.
                    """
                    return PyMenu(self.service, "/results/graphics_window/display_states/apply").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete a display state.
                    """
                    return PyMenu(self.service, "/results/graphics_window/display_states/delete").execute(*args, **kwargs)
                def use_active(self, *args, **kwargs):
                    """
                    Update an existing display state's settings to match those of the active graphics window.
                    """
                    return PyMenu(self.service, "/results/graphics_window/display_states/use_active").execute(*args, **kwargs)
                def copy(self, *args, **kwargs):
                    """
                    Create a new display state with settings copied from an existing display state.
                    """
                    return PyMenu(self.service, "/results/graphics_window/display_states/copy").execute(*args, **kwargs)
                def read(self, *args, **kwargs):
                    """
                    Read display states from a file.
                    """
                    return PyMenu(self.service, "/results/graphics_window/display_states/read").execute(*args, **kwargs)
                def write(self, *args, **kwargs):
                    """
                    Write display states to a file.
                    """
                    return PyMenu(self.service, "/results/graphics_window/display_states/write").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit a particular display state setting.
                    """
                    return PyMenu(self.service, "/results/graphics_window/display_states/edit").execute(*args, **kwargs)
                def create(self, *args, **kwargs):
                    """
                    Create a new display state.
                    """
                    return PyMenu(self.service, "/results/graphics_window/display_states/create").execute(*args, **kwargs)

            class view_sync(metaclass=PyMenuMeta):
                """
                Enter the display state manipulation menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def list(self, *args, **kwargs):
                    """
                    Print window ids of open windows.
                    """
                    return PyMenu(self.service, "/results/graphics_window/view_sync/list").execute(*args, **kwargs)
                def start(self, *args, **kwargs):
                    """
                    Start view synchronization.
                    """
                    return PyMenu(self.service, "/results/graphics_window/view_sync/start").execute(*args, **kwargs)
                def stop(self, *args, **kwargs):
                    """
                    Stop view synchronization.
                    """
                    return PyMenu(self.service, "/results/graphics_window/view_sync/stop").execute(*args, **kwargs)
                def remove_all(self, *args, **kwargs):
                    """
                    Unsynchronize all windows.
                    """
                    return PyMenu(self.service, "/results/graphics_window/view_sync/remove_all").execute(*args, **kwargs)
                def add_all(self, *args, **kwargs):
                    """
                    Synchronize all windows.
                    """
                    return PyMenu(self.service, "/results/graphics_window/view_sync/add_all").execute(*args, **kwargs)
                def add(self, *args, **kwargs):
                    """
                    Add list of window ids for synchronization.
                    """
                    return PyMenu(self.service, "/results/graphics_window/view_sync/add").execute(*args, **kwargs)
                def remove(self, *args, **kwargs):
                    """
                    Remove list of window ids from synchronization.
                    """
                    return PyMenu(self.service, "/results/graphics_window/view_sync/remove").execute(*args, **kwargs)

    class solution(metaclass=PyMenuMeta):
        """
        Enter solution menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
            self.calculation_activities = self.__class__.calculation_activities(path + [("calculation_activities", None)], service)
            self.cell_registers = self.__class__.cell_registers(path + [("cell_registers", None)], service)
            self.controls = self.__class__.controls(path + [("controls", None)], service)
            self.expert = self.__class__.expert(path + [("expert", None)], service)
            self.initialize = self.__class__.initialize(path + [("initialize", None)], service)
            self.methods = self.__class__.methods(path + [("methods", None)], service)
            self.monitors = self.__class__.monitors(path + [("monitors", None)], service)
            self.report_definitions = self.__class__.report_definitions(path + [("report_definitions", None)], service)
            self.run_calculation = self.__class__.run_calculation(path + [("run_calculation", None)], service)

        class calculation_activities(metaclass=PyMenuMeta):
            """
            Enter calculation activities menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.animate = self.__class__.animate(path + [("animate", None)], service)
                self.auto_save = self.__class__.auto_save(path + [("auto_save", None)], service)
                self.cell_register_operations = self.__class__.cell_register_operations(path + [("cell_register_operations", None)], service)
                self.execute_commands = self.__class__.execute_commands(path + [("execute_commands", None)], service)
                self.solution_strategy = self.__class__.solution_strategy(path + [("solution_strategy", None)], service)

            class animate(metaclass=PyMenuMeta):
                """
                Enter the animation menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.define = self.__class__.define(path + [("define", None)], service)
                    self.objects = self.__class__.objects(path + [("objects", None)], service)

                class define(metaclass=PyMenuMeta):
                    """
                    Enter the animation definition menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def define_monitor(self, *args, **kwargs):
                        """
                        Define new animation.
                        """
                        return PyMenu(self.service, "/solution/calculation_activities/animate/define/define_monitor").execute(*args, **kwargs)
                    def edit_monitor(self, *args, **kwargs):
                        """
                        Change animation monitor attributes.
                        """
                        return PyMenu(self.service, "/solution/calculation_activities/animate/define/edit_monitor").execute(*args, **kwargs)

                class objects(metaclass=PyMenuMeta):
                    """
                    Enter to define, edit, delete solution animation objects.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def create(self, *args, **kwargs):
                        """
                        Create new graphics object.
                        """
                        return PyMenu(self.service, "/solution/calculation_activities/animate/objects/create").execute(*args, **kwargs)
                    def edit(self, *args, **kwargs):
                        """
                        Edit graphics object.
                        """
                        return PyMenu(self.service, "/solution/calculation_activities/animate/objects/edit").execute(*args, **kwargs)
                    def copy(self, *args, **kwargs):
                        """
                        Copy graphics object.
                        """
                        return PyMenu(self.service, "/solution/calculation_activities/animate/objects/copy").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete graphics object.
                        """
                        return PyMenu(self.service, "/solution/calculation_activities/animate/objects/delete").execute(*args, **kwargs)
                    def clear_history(self, *args, **kwargs):
                        """
                        Clear object history.
                        """
                        return PyMenu(self.service, "/solution/calculation_activities/animate/objects/clear_history").execute(*args, **kwargs)

            class auto_save(metaclass=PyMenuMeta):
                """
                Enter the auto save menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def case_frequency(self, *args, **kwargs):
                    """
                    Set the preference for saving case files.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/auto_save/case_frequency").execute(*args, **kwargs)
                def data_frequency(self, *args, **kwargs):
                    """
                    Set the iteration or time step increment for saving data files.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/auto_save/data_frequency").execute(*args, **kwargs)
                def root_name(self, *args, **kwargs):
                    """
                    Set the root name for auto-saved files. The number of iterations or time steps will be appended to this root name.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/auto_save/root_name").execute(*args, **kwargs)
                def retain_most_recent_files(self, *args, **kwargs):
                    """
                    After the maximum (as in max-files) is reached, a file will be deleted for each file saved.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/auto_save/retain_most_recent_files").execute(*args, **kwargs)
                def max_files(self, *args, **kwargs):
                    """
                    Set the maximum number of data files to save. After the maximum is reached, a file will be deleted for each file saved.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/auto_save/max_files").execute(*args, **kwargs)
                def append_file_name_with(self, *args, **kwargs):
                    """
                    Set the suffix for auto-saved files. The file name can be appended by flow-time, time-step value or by user specified flags in file name.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/auto_save/append_file_name_with").execute(*args, **kwargs)
                def save_data_file_every(self, *args, **kwargs):
                    """
                    Set the auto save frequency type to either time-step or crank-angle and set the corresponding frequency.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/auto_save/save_data_file_every").execute(*args, **kwargs)

            class cell_register_operations(metaclass=PyMenuMeta):
                """
                Manage Cell Register Operations.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def add(self, *args, **kwargs):
                    """
                    Add a new object.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/cell_register_operations/add").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit an object.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/cell_register_operations/edit").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete an object.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/cell_register_operations/delete").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    List objects.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/cell_register_operations/list").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    List properties of an object.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/cell_register_operations/list_properties").execute(*args, **kwargs)

            class execute_commands(metaclass=PyMenuMeta):
                """
                Enter the execute-monitor-commands menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def add_edit(self, *args, **kwargs):
                    """
                    Add or edit execute-commands.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/execute_commands/add_edit").execute(*args, **kwargs)
                def enable(self, *args, **kwargs):
                    """
                    Enable an execute-command.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/execute_commands/enable").execute(*args, **kwargs)
                def disable(self, *args, **kwargs):
                    """
                    Disable an execute-command.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/execute_commands/disable").execute(*args, **kwargs)
                def copy(self, *args, **kwargs):
                    """
                    Copy an execute-command.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/execute_commands/copy").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete an execute-command.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/execute_commands/delete").execute(*args, **kwargs)
                def export(self, *args, **kwargs):
                    """
                    Export execute-commands to a TSV file.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/execute_commands/export").execute(*args, **kwargs)
                def import_(self, *args, **kwargs):
                    """
                    Import execute-commands from a TSV file.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/execute_commands/import").execute(*args, **kwargs)

            class solution_strategy(metaclass=PyMenuMeta):
                """
                Enter the automatic initialization and case modification strategy menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.automatic_case_modification = self.__class__.automatic_case_modification(path + [("automatic_case_modification", None)], service)
                def enable_strategy(self, *args, **kwargs):
                    """
                    Specify whether automatic initialization and case modification should be enabled.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/solution_strategy/enable_strategy").execute(*args, **kwargs)
                def execute_strategy(self, *args, **kwargs):
                    """
                    Execute the automatic initialization and case modification strategy defined at present.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/solution_strategy/execute_strategy").execute(*args, **kwargs)
                def add_edit_modification(self, *args, **kwargs):
                    """
                    Define a single case modification.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/solution_strategy/add_edit_modification").execute(*args, **kwargs)
                def copy_modification(self, *args, **kwargs):
                    """
                    Copy a single case modification.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/solution_strategy/copy_modification").execute(*args, **kwargs)
                def delete_modification(self, *args, **kwargs):
                    """
                    Delete a single case modification.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/solution_strategy/delete_modification").execute(*args, **kwargs)
                def enable_modification(self, *args, **kwargs):
                    """
                    Enable a single defined case modification.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/solution_strategy/enable_modification").execute(*args, **kwargs)
                def disable_modification(self, *args, **kwargs):
                    """
                    Disable a single defined case modification.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/solution_strategy/disable_modification").execute(*args, **kwargs)
                def import_modifications(self, *args, **kwargs):
                    """
                    Import a list of case modifications from a tsv file.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/solution_strategy/import_modifications").execute(*args, **kwargs)
                def export_modifications(self, *args, **kwargs):
                    """
                    Export all case modifications to a tsv file.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/solution_strategy/export_modifications").execute(*args, **kwargs)
                def continue_strategy_execution(self, *args, **kwargs):
                    """
                    Continue execution of the automatic initialization and case modification strategy defined at present.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/solution_strategy/continue_strategy_execution").execute(*args, **kwargs)
                def automatic_initialization(self, *args, **kwargs):
                    """
                    Define how the case is to be initialized automatically.
                    """
                    return PyMenu(self.service, "/solution/calculation_activities/solution_strategy/automatic_initialization").execute(*args, **kwargs)

                class automatic_case_modification(metaclass=PyMenuMeta):
                    """
                    Define how the case is to be modified as the solution progresses.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def before_init_modification(self, *args, **kwargs):
                        """
                        Specify modification to be performed before initialization.
                        """
                        return PyMenu(self.service, "/solution/calculation_activities/solution_strategy/automatic_case_modification/before_init_modification").execute(*args, **kwargs)
                    def original_settings(self, *args, **kwargs):
                        """
                        Specify modification to be performed after initialization to restore to original settings.
                        """
                        return PyMenu(self.service, "/solution/calculation_activities/solution_strategy/automatic_case_modification/original_settings").execute(*args, **kwargs)
                    def modifications(self, *args, **kwargs):
                        """
                        Specify modifications to be performed during solution.
                        """
                        return PyMenu(self.service, "/solution/calculation_activities/solution_strategy/automatic_case_modification/modifications").execute(*args, **kwargs)

        class cell_registers(metaclass=PyMenuMeta):
            """
            Manage Cell Registers.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def adapt(self, *args, **kwargs):
                """
                Adapt cell register objects.
                """
                return PyMenu(self.service, "/solution/cell_registers/adapt").execute(*args, **kwargs)
            def add(self, *args, **kwargs):
                """
                Add a new object.
                """
                return PyMenu(self.service, "/solution/cell_registers/add").execute(*args, **kwargs)
            def apply_poor_mesh_numerics(self, *args, **kwargs):
                """
                Apply poor mesh numerics to cell register objects.
                """
                return PyMenu(self.service, "/solution/cell_registers/apply_poor_mesh_numerics").execute(*args, **kwargs)
            def coarsen(self, *args, **kwargs):
                """
                Coarsen cell register objects.
                """
                return PyMenu(self.service, "/solution/cell_registers/coarsen").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                Display cell register objects.
                """
                return PyMenu(self.service, "/solution/cell_registers/display").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an object.
                """
                return PyMenu(self.service, "/solution/cell_registers/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an object.
                """
                return PyMenu(self.service, "/solution/cell_registers/delete").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List objects.
                """
                return PyMenu(self.service, "/solution/cell_registers/list").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                List properties of an object.
                """
                return PyMenu(self.service, "/solution/cell_registers/list_properties").execute(*args, **kwargs)
            def refine(self, *args, **kwargs):
                """
                Refine cell register objects.
                """
                return PyMenu(self.service, "/solution/cell_registers/refine").execute(*args, **kwargs)

        class controls(metaclass=PyMenuMeta):
            """
            Enter the controls menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.acoustics_wave_equation_controls = self.__class__.acoustics_wave_equation_controls(path + [("acoustics_wave_equation_controls", None)], service)
                self.advanced = self.__class__.advanced(path + [("advanced", None)], service)
                self.contact_solution_controls = self.__class__.contact_solution_controls(path + [("contact_solution_controls", None)], service)
                self.query = self.__class__.query(path + [("query", None)], service)
            def courant_number(self, *args, **kwargs):
                """
                Set the fine mesh Courant number (time step factor).
                """
                return PyMenu(self.service, "/solution/controls/courant_number").execute(*args, **kwargs)
            def equations(self, *args, **kwargs):
                """
                Enter the equations menu.
                """
                return PyMenu(self.service, "/solution/controls/equations").execute(*args, **kwargs)
            def limits(self, *args, **kwargs):
                """
                Set solver limits for the values of various solution variables.
                """
                return PyMenu(self.service, "/solution/controls/limits").execute(*args, **kwargs)
            def p_v_controls(self, *args, **kwargs):
                """
                Set P-V-Controls.
                """
                return PyMenu(self.service, "/solution/controls/p_v_controls").execute(*args, **kwargs)
            def relaxation_factor(self, *args, **kwargs):
                """
                Enter the relaxation-factor menu.
                """
                return PyMenu(self.service, "/solution/controls/relaxation_factor").execute(*args, **kwargs)
            def set_controls_to_default(self, *args, **kwargs):
                """
                Set controls to default values.
                """
                return PyMenu(self.service, "/solution/controls/set_controls_to_default").execute(*args, **kwargs)
            def under_relaxation(self, *args, **kwargs):
                """
                Enter the under-relaxation menu.
                """
                return PyMenu(self.service, "/solution/controls/under_relaxation").execute(*args, **kwargs)

            class acoustics_wave_equation_controls(metaclass=PyMenuMeta):
                """
                Enter menu for acoustics wave equation solver controls.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.expert = self.__class__.expert(path + [("expert", None)], service)
                def relative_convergence_criterion(self, *args, **kwargs):
                    """
                    Specify convergence tolerance for the timestep iterations
                    as the target residual reduction factor.
                    """
                    return PyMenu(self.service, "/solution/controls/acoustics_wave_equation_controls/relative_convergence_criterion").execute(*args, **kwargs)
                def max_iterations_per_timestep(self, *args, **kwargs):
                    """
                    Specify maximum number of iterations per timestep.
                    """
                    return PyMenu(self.service, "/solution/controls/acoustics_wave_equation_controls/max_iterations_per_timestep").execute(*args, **kwargs)

                class expert(metaclass=PyMenuMeta):
                    """
                    Enter menu for expert controls.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def under_relaxation_factor(self, *args, **kwargs):
                        """
                        Specify under-relaxation factor to be used in 
                        the diagonal matrix elements of implicit solver.
                        """
                        return PyMenu(self.service, "/solution/controls/acoustics_wave_equation_controls/expert/under_relaxation_factor").execute(*args, **kwargs)
                    def explicit_relaxation_factor(self, *args, **kwargs):
                        """
                        Specify explicit relaxation factor to be applied to
                        the solution correction when updating solution in the timestep iterations.
                        """
                        return PyMenu(self.service, "/solution/controls/acoustics_wave_equation_controls/expert/explicit_relaxation_factor").execute(*args, **kwargs)

            class advanced(metaclass=PyMenuMeta):
                """
                Controls advanced options.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.amg_options = self.__class__.amg_options(path + [("amg_options", None)], service)
                    self.fast_transient_settings = self.__class__.fast_transient_settings(path + [("fast_transient_settings", None)], service)
                def correction_tolerance(self, *args, **kwargs):
                    """
                    Enter the correction tolerance menu.
                    """
                    return PyMenu(self.service, "/solution/controls/advanced/correction_tolerance").execute(*args, **kwargs)
                def multi_grid_amg(self, *args, **kwargs):
                    """
                    Set the parameters that govern the algebraic multigrid procedure.
                    """
                    return PyMenu(self.service, "/solution/controls/advanced/multi_grid_amg").execute(*args, **kwargs)
                def multi_grid_controls(self, *args, **kwargs):
                    """
                    Enter the multi-grid-controls menu.
                    """
                    return PyMenu(self.service, "/solution/controls/advanced/multi_grid_controls").execute(*args, **kwargs)
                def multi_grid_fas(self, *args, **kwargs):
                    """
                    Set the coefficients that govern the FAS multigrid procedure.
                    """
                    return PyMenu(self.service, "/solution/controls/advanced/multi_grid_fas").execute(*args, **kwargs)
                def multi_stage(self, *args, **kwargs):
                    """
                    Set the multiple-stage time stepping scheme coefficients.
                    """
                    return PyMenu(self.service, "/solution/controls/advanced/multi_stage").execute(*args, **kwargs)
                def relaxation_method(self, *args, **kwargs):
                    """
                    Set the solver relaxation method.
                    """
                    return PyMenu(self.service, "/solution/controls/advanced/relaxation_method").execute(*args, **kwargs)
                def slope_limiter_set(self, *args, **kwargs):
                    """
                    Enter the slope limiter set menu.
                    """
                    return PyMenu(self.service, "/solution/controls/advanced/slope_limiter_set").execute(*args, **kwargs)

                class amg_options(metaclass=PyMenuMeta):
                    """
                    Enter AMG options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def laplace_coarsening(self, *args, **kwargs):
                        """
                        Set AMG laplace coarsening options.
                        """
                        return PyMenu(self.service, "/solution/controls/advanced/amg_options/laplace_coarsening").execute(*args, **kwargs)
                    def conservative_amg_coarsening(self, *args, **kwargs):
                        """
                        Use conservative AMG coarsening?.
                        """
                        return PyMenu(self.service, "/solution/controls/advanced/amg_options/conservative_amg_coarsening").execute(*args, **kwargs)
                    def aggressive_amg_coarsening(self, *args, **kwargs):
                        """
                        Use aggressive AMG coarsening.
                        """
                        return PyMenu(self.service, "/solution/controls/advanced/amg_options/aggressive_amg_coarsening").execute(*args, **kwargs)
                    def amg_gpgpu_options(self, *args, **kwargs):
                        """
                        Set GPGPU AMG solver options.
                        """
                        return PyMenu(self.service, "/solution/controls/advanced/amg_options/amg_gpgpu_options").execute(*args, **kwargs)

                class fast_transient_settings(metaclass=PyMenuMeta):
                    """
                    Enter the fast transient settings menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def rk2(self, *args, **kwargs):
                        """
                        Enable the use of a two-stage Runge-Kutta scheme for time integration.
                        """
                        return PyMenu(self.service, "/solution/controls/advanced/fast_transient_settings/rk2").execute(*args, **kwargs)

            class contact_solution_controls(metaclass=PyMenuMeta):
                """
                Solver controls for contact marks method.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.parameters = self.__class__.parameters(path + [("parameters", None)], service)
                    self.spatial = self.__class__.spatial(path + [("spatial", None)], service)
                    self.transient = self.__class__.transient(path + [("transient", None)], service)
                    self.amg = self.__class__.amg(path + [("amg", None)], service)
                    self.models = self.__class__.models(path + [("models", None)], service)
                    self.methods = self.__class__.methods(path + [("methods", None)], service)
                    self.miscellaneous = self.__class__.miscellaneous(path + [("miscellaneous", None)], service)
                def solution_stabilization(self, *args, **kwargs):
                    """
                    Automatic solver settings adjustment for solution stabilization during contact process.
                    """
                    return PyMenu(self.service, "/solution/controls/contact_solution_controls/solution_stabilization").execute(*args, **kwargs)
                def set_settings_to_default(self, *args, **kwargs):
                    """
                    Set contact solution stabilization to default.
                    """
                    return PyMenu(self.service, "/solution/controls/contact_solution_controls/set_settings_to_default").execute(*args, **kwargs)
                def verbosity(self, *args, **kwargs):
                    """
                    Specify verbosity level for contact solution controls.
                    """
                    return PyMenu(self.service, "/solution/controls/contact_solution_controls/verbosity").execute(*args, **kwargs)

                class parameters(metaclass=PyMenuMeta):
                    """
                    Parameters used in stabilization strategy.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def iterations(self, *args, **kwargs):
                        """
                        Specify additional iterations to accomodate contact solution stabilization.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/parameters/iterations").execute(*args, **kwargs)
                    def solution_stabilization_persistence(self, *args, **kwargs):
                        """
                        Persistence of the solution stabilization based on events [0-contact based, 1-always on].
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/parameters/solution_stabilization_persistence").execute(*args, **kwargs)
                    def persistence_fixed_time_steps(self, *args, **kwargs):
                        """
                        Specify fixed time-steps for solution stabilization persistence after trigger.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/parameters/persistence_fixed_time_steps").execute(*args, **kwargs)
                    def persistence_fixed_duration(self, *args, **kwargs):
                        """
                        Specify fixed time for solution stabilization persistence after trigger.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/parameters/persistence_fixed_duration").execute(*args, **kwargs)
                    def extrapolation_method(self, *args, **kwargs):
                        """
                        Solution extrapolation method for cells changing status from contact to non-contact [0-none, 1-local extrapolation].
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/parameters/extrapolation_method").execute(*args, **kwargs)

                class spatial(metaclass=PyMenuMeta):
                    """
                    Spatial discretization control options.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def first_to_second_order_blending(self, *args, **kwargs):
                        """
                        Set factor to control first order to second order blending.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/spatial/first_to_second_order_blending").execute(*args, **kwargs)
                    def first_to_second_order_blending_list(self, *args, **kwargs):
                        """
                        List set factor to control first order to second order blending.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/spatial/first_to_second_order_blending_list").execute(*args, **kwargs)
                    def scheme(self, *args, **kwargs):
                        """
                        Set advection scheme for contact event stability.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/spatial/scheme").execute(*args, **kwargs)
                    def flow_skew_diffusion_exclude(self, *args, **kwargs):
                        """
                        Exclude skew diffusion discretization contribution for momentum.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/spatial/flow_skew_diffusion_exclude").execute(*args, **kwargs)
                    def scalars_skew_diffusion_exclude(self, *args, **kwargs):
                        """
                        Exclude skew diffusion discretization contribution for scalars.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/spatial/scalars_skew_diffusion_exclude").execute(*args, **kwargs)
                    def rhie_chow_flux_specify(self, *args, **kwargs):
                        """
                        Allow specification of the the rhie-chow flux method.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/spatial/rhie_chow_flux_specify").execute(*args, **kwargs)
                    def rhie_chow_method(self, *args, **kwargs):
                        """
                        Enter the rhie-chow flux method.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/spatial/rhie_chow_method").execute(*args, **kwargs)

                class transient(metaclass=PyMenuMeta):
                    """
                    Transient discretization control options .
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def transient_parameters_specify(self, *args, **kwargs):
                        """
                        Allow transient parameter specification.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/transient/transient_parameters_specify").execute(*args, **kwargs)
                    def transient_scheme(self, *args, **kwargs):
                        """
                        Specify temporal scheme to be used.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/transient/transient_scheme").execute(*args, **kwargs)
                    def time_scale_modification_method(self, *args, **kwargs):
                        """
                        Enter time scale modification method.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/transient/time_scale_modification_method").execute(*args, **kwargs)
                    def time_scale_modification_factor(self, *args, **kwargs):
                        """
                        Specify time-scale modification factor.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/transient/time_scale_modification_factor").execute(*args, **kwargs)

                class amg(metaclass=PyMenuMeta):
                    """
                    AMG control options.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def enforce_laplace_coarsening(self, *args, **kwargs):
                        """
                        Enforce the use of laplace coarsening in AMG.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/amg/enforce_laplace_coarsening").execute(*args, **kwargs)
                    def increase_pre_sweeps(self, *args, **kwargs):
                        """
                        Allow increase in AMG pre-sweep.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/amg/increase_pre_sweeps").execute(*args, **kwargs)
                    def pre_sweeps(self, *args, **kwargs):
                        """
                        Specify the number of AMG pre-sweeps.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/amg/pre_sweeps").execute(*args, **kwargs)
                    def specify_coarsening_rate(self, *args, **kwargs):
                        """
                        Modify AMG coarsening rate.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/amg/specify_coarsening_rate").execute(*args, **kwargs)
                    def coarsen_rate(self, *args, **kwargs):
                        """
                        Specify AMG coarsening rate.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/amg/coarsen_rate").execute(*args, **kwargs)

                class models(metaclass=PyMenuMeta):
                    """
                    Model control options.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def model_ramping(self, *args, **kwargs):
                        """
                        Activate model ramping for solver stability and accuracy.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/models/model_ramping").execute(*args, **kwargs)
                    def ramp_flow(self, *args, **kwargs):
                        """
                        Ramp flow for solver stability and accuracy.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/models/ramp_flow").execute(*args, **kwargs)
                    def ramp_turbulence(self, *args, **kwargs):
                        """
                        Ramp turbulence for solver stability and accuracy.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/models/ramp_turbulence").execute(*args, **kwargs)
                    def ramp_scalars(self, *args, **kwargs):
                        """
                        Ramp all scalar transport equations for solver stability and accuracy.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/models/ramp_scalars").execute(*args, **kwargs)

                class methods(metaclass=PyMenuMeta):
                    """
                    Methods control options.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def pressure_velocity_coupling_controls(self, *args, **kwargs):
                        """
                        Enable pressure-velocity coupling method change for solver stability and accuracy.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/methods/pressure_velocity_coupling_controls").execute(*args, **kwargs)
                    def pressure_velocity_coupling_method(self, *args, **kwargs):
                        """
                        Specify pressure-velocity coupling method change for solver stability and accuracy.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/methods/pressure_velocity_coupling_method").execute(*args, **kwargs)
                    def gradient_controls(self, *args, **kwargs):
                        """
                        Modify gradient method for solver stability and accuracy.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/methods/gradient_controls").execute(*args, **kwargs)
                    def specify_gradient_method(self, *args, **kwargs):
                        """
                        Specify gradient method for solver stability and accuracy.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/methods/specify_gradient_method").execute(*args, **kwargs)

                class miscellaneous(metaclass=PyMenuMeta):
                    """
                    Miscellaneous.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def compute_statistics(self, *args, **kwargs):
                        """
                        Compute solution statistics for contact updates.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/miscellaneous/compute_statistics").execute(*args, **kwargs)
                    def statistics_level(self, *args, **kwargs):
                        """
                        Solution statistics level for contact updates.
                        """
                        return PyMenu(self.service, "/solution/controls/contact_solution_controls/miscellaneous/statistics_level").execute(*args, **kwargs)

            class query(metaclass=PyMenuMeta):
                """
                Enter controls query menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.acoustics_wave_equation_controls = self.__class__.acoustics_wave_equation_controls(path + [("acoustics_wave_equation_controls", None)], service)
                    self.advanced = self.__class__.advanced(path + [("advanced", None)], service)
                def courant_number(self, *args, **kwargs):
                    """
                    Get the fine mesh Courant number (time step factor).
                    """
                    return PyMenu(self.service, "/solution/controls/query/courant_number").execute(*args, **kwargs)
                def equations(self, *args, **kwargs):
                    """
                    Enter the equations menu.
                    """
                    return PyMenu(self.service, "/solution/controls/query/equations").execute(*args, **kwargs)
                def limits(self, *args, **kwargs):
                    """
                    Get solver limits for the values of various solution variables.
                    """
                    return PyMenu(self.service, "/solution/controls/query/limits").execute(*args, **kwargs)
                def p_v_controls(self, *args, **kwargs):
                    """
                    Get P-V-Controls.
                    """
                    return PyMenu(self.service, "/solution/controls/query/p_v_controls").execute(*args, **kwargs)
                def relaxation_factor(self, *args, **kwargs):
                    """
                    Enter the relaxation-factor menu.
                    """
                    return PyMenu(self.service, "/solution/controls/query/relaxation_factor").execute(*args, **kwargs)
                def under_relaxation(self, *args, **kwargs):
                    """
                    Enter under relaxation menu.
                    """
                    return PyMenu(self.service, "/solution/controls/query/under_relaxation").execute(*args, **kwargs)

                class acoustics_wave_equation_controls(metaclass=PyMenuMeta):
                    """
                    Enter menu for acoustics wave equation solver controls.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.expert = self.__class__.expert(path + [("expert", None)], service)
                    def relative_convergence_criterion(self, *args, **kwargs):
                        """
                        Specify convergence tolerance for the timestep iterations
                        as the target residual reduction factor.
                        """
                        return PyMenu(self.service, "/solution/controls/query/acoustics_wave_equation_controls/relative_convergence_criterion").execute(*args, **kwargs)
                    def max_iterations_per_timestep(self, *args, **kwargs):
                        """
                        Specify maximum number of iterations per timestep.
                        """
                        return PyMenu(self.service, "/solution/controls/query/acoustics_wave_equation_controls/max_iterations_per_timestep").execute(*args, **kwargs)

                    class expert(metaclass=PyMenuMeta):
                        """
                        Enter menu for expert controls.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def under_relaxation_factor(self, *args, **kwargs):
                            """
                            Specify under-relaxation factor to be used in 
                            the diagonal matrix elements of implicit solver.
                            """
                            return PyMenu(self.service, "/solution/controls/query/acoustics_wave_equation_controls/expert/under_relaxation_factor").execute(*args, **kwargs)
                        def explicit_relaxation_factor(self, *args, **kwargs):
                            """
                            Specify explicit relaxation factor to be applied to
                            the solution correction when updating solution in the timestep iterations.
                            """
                            return PyMenu(self.service, "/solution/controls/query/acoustics_wave_equation_controls/expert/explicit_relaxation_factor").execute(*args, **kwargs)

                class advanced(metaclass=PyMenuMeta):
                    """
                    Controls advanced options.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.amg_options = self.__class__.amg_options(path + [("amg_options", None)], service)
                    def correction_tolerance(self, *args, **kwargs):
                        """
                        Enter the correction tolerance menu.
                        """
                        return PyMenu(self.service, "/solution/controls/query/advanced/correction_tolerance").execute(*args, **kwargs)
                    def multi_grid_amg(self, *args, **kwargs):
                        """
                        Get the parameters that govern the algebraic multigrid procedure.
                        """
                        return PyMenu(self.service, "/solution/controls/query/advanced/multi_grid_amg").execute(*args, **kwargs)
                    def multi_grid_controls(self, *args, **kwargs):
                        """
                        Enter the multi-grid-controls menu.
                        """
                        return PyMenu(self.service, "/solution/controls/query/advanced/multi_grid_controls").execute(*args, **kwargs)
                    def multi_grid_fas(self, *args, **kwargs):
                        """
                        Get the coefficients that govern the FAS multigrid procedure.
                        """
                        return PyMenu(self.service, "/solution/controls/query/advanced/multi_grid_fas").execute(*args, **kwargs)
                    def multi_stage(self, *args, **kwargs):
                        """
                        Set the multiple-stage time stepping scheme coefficients.
                        """
                        return PyMenu(self.service, "/solution/controls/query/advanced/multi_stage").execute(*args, **kwargs)
                    def relaxation_method(self, *args, **kwargs):
                        """
                        Set the solver relaxation method.
                        """
                        return PyMenu(self.service, "/solution/controls/query/advanced/relaxation_method").execute(*args, **kwargs)

                    class amg_options(metaclass=PyMenuMeta):
                        """
                        Enter AMG options menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def laplace_coarsening(self, *args, **kwargs):
                            """
                            Get AMG laplace coarsening options.
                            """
                            return PyMenu(self.service, "/solution/controls/query/advanced/amg_options/laplace_coarsening").execute(*args, **kwargs)
                        def conservative_amg_coarsening(self, *args, **kwargs):
                            """
                            Use conservative AMG coarsening?.
                            """
                            return PyMenu(self.service, "/solution/controls/query/advanced/amg_options/conservative_amg_coarsening").execute(*args, **kwargs)
                        def aggressive_amg_coarsening(self, *args, **kwargs):
                            """
                            Use aggressive AMG coarsening.
                            """
                            return PyMenu(self.service, "/solution/controls/query/advanced/amg_options/aggressive_amg_coarsening").execute(*args, **kwargs)
                        def amg_gpgpu_options(self, *args, **kwargs):
                            """
                            Amg gpu options.
                            """
                            return PyMenu(self.service, "/solution/controls/query/advanced/amg_options/amg_gpgpu_options").execute(*args, **kwargs)

        class expert(metaclass=PyMenuMeta):
            """
            Enter expert options for solution.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.divergence_prevention = self.__class__.divergence_prevention(path + [("divergence_prevention", None)], service)
                self.high_speed_numerics = self.__class__.high_speed_numerics(path + [("high_speed_numerics", None)], service)
                self.poor_mesh_numerics = self.__class__.poor_mesh_numerics(path + [("poor_mesh_numerics", None)], service)
                self.previous_defaults = self.__class__.previous_defaults(path + [("previous_defaults", None)], service)
                self.non_reflecting_boundary_treatment = self.__class__.non_reflecting_boundary_treatment(path + [("non_reflecting_boundary_treatment", None)], service)
                self.open_channel_wave_options = self.__class__.open_channel_wave_options(path + [("open_channel_wave_options", None)], service)
                self.secondary_gradient_limiting = self.__class__.secondary_gradient_limiting(path + [("secondary_gradient_limiting", None)], service)
            def alternate_wall_temp_formulation(self, *args, **kwargs):
                """
                Alternate formulation for wall temperatures?.
                """
                return PyMenu(self.service, "/solution/expert/alternate_wall_temp_formulation").execute(*args, **kwargs)
            def bc_pressure_extrapolations(self, *args, **kwargs):
                """
                Setting pressure extrapolations schemes on boundaries.
                """
                return PyMenu(self.service, "/solution/expert/bc_pressure_extrapolations").execute(*args, **kwargs)
            def bcd_boundedness(self, *args, **kwargs):
                """
                BCD scheme boundedness strength, constant or expression (0 to 1).
                """
                return PyMenu(self.service, "/solution/expert/bcd_boundedness").execute(*args, **kwargs)
            def bcd_weights_freeze(self, *args, **kwargs):
                """
                At each timestep, freeze BCD scheme weights after specified iteration
                in order to improve timestep convergence.
                """
                return PyMenu(self.service, "/solution/expert/bcd_weights_freeze").execute(*args, **kwargs)
            def correction_form(self, *args, **kwargs):
                """
                Discretize momentum equations in correction form for the pressure-based solver.
                """
                return PyMenu(self.service, "/solution/expert/correction_form").execute(*args, **kwargs)
            def disable_reconstruction(self, *args, **kwargs):
                """
                Enable/Disable reconstruction. When disabled, accuracy will be first-order.
                """
                return PyMenu(self.service, "/solution/expert/disable_reconstruction").execute(*args, **kwargs)
            def energy_numerical_noise_filter(self, *args, **kwargs):
                """
                The energy equation numerical noise filter can be enabled to eliminate non-physical numerical noise in the energy field.
                     The numerical noise can appear in solution fields where large variations in specific heat or combustion with phase change are present.
                     Using the energy equation numerical noise filter increases robustness, but may make the solution slightly more diffusive.
                """
                return PyMenu(self.service, "/solution/expert/energy_numerical_noise_filter").execute(*args, **kwargs)
            def explicit_under_relaxation_value(self, *args, **kwargs):
                """
                Explicit under-relaxation value.
                """
                return PyMenu(self.service, "/solution/expert/explicit_under_relaxation_value").execute(*args, **kwargs)
            def equation_ordering(self, *args, **kwargs):
                """
                Set the equation order.
                """
                return PyMenu(self.service, "/solution/expert/equation_ordering").execute(*args, **kwargs)
            def flow_warnings(self, *args, **kwargs):
                """
                Control the display of warning diagnostics for boundaries with reversed flow, etc.
                """
                return PyMenu(self.service, "/solution/expert/flow_warnings").execute(*args, **kwargs)
            def limiter_warnings(self, *args, **kwargs):
                """
                Control the display of limiter warning diagnostics.
                """
                return PyMenu(self.service, "/solution/expert/limiter_warnings").execute(*args, **kwargs)
            def linearized_mass_transfer_udf(self, *args, **kwargs):
                """
                Use linearized mass transfer UDFs?.
                """
                return PyMenu(self.service, "/solution/expert/linearized_mass_transfer_udf").execute(*args, **kwargs)
            def lock_solid_temperature(self, *args, **kwargs):
                """
                Lock the temperature for all solid and shell cell zones in the domain.
                """
                return PyMenu(self.service, "/solution/expert/lock_solid_temperature").execute(*args, **kwargs)
            def material_property_warnings(self, *args, **kwargs):
                """
                Control the display of material property warning diagnostics:
                 0 - off (no messages)
                 1 - messages per material
                 2 - messages per material and per property.
                """
                return PyMenu(self.service, "/solution/expert/material_property_warnings").execute(*args, **kwargs)
            def mp_mfluid_aniso_drag(self, *args, **kwargs):
                """
                Set anisotropic drag parameters for Eulerian multiphase.
                """
                return PyMenu(self.service, "/solution/expert/mp_mfluid_aniso_drag").execute(*args, **kwargs)
            def mp_reference_density(self, *args, **kwargs):
                """
                Set reference density option for Eulerian multiphase.
                """
                return PyMenu(self.service, "/solution/expert/mp_reference_density").execute(*args, **kwargs)
            def numerical_beach_controls(self, *args, **kwargs):
                """
                Set damping function in flow direction.
                """
                return PyMenu(self.service, "/solution/expert/numerical_beach_controls").execute(*args, **kwargs)
            def open_channel_controls(self, *args, **kwargs):
                """
                
                Set additional open channel controls.
                """
                return PyMenu(self.service, "/solution/expert/open_channel_controls").execute(*args, **kwargs)
            def retain_cell_residuals(self, *args, **kwargs):
                """
                Retain cell residuals for postprocessing?.
                """
                return PyMenu(self.service, "/solution/expert/retain_cell_residuals").execute(*args, **kwargs)
            def retain_temporary_solver_mem(self, *args, **kwargs):
                """
                Retain temporary solver memory?.
                """
                return PyMenu(self.service, "/solution/expert/retain_temporary_solver_mem").execute(*args, **kwargs)
            def set_all_species_together(self, *args, **kwargs):
                """
                Set all species discretizations and URFs together.
                """
                return PyMenu(self.service, "/solution/expert/set_all_species_together").execute(*args, **kwargs)
            def show_all_discretization_schemes(self, *args, **kwargs):
                """
                Allow selection of all applicable discretization schemes?.
                """
                return PyMenu(self.service, "/solution/expert/show_all_discretization_schemes").execute(*args, **kwargs)
            def singhal_et_al_cavitation_model(self, *args, **kwargs):
                """
                Use Singhal-et-al cavitation model?.
                """
                return PyMenu(self.service, "/solution/expert/singhal_et_al_cavitation_model").execute(*args, **kwargs)
            def surface_tension(self, *args, **kwargs):
                """
                Set surface-tension calculation options.
                """
                return PyMenu(self.service, "/solution/expert/surface_tension").execute(*args, **kwargs)
            def surface_tension_expert(self, *args, **kwargs):
                """
                Set surface-tension expert options.
                """
                return PyMenu(self.service, "/solution/expert/surface_tension_expert").execute(*args, **kwargs)
            def vof_explicit_controls(self, *args, **kwargs):
                """
                Set Explicit VOF controls.
                """
                return PyMenu(self.service, "/solution/expert/vof_explicit_controls").execute(*args, **kwargs)

            class divergence_prevention(metaclass=PyMenuMeta):
                """
                Enter the divergence prevention menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def enable(self, *args, **kwargs):
                    """
                    Enable divergence prevention.
                    """
                    return PyMenu(self.service, "/solution/expert/divergence_prevention/enable").execute(*args, **kwargs)

            class high_speed_numerics(metaclass=PyMenuMeta):
                """
                Enter high-speed-numerics menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def enable(self, *args, **kwargs):
                    """
                    Enable/disable high-speed-numerics.
                    """
                    return PyMenu(self.service, "/solution/expert/high_speed_numerics/enable").execute(*args, **kwargs)
                def expert(self, *args, **kwargs):
                    """
                    Expert high-speed-numerics.
                    """
                    return PyMenu(self.service, "/solution/expert/high_speed_numerics/expert").execute(*args, **kwargs)
                def visualize_pressure_discontinuity_sensor(self, *args, **kwargs):
                    """
                    Enable/disable pressure-discontinuity-sensor visualization.
                    """
                    return PyMenu(self.service, "/solution/expert/high_speed_numerics/visualize_pressure_discontinuity_sensor").execute(*args, **kwargs)

            class poor_mesh_numerics(metaclass=PyMenuMeta):
                """
                Enter Poor Mesh Numerics Menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.solution_based_pmn = self.__class__.solution_based_pmn(path + [("solution_based_pmn", None)], service)
                def enable(self, *args, **kwargs):
                    """
                    Solution correction on meshes of poor quality.
                    """
                    return PyMenu(self.service, "/solution/expert/poor_mesh_numerics/enable").execute(*args, **kwargs)
                def cell_quality_based(self, *args, **kwargs):
                    """
                    Enable/disable poor mesh numerics on cells with low quality.
                    """
                    return PyMenu(self.service, "/solution/expert/poor_mesh_numerics/cell_quality_based").execute(*args, **kwargs)
                def set_quality_threshold(self, *args, **kwargs):
                    """
                    Set quality threshold.
                    """
                    return PyMenu(self.service, "/solution/expert/poor_mesh_numerics/set_quality_threshold").execute(*args, **kwargs)
                def solution_and_quality_based(self, *args, **kwargs):
                    """
                    Enable/disable poor mesh numerics based on solution and cell quality.
                    """
                    return PyMenu(self.service, "/solution/expert/poor_mesh_numerics/solution_and_quality_based").execute(*args, **kwargs)
                def gradient_quality_based(self, *args, **kwargs):
                    """
                    Enable/disable poor mesh numerics based on cell gradient quality.
                    """
                    return PyMenu(self.service, "/solution/expert/poor_mesh_numerics/gradient_quality_based").execute(*args, **kwargs)
                def orthogonality_enhancing_cell_centroids(self, *args, **kwargs):
                    """
                    Relocate select cell centroids, to improve orthogonality metrics and solution stability.
                    """
                    return PyMenu(self.service, "/solution/expert/poor_mesh_numerics/orthogonality_enhancing_cell_centroids").execute(*args, **kwargs)
                def user_defined_on_register(self, *args, **kwargs):
                    """
                    Include cells in register in poor mesh numerics.
                    """
                    return PyMenu(self.service, "/solution/expert/poor_mesh_numerics/user_defined_on_register").execute(*args, **kwargs)
                def reset_poor_elements(self, *args, **kwargs):
                    """
                    Reset marking of poor cell elements.
                    """
                    return PyMenu(self.service, "/solution/expert/poor_mesh_numerics/reset_poor_elements").execute(*args, **kwargs)
                def print_poor_elements_count(self, *args, **kwargs):
                    """
                    Print poor cells count.
                    """
                    return PyMenu(self.service, "/solution/expert/poor_mesh_numerics/print_poor_elements_count").execute(*args, **kwargs)
                def enhanced_pmn(self, *args, **kwargs):
                    """
                    This option is available with the density-based solver. When enabled, it will apply quality-based poor-mesh-numerics order=1 on any cells with a quality-measure below 0.2. In addition, their CFL number is limited to 1.0.
                    """
                    return PyMenu(self.service, "/solution/expert/poor_mesh_numerics/enhanced_pmn").execute(*args, **kwargs)

                class solution_based_pmn(metaclass=PyMenuMeta):
                    """
                    Solution based poor-mesh numerics menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def enable(self, *args, **kwargs):
                        """
                        Enable solution based treatment.
                        """
                        return PyMenu(self.service, "/solution/expert/poor_mesh_numerics/solution_based_pmn/enable").execute(*args, **kwargs)
                    def mark_primary_solution_limits(self, *args, **kwargs):
                        """
                        Mark cells violating solution limits.
                        """
                        return PyMenu(self.service, "/solution/expert/poor_mesh_numerics/solution_based_pmn/mark_primary_solution_limits").execute(*args, **kwargs)
                    def mark_velocity_limit(self, *args, **kwargs):
                        """
                        Mark cells exceeding velocity limit.
                        """
                        return PyMenu(self.service, "/solution/expert/poor_mesh_numerics/solution_based_pmn/mark_velocity_limit").execute(*args, **kwargs)
                    def mark_cfl_limit(self, *args, **kwargs):
                        """
                        Mark cells exceeding cfl limit.
                        """
                        return PyMenu(self.service, "/solution/expert/poor_mesh_numerics/solution_based_pmn/mark_cfl_limit").execute(*args, **kwargs)
                    def mark_cfl_jump(self, *args, **kwargs):
                        """
                        Mark cells exceeding cfl jump in neighborhood.
                        """
                        return PyMenu(self.service, "/solution/expert/poor_mesh_numerics/solution_based_pmn/mark_cfl_jump").execute(*args, **kwargs)

            class previous_defaults(metaclass=PyMenuMeta):
                """
                Enter previous defaults menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def undo_r19_point_0_default_changes(self, *args, **kwargs):
                    """
                    Undo default changes introduced in R19.0.
                    """
                    return PyMenu(self.service, "/solution/expert/previous_defaults/undo_r19_point_0_default_changes").execute(*args, **kwargs)
                def undo_2019r1_default_changes(self, *args, **kwargs):
                    """
                    Undo default changes introduced in 2019R1.
                    """
                    return PyMenu(self.service, "/solution/expert/previous_defaults/undo_2019r1_default_changes").execute(*args, **kwargs)
                def undo_2019r3_default_changes(self, *args, **kwargs):
                    """
                    Undo default changes introduced in 2019R3.
                    """
                    return PyMenu(self.service, "/solution/expert/previous_defaults/undo_2019r3_default_changes").execute(*args, **kwargs)
                def undo_2021r1_default_changes(self, *args, **kwargs):
                    """
                    Undo default changes introduced in 2021R1.
                    """
                    return PyMenu(self.service, "/solution/expert/previous_defaults/undo_2021r1_default_changes").execute(*args, **kwargs)
                def undo_2021r2_default_changes(self, *args, **kwargs):
                    """
                    Undo default changes introduced in 2021R2.
                    """
                    return PyMenu(self.service, "/solution/expert/previous_defaults/undo_2021r2_default_changes").execute(*args, **kwargs)
                def undo_2022r1_default_changes(self, *args, **kwargs):
                    """
                    Undo default changes introduced in 2022R1.
                    """
                    return PyMenu(self.service, "/solution/expert/previous_defaults/undo_2022r1_default_changes").execute(*args, **kwargs)

            class non_reflecting_boundary_treatment(metaclass=PyMenuMeta):
                """
                Enter non reflecting boundary treatment using minimal pressure reflection approach menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def pressure_inlet(self, *args, **kwargs):
                    """
                    Enabling the use of minimal pressure reflection treatment. This treatment will minimize pressure wave reflections from the boundaries on which this option is active, but not necessarily fully eliminating them. The reflections would be of an acceptable limit in order to not contaminate the solution, the simulation will gain from the robustness of the new algorithm compared to traditional non-reflecting boundary condition treatment.
                    """
                    return PyMenu(self.service, "/solution/expert/non_reflecting_boundary_treatment/pressure_inlet").execute(*args, **kwargs)
                def pressure_outlet(self, *args, **kwargs):
                    """
                    Enabling the use of minimal pressure reflection treatment. This treatment will minimize pressure wave reflections from the boundaries on which this option is active, but not necessarily fully eliminating them. The reflections would be of an acceptable limit in order to not contaminate the solution, the simulation will gain from the robustness of the new algorithm compared to traditional non-reflecting boundary condition treatment.
                    """
                    return PyMenu(self.service, "/solution/expert/non_reflecting_boundary_treatment/pressure_outlet").execute(*args, **kwargs)
                def velocity_inlet(self, *args, **kwargs):
                    """
                    Enabling the use of minimal pressure reflection treatment. This treatment will minimize pressure wave reflections from the boundaries on which this option is active, but not necessarily fully eliminating them. The reflections would be of an acceptable limit in order to not contaminate the solution, the simulation will gain from the robustness of the new algorithm compared to traditional non-reflecting boundary condition treatment.
                    """
                    return PyMenu(self.service, "/solution/expert/non_reflecting_boundary_treatment/velocity_inlet").execute(*args, **kwargs)

            class open_channel_wave_options(metaclass=PyMenuMeta):
                """
                Enter the open-channel-wave-options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def set_verbosity(self, *args, **kwargs):
                    """
                    Set open channel wave verbosity.
                    """
                    return PyMenu(self.service, "/solution/expert/open_channel_wave_options/set_verbosity").execute(*args, **kwargs)
                def stokes_wave_variants(self, *args, **kwargs):
                    """
                    Set stokes wave theory variants.
                    """
                    return PyMenu(self.service, "/solution/expert/open_channel_wave_options/stokes_wave_variants").execute(*args, **kwargs)
                def set_buffer_layer_ht(self, *args, **kwargs):
                    """
                    Set bufer layer height between phases for segregated velocity inputs.
                    """
                    return PyMenu(self.service, "/solution/expert/open_channel_wave_options/set_buffer_layer_ht").execute(*args, **kwargs)

            class secondary_gradient_limiting(metaclass=PyMenuMeta):
                """
                Enter the Secondary Gradient Limiting Menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def energy(self, *args, **kwargs):
                    """
                    Enable/disable secondary gradient limiting at coupled walls for energy equation.
                    """
                    return PyMenu(self.service, "/solution/expert/secondary_gradient_limiting/energy").execute(*args, **kwargs)
                def uds(self, *args, **kwargs):
                    """
                    Enable/disable secondary gradient limiting at coupled walls for user-defined scalars.
                    """
                    return PyMenu(self.service, "/solution/expert/secondary_gradient_limiting/uds").execute(*args, **kwargs)
                def mesh_quality_limits(self, *args, **kwargs):
                    """
                    Specify minimum and maximum mesh quality limits.
                    """
                    return PyMenu(self.service, "/solution/expert/secondary_gradient_limiting/mesh_quality_limits").execute(*args, **kwargs)

        class initialize(metaclass=PyMenuMeta):
            """
            Enter the flow initialization menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.compute_defaults = self.__class__.compute_defaults(path + [("compute_defaults", None)], service)
                self.mp_localized_turb_init = self.__class__.mp_localized_turb_init(path + [("mp_localized_turb_init", None)], service)
                self.vof_patch_smooth_options = self.__class__.vof_patch_smooth_options(path + [("vof_patch_smooth_options", None)], service)
                self.set_fmg_options = self.__class__.set_fmg_options(path + [("set_fmg_options", None)], service)
                self.set_hyb_initialization = self.__class__.set_hyb_initialization(path + [("set_hyb_initialization", None)], service)
            def open_channel_auto_init(self, *args, **kwargs):
                """
                Open channel automatic initialization.
                """
                return PyMenu(self.service, "/solution/initialize/open_channel_auto_init").execute(*args, **kwargs)
            def levelset_auto_init(self, *args, **kwargs):
                """
                Levelset function automatic initialization.
                """
                return PyMenu(self.service, "/solution/initialize/levelset_auto_init").execute(*args, **kwargs)
            def dpm_reset(self, *args, **kwargs):
                """
                Reset discrete phase source terms to zero.
                """
                return PyMenu(self.service, "/solution/initialize/dpm_reset").execute(*args, **kwargs)
            def lwf_initialization(self, *args, **kwargs):
                """
                Delete wall film particles and initialize wall film variables to zero.
                """
                return PyMenu(self.service, "/solution/initialize/lwf_initialization").execute(*args, **kwargs)
            def initialize_flow(self, *args, **kwargs):
                """
                Initialize the flow field with the current default values.
                """
                return PyMenu(self.service, "/solution/initialize/initialize_flow").execute(*args, **kwargs)
            def init_acoustics_options(self, *args, **kwargs):
                """
                Specify number of timesteps for ramping of sources
                and initialize acoustics model variables.
                During ramping the sound sources are multiplied by a factor smoothly growing from 0 to 1.
                """
                return PyMenu(self.service, "/solution/initialize/init_acoustics_options").execute(*args, **kwargs)
            def hyb_initialization(self, *args, **kwargs):
                """
                Initialize using the hybrid initialization method.
                """
                return PyMenu(self.service, "/solution/initialize/hyb_initialization").execute(*args, **kwargs)
            def init_flow_statistics(self, *args, **kwargs):
                """
                Initialize statistics.
                """
                return PyMenu(self.service, "/solution/initialize/init_flow_statistics").execute(*args, **kwargs)
            def patch(self, *args, **kwargs):
                """
                Patch a value for a flow variable in the domain.
                """
                return PyMenu(self.service, "/solution/initialize/patch").execute(*args, **kwargs)
            def show_time_sampled(self, *args, **kwargs):
                """
                Display the amount of simulated time covered by the data sampled for unsteady statistics.
                """
                return PyMenu(self.service, "/solution/initialize/show_time_sampled").execute(*args, **kwargs)
            def show_iterations_sampled(self, *args, **kwargs):
                """
                Display the amount of simulated iterations covered by the data sampled for steady statistics.
                """
                return PyMenu(self.service, "/solution/initialize/show_iterations_sampled").execute(*args, **kwargs)
            def init_turb_vel_fluctuations(self, *args, **kwargs):
                """
                Initialize turbulent velocity fluctuations.
                """
                return PyMenu(self.service, "/solution/initialize/init_turb_vel_fluctuations").execute(*args, **kwargs)
            def fmg_initialization(self, *args, **kwargs):
                """
                Initialize using the full-multigrid initialization (FMG).
                """
                return PyMenu(self.service, "/solution/initialize/fmg_initialization").execute(*args, **kwargs)
            def repair_wall_distance(self, *args, **kwargs):
                """
                Correct wall distance at very high aspect ratio hexahedral/polyhedral cells.
                """
                return PyMenu(self.service, "/solution/initialize/repair_wall_distance").execute(*args, **kwargs)
            def set_defaults(self, *args, **kwargs):
                """
                Enter the set defaults menu.
                """
                return PyMenu(self.service, "/solution/initialize/set_defaults").execute(*args, **kwargs)
            def set_fmg_initialization(self, *args, **kwargs):
                """
                Enter the set full-multigrid for initialization menu.
                """
                return PyMenu(self.service, "/solution/initialize/set_fmg_initialization").execute(*args, **kwargs)
            def list_defaults(self, *args, **kwargs):
                """
                List default values.
                """
                return PyMenu(self.service, "/solution/initialize/list_defaults").execute(*args, **kwargs)
            def reference_frame(self, *args, **kwargs):
                """
                Set reference frame absolute or relative.
                """
                return PyMenu(self.service, "/solution/initialize/reference_frame").execute(*args, **kwargs)

            class compute_defaults(metaclass=PyMenuMeta):
                """
                Enter the compute defaults menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def axis(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/axis").execute(*args, **kwargs)
                def degassing(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/degassing").execute(*args, **kwargs)
                def dummy_entry(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/dummy_entry").execute(*args, **kwargs)
                def all_zones(self, *args, **kwargs):
                    """
                    Initialize the flow field with the default values.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/all_zones").execute(*args, **kwargs)
                def exhaust_fan(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/exhaust_fan").execute(*args, **kwargs)
                def fan(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/fan").execute(*args, **kwargs)
                def fluid(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/fluid").execute(*args, **kwargs)
                def geometry(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/geometry").execute(*args, **kwargs)
                def inlet_vent(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/inlet_vent").execute(*args, **kwargs)
                def intake_fan(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/intake_fan").execute(*args, **kwargs)
                def interface(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/interface").execute(*args, **kwargs)
                def interior(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/interior").execute(*args, **kwargs)
                def mass_flow_inlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/mass_flow_inlet").execute(*args, **kwargs)
                def mass_flow_outlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/mass_flow_outlet").execute(*args, **kwargs)
                def network(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/network").execute(*args, **kwargs)
                def network_end(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/network_end").execute(*args, **kwargs)
                def outflow(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/outflow").execute(*args, **kwargs)
                def outlet_vent(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/outlet_vent").execute(*args, **kwargs)
                def overset(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/overset").execute(*args, **kwargs)
                def periodic(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/periodic").execute(*args, **kwargs)
                def porous_jump(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/porous_jump").execute(*args, **kwargs)
                def pressure_far_field(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/pressure_far_field").execute(*args, **kwargs)
                def pressure_inlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/pressure_inlet").execute(*args, **kwargs)
                def pressure_outlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/pressure_outlet").execute(*args, **kwargs)
                def radiator(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/radiator").execute(*args, **kwargs)
                def rans_les_interface(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/rans_les_interface").execute(*args, **kwargs)
                def recirculation_inlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/recirculation_inlet").execute(*args, **kwargs)
                def recirculation_outlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/recirculation_outlet").execute(*args, **kwargs)
                def shadow(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/shadow").execute(*args, **kwargs)
                def solid(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/solid").execute(*args, **kwargs)
                def symmetry(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/symmetry").execute(*args, **kwargs)
                def velocity_inlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/velocity_inlet").execute(*args, **kwargs)
                def wall(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solution/initialize/compute_defaults/wall").execute(*args, **kwargs)

            class mp_localized_turb_init(metaclass=PyMenuMeta):
                """
                Localized initialization of turbulent flow variables for VOF/Mixture multiphase flow models.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def enable(self, *args, **kwargs):
                    """
                    Localized initialization of turbulent flow variables for VOF/Mixture multiphase flow models.
                    """
                    return PyMenu(self.service, "/solution/initialize/mp_localized_turb_init/enable").execute(*args, **kwargs)
                def turb_init_parameters(self, *args, **kwargs):
                    """
                    Turbulent flow parameters for localized initialization.
                    """
                    return PyMenu(self.service, "/solution/initialize/mp_localized_turb_init/turb_init_parameters").execute(*args, **kwargs)

            class vof_patch_smooth_options(metaclass=PyMenuMeta):
                """
                Enter the vof patch/smooth options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def set_options(self, *args, **kwargs):
                    """
                    Patch and smoothing options for volume fraction.
                    """
                    return PyMenu(self.service, "/solution/initialize/vof_patch_smooth_options/set_options").execute(*args, **kwargs)
                def execute_smoothing(self, *args, **kwargs):
                    """
                    Execute volumetric smoothing for volume fraction.
                    """
                    return PyMenu(self.service, "/solution/initialize/vof_patch_smooth_options/execute_smoothing").execute(*args, **kwargs)

            class set_fmg_options(metaclass=PyMenuMeta):
                """
                Enter the full-multigrid option menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def viscous_terms(self, *args, **kwargs):
                    """
                    Enable/disable viscous terms during FMG initialization.
                    """
                    return PyMenu(self.service, "/solution/initialize/set_fmg_options/viscous_terms").execute(*args, **kwargs)
                def species_reactions(self, *args, **kwargs):
                    """
                    Enable/disable species volumetric reactions during FMG initialization.
                    """
                    return PyMenu(self.service, "/solution/initialize/set_fmg_options/species_reactions").execute(*args, **kwargs)
                def set_turbulent_viscosity_ratio(self, *args, **kwargs):
                    """
                    Set turbulent viscosity ratio used during FMG initialization.
                    """
                    return PyMenu(self.service, "/solution/initialize/set_fmg_options/set_turbulent_viscosity_ratio").execute(*args, **kwargs)

            class set_hyb_initialization(metaclass=PyMenuMeta):
                """
                Enter the settings for hybrid initialization method.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def general_settings(self, *args, **kwargs):
                    """
                    Enter the general settings menu.
                    """
                    return PyMenu(self.service, "/solution/initialize/set_hyb_initialization/general_settings").execute(*args, **kwargs)
                def turbulent_settings(self, *args, **kwargs):
                    """
                    Enter the turbulent settings menu.
                    """
                    return PyMenu(self.service, "/solution/initialize/set_hyb_initialization/turbulent_settings").execute(*args, **kwargs)
                def species_settings(self, *args, **kwargs):
                    """
                    Enter the species settings menu.
                    """
                    return PyMenu(self.service, "/solution/initialize/set_hyb_initialization/species_settings").execute(*args, **kwargs)

        class methods(metaclass=PyMenuMeta):
            """
            Enter the methods menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.expert = self.__class__.expert(path + [("expert", None)], service)
                self.high_order_term_relaxation = self.__class__.high_order_term_relaxation(path + [("high_order_term_relaxation", None)], service)
                self.multiphase_numerics = self.__class__.multiphase_numerics(path + [("multiphase_numerics", None)], service)
                self.nita_expert_controls = self.__class__.nita_expert_controls(path + [("nita_expert_controls", None)], service)
                self.overset = self.__class__.overset(path + [("overset", None)], service)
                self.pseudo_time_method = self.__class__.pseudo_time_method(path + [("pseudo_time_method", None)], service)
                self.query = self.__class__.query(path + [("query", None)], service)
                self.warped_face_gradient_correction = self.__class__.warped_face_gradient_correction(path + [("warped_face_gradient_correction", None)], service)
            def accelerated_non_iterative_time_marching(self, *args, **kwargs):
                """
                Enable/disable accelerated non-iterative time marching.
                """
                return PyMenu(self.service, "/solution/methods/accelerated_non_iterative_time_marching").execute(*args, **kwargs)
            def convergence_acceleration_for_stretched_meshes(self, *args, **kwargs):
                """
                Enable convergence acceleration for stretched meshes to improve the convergence of the implicit density based solver on meshes with high cell stretching.
                """
                return PyMenu(self.service, "/solution/methods/convergence_acceleration_for_stretched_meshes").execute(*args, **kwargs)
            def discretization_scheme(self, *args, **kwargs):
                """
                Enter the discretization-scheme menu.
                """
                return PyMenu(self.service, "/solution/methods/discretization_scheme").execute(*args, **kwargs)
            def flux_type(self, *args, **kwargs):
                """
                Enter the flux type.
                """
                return PyMenu(self.service, "/solution/methods/flux_type").execute(*args, **kwargs)
            def frozen_flux(self, *args, **kwargs):
                """
                Enable/disable frozen flux formulation for transient flows.
                """
                return PyMenu(self.service, "/solution/methods/frozen_flux").execute(*args, **kwargs)
            def gradient_scheme(self, *args, **kwargs):
                """
                Set gradient options.
                """
                return PyMenu(self.service, "/solution/methods/gradient_scheme").execute(*args, **kwargs)
            def nb_gradient_boundary_option(self, *args, **kwargs):
                """
                Set ggnb options.
                """
                return PyMenu(self.service, "/solution/methods/nb_gradient_boundary_option").execute(*args, **kwargs)
            def noniterative_time_advance(self, *args, **kwargs):
                """
                Enable/disable the noniterative time advancement scheme.
                """
                return PyMenu(self.service, "/solution/methods/noniterative_time_advance").execute(*args, **kwargs)
            def p_v_coupling(self, *args, **kwargs):
                """
                Select the pressure velocity coupling scheme.
                """
                return PyMenu(self.service, "/solution/methods/p_v_coupling").execute(*args, **kwargs)
            def phase_based_vof_discretization(self, *args, **kwargs):
                """
                Set phase based slope limiter for VOF compressive scheme.
                """
                return PyMenu(self.service, "/solution/methods/phase_based_vof_discretization").execute(*args, **kwargs)
            def reduced_rank_extrapolation(self, *args, **kwargs):
                """
                Enable Reduced Rank Extrapolation method to accelerate solution time.
                """
                return PyMenu(self.service, "/solution/methods/reduced_rank_extrapolation").execute(*args, **kwargs)
            def reduced_rank_extrapolation_options(self, *args, **kwargs):
                """
                Reduced Rank Extrapolation options.
                """
                return PyMenu(self.service, "/solution/methods/reduced_rank_extrapolation_options").execute(*args, **kwargs)
            def residual_smoothing(self, *args, **kwargs):
                """
                Set residual smoothing factor and number of iterations.
                """
                return PyMenu(self.service, "/solution/methods/residual_smoothing").execute(*args, **kwargs)
            def set_solution_methods_to_default(self, *args, **kwargs):
                """
                Set solution methods to default values.
                """
                return PyMenu(self.service, "/solution/methods/set_solution_methods_to_default").execute(*args, **kwargs)
            def unsteady_1st_order(self, *args, **kwargs):
                """
                Enable/disable first-order unsteady solution model.
                """
                return PyMenu(self.service, "/solution/methods/unsteady_1st_order").execute(*args, **kwargs)
            def unsteady_2nd_order(self, *args, **kwargs):
                """
                Enable/disable the second-order unsteady solution model.
                """
                return PyMenu(self.service, "/solution/methods/unsteady_2nd_order").execute(*args, **kwargs)
            def unsteady_2nd_order_bounded(self, *args, **kwargs):
                """
                Enable/disable bounded second-order unsteady formulation.
                """
                return PyMenu(self.service, "/solution/methods/unsteady_2nd_order_bounded").execute(*args, **kwargs)
            def unsteady_global_time(self, *args, **kwargs):
                """
                Enable/disable the unsteady global-time-step solution model.
                """
                return PyMenu(self.service, "/solution/methods/unsteady_global_time").execute(*args, **kwargs)
            def vof_numerics(self, *args, **kwargs):
                """
                Set VOF numeric options.
                """
                return PyMenu(self.service, "/solution/methods/vof_numerics").execute(*args, **kwargs)

            class expert(metaclass=PyMenuMeta):
                """
                Enter expert menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def reactions(self, *args, **kwargs):
                    """
                    Enable/disable the species reaction sources and set relaxation factor.
                    """
                    return PyMenu(self.service, "/solution/methods/expert/reactions").execute(*args, **kwargs)
                def numerics(self, *args, **kwargs):
                    """
                    Set numeric options.
                    """
                    return PyMenu(self.service, "/solution/methods/expert/numerics").execute(*args, **kwargs)

            class high_order_term_relaxation(metaclass=PyMenuMeta):
                """
                Enter High Order Relaxation Menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.options = self.__class__.options(path + [("options", None)], service)
                def enable(self, *args, **kwargs):
                    """
                    Enable/Disable High Order Term Relaxation.
                    """
                    return PyMenu(self.service, "/solution/methods/high_order_term_relaxation/enable").execute(*args, **kwargs)

                class options(metaclass=PyMenuMeta):
                    """
                    High Order Term Relaxation Options.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.variables = self.__class__.variables(path + [("variables", None)], service)
                    def relaxation_factor(self, *args, **kwargs):
                        """
                        Sets relaxation factor.
                        """
                        return PyMenu(self.service, "/solution/methods/high_order_term_relaxation/options/relaxation_factor").execute(*args, **kwargs)
                    def expert(self, *args, **kwargs):
                        """
                        Enter high order relaxation option with respect to diffusion gradient.
                        """
                        return PyMenu(self.service, "/solution/methods/high_order_term_relaxation/options/expert").execute(*args, **kwargs)

                    class variables(metaclass=PyMenuMeta):
                        """
                        Select Variables.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def select(self, *args, **kwargs):
                            """
                            Select variables for high order term relaxation.
                            """
                            return PyMenu(self.service, "/solution/methods/high_order_term_relaxation/options/variables/select").execute(*args, **kwargs)

            class multiphase_numerics(metaclass=PyMenuMeta):
                """
                Enter the multiphase numerics options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.porous_media = self.__class__.porous_media(path + [("porous_media", None)], service)
                    self.compressible_flow = self.__class__.compressible_flow(path + [("compressible_flow", None)], service)
                    self.boiling_parameters = self.__class__.boiling_parameters(path + [("boiling_parameters", None)], service)
                    self.viscous_flow = self.__class__.viscous_flow(path + [("viscous_flow", None)], service)
                    self.heat_mass_transfer = self.__class__.heat_mass_transfer(path + [("heat_mass_transfer", None)], service)
                    self.advanced_stability_controls = self.__class__.advanced_stability_controls(path + [("advanced_stability_controls", None)], service)
                    self.default_controls = self.__class__.default_controls(path + [("default_controls", None)], service)
                    self.face_pressure_controls = self.__class__.face_pressure_controls(path + [("face_pressure_controls", None)], service)
                    self.solution_stabilization = self.__class__.solution_stabilization(path + [("solution_stabilization", None)], service)

                class porous_media(metaclass=PyMenuMeta):
                    """
                    Multiphase relative permeability numerics menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def relative_permeability(self, *args, **kwargs):
                        """
                        Multiphase relative permeability fix option.
                        """
                        return PyMenu(self.service, "/solution/methods/multiphase_numerics/porous_media/relative_permeability").execute(*args, **kwargs)

                class compressible_flow(metaclass=PyMenuMeta):
                    """
                    Multiphase compressible numerics options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def enhanced_numerics(self, *args, **kwargs):
                        """
                        Multiphase enhanced compressible flow numerics options.
                        """
                        return PyMenu(self.service, "/solution/methods/multiphase_numerics/compressible_flow/enhanced_numerics").execute(*args, **kwargs)
                    def alternate_bc_formulation(self, *args, **kwargs):
                        """
                        Multiphase compressible flow BC alternate method.
                        """
                        return PyMenu(self.service, "/solution/methods/multiphase_numerics/compressible_flow/alternate_bc_formulation").execute(*args, **kwargs)

                class boiling_parameters(metaclass=PyMenuMeta):
                    """
                    Multiphase boiling parameters menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def thin_film(self, *args, **kwargs):
                        """
                        Multiphase boiling thin film effects.
                        """
                        return PyMenu(self.service, "/solution/methods/multiphase_numerics/boiling_parameters/thin_film").execute(*args, **kwargs)
                    def liquid_vof_factor(self, *args, **kwargs):
                        """
                        Multiphase boiling liquid volume fraction effects.
                        """
                        return PyMenu(self.service, "/solution/methods/multiphase_numerics/boiling_parameters/liquid_vof_factor").execute(*args, **kwargs)

                class viscous_flow(metaclass=PyMenuMeta):
                    """
                    Multiphase viscous flow numerics options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def viscosity_averaging(self, *args, **kwargs):
                        """
                        Multiphase options for viscosity averaging.
                        """
                        return PyMenu(self.service, "/solution/methods/multiphase_numerics/viscous_flow/viscosity_averaging").execute(*args, **kwargs)
                    def turb_visc_based_damping(self, *args, **kwargs):
                        """
                        Turbulence viscosity based damping controls.
                        """
                        return PyMenu(self.service, "/solution/methods/multiphase_numerics/viscous_flow/turb_visc_based_damping").execute(*args, **kwargs)
                    def interfacial_artificial_viscosity(self, *args, **kwargs):
                        """
                        Interfacial artifical viscosity controls.
                        """
                        return PyMenu(self.service, "/solution/methods/multiphase_numerics/viscous_flow/interfacial_artificial_viscosity").execute(*args, **kwargs)

                class heat_mass_transfer(metaclass=PyMenuMeta):
                    """
                    Multiphase interphase heat and mass transfer numerics options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.cavitation = self.__class__.cavitation(path + [("cavitation", None)], service)
                        self.evaporation_condensation = self.__class__.evaporation_condensation(path + [("evaporation_condensation", None)], service)
                        self.boiling = self.__class__.boiling(path + [("boiling", None)], service)
                        self.area_density = self.__class__.area_density(path + [("area_density", None)], service)
                    def alternative_energy_treatment(self, *args, **kwargs):
                        """
                        Alternative treatment of latent heat source due to mass transfer.
                        """
                        return PyMenu(self.service, "/solution/methods/multiphase_numerics/heat_mass_transfer/alternative_energy_treatment").execute(*args, **kwargs)

                    class cavitation(metaclass=PyMenuMeta):
                        """
                        Cavitation numerics options menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def schnerr_evap_coeff(self, *args, **kwargs):
                            """
                            Evaporation coefficient for Schnerr-Sauer model.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/heat_mass_transfer/cavitation/schnerr_evap_coeff").execute(*args, **kwargs)
                        def schnerr_cond_coeff(self, *args, **kwargs):
                            """
                            Condensation coefficient for Schnerr-Sauer model.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/heat_mass_transfer/cavitation/schnerr_cond_coeff").execute(*args, **kwargs)
                        def max_vapor_pressure_ratio(self, *args, **kwargs):
                            """
                            Maximum limit on vapor pressure after turbulence and thermal correction.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/heat_mass_transfer/cavitation/max_vapor_pressure_ratio").execute(*args, **kwargs)
                        def min_vapor_pressure(self, *args, **kwargs):
                            """
                            Minimum vapor pressure limit for cavitation model.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/heat_mass_transfer/cavitation/min_vapor_pressure").execute(*args, **kwargs)
                        def display_clipped_pressure(self, *args, **kwargs):
                            """
                            Clipped pressure is just used for the properties evaluation. Mass Transfer Rate uses unclipped pressure.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/heat_mass_transfer/cavitation/display_clipped_pressure").execute(*args, **kwargs)
                        def turbulent_diffusion(self, *args, **kwargs):
                            """
                            Enable/disable turbulent diffusion treatment between phases participating in cavitation.
                            This treatment is generally recommended for better solution stability.
                            However, in case of numerical difficulties, it can be disabled.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/heat_mass_transfer/cavitation/turbulent_diffusion").execute(*args, **kwargs)

                    class evaporation_condensation(metaclass=PyMenuMeta):
                        """
                        Evaporation-condensation advanced options menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def vof_from_min_limit(self, *args, **kwargs):
                            """
                            Minimum volume fraction below which mass transfer rate is set to zero.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/heat_mass_transfer/evaporation_condensation/vof_from_min_limit").execute(*args, **kwargs)
                        def vof_from_max_limit(self, *args, **kwargs):
                            """
                            Maximum volume fraction above which mass transfer rate is set to zero.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/heat_mass_transfer/evaporation_condensation/vof_from_max_limit").execute(*args, **kwargs)
                        def vof_to_min_limit(self, *args, **kwargs):
                            """
                            Minimum volume fraction below which mass transfer rate is set to zero.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/heat_mass_transfer/evaporation_condensation/vof_to_min_limit").execute(*args, **kwargs)
                        def vof_to_max_limit(self, *args, **kwargs):
                            """
                            Maximum volume fraction above which mass transfer rate is set to zero.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/heat_mass_transfer/evaporation_condensation/vof_to_max_limit").execute(*args, **kwargs)
                        def ia_norm_min_limit(self, *args, **kwargs):
                            """
                            Minimum normalized area density below which mass transfer rate is set to zero.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/heat_mass_transfer/evaporation_condensation/ia_norm_min_limit").execute(*args, **kwargs)
                        def max_rel_humidity(self, *args, **kwargs):
                            """
                            Maximum value of relative humidity to limit condensation rate.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/heat_mass_transfer/evaporation_condensation/max_rel_humidity").execute(*args, **kwargs)

                    class boiling(metaclass=PyMenuMeta):
                        """
                        Boiling advanced options menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def heat_flux_relaxation_factor(self, *args, **kwargs):
                            """
                            Under-relaxation factor for boiling heat flux.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/heat_mass_transfer/boiling/heat_flux_relaxation_factor").execute(*args, **kwargs)
                        def show_expert_options(self, *args, **kwargs):
                            """
                            Exposes expert options of min/max superheat along with wetting fraction controls.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/heat_mass_transfer/boiling/show_expert_options").execute(*args, **kwargs)
                        def two_resistance_boiling_framework(self, *args, **kwargs):
                            """
                            Allow generalized two-resistance framework for boiling model.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/heat_mass_transfer/boiling/two_resistance_boiling_framework").execute(*args, **kwargs)

                    class area_density(metaclass=PyMenuMeta):
                        """
                        Interfacial area density menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def vof_min_seeding(self, *args, **kwargs):
                            """
                            Minimum vof seeding for non-zero area density in heat and mass transfer.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/heat_mass_transfer/area_density/vof_min_seeding").execute(*args, **kwargs)
                        def ia_grad_sym(self, *args, **kwargs):
                            """
                            Interfacial area density gradient-symmetric mechanism.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/heat_mass_transfer/area_density/ia_grad_sym").execute(*args, **kwargs)

                class advanced_stability_controls(metaclass=PyMenuMeta):
                    """
                    Stability controls for multiphase flow.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.pseudo_time = self.__class__.pseudo_time(path + [("pseudo_time", None)], service)
                        self.p_v_coupling = self.__class__.p_v_coupling(path + [("p_v_coupling", None)], service)
                        self.hybrid_nita = self.__class__.hybrid_nita(path + [("hybrid_nita", None)], service)
                        self.equation_order = self.__class__.equation_order(path + [("equation_order", None)], service)
                        self.anti_diffusion = self.__class__.anti_diffusion(path + [("anti_diffusion", None)], service)

                    class pseudo_time(metaclass=PyMenuMeta):
                        """
                        Pseudo-Time stability controls for multiphase flow.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.auto_dt_advanced_controls = self.__class__.auto_dt_advanced_controls(path + [("auto_dt_advanced_controls", None)], service)
                        def smoothed_density_stabilization_method(self, *args, **kwargs):
                            """
                            Set smoothed density stabilization method.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/pseudo_time/smoothed_density_stabilization_method").execute(*args, **kwargs)
                        def false_time_step_linearization(self, *args, **kwargs):
                            """
                            Set false time-step linearization for added stability.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/pseudo_time/false_time_step_linearization").execute(*args, **kwargs)

                        class auto_dt_advanced_controls(metaclass=PyMenuMeta):
                            """
                            Set automatic time-stepping controls for better solution stability.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def enable(self, *args, **kwargs):
                                """
                                Enable advanced automatic time stepping for better stability.
                                """
                                return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/pseudo_time/auto_dt_advanced_controls/enable").execute(*args, **kwargs)
                            def dt_init_limit(self, *args, **kwargs):
                                """
                                Set maximum value for pseudo time step size during first iteration.
                                """
                                return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/pseudo_time/auto_dt_advanced_controls/dt_init_limit").execute(*args, **kwargs)
                            def dt_max(self, *args, **kwargs):
                                """
                                Set maximum value for pseudo time step size.
                                """
                                return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/pseudo_time/auto_dt_advanced_controls/dt_max").execute(*args, **kwargs)
                            def dt_factor_min(self, *args, **kwargs):
                                """
                                Set minimum limit for reduction in pseudo time step size.
                                """
                                return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/pseudo_time/auto_dt_advanced_controls/dt_factor_min").execute(*args, **kwargs)
                            def dt_factor_max(self, *args, **kwargs):
                                """
                                Set maximum limit for increase in pseudo time step size.
                                """
                                return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/pseudo_time/auto_dt_advanced_controls/dt_factor_max").execute(*args, **kwargs)
                            def max_velocity_ratio(self, *args, **kwargs):
                                """
                                Set velocity ratio to freeze the time step size for better solution stability.
                                """
                                return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/pseudo_time/auto_dt_advanced_controls/max_velocity_ratio").execute(*args, **kwargs)

                    class p_v_coupling(metaclass=PyMenuMeta):
                        """
                        Pressure velocity coupling controls for multiphase flow.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.coupled_vof = self.__class__.coupled_vof(path + [("coupled_vof", None)], service)
                            self.rhie_chow_flux = self.__class__.rhie_chow_flux(path + [("rhie_chow_flux", None)], service)
                            self.skewness_correction = self.__class__.skewness_correction(path + [("skewness_correction", None)], service)

                        class coupled_vof(metaclass=PyMenuMeta):
                            """
                            Set Coupled VOF stability controls.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def buoyancy_force_linearization(self, *args, **kwargs):
                                """
                                Set buoynacy force linerization options in coupled vof.
                                """
                                return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/p_v_coupling/coupled_vof/buoyancy_force_linearization").execute(*args, **kwargs)

                        class rhie_chow_flux(metaclass=PyMenuMeta):
                            """
                            Set Rhie-Chow related stability controls.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def low_order_rhie_chow(self, *args, **kwargs):
                                """
                                Use low order velocity interpolation in flux calculation.
                                """
                                return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/p_v_coupling/rhie_chow_flux/low_order_rhie_chow").execute(*args, **kwargs)

                        class skewness_correction(metaclass=PyMenuMeta):
                            """
                            Skewness correction related stabiity controls for multiphase flow.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def limit_pressure_correction_gradient(self, *args, **kwargs):
                                """
                                Use limited pressure correction gradient in skewness corrections for better stability.
                                """
                                return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/p_v_coupling/skewness_correction/limit_pressure_correction_gradient").execute(*args, **kwargs)

                    class hybrid_nita(metaclass=PyMenuMeta):
                        """
                        Hybrid NITA stability controls for multiphase flow.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.instability_detector = self.__class__.instability_detector(path + [("instability_detector", None)], service)
                        def outer_iterations(self, *args, **kwargs):
                            """
                            Set number of outer iterations in hybrid nita.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/hybrid_nita/outer_iterations").execute(*args, **kwargs)
                        def initial_outer_iterations(self, *args, **kwargs):
                            """
                            Set hybrid nita start-up controls.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/hybrid_nita/initial_outer_iterations").execute(*args, **kwargs)

                        class instability_detector(metaclass=PyMenuMeta):
                            """
                            Set Hybrid NITA instability detector controls.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def enable_instability_detector(self, *args, **kwargs):
                                """
                                Enable instability detector for better stability.
                                """
                                return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/enable_instability_detector").execute(*args, **kwargs)
                            def set_cfl_limit(self, *args, **kwargs):
                                """
                                Set Courant Number limit for detection of unstable event.
                                """
                                return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/set_cfl_limit").execute(*args, **kwargs)
                            def set_cfl_type(self, *args, **kwargs):
                                """
                                Set Courant Number type for detection of unstable event.
                                """
                                return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/set_cfl_type").execute(*args, **kwargs)
                            def set_velocity_limit(self, *args, **kwargs):
                                """
                                Set velocity limit for detection of unstable event.
                                """
                                return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/set_velocity_limit").execute(*args, **kwargs)
                            def unstable_event_outer_iterations(self, *args, **kwargs):
                                """
                                Set number of outer iterations for unstable event.
                                """
                                return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/unstable_event_outer_iterations").execute(*args, **kwargs)

                    class equation_order(metaclass=PyMenuMeta):
                        """
                        Equation Order Menu for Homogeneous Multiphase Flow Models.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def solve_flow_last(self, *args, **kwargs):
                            """
                            Solve flow equation at the end of iteration as an alternative.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/equation_order/solve_flow_last").execute(*args, **kwargs)
                        def solve_exp_vof_at_end(self, *args, **kwargs):
                            """
                            Solve Explicit VOF at the end of time-step as an alternative.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/equation_order/solve_exp_vof_at_end").execute(*args, **kwargs)

                    class anti_diffusion(metaclass=PyMenuMeta):
                        """
                        Anti Diffusion Menu for VOF/Multi-Fluid VOF Models.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def enable_dynamic_strength(self, *args, **kwargs):
                            """
                            Enable dynamic strength to reduce compression in the tangential direction to the interface.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/anti_diffusion/enable_dynamic_strength").execute(*args, **kwargs)
                        def set_dynamic_strength_exponent(self, *args, **kwargs):
                            """
                            Set cosine exponent in dynamic strength treatment.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/anti_diffusion/set_dynamic_strength_exponent").execute(*args, **kwargs)
                        def set_maximum_dynamic_strength(self, *args, **kwargs):
                            """
                            Set maximum value of dynamic anti-diffusion strength.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/advanced_stability_controls/anti_diffusion/set_maximum_dynamic_strength").execute(*args, **kwargs)

                class default_controls(metaclass=PyMenuMeta):
                    """
                    Multiphase default controls menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def recommended_defaults_for_existing_cases(self, *args, **kwargs):
                        """
                        Activate multiphase defaults for loaded case.
                        """
                        return PyMenu(self.service, "/solution/methods/multiphase_numerics/default_controls/recommended_defaults_for_existing_cases").execute(*args, **kwargs)
                    def revert_to_pre_r20_point_1_default_settings(self, *args, **kwargs):
                        """
                        Revert to pre-R20.1 multiphase flow default settings.
                        """
                        return PyMenu(self.service, "/solution/methods/multiphase_numerics/default_controls/revert_to_pre_r20_point_1_default_settings").execute(*args, **kwargs)

                class face_pressure_controls(metaclass=PyMenuMeta):
                    """
                    Enter the face pressure expert controls menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def face_pressure_options(self, *args, **kwargs):
                        """
                        Set face pressure options.
                        """
                        return PyMenu(self.service, "/solution/methods/multiphase_numerics/face_pressure_controls/face_pressure_options").execute(*args, **kwargs)

                class solution_stabilization(metaclass=PyMenuMeta):
                    """
                    VOF solution stabilization menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.additional_stabilization_controls = self.__class__.additional_stabilization_controls(path + [("additional_stabilization_controls", None)], service)
                        self.velocity_limiting_treatment = self.__class__.velocity_limiting_treatment(path + [("velocity_limiting_treatment", None)], service)
                    def execute_settings_optimization(self, *args, **kwargs):
                        """
                        Execute optimized settings for VOF.
                        """
                        return PyMenu(self.service, "/solution/methods/multiphase_numerics/solution_stabilization/execute_settings_optimization").execute(*args, **kwargs)
                    def execute_advanced_stabilization(self, *args, **kwargs):
                        """
                        Execute advanced stabilization for VOF.
                        """
                        return PyMenu(self.service, "/solution/methods/multiphase_numerics/solution_stabilization/execute_advanced_stabilization").execute(*args, **kwargs)
                    def execute_additional_stability_controls(self, *args, **kwargs):
                        """
                        Execute additional stability controls for VOF.
                        """
                        return PyMenu(self.service, "/solution/methods/multiphase_numerics/solution_stabilization/execute_additional_stability_controls").execute(*args, **kwargs)

                    class additional_stabilization_controls(metaclass=PyMenuMeta):
                        """
                        Additional advanced stability controls for VOF.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def blended_compressive_scheme(self, *args, **kwargs):
                            """
                            Blended Compressive discretization scheme for VOF.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/solution_stabilization/additional_stabilization_controls/blended_compressive_scheme").execute(*args, **kwargs)
                        def pseudo_time_stabilization(self, *args, **kwargs):
                            """
                            Pseudo-Time Momentum stabilization and False Time Step Linearization methods for VOF.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/solution_stabilization/additional_stabilization_controls/pseudo_time_stabilization").execute(*args, **kwargs)

                    class velocity_limiting_treatment(metaclass=PyMenuMeta):
                        """
                        Velocity limiting related stabiity controls for VOF.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def enable_velocity_limiting(self, *args, **kwargs):
                            """
                            Enable velocity limiting treatment.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/enable_velocity_limiting").execute(*args, **kwargs)
                        def set_velocity_and_vof_cutoffs(self, *args, **kwargs):
                            """
                            Set phase based velocity limiting controls.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_velocity_and_vof_cutoffs").execute(*args, **kwargs)
                        def set_damping_strengths(self, *args, **kwargs):
                            """
                            Set phase based damping strength.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_damping_strengths").execute(*args, **kwargs)
                        def set_velocity_cutoff(self, *args, **kwargs):
                            """
                            Enter max velocity magnitude.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_velocity_cutoff").execute(*args, **kwargs)
                        def set_damping_strength(self, *args, **kwargs):
                            """
                            Enter damping strength.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_damping_strength").execute(*args, **kwargs)
                        def verbosity(self, *args, **kwargs):
                            """
                            Enable verbosity to print number of velocity limited cells during iterations.
                            """
                            return PyMenu(self.service, "/solution/methods/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/verbosity").execute(*args, **kwargs)

            class nita_expert_controls(metaclass=PyMenuMeta):
                """
                Enter the nita expert controls menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def set_verbosity(self, *args, **kwargs):
                    """
                    Set nita verbosity option.
                    """
                    return PyMenu(self.service, "/solution/methods/nita_expert_controls/set_verbosity").execute(*args, **kwargs)
                def skewness_neighbor_coupling(self, *args, **kwargs):
                    """
                    Set skewness neighbor coupling for nita.
                    """
                    return PyMenu(self.service, "/solution/methods/nita_expert_controls/skewness_neighbor_coupling").execute(*args, **kwargs)
                def hybrid_nita_settings(self, *args, **kwargs):
                    """
                    Select a hybrid NITA settings option for faster performance and better robustness.
                    """
                    return PyMenu(self.service, "/solution/methods/nita_expert_controls/hybrid_nita_settings").execute(*args, **kwargs)

            class overset(metaclass=PyMenuMeta):
                """
                Enter overset solver options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.expert = self.__class__.expert(path + [("expert", None)], service)
                def high_order_pressure(self, *args, **kwargs):
                    """
                    High order pressure extrapolation at overset interface.
                    """
                    return PyMenu(self.service, "/solution/methods/overset/high_order_pressure").execute(*args, **kwargs)
                def interpolation_method(self, *args, **kwargs):
                    """
                    Choose the interpolation method for overset interface(s).
                    """
                    return PyMenu(self.service, "/solution/methods/overset/interpolation_method").execute(*args, **kwargs)
                def orphan_cell_treatment(self, *args, **kwargs):
                    """
                    Enable solver to run with orphans present.
                    """
                    return PyMenu(self.service, "/solution/methods/overset/orphan_cell_treatment").execute(*args, **kwargs)

                class expert(metaclass=PyMenuMeta):
                    """
                    Enter overset expert solver options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def mass_flux_correction_method(self, *args, **kwargs):
                        """
                        Enter mass flux correction option at overset interfaces.
                        """
                        return PyMenu(self.service, "/solution/methods/overset/expert/mass_flux_correction_method").execute(*args, **kwargs)
                    def hybrid_mode_selection(self, *args, **kwargs):
                        """
                        Mode for hybrid interpolation.
                        """
                        return PyMenu(self.service, "/solution/methods/overset/expert/hybrid_mode_selection").execute(*args, **kwargs)

            class pseudo_time_method(metaclass=PyMenuMeta):
                """
                Enter the pseudo time method menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def formulation(self, *args, **kwargs):
                    """
                    Select the pseudo time step size formulation for the pseudo time method.
                    """
                    return PyMenu(self.service, "/solution/methods/pseudo_time_method/formulation").execute(*args, **kwargs)
                def local_time_step_settings(self, *args, **kwargs):
                    """
                    Adjust the settings for the local time step formulation.
                    """
                    return PyMenu(self.service, "/solution/methods/pseudo_time_method/local_time_step_settings").execute(*args, **kwargs)
                def global_time_step_settings(self, *args, **kwargs):
                    """
                    Adjust the settings for the global time step formulation.
                    """
                    return PyMenu(self.service, "/solution/methods/pseudo_time_method/global_time_step_settings").execute(*args, **kwargs)
                def advanced_options(self, *args, **kwargs):
                    """
                    Enter the advanced options menu to define pseudo time settings for equations.
                    """
                    return PyMenu(self.service, "/solution/methods/pseudo_time_method/advanced_options").execute(*args, **kwargs)
                def relaxation_factors(self, *args, **kwargs):
                    """
                    Enter the relaxation factors menu to set the pseudo time explicit relaxation factors for equations.
                    """
                    return PyMenu(self.service, "/solution/methods/pseudo_time_method/relaxation_factors").execute(*args, **kwargs)
                def relaxation_method(self, *args, **kwargs):
                    """
                    Select relaxation definition for pseudo time method.
                    """
                    return PyMenu(self.service, "/solution/methods/pseudo_time_method/relaxation_method").execute(*args, **kwargs)
                def relaxation_bounds(self, *args, **kwargs):
                    """
                    Select relaxation bounding scheme for pseudo time method.
                    """
                    return PyMenu(self.service, "/solution/methods/pseudo_time_method/relaxation_bounds").execute(*args, **kwargs)
                def verbosity(self, *args, **kwargs):
                    """
                    Set the verbosity for the pseudo time method.
                    """
                    return PyMenu(self.service, "/solution/methods/pseudo_time_method/verbosity").execute(*args, **kwargs)

            class query(metaclass=PyMenuMeta):
                """
                Enter methods query menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def discretization_scheme(self, *args, **kwargs):
                    """
                    Enter the discretization-scheme menu.
                    """
                    return PyMenu(self.service, "/solution/methods/query/discretization_scheme").execute(*args, **kwargs)
                def p_v_coupling(self, *args, **kwargs):
                    """
                    Get the pressure velocity coupling scheme.
                    """
                    return PyMenu(self.service, "/solution/methods/query/p_v_coupling").execute(*args, **kwargs)

            class warped_face_gradient_correction(metaclass=PyMenuMeta):
                """
                Enter warped-face-gradient-correction menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def enable(self, *args, **kwargs):
                    """
                    Enable Warped-Face Gradient Correction.
                    """
                    return PyMenu(self.service, "/solution/methods/warped_face_gradient_correction/enable").execute(*args, **kwargs)
                def turbulence_options(self, *args, **kwargs):
                    """
                    Set turbulence Warped Face Gradient Correction.
                    """
                    return PyMenu(self.service, "/solution/methods/warped_face_gradient_correction/turbulence_options").execute(*args, **kwargs)

        class monitors(metaclass=PyMenuMeta):
            """
            Enter the monitors menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self._ = self.__class__._(path + [("_", None)], service)
                self.__ = self.__class__.__(path + [("__", None)], service)
                self.report_files = self.__class__.report_files(path + [("report_files", None)], service)
                self.report_plots = self.__class__.report_plots(path + [("report_plots", None)], service)
                self.residual = self.__class__.residual(path + [("residual", None)], service)
            def convergence_conditions(self, *args, **kwargs):
                """
                Manage convergence report.
                """
                return PyMenu(self.service, "/solution/monitors/convergence_conditions").execute(*args, **kwargs)
            def set_average_over(self, *args, **kwargs):
                """
                Set the average over input for monitors.
                """
                return PyMenu(self.service, "/solution/monitors/set_average_over").execute(*args, **kwargs)

            class _(metaclass=PyMenuMeta):
                """
                Enter the convergence menu to add surface, volume, drag, lift and moment monitors to convergence criteria.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def add_edit(self, *args, **kwargs):
                    """
                    Add or edit convergence criterion for surface, volume, drag, lift and moment monitors.
                    """
                    return PyMenu(self.service, "/solution/monitors/_/add_edit").execute(*args, **kwargs)
                def frequency(self, *args, **kwargs):
                    """
                    To set how often convergence checks are done with respect to iterations or time steps.
                    """
                    return PyMenu(self.service, "/solution/monitors/_/frequency").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    List defined convergence criteria for monitors.
                    """
                    return PyMenu(self.service, "/solution/monitors/_/list").execute(*args, **kwargs)
                def condition(self, *args, **kwargs):
                    """
                    Option to stop the calculations. All convergence conditions are met or any convergence condition is met.
                    """
                    return PyMenu(self.service, "/solution/monitors/_/condition").execute(*args, **kwargs)
                def average_over_last_n_iterations_timesteps(self, *args, **kwargs):
                    """
                    Option to average over previous values for checking convergence.
                    """
                    return PyMenu(self.service, "/solution/monitors/_/average_over_last_n_iterations_timesteps").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete a monitor from convergence criteria.
                    """
                    return PyMenu(self.service, "/solution/monitors/_/delete").execute(*args, **kwargs)

            class __(metaclass=PyMenuMeta):
                """
                Enter the statistic monitors menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def monitors(self, *args, **kwargs):
                    """
                    Choose which statistics to monitor as printed and/or plotted output.
                    """
                    return PyMenu(self.service, "/solution/monitors/__/monitors").execute(*args, **kwargs)
                def plot(self, *args, **kwargs):
                    """
                    Enable/disable plotting of statistics during iteration.
                    """
                    return PyMenu(self.service, "/solution/monitors/__/plot").execute(*args, **kwargs)
                def print(self, *args, **kwargs):
                    """
                    Enable/disable printing of statistics during iteration.
                    """
                    return PyMenu(self.service, "/solution/monitors/__/print").execute(*args, **kwargs)
                def write(self, *args, **kwargs):
                    """
                    Enable/disable writing of statistics during iteration.
                    """
                    return PyMenu(self.service, "/solution/monitors/__/write").execute(*args, **kwargs)
                def window(self, *args, **kwargs):
                    """
                    Specify first window in which statistics will be plotted during iteration.
                    Multiple statistics are plotted in separate windows, beginning with this one.
                    """
                    return PyMenu(self.service, "/solution/monitors/__/window").execute(*args, **kwargs)
                def file_basename(self, *args, **kwargs):
                    """
                    Specify the file basename and extension. The name of the individual monitor will be insterted automatically.
                    """
                    return PyMenu(self.service, "/solution/monitors/__/file_basename").execute(*args, **kwargs)
                def x_axis(self, *args, **kwargs):
                    """
                    Choose what quantity to use on the abscissa in the plot and in the data written to files.
                    """
                    return PyMenu(self.service, "/solution/monitors/__/x_axis").execute(*args, **kwargs)

            class report_files(metaclass=PyMenuMeta):
                """
                Manage report files.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def add(self, *args, **kwargs):
                    """
                    Add a new object.
                    """
                    return PyMenu(self.service, "/solution/monitors/report_files/add").execute(*args, **kwargs)
                def clear_data(self, *args, **kwargs):
                    """
                    Delete the report file from the system.
                    """
                    return PyMenu(self.service, "/solution/monitors/report_files/clear_data").execute(*args, **kwargs)
                def delete_all(self, *args, **kwargs):
                    """
                    Delete all report file objects.
                    """
                    return PyMenu(self.service, "/solution/monitors/report_files/delete_all").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit an object.
                    """
                    return PyMenu(self.service, "/solution/monitors/report_files/edit").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete an object.
                    """
                    return PyMenu(self.service, "/solution/monitors/report_files/delete").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    List objects.
                    """
                    return PyMenu(self.service, "/solution/monitors/report_files/list").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    List properties of an object.
                    """
                    return PyMenu(self.service, "/solution/monitors/report_files/list_properties").execute(*args, **kwargs)

            class report_plots(metaclass=PyMenuMeta):
                """
                Manage report plots.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def add(self, *args, **kwargs):
                    """
                    Add a new object.
                    """
                    return PyMenu(self.service, "/solution/monitors/report_plots/add").execute(*args, **kwargs)
                def axes(self, *args, **kwargs):
                    """
                    Set axes options of an object.
                    """
                    return PyMenu(self.service, "/solution/monitors/report_plots/axes").execute(*args, **kwargs)
                def clear_data(self, *args, **kwargs):
                    """
                    Clear report plot data.
                    """
                    return PyMenu(self.service, "/solution/monitors/report_plots/clear_data").execute(*args, **kwargs)
                def curves(self, *args, **kwargs):
                    """
                    Set curves options of an object.
                    """
                    return PyMenu(self.service, "/solution/monitors/report_plots/curves").execute(*args, **kwargs)
                def delete_all(self, *args, **kwargs):
                    """
                    Delete all plot objects.
                    """
                    return PyMenu(self.service, "/solution/monitors/report_plots/delete_all").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit an object.
                    """
                    return PyMenu(self.service, "/solution/monitors/report_plots/edit").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete an object.
                    """
                    return PyMenu(self.service, "/solution/monitors/report_plots/delete").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    List objects.
                    """
                    return PyMenu(self.service, "/solution/monitors/report_plots/list").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    List properties of an object.
                    """
                    return PyMenu(self.service, "/solution/monitors/report_plots/list_properties").execute(*args, **kwargs)
                def plot(self, *args, **kwargs):
                    """
                    Plot.
                    """
                    return PyMenu(self.service, "/solution/monitors/report_plots/plot").execute(*args, **kwargs)

            class residual(metaclass=PyMenuMeta):
                """
                Enter the residual monitors menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def check_convergence(self, *args, **kwargs):
                    """
                    Choose which currently-monitored residuals
                    should be checked for convergence.
                    """
                    return PyMenu(self.service, "/solution/monitors/residual/check_convergence").execute(*args, **kwargs)
                def convergence_criteria(self, *args, **kwargs):
                    """
                    Set convergence criteria for residuals which are
                    currently being both monitored and checked.
                    """
                    return PyMenu(self.service, "/solution/monitors/residual/convergence_criteria").execute(*args, **kwargs)
                def criterion_type(self, *args, **kwargs):
                    """
                    Set convergence criterion type.
                    """
                    return PyMenu(self.service, "/solution/monitors/residual/criterion_type").execute(*args, **kwargs)
                def monitor(self, *args, **kwargs):
                    """
                    Choose which residuals to monitor as printed and/or plotted output.
                    """
                    return PyMenu(self.service, "/solution/monitors/residual/monitor").execute(*args, **kwargs)
                def enhanced_continuity_residual(self, *args, **kwargs):
                    """
                    Scale the continuity residuals locally based on the enhanced formulation.
                    """
                    return PyMenu(self.service, "/solution/monitors/residual/enhanced_continuity_residual").execute(*args, **kwargs)
                def n_display(self, *args, **kwargs):
                    """
                    Set the number of most recent residuals to display in plots.
                    """
                    return PyMenu(self.service, "/solution/monitors/residual/n_display").execute(*args, **kwargs)
                def n_maximize_norms(self, *args, **kwargs):
                    """
                    Set the number of iterations through which normalization
                    factors will be maximized.
                    """
                    return PyMenu(self.service, "/solution/monitors/residual/n_maximize_norms").execute(*args, **kwargs)
                def normalization_factors(self, *args, **kwargs):
                    """
                    Set normalization factors for currently-monitored residuals.
                    """
                    return PyMenu(self.service, "/solution/monitors/residual/normalization_factors").execute(*args, **kwargs)
                def normalize(self, *args, **kwargs):
                    """
                    Choose whether or not to normalize residuals in printed and plotted output.
                    """
                    return PyMenu(self.service, "/solution/monitors/residual/normalize").execute(*args, **kwargs)
                def n_save(self, *args, **kwargs):
                    """
                    Set number of residuals to be saved with data.
                    History is automatically compacted when buffer becomes full.
                    """
                    return PyMenu(self.service, "/solution/monitors/residual/n_save").execute(*args, **kwargs)
                def plot(self, *args, **kwargs):
                    """
                    Choose whether or not residuals will be plotted during iteration.
                    """
                    return PyMenu(self.service, "/solution/monitors/residual/plot").execute(*args, **kwargs)
                def print(self, *args, **kwargs):
                    """
                    Choose whether or not residuals will be printed during iteration.
                    """
                    return PyMenu(self.service, "/solution/monitors/residual/print").execute(*args, **kwargs)
                def relative_conv_criteria(self, *args, **kwargs):
                    """
                    Set relative convergence criteria for residuals which are
                    currently being both monitored and checked.
                    """
                    return PyMenu(self.service, "/solution/monitors/residual/relative_conv_criteria").execute(*args, **kwargs)
                def re_normalize(self, *args, **kwargs):
                    """
                    Renormalize residuals by maximum values.
                    """
                    return PyMenu(self.service, "/solution/monitors/residual/re_normalize").execute(*args, **kwargs)
                def reset(self, *args, **kwargs):
                    """
                    Delete the residual history and reset iteration counter to unity.
                    """
                    return PyMenu(self.service, "/solution/monitors/residual/reset").execute(*args, **kwargs)
                def scale_by_coefficient(self, *args, **kwargs):
                    """
                    Enable/disable scaling of residuals by coefficient sum in printed and plotted output.
                    """
                    return PyMenu(self.service, "/solution/monitors/residual/scale_by_coefficient").execute(*args, **kwargs)

        class report_definitions(metaclass=PyMenuMeta):
            """
            Manage report definitions.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def add(self, *args, **kwargs):
                """
                Add a new object.
                """
                return PyMenu(self.service, "/solution/report_definitions/add").execute(*args, **kwargs)
            def compute(self, *args, **kwargs):
                """
                Computes selected report definition.
                """
                return PyMenu(self.service, "/solution/report_definitions/compute").execute(*args, **kwargs)
            def copy(self, *args, **kwargs):
                """
                Makes a copy of selected report definition with new name.
                """
                return PyMenu(self.service, "/solution/report_definitions/copy").execute(*args, **kwargs)
            def delete_all(self, *args, **kwargs):
                """
                Delete all report definition objects.
                """
                return PyMenu(self.service, "/solution/report_definitions/delete_all").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an object.
                """
                return PyMenu(self.service, "/solution/report_definitions/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an object.
                """
                return PyMenu(self.service, "/solution/report_definitions/delete").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List objects.
                """
                return PyMenu(self.service, "/solution/report_definitions/list").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                List properties of an object.
                """
                return PyMenu(self.service, "/solution/report_definitions/list_properties").execute(*args, **kwargs)
            def rename(self, *args, **kwargs):
                """
                Rename selected report definition with new name.
                """
                return PyMenu(self.service, "/solution/report_definitions/rename").execute(*args, **kwargs)

        class run_calculation(metaclass=PyMenuMeta):
            """
            Enter run calculation menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.data_sampling_options = self.__class__.data_sampling_options(path + [("data_sampling_options", None)], service)
                self.transient_controls = self.__class__.transient_controls(path + [("transient_controls", None)], service)
            def adaptive_time_stepping(self, *args, **kwargs):
                """
                Set Error-based adaptive time-stepping parameters.
                """
                return PyMenu(self.service, "/solution/run_calculation/adaptive_time_stepping").execute(*args, **kwargs)
            def cfl_based_adaptive_time_stepping(self, *args, **kwargs):
                """
                Set CFL-based adaptive time-stepping parameters.
                """
                return PyMenu(self.service, "/solution/run_calculation/cfl_based_adaptive_time_stepping").execute(*args, **kwargs)
            def data_sampling(self, *args, **kwargs):
                """
                Set iteration options.
                """
                return PyMenu(self.service, "/solution/run_calculation/data_sampling").execute(*args, **kwargs)
            def dual_time_iterate(self, *args, **kwargs):
                """
                Perform unsteady iterations.
                """
                return PyMenu(self.service, "/solution/run_calculation/dual_time_iterate").execute(*args, **kwargs)
            def iterate(self, *args, **kwargs):
                """
                Perform a specified number of iterations.
                """
                return PyMenu(self.service, "/solution/run_calculation/iterate").execute(*args, **kwargs)
            def max_corrections(self, *args, **kwargs):
                """
                Enter the max-corrections menu.
                """
                return PyMenu(self.service, "/solution/run_calculation/max_corrections").execute(*args, **kwargs)
            def mesh_motion(self, *args, **kwargs):
                """
                Perform mesh motion.
                """
                return PyMenu(self.service, "/solution/run_calculation/mesh_motion").execute(*args, **kwargs)
            def multistage_time_iterate(self, *args, **kwargs):
                """
                Perform unsteady iterations.
                """
                return PyMenu(self.service, "/solution/run_calculation/multistage_time_iterate").execute(*args, **kwargs)
            def number_of_iterations(self, *args, **kwargs):
                """
                Set number of iterations.
                """
                return PyMenu(self.service, "/solution/run_calculation/number_of_iterations").execute(*args, **kwargs)
            def reporting_interval(self, *args, **kwargs):
                """
                Set number of solver iterations before returning to scheme.
                """
                return PyMenu(self.service, "/solution/run_calculation/reporting_interval").execute(*args, **kwargs)
            def residual_tolerance(self, *args, **kwargs):
                """
                Enter the residual tolerance menu.
                """
                return PyMenu(self.service, "/solution/run_calculation/residual_tolerance").execute(*args, **kwargs)
            def residual_verbosity(self, *args, **kwargs):
                """
                Set the residual report verbosity.
                """
                return PyMenu(self.service, "/solution/run_calculation/residual_verbosity").execute(*args, **kwargs)
            def second_order_time_options(self, *args, **kwargs):
                """
                Set options for second-order time formulation.
                """
                return PyMenu(self.service, "/solution/run_calculation/second_order_time_options").execute(*args, **kwargs)
            def solution_steering(self, *args, **kwargs):
                """
                Enable solution steering for density-based solver.
                """
                return PyMenu(self.service, "/solution/run_calculation/solution_steering").execute(*args, **kwargs)
            def set_solution_steering(self, *args, **kwargs):
                """
                Set Solution Steering Parameters.
                """
                return PyMenu(self.service, "/solution/run_calculation/set_solution_steering").execute(*args, **kwargs)
            def summary(self, *args, **kwargs):
                """
                Print report summary.
                """
                return PyMenu(self.service, "/solution/run_calculation/summary").execute(*args, **kwargs)
            def time_step(self, *args, **kwargs):
                """
                Set the time step.
                """
                return PyMenu(self.service, "/solution/run_calculation/time_step").execute(*args, **kwargs)
            def update_physical_time(self, *args, **kwargs):
                """
                Update the solution to the next physical time level.
                """
                return PyMenu(self.service, "/solution/run_calculation/update_physical_time").execute(*args, **kwargs)
            def variable_time_stepping(self, *args, **kwargs):
                """
                Set Multiphase-Specific Adaptive time stepping parameters.
                """
                return PyMenu(self.service, "/solution/run_calculation/variable_time_stepping").execute(*args, **kwargs)

            class data_sampling_options(metaclass=PyMenuMeta):
                """
                Data sampling options for statistics.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def add_datasets(self, *args, **kwargs):
                    """
                    Add a dataset. After providing the zones for a dataset, press [Enter] to move onto selecting quantities. Enter () to complete the quantity selection for this dataset.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/data_sampling_options/add_datasets").execute(*args, **kwargs)
                def add_rtdft_datasets(self, *args, **kwargs):
                    """
                    Add a dataset. After providing the zones for a dataset, press [Enter] to move onto selecting quantities. Enter () to complete the quantity selection for this dataset.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/data_sampling_options/add_rtdft_datasets").execute(*args, **kwargs)
                def remove_dataset(self, *args, **kwargs):
                    """
                    Remove dataset.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/data_sampling_options/remove_dataset").execute(*args, **kwargs)
                def list_datasets(self, *args, **kwargs):
                    """
                    List dataset.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/data_sampling_options/list_datasets").execute(*args, **kwargs)

            class transient_controls(metaclass=PyMenuMeta):
                """
                Enter into the transient controls menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.multiphase_specific_time_constraints = self.__class__.multiphase_specific_time_constraints(path + [("multiphase_specific_time_constraints", None)], service)
                def specified_time_step(self, *args, **kwargs):
                    """
                    Use specified time step or courant number.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/specified_time_step").execute(*args, **kwargs)
                def fixed_user_specified(self, *args, **kwargs):
                    """
                    Enable user-specified fixed time stepping method.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/fixed_user_specified").execute(*args, **kwargs)
                def fixed_periodic(self, *args, **kwargs):
                    """
                    Set period- or frequency-based fixed time-stepping parameters.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/fixed_periodic").execute(*args, **kwargs)
                def duration_specification_method(self, *args, **kwargs):
                    """
                    Set Duration Specification Method: [0] Incremental Time Steps, [1] Total Time Steps, [2] Total Time, [3] Incremental Time.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/duration_specification_method").execute(*args, **kwargs)
                def incremental_time(self, *args, **kwargs):
                    """
                    Set Incremental Time.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/incremental_time").execute(*args, **kwargs)
                def max_iterations_per_time_step(self, *args, **kwargs):
                    """
                    Set Max Iterations/Time step.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/max_iterations_per_time_step").execute(*args, **kwargs)
                def number_of_time_steps(self, *args, **kwargs):
                    """
                    Set inceremtal number of Time steps.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/number_of_time_steps").execute(*args, **kwargs)
                def total_number_of_time_steps(self, *args, **kwargs):
                    """
                    Set total number of Time steps.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/total_number_of_time_steps").execute(*args, **kwargs)
                def total_time(self, *args, **kwargs):
                    """
                    Set Total Simulation Time.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/total_time").execute(*args, **kwargs)
                def time_step_size(self, *args, **kwargs):
                    """
                    Set the physical time step size.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/time_step_size").execute(*args, **kwargs)
                def solution_status(self, *args, **kwargs):
                    """
                    Activate the simulation status panel.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/solution_status").execute(*args, **kwargs)
                def extrapolate_vars(self, *args, **kwargs):
                    """
                    Applies a predictor algorithm for computing initial condition at time step n+1.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/extrapolate_vars").execute(*args, **kwargs)
                def extrapolate_eqn_vars(self, *args, **kwargs):
                    """
                    Enter the extrapolation menu.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/extrapolate_eqn_vars").execute(*args, **kwargs)
                def max_flow_time(self, *args, **kwargs):
                    """
                    Set maximum flow time.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/max_flow_time").execute(*args, **kwargs)
                def cfl_based_time_stepping_advanced_options(self, *args, **kwargs):
                    """
                    Set CFL-based adaptive time-stepping advanced parameters.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/cfl_based_time_stepping_advanced_options").execute(*args, **kwargs)
                def cfl_based_time_stepping(self, *args, **kwargs):
                    """
                    Set CFL-based adaptive time-stepping parameters.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/cfl_based_time_stepping").execute(*args, **kwargs)
                def multiphase_specific_time_stepping(self, *args, **kwargs):
                    """
                    Set Multiphase-specific adaptive time stepping parameters.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/multiphase_specific_time_stepping").execute(*args, **kwargs)
                def udf_based_time_stepping(self, *args, **kwargs):
                    """
                    Set the time-stepping parameters for user-defined time stepping method.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/udf_based_time_stepping").execute(*args, **kwargs)
                def error_based_time_stepping(self, *args, **kwargs):
                    """
                    Set Error-based adaptive time-stepping parameters.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/error_based_time_stepping").execute(*args, **kwargs)
                def undo_timestep(self, *args, **kwargs):
                    """
                    Undo the previous time step.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/undo_timestep").execute(*args, **kwargs)
                def predict_next_time(self, *args, **kwargs):
                    """
                    Applies a predictor algorithm for computing initial condition at time step n+1.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/predict_next_time").execute(*args, **kwargs)
                def rotating_mesh_flow_predictor(self, *args, **kwargs):
                    """
                    Improve prediction of flow field at time step n+1 for rotating mesh.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/rotating_mesh_flow_predictor").execute(*args, **kwargs)
                def solid_time_step_size(self, *args, **kwargs):
                    """
                    Specify a different time step size for solid zones.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/solid_time_step_size").execute(*args, **kwargs)
                def time_step_size_for_acoustic_export(self, *args, **kwargs):
                    """
                    Set number of time step size for acoustic export.
                    """
                    return PyMenu(self.service, "/solution/run_calculation/transient_controls/time_step_size_for_acoustic_export").execute(*args, **kwargs)

                class multiphase_specific_time_constraints(metaclass=PyMenuMeta):
                    """
                    Set Multiphase-specific time constraints.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.time_scale_options = self.__class__.time_scale_options(path + [("time_scale_options", None)], service)
                    def moving_mesh_cfl_constraint(self, *args, **kwargs):
                        """
                        Enable time step size constraints based on moving mesh courant number.
                        """
                        return PyMenu(self.service, "/solution/run_calculation/transient_controls/multiphase_specific_time_constraints/moving_mesh_cfl_constraint").execute(*args, **kwargs)
                    def physics_based_constraint(self, *args, **kwargs):
                        """
                        Include physics driven time-step constraints.
                        """
                        return PyMenu(self.service, "/solution/run_calculation/transient_controls/multiphase_specific_time_constraints/physics_based_constraint").execute(*args, **kwargs)
                    def verbosity(self, *args, **kwargs):
                        """
                        Set verbosity to print multiphase specific time scales.
                        """
                        return PyMenu(self.service, "/solution/run_calculation/transient_controls/multiphase_specific_time_constraints/verbosity").execute(*args, **kwargs)

                    class time_scale_options(metaclass=PyMenuMeta):
                        """
                        Set physics based time scale options.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def viscous_scale(self, *args, **kwargs):
                            """
                            Include viscous time scale.
                            """
                            return PyMenu(self.service, "/solution/run_calculation/transient_controls/multiphase_specific_time_constraints/time_scale_options/viscous_scale").execute(*args, **kwargs)
                        def gravity_scale(self, *args, **kwargs):
                            """
                            Include gravity based time scale.
                            """
                            return PyMenu(self.service, "/solution/run_calculation/transient_controls/multiphase_specific_time_constraints/time_scale_options/gravity_scale").execute(*args, **kwargs)
                        def surface_tension_scale(self, *args, **kwargs):
                            """
                            Include surface tension based time scale.
                            """
                            return PyMenu(self.service, "/solution/run_calculation/transient_controls/multiphase_specific_time_constraints/time_scale_options/surface_tension_scale").execute(*args, **kwargs)
                        def acoustic_scale(self, *args, **kwargs):
                            """
                            Include acoustic time scale.
                            """
                            return PyMenu(self.service, "/solution/run_calculation/transient_controls/multiphase_specific_time_constraints/time_scale_options/acoustic_scale").execute(*args, **kwargs)

    class solve(metaclass=PyMenuMeta):
        """
        Enter the solve menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
            self.animate = self.__class__.animate(path + [("animate", None)], service)
            self.initialize = self.__class__.initialize(path + [("initialize", None)], service)
            self.monitors = self.__class__.monitors(path + [("monitors", None)], service)
            self.report_files = self.__class__.report_files(path + [("report_files", None)], service)
            self.report_definitions = self.__class__.report_definitions(path + [("report_definitions", None)], service)
            self.report_plots = self.__class__.report_plots(path + [("report_plots", None)], service)
            self.cell_registers = self.__class__.cell_registers(path + [("cell_registers", None)], service)
            self.cell_register_operations = self.__class__.cell_register_operations(path + [("cell_register_operations", None)], service)
            self.set = self.__class__.set(path + [("set", None)], service)
            self.execute_commands = self.__class__.execute_commands(path + [("execute_commands", None)], service)
        def patch(self, *args, **kwargs):
            """
            Patch a value for a flow variable in the domain.
            """
            return PyMenu(self.service, "/solve/patch").execute(*args, **kwargs)
        def iterate(self, *args, **kwargs):
            """
            Perform a specified number of iterations.
            """
            return PyMenu(self.service, "/solve/iterate").execute(*args, **kwargs)
        def iterate_steady_2way_fsi(self, *args, **kwargs):
            """
            Perform a specified number of steps.
            """
            return PyMenu(self.service, "/solve/iterate_steady_2way_fsi").execute(*args, **kwargs)
        def convergence_conditions(self, *args, **kwargs):
            """
            Manage convergence report.
            """
            return PyMenu(self.service, "/solve/convergence_conditions").execute(*args, **kwargs)
        def dpm_update(self, *args, **kwargs):
            """
            Update discrete phase source terms.
            """
            return PyMenu(self.service, "/solve/dpm_update").execute(*args, **kwargs)
        def dual_time_iterate(self, *args, **kwargs):
            """
            Perform unsteady iterations.
            """
            return PyMenu(self.service, "/solve/dual_time_iterate").execute(*args, **kwargs)
        def multistage_time_iterate(self, *args, **kwargs):
            """
            Perform unsteady iterations.
            """
            return PyMenu(self.service, "/solve/multistage_time_iterate").execute(*args, **kwargs)
        def update_physical_time(self, *args, **kwargs):
            """
            Update the solution to the next physical time level.
            """
            return PyMenu(self.service, "/solve/update_physical_time").execute(*args, **kwargs)
        def mesh_motion(self, *args, **kwargs):
            """
            Perform mesh motion.
            """
            return PyMenu(self.service, "/solve/mesh_motion").execute(*args, **kwargs)

        class animate(metaclass=PyMenuMeta):
            """
            Enter the animation menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.define = self.__class__.define(path + [("define", None)], service)
                self.playback = self.__class__.playback(path + [("playback", None)], service)
                self.objects = self.__class__.objects(path + [("objects", None)], service)
                self.pulse = self.__class__.pulse(path + [("pulse", None)], service)

            class define(metaclass=PyMenuMeta):
                """
                Enter the animation definition menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def define_monitor(self, *args, **kwargs):
                    """
                    Define new animation.
                    """
                    return PyMenu(self.service, "/solve/animate/define/define_monitor").execute(*args, **kwargs)
                def edit_monitor(self, *args, **kwargs):
                    """
                    Change animation monitor attributes.
                    """
                    return PyMenu(self.service, "/solve/animate/define/edit_monitor").execute(*args, **kwargs)

            class playback(metaclass=PyMenuMeta):
                """
                Enter animation playback menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.video = self.__class__.video(path + [("video", None)], service)
                def read(self, *args, **kwargs):
                    """
                    Read new animation from file or already-defined animations.
                    """
                    return PyMenu(self.service, "/solve/animate/playback/read").execute(*args, **kwargs)
                def play(self, *args, **kwargs):
                    """
                    Play the selected animation.
                    """
                    return PyMenu(self.service, "/solve/animate/playback/play").execute(*args, **kwargs)
                def write(self, *args, **kwargs):
                    """
                    Write animation sequence to the file.
                    """
                    return PyMenu(self.service, "/solve/animate/playback/write").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete animation sequence.
                    """
                    return PyMenu(self.service, "/solve/animate/playback/delete").execute(*args, **kwargs)
                def stored_view(self, *args, **kwargs):
                    """
                    Play the 3D animation sequence using the view stored in the sequence.
                    """
                    return PyMenu(self.service, "/solve/animate/playback/stored_view").execute(*args, **kwargs)
                def set_custom_frames(self, *args, **kwargs):
                    """
                    Set custom frames start, end, skip frames for video export.
                    """
                    return PyMenu(self.service, "/solve/animate/playback/set_custom_frames").execute(*args, **kwargs)

                class video(metaclass=PyMenuMeta):
                    """
                    Set options for exporting video file menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.advance_quality = self.__class__.advance_quality(path + [("advance_quality", None)], service)
                    def fps(self, *args, **kwargs):
                        """
                        Set the Frame Per Sec(FPS) for exporting video file.
                        """
                        return PyMenu(self.service, "/solve/animate/playback/video/fps").execute(*args, **kwargs)
                    def format(self, *args, **kwargs):
                        """
                        Set format for exporting video file.
                        """
                        return PyMenu(self.service, "/solve/animate/playback/video/format").execute(*args, **kwargs)
                    def quality(self, *args, **kwargs):
                        """
                        Set quality for exporting video file.
                        """
                        return PyMenu(self.service, "/solve/animate/playback/video/quality").execute(*args, **kwargs)
                    def name(self, *args, **kwargs):
                        """
                        Exporting video file name.
                        """
                        return PyMenu(self.service, "/solve/animate/playback/video/name").execute(*args, **kwargs)
                    def use_original_resolution(self, *args, **kwargs):
                        """
                        Enable original resolution.
                        """
                        return PyMenu(self.service, "/solve/animate/playback/video/use_original_resolution").execute(*args, **kwargs)
                    def scale(self, *args, **kwargs):
                        """
                        Set scale by which video resolution will expand.
                        """
                        return PyMenu(self.service, "/solve/animate/playback/video/scale").execute(*args, **kwargs)
                    def set_standard_resolution(self, *args, **kwargs):
                        """
                        Select from pre-defined resolution list.
                        """
                        return PyMenu(self.service, "/solve/animate/playback/video/set_standard_resolution").execute(*args, **kwargs)
                    def width(self, *args, **kwargs):
                        """
                        Set the width for exporting video file.
                        """
                        return PyMenu(self.service, "/solve/animate/playback/video/width").execute(*args, **kwargs)
                    def height(self, *args, **kwargs):
                        """
                        Set the height for exporting video file.
                        """
                        return PyMenu(self.service, "/solve/animate/playback/video/height").execute(*args, **kwargs)

                    class advance_quality(metaclass=PyMenuMeta):
                        """
                        Advance Quality setting.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def bitrate_scale(self, *args, **kwargs):
                            """
                            Mp4 bitrate scale - Best-64000 High-32000 Medium-16000 Low-8000.
                            """
                            return PyMenu(self.service, "/solve/animate/playback/video/advance_quality/bitrate_scale").execute(*args, **kwargs)
                        def enable_h264(self, *args, **kwargs):
                            """
                            H264 encoding flag.
                            """
                            return PyMenu(self.service, "/solve/animate/playback/video/advance_quality/enable_h264").execute(*args, **kwargs)
                        def bitrate(self, *args, **kwargs):
                            """
                            Set video bitrate(kbits/sec) for exporting video file.
                            """
                            return PyMenu(self.service, "/solve/animate/playback/video/advance_quality/bitrate").execute(*args, **kwargs)
                        def compression_method(self, *args, **kwargs):
                            """
                            Compression methode for Microsoft AVI movie.
                            """
                            return PyMenu(self.service, "/solve/animate/playback/video/advance_quality/compression_method").execute(*args, **kwargs)
                        def keyframe(self, *args, **kwargs):
                            """
                            Set video keyframe rate for exporting video file.
                            """
                            return PyMenu(self.service, "/solve/animate/playback/video/advance_quality/keyframe").execute(*args, **kwargs)

            class objects(metaclass=PyMenuMeta):
                """
                Enter to define, edit, delete solution animation objects.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def create(self, *args, **kwargs):
                    """
                    Create new graphics object.
                    """
                    return PyMenu(self.service, "/solve/animate/objects/create").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit graphics object.
                    """
                    return PyMenu(self.service, "/solve/animate/objects/edit").execute(*args, **kwargs)
                def copy(self, *args, **kwargs):
                    """
                    Copy graphics object.
                    """
                    return PyMenu(self.service, "/solve/animate/objects/copy").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete graphics object.
                    """
                    return PyMenu(self.service, "/solve/animate/objects/delete").execute(*args, **kwargs)
                def clear_history(self, *args, **kwargs):
                    """
                    Clear object history.
                    """
                    return PyMenu(self.service, "/solve/animate/objects/clear_history").execute(*args, **kwargs)

            class pulse(metaclass=PyMenuMeta):
                """
                Enter save pulse menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.video = self.__class__.video(path + [("video", None)], service)
                    self.hardcopy = self.__class__.hardcopy(path + [("hardcopy", None)], service)
                def pulse_mode(self, *args, **kwargs):
                    """
                    Set pulse-mode.
                    """
                    return PyMenu(self.service, "/solve/animate/pulse/pulse_mode").execute(*args, **kwargs)
                def write(self, *args, **kwargs):
                    """
                    Exporting pulse.
                    """
                    return PyMenu(self.service, "/solve/animate/pulse/write").execute(*args, **kwargs)

                class video(metaclass=PyMenuMeta):
                    """
                    Enter the video window options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.advance_quality = self.__class__.advance_quality(path + [("advance_quality", None)], service)
                    def fps(self, *args, **kwargs):
                        """
                        Set the Frame Per Sec(FPS) for exporting video file.
                        """
                        return PyMenu(self.service, "/solve/animate/pulse/video/fps").execute(*args, **kwargs)
                    def format(self, *args, **kwargs):
                        """
                        Set format for exporting video file.
                        """
                        return PyMenu(self.service, "/solve/animate/pulse/video/format").execute(*args, **kwargs)
                    def quality(self, *args, **kwargs):
                        """
                        Set quality for exporting video file.
                        """
                        return PyMenu(self.service, "/solve/animate/pulse/video/quality").execute(*args, **kwargs)
                    def name(self, *args, **kwargs):
                        """
                        Exporting video file name.
                        """
                        return PyMenu(self.service, "/solve/animate/pulse/video/name").execute(*args, **kwargs)
                    def use_original_resolution(self, *args, **kwargs):
                        """
                        Enable original resolution.
                        """
                        return PyMenu(self.service, "/solve/animate/pulse/video/use_original_resolution").execute(*args, **kwargs)
                    def scale(self, *args, **kwargs):
                        """
                        Set scale by which video resolution will expand.
                        """
                        return PyMenu(self.service, "/solve/animate/pulse/video/scale").execute(*args, **kwargs)
                    def set_standard_resolution(self, *args, **kwargs):
                        """
                        Select from pre-defined resolution list.
                        """
                        return PyMenu(self.service, "/solve/animate/pulse/video/set_standard_resolution").execute(*args, **kwargs)
                    def width(self, *args, **kwargs):
                        """
                        Set the width for exporting video file.
                        """
                        return PyMenu(self.service, "/solve/animate/pulse/video/width").execute(*args, **kwargs)
                    def height(self, *args, **kwargs):
                        """
                        Set the height for exporting video file.
                        """
                        return PyMenu(self.service, "/solve/animate/pulse/video/height").execute(*args, **kwargs)

                    class advance_quality(metaclass=PyMenuMeta):
                        """
                        Advance Quality setting.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def bitrate_scale(self, *args, **kwargs):
                            """
                            Mp4 bitrate scale - Best-64000 High-32000 Medium-16000 Low-8000.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/video/advance_quality/bitrate_scale").execute(*args, **kwargs)
                        def enable_h264(self, *args, **kwargs):
                            """
                            H264 encoding flag.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/video/advance_quality/enable_h264").execute(*args, **kwargs)
                        def bitrate(self, *args, **kwargs):
                            """
                            Set video bitrate(kbits/sec) for exporting video file.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/video/advance_quality/bitrate").execute(*args, **kwargs)
                        def compression_method(self, *args, **kwargs):
                            """
                            Compression methode for Microsoft AVI movie.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/video/advance_quality/compression_method").execute(*args, **kwargs)
                        def keyframe(self, *args, **kwargs):
                            """
                            Set video keyframe rate for exporting video file.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/video/advance_quality/keyframe").execute(*args, **kwargs)

                class hardcopy(metaclass=PyMenuMeta):
                    """
                    Hardcopy options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.color_mode = self.__class__.color_mode(path + [("color_mode", None)], service)
                        self.driver = self.__class__.driver(path + [("driver", None)], service)
                    def invert_background(self, *args, **kwargs):
                        """
                        Use a white background when the picture is saved.
                        """
                        return PyMenu(self.service, "/solve/animate/pulse/hardcopy/invert_background").execute(*args, **kwargs)
                    def landscape(self, *args, **kwargs):
                        """
                        Plot hardcopies in landscape or portrait orientation.
                        """
                        return PyMenu(self.service, "/solve/animate/pulse/hardcopy/landscape").execute(*args, **kwargs)
                    def preview(self, *args, **kwargs):
                        """
                        Display a preview image of a hardcopy.
                        """
                        return PyMenu(self.service, "/solve/animate/pulse/hardcopy/preview").execute(*args, **kwargs)
                    def x_resolution(self, *args, **kwargs):
                        """
                        Set the width of raster-formatted images in pixels (0 implies current window size).
                        """
                        return PyMenu(self.service, "/solve/animate/pulse/hardcopy/x_resolution").execute(*args, **kwargs)
                    def y_resolution(self, *args, **kwargs):
                        """
                        Set the height of raster-formatted images in pixels (0 implies current window size).
                        """
                        return PyMenu(self.service, "/solve/animate/pulse/hardcopy/y_resolution").execute(*args, **kwargs)
                    def dpi(self, *args, **kwargs):
                        """
                        Set the DPI for EPS and Postscript files, specifies the resolution in dots per inch (DPI) instead of setting the width and height.
                        """
                        return PyMenu(self.service, "/solve/animate/pulse/hardcopy/dpi").execute(*args, **kwargs)
                    def use_window_resolution(self, *args, **kwargs):
                        """
                        Use the currently active window's resolution for hardcopy (ignores the x-resolution and y-resolution in this case).
                        """
                        return PyMenu(self.service, "/solve/animate/pulse/hardcopy/use_window_resolution").execute(*args, **kwargs)
                    def set_standard_resolution(self, *args, **kwargs):
                        """
                        Select from pre-defined resolution list.
                        """
                        return PyMenu(self.service, "/solve/animate/pulse/hardcopy/set_standard_resolution").execute(*args, **kwargs)
                    def jpeg_hardcopy_quality(self, *args, **kwargs):
                        """
                        To set jpeg hardcopy quality.
                        """
                        return PyMenu(self.service, "/solve/animate/pulse/hardcopy/jpeg_hardcopy_quality").execute(*args, **kwargs)

                    class color_mode(metaclass=PyMenuMeta):
                        """
                        Enter the hardcopy color mode menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def color(self, *args, **kwargs):
                            """
                            Plot hardcopies in color.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/hardcopy/color_mode/color").execute(*args, **kwargs)
                        def gray_scale(self, *args, **kwargs):
                            """
                            Convert color to grayscale for hardcopy.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/hardcopy/color_mode/gray_scale").execute(*args, **kwargs)
                        def mono_chrome(self, *args, **kwargs):
                            """
                            Convert color to monochrome (black and white) for hardcopy.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/hardcopy/color_mode/mono_chrome").execute(*args, **kwargs)
                        def list(self, *args, **kwargs):
                            """
                            Display the current hardcopy color mode.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/hardcopy/color_mode/list").execute(*args, **kwargs)

                    class driver(metaclass=PyMenuMeta):
                        """
                        Enter the set hardcopy driver menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.post_format = self.__class__.post_format(path + [("post_format", None)], service)
                        def dump_window(self, *args, **kwargs):
                            """
                            Set the command used to dump the graphics window to a file.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/hardcopy/driver/dump_window").execute(*args, **kwargs)
                        def eps(self, *args, **kwargs):
                            """
                            Produce encapsulated PostScript (EPS) output for hardcopies.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/hardcopy/driver/eps").execute(*args, **kwargs)
                        def jpeg(self, *args, **kwargs):
                            """
                            Produce JPEG output for hardcopies.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/hardcopy/driver/jpeg").execute(*args, **kwargs)
                        def post_script(self, *args, **kwargs):
                            """
                            Produce PostScript output for hardcopies.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/hardcopy/driver/post_script").execute(*args, **kwargs)
                        def ppm(self, *args, **kwargs):
                            """
                            Produce PPM output for hardcopies.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/hardcopy/driver/ppm").execute(*args, **kwargs)
                        def tiff(self, *args, **kwargs):
                            """
                            Use TIFF output for hardcopies.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/hardcopy/driver/tiff").execute(*args, **kwargs)
                        def png(self, *args, **kwargs):
                            """
                            Use PNG output for hardcopies.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/hardcopy/driver/png").execute(*args, **kwargs)
                        def hsf(self, *args, **kwargs):
                            """
                            Use HSF output for hardcopies.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/hardcopy/driver/hsf").execute(*args, **kwargs)
                        def avz(self, *args, **kwargs):
                            """
                            Use AVZ output for hardcopies.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/hardcopy/driver/avz").execute(*args, **kwargs)
                        def glb(self, *args, **kwargs):
                            """
                            Use GLB output for hardcopies.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/hardcopy/driver/glb").execute(*args, **kwargs)
                        def vrml(self, *args, **kwargs):
                            """
                            Use VRML output for hardcopies.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/hardcopy/driver/vrml").execute(*args, **kwargs)
                        def list(self, *args, **kwargs):
                            """
                            List the current hardcopy driver.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/hardcopy/driver/list").execute(*args, **kwargs)
                        def options(self, *args, **kwargs):
                            """
                            Set the hardcopy options. Available options are:
                            \\n               	"no gamma correction", disables gamma correction of colors,
                            \\n               	"physical size = (width,height)", where width and height
                                      are the actual measurements of the printable area of the page
                                      in centimeters.
                            \\n               	"subscreen = (left,right,bottom,top)", where left,right,
                                      bottom, and top are numbers in [-1,1] describing a subwindow on
                                      the page in which to place the hardcopy.
                            
                            \\n          The options may be combined by separating them with commas.
                            """
                            return PyMenu(self.service, "/solve/animate/pulse/hardcopy/driver/options").execute(*args, **kwargs)

                        class post_format(metaclass=PyMenuMeta):
                            """
                            Enter the PostScript driver format menu.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def fast_raster(self, *args, **kwargs):
                                """
                                Use the new raster format.
                                """
                                return PyMenu(self.service, "/solve/animate/pulse/hardcopy/driver/post_format/fast_raster").execute(*args, **kwargs)
                            def raster(self, *args, **kwargs):
                                """
                                Use the original raster format.
                                """
                                return PyMenu(self.service, "/solve/animate/pulse/hardcopy/driver/post_format/raster").execute(*args, **kwargs)
                            def rle_raster(self, *args, **kwargs):
                                """
                                Use the run-length encoded raster format.
                                """
                                return PyMenu(self.service, "/solve/animate/pulse/hardcopy/driver/post_format/rle_raster").execute(*args, **kwargs)
                            def vector(self, *args, **kwargs):
                                """
                                Use vector format.
                                """
                                return PyMenu(self.service, "/solve/animate/pulse/hardcopy/driver/post_format/vector").execute(*args, **kwargs)

        class initialize(metaclass=PyMenuMeta):
            """
            Enter the flow initialization menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.compute_defaults = self.__class__.compute_defaults(path + [("compute_defaults", None)], service)
                self.mp_localized_turb_init = self.__class__.mp_localized_turb_init(path + [("mp_localized_turb_init", None)], service)
                self.vof_patch_smooth_options = self.__class__.vof_patch_smooth_options(path + [("vof_patch_smooth_options", None)], service)
                self.set_fmg_options = self.__class__.set_fmg_options(path + [("set_fmg_options", None)], service)
                self.set_hyb_initialization = self.__class__.set_hyb_initialization(path + [("set_hyb_initialization", None)], service)
            def open_channel_auto_init(self, *args, **kwargs):
                """
                Open channel automatic initialization.
                """
                return PyMenu(self.service, "/solve/initialize/open_channel_auto_init").execute(*args, **kwargs)
            def levelset_auto_init(self, *args, **kwargs):
                """
                Levelset function automatic initialization.
                """
                return PyMenu(self.service, "/solve/initialize/levelset_auto_init").execute(*args, **kwargs)
            def dpm_reset(self, *args, **kwargs):
                """
                Reset discrete phase source terms to zero.
                """
                return PyMenu(self.service, "/solve/initialize/dpm_reset").execute(*args, **kwargs)
            def lwf_initialization(self, *args, **kwargs):
                """
                Delete wall film particles and initialize wall film variables to zero.
                """
                return PyMenu(self.service, "/solve/initialize/lwf_initialization").execute(*args, **kwargs)
            def initialize_flow(self, *args, **kwargs):
                """
                Initialize the flow field with the current default values.
                """
                return PyMenu(self.service, "/solve/initialize/initialize_flow").execute(*args, **kwargs)
            def init_acoustics_options(self, *args, **kwargs):
                """
                Specify number of timesteps for ramping of sources
                and initialize acoustics model variables.
                During ramping the sound sources are multiplied by a factor smoothly growing from 0 to 1.
                """
                return PyMenu(self.service, "/solve/initialize/init_acoustics_options").execute(*args, **kwargs)
            def hyb_initialization(self, *args, **kwargs):
                """
                Initialize using the hybrid initialization method.
                """
                return PyMenu(self.service, "/solve/initialize/hyb_initialization").execute(*args, **kwargs)
            def init_flow_statistics(self, *args, **kwargs):
                """
                Initialize statistics.
                """
                return PyMenu(self.service, "/solve/initialize/init_flow_statistics").execute(*args, **kwargs)
            def patch(self, *args, **kwargs):
                """
                Patch a value for a flow variable in the domain.
                """
                return PyMenu(self.service, "/solve/initialize/patch").execute(*args, **kwargs)
            def show_time_sampled(self, *args, **kwargs):
                """
                Display the amount of simulated time covered by the data sampled for unsteady statistics.
                """
                return PyMenu(self.service, "/solve/initialize/show_time_sampled").execute(*args, **kwargs)
            def show_iterations_sampled(self, *args, **kwargs):
                """
                Display the amount of simulated iterations covered by the data sampled for steady statistics.
                """
                return PyMenu(self.service, "/solve/initialize/show_iterations_sampled").execute(*args, **kwargs)
            def init_turb_vel_fluctuations(self, *args, **kwargs):
                """
                Initialize turbulent velocity fluctuations.
                """
                return PyMenu(self.service, "/solve/initialize/init_turb_vel_fluctuations").execute(*args, **kwargs)
            def fmg_initialization(self, *args, **kwargs):
                """
                Initialize using the full-multigrid initialization (FMG).
                """
                return PyMenu(self.service, "/solve/initialize/fmg_initialization").execute(*args, **kwargs)
            def repair_wall_distance(self, *args, **kwargs):
                """
                Correct wall distance at very high aspect ratio hexahedral/polyhedral cells.
                """
                return PyMenu(self.service, "/solve/initialize/repair_wall_distance").execute(*args, **kwargs)
            def set_defaults(self, *args, **kwargs):
                """
                Enter the set defaults menu.
                """
                return PyMenu(self.service, "/solve/initialize/set_defaults").execute(*args, **kwargs)
            def set_fmg_initialization(self, *args, **kwargs):
                """
                Enter the set full-multigrid for initialization menu.
                """
                return PyMenu(self.service, "/solve/initialize/set_fmg_initialization").execute(*args, **kwargs)
            def list_defaults(self, *args, **kwargs):
                """
                List default values.
                """
                return PyMenu(self.service, "/solve/initialize/list_defaults").execute(*args, **kwargs)
            def reference_frame(self, *args, **kwargs):
                """
                Set reference frame absolute or relative.
                """
                return PyMenu(self.service, "/solve/initialize/reference_frame").execute(*args, **kwargs)

            class compute_defaults(metaclass=PyMenuMeta):
                """
                Enter the compute defaults menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def axis(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/axis").execute(*args, **kwargs)
                def degassing(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/degassing").execute(*args, **kwargs)
                def dummy_entry(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/dummy_entry").execute(*args, **kwargs)
                def all_zones(self, *args, **kwargs):
                    """
                    Initialize the flow field with the default values.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/all_zones").execute(*args, **kwargs)
                def exhaust_fan(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/exhaust_fan").execute(*args, **kwargs)
                def fan(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/fan").execute(*args, **kwargs)
                def fluid(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/fluid").execute(*args, **kwargs)
                def geometry(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/geometry").execute(*args, **kwargs)
                def inlet_vent(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/inlet_vent").execute(*args, **kwargs)
                def intake_fan(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/intake_fan").execute(*args, **kwargs)
                def interface(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/interface").execute(*args, **kwargs)
                def interior(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/interior").execute(*args, **kwargs)
                def mass_flow_inlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/mass_flow_inlet").execute(*args, **kwargs)
                def mass_flow_outlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/mass_flow_outlet").execute(*args, **kwargs)
                def network(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/network").execute(*args, **kwargs)
                def network_end(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/network_end").execute(*args, **kwargs)
                def outflow(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/outflow").execute(*args, **kwargs)
                def outlet_vent(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/outlet_vent").execute(*args, **kwargs)
                def overset(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/overset").execute(*args, **kwargs)
                def periodic(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/periodic").execute(*args, **kwargs)
                def porous_jump(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/porous_jump").execute(*args, **kwargs)
                def pressure_far_field(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/pressure_far_field").execute(*args, **kwargs)
                def pressure_inlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/pressure_inlet").execute(*args, **kwargs)
                def pressure_outlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/pressure_outlet").execute(*args, **kwargs)
                def radiator(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/radiator").execute(*args, **kwargs)
                def rans_les_interface(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/rans_les_interface").execute(*args, **kwargs)
                def recirculation_inlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/recirculation_inlet").execute(*args, **kwargs)
                def recirculation_outlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/recirculation_outlet").execute(*args, **kwargs)
                def shadow(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/shadow").execute(*args, **kwargs)
                def solid(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/solid").execute(*args, **kwargs)
                def symmetry(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/symmetry").execute(*args, **kwargs)
                def velocity_inlet(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/velocity_inlet").execute(*args, **kwargs)
                def wall(self, *args, **kwargs):
                    """
                    Compute flow-initialization defaults from a zone of this type.
                    """
                    return PyMenu(self.service, "/solve/initialize/compute_defaults/wall").execute(*args, **kwargs)

            class mp_localized_turb_init(metaclass=PyMenuMeta):
                """
                Localized initialization of turbulent flow variables for VOF/Mixture multiphase flow models.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def enable(self, *args, **kwargs):
                    """
                    Localized initialization of turbulent flow variables for VOF/Mixture multiphase flow models.
                    """
                    return PyMenu(self.service, "/solve/initialize/mp_localized_turb_init/enable").execute(*args, **kwargs)
                def turb_init_parameters(self, *args, **kwargs):
                    """
                    Turbulent flow parameters for localized initialization.
                    """
                    return PyMenu(self.service, "/solve/initialize/mp_localized_turb_init/turb_init_parameters").execute(*args, **kwargs)

            class vof_patch_smooth_options(metaclass=PyMenuMeta):
                """
                Enter the vof patch/smooth options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def set_options(self, *args, **kwargs):
                    """
                    Patch and smoothing options for volume fraction.
                    """
                    return PyMenu(self.service, "/solve/initialize/vof_patch_smooth_options/set_options").execute(*args, **kwargs)
                def execute_smoothing(self, *args, **kwargs):
                    """
                    Execute volumetric smoothing for volume fraction.
                    """
                    return PyMenu(self.service, "/solve/initialize/vof_patch_smooth_options/execute_smoothing").execute(*args, **kwargs)

            class set_fmg_options(metaclass=PyMenuMeta):
                """
                Enter the full-multigrid option menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def viscous_terms(self, *args, **kwargs):
                    """
                    Enable/disable viscous terms during FMG initialization.
                    """
                    return PyMenu(self.service, "/solve/initialize/set_fmg_options/viscous_terms").execute(*args, **kwargs)
                def species_reactions(self, *args, **kwargs):
                    """
                    Enable/disable species volumetric reactions during FMG initialization.
                    """
                    return PyMenu(self.service, "/solve/initialize/set_fmg_options/species_reactions").execute(*args, **kwargs)
                def set_turbulent_viscosity_ratio(self, *args, **kwargs):
                    """
                    Set turbulent viscosity ratio used during FMG initialization.
                    """
                    return PyMenu(self.service, "/solve/initialize/set_fmg_options/set_turbulent_viscosity_ratio").execute(*args, **kwargs)

            class set_hyb_initialization(metaclass=PyMenuMeta):
                """
                Enter the settings for hybrid initialization method.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def general_settings(self, *args, **kwargs):
                    """
                    Enter the general settings menu.
                    """
                    return PyMenu(self.service, "/solve/initialize/set_hyb_initialization/general_settings").execute(*args, **kwargs)
                def turbulent_settings(self, *args, **kwargs):
                    """
                    Enter the turbulent settings menu.
                    """
                    return PyMenu(self.service, "/solve/initialize/set_hyb_initialization/turbulent_settings").execute(*args, **kwargs)
                def species_settings(self, *args, **kwargs):
                    """
                    Enter the species settings menu.
                    """
                    return PyMenu(self.service, "/solve/initialize/set_hyb_initialization/species_settings").execute(*args, **kwargs)

        class monitors(metaclass=PyMenuMeta):
            """
            Enter the monitors menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self._ = self.__class__._(path + [("_", None)], service)
                self.__ = self.__class__.__(path + [("__", None)], service)
                self.report_files = self.__class__.report_files(path + [("report_files", None)], service)
                self.report_plots = self.__class__.report_plots(path + [("report_plots", None)], service)
                self.residual = self.__class__.residual(path + [("residual", None)], service)
            def convergence_conditions(self, *args, **kwargs):
                """
                Manage convergence report.
                """
                return PyMenu(self.service, "/solve/monitors/convergence_conditions").execute(*args, **kwargs)
            def set_average_over(self, *args, **kwargs):
                """
                Set the average over input for monitors.
                """
                return PyMenu(self.service, "/solve/monitors/set_average_over").execute(*args, **kwargs)

            class _(metaclass=PyMenuMeta):
                """
                Enter the convergence menu to add surface, volume, drag, lift and moment monitors to convergence criteria.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def add_edit(self, *args, **kwargs):
                    """
                    Add or edit convergence criterion for surface, volume, drag, lift and moment monitors.
                    """
                    return PyMenu(self.service, "/solve/monitors/_/add_edit").execute(*args, **kwargs)
                def frequency(self, *args, **kwargs):
                    """
                    To set how often convergence checks are done with respect to iterations or time steps.
                    """
                    return PyMenu(self.service, "/solve/monitors/_/frequency").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    List defined convergence criteria for monitors.
                    """
                    return PyMenu(self.service, "/solve/monitors/_/list").execute(*args, **kwargs)
                def condition(self, *args, **kwargs):
                    """
                    Option to stop the calculations. All convergence conditions are met or any convergence condition is met.
                    """
                    return PyMenu(self.service, "/solve/monitors/_/condition").execute(*args, **kwargs)
                def average_over_last_n_iterations_timesteps(self, *args, **kwargs):
                    """
                    Option to average over previous values for checking convergence.
                    """
                    return PyMenu(self.service, "/solve/monitors/_/average_over_last_n_iterations_timesteps").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete a monitor from convergence criteria.
                    """
                    return PyMenu(self.service, "/solve/monitors/_/delete").execute(*args, **kwargs)

            class __(metaclass=PyMenuMeta):
                """
                Enter the statistic monitors menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def monitors(self, *args, **kwargs):
                    """
                    Choose which statistics to monitor as printed and/or plotted output.
                    """
                    return PyMenu(self.service, "/solve/monitors/__/monitors").execute(*args, **kwargs)
                def plot(self, *args, **kwargs):
                    """
                    Enable/disable plotting of statistics during iteration.
                    """
                    return PyMenu(self.service, "/solve/monitors/__/plot").execute(*args, **kwargs)
                def print(self, *args, **kwargs):
                    """
                    Enable/disable printing of statistics during iteration.
                    """
                    return PyMenu(self.service, "/solve/monitors/__/print").execute(*args, **kwargs)
                def write(self, *args, **kwargs):
                    """
                    Enable/disable writing of statistics during iteration.
                    """
                    return PyMenu(self.service, "/solve/monitors/__/write").execute(*args, **kwargs)
                def window(self, *args, **kwargs):
                    """
                    Specify first window in which statistics will be plotted during iteration.
                    Multiple statistics are plotted in separate windows, beginning with this one.
                    """
                    return PyMenu(self.service, "/solve/monitors/__/window").execute(*args, **kwargs)
                def file_basename(self, *args, **kwargs):
                    """
                    Specify the file basename and extension. The name of the individual monitor will be insterted automatically.
                    """
                    return PyMenu(self.service, "/solve/monitors/__/file_basename").execute(*args, **kwargs)
                def x_axis(self, *args, **kwargs):
                    """
                    Choose what quantity to use on the abscissa in the plot and in the data written to files.
                    """
                    return PyMenu(self.service, "/solve/monitors/__/x_axis").execute(*args, **kwargs)

            class report_files(metaclass=PyMenuMeta):
                """
                Manage report files.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def add(self, *args, **kwargs):
                    """
                    Add a new object.
                    """
                    return PyMenu(self.service, "/solve/monitors/report_files/add").execute(*args, **kwargs)
                def clear_data(self, *args, **kwargs):
                    """
                    Delete the report file from the system.
                    """
                    return PyMenu(self.service, "/solve/monitors/report_files/clear_data").execute(*args, **kwargs)
                def delete_all(self, *args, **kwargs):
                    """
                    Delete all report file objects.
                    """
                    return PyMenu(self.service, "/solve/monitors/report_files/delete_all").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit an object.
                    """
                    return PyMenu(self.service, "/solve/monitors/report_files/edit").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete an object.
                    """
                    return PyMenu(self.service, "/solve/monitors/report_files/delete").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    List objects.
                    """
                    return PyMenu(self.service, "/solve/monitors/report_files/list").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    List properties of an object.
                    """
                    return PyMenu(self.service, "/solve/monitors/report_files/list_properties").execute(*args, **kwargs)

            class report_plots(metaclass=PyMenuMeta):
                """
                Manage report plots.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def add(self, *args, **kwargs):
                    """
                    Add a new object.
                    """
                    return PyMenu(self.service, "/solve/monitors/report_plots/add").execute(*args, **kwargs)
                def axes(self, *args, **kwargs):
                    """
                    Set axes options of an object.
                    """
                    return PyMenu(self.service, "/solve/monitors/report_plots/axes").execute(*args, **kwargs)
                def clear_data(self, *args, **kwargs):
                    """
                    Clear report plot data.
                    """
                    return PyMenu(self.service, "/solve/monitors/report_plots/clear_data").execute(*args, **kwargs)
                def curves(self, *args, **kwargs):
                    """
                    Set curves options of an object.
                    """
                    return PyMenu(self.service, "/solve/monitors/report_plots/curves").execute(*args, **kwargs)
                def delete_all(self, *args, **kwargs):
                    """
                    Delete all plot objects.
                    """
                    return PyMenu(self.service, "/solve/monitors/report_plots/delete_all").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit an object.
                    """
                    return PyMenu(self.service, "/solve/monitors/report_plots/edit").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete an object.
                    """
                    return PyMenu(self.service, "/solve/monitors/report_plots/delete").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    List objects.
                    """
                    return PyMenu(self.service, "/solve/monitors/report_plots/list").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    List properties of an object.
                    """
                    return PyMenu(self.service, "/solve/monitors/report_plots/list_properties").execute(*args, **kwargs)
                def plot(self, *args, **kwargs):
                    """
                    Plot.
                    """
                    return PyMenu(self.service, "/solve/monitors/report_plots/plot").execute(*args, **kwargs)

            class residual(metaclass=PyMenuMeta):
                """
                Enter the residual monitors menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def check_convergence(self, *args, **kwargs):
                    """
                    Choose which currently-monitored residuals
                    should be checked for convergence.
                    """
                    return PyMenu(self.service, "/solve/monitors/residual/check_convergence").execute(*args, **kwargs)
                def convergence_criteria(self, *args, **kwargs):
                    """
                    Set convergence criteria for residuals which are
                    currently being both monitored and checked.
                    """
                    return PyMenu(self.service, "/solve/monitors/residual/convergence_criteria").execute(*args, **kwargs)
                def criterion_type(self, *args, **kwargs):
                    """
                    Set convergence criterion type.
                    """
                    return PyMenu(self.service, "/solve/monitors/residual/criterion_type").execute(*args, **kwargs)
                def monitor(self, *args, **kwargs):
                    """
                    Choose which residuals to monitor as printed and/or plotted output.
                    """
                    return PyMenu(self.service, "/solve/monitors/residual/monitor").execute(*args, **kwargs)
                def enhanced_continuity_residual(self, *args, **kwargs):
                    """
                    Scale the continuity residuals locally based on the enhanced formulation.
                    """
                    return PyMenu(self.service, "/solve/monitors/residual/enhanced_continuity_residual").execute(*args, **kwargs)
                def n_display(self, *args, **kwargs):
                    """
                    Set the number of most recent residuals to display in plots.
                    """
                    return PyMenu(self.service, "/solve/monitors/residual/n_display").execute(*args, **kwargs)
                def n_maximize_norms(self, *args, **kwargs):
                    """
                    Set the number of iterations through which normalization
                    factors will be maximized.
                    """
                    return PyMenu(self.service, "/solve/monitors/residual/n_maximize_norms").execute(*args, **kwargs)
                def normalization_factors(self, *args, **kwargs):
                    """
                    Set normalization factors for currently-monitored residuals.
                    """
                    return PyMenu(self.service, "/solve/monitors/residual/normalization_factors").execute(*args, **kwargs)
                def normalize(self, *args, **kwargs):
                    """
                    Choose whether or not to normalize residuals in printed and plotted output.
                    """
                    return PyMenu(self.service, "/solve/monitors/residual/normalize").execute(*args, **kwargs)
                def n_save(self, *args, **kwargs):
                    """
                    Set number of residuals to be saved with data.
                    History is automatically compacted when buffer becomes full.
                    """
                    return PyMenu(self.service, "/solve/monitors/residual/n_save").execute(*args, **kwargs)
                def plot(self, *args, **kwargs):
                    """
                    Choose whether or not residuals will be plotted during iteration.
                    """
                    return PyMenu(self.service, "/solve/monitors/residual/plot").execute(*args, **kwargs)
                def print(self, *args, **kwargs):
                    """
                    Choose whether or not residuals will be printed during iteration.
                    """
                    return PyMenu(self.service, "/solve/monitors/residual/print").execute(*args, **kwargs)
                def relative_conv_criteria(self, *args, **kwargs):
                    """
                    Set relative convergence criteria for residuals which are
                    currently being both monitored and checked.
                    """
                    return PyMenu(self.service, "/solve/monitors/residual/relative_conv_criteria").execute(*args, **kwargs)
                def re_normalize(self, *args, **kwargs):
                    """
                    Renormalize residuals by maximum values.
                    """
                    return PyMenu(self.service, "/solve/monitors/residual/re_normalize").execute(*args, **kwargs)
                def reset(self, *args, **kwargs):
                    """
                    Delete the residual history and reset iteration counter to unity.
                    """
                    return PyMenu(self.service, "/solve/monitors/residual/reset").execute(*args, **kwargs)
                def scale_by_coefficient(self, *args, **kwargs):
                    """
                    Enable/disable scaling of residuals by coefficient sum in printed and plotted output.
                    """
                    return PyMenu(self.service, "/solve/monitors/residual/scale_by_coefficient").execute(*args, **kwargs)

        class report_files(metaclass=PyMenuMeta):
            """
            Manage report files.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def add(self, *args, **kwargs):
                """
                Add a new object.
                """
                return PyMenu(self.service, "/solve/report_files/add").execute(*args, **kwargs)
            def clear_data(self, *args, **kwargs):
                """
                Delete the report file from the system.
                """
                return PyMenu(self.service, "/solve/report_files/clear_data").execute(*args, **kwargs)
            def delete_all(self, *args, **kwargs):
                """
                Delete all report file objects.
                """
                return PyMenu(self.service, "/solve/report_files/delete_all").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an object.
                """
                return PyMenu(self.service, "/solve/report_files/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an object.
                """
                return PyMenu(self.service, "/solve/report_files/delete").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List objects.
                """
                return PyMenu(self.service, "/solve/report_files/list").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                List properties of an object.
                """
                return PyMenu(self.service, "/solve/report_files/list_properties").execute(*args, **kwargs)

        class report_definitions(metaclass=PyMenuMeta):
            """
            Manage report definitions.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def add(self, *args, **kwargs):
                """
                Add a new object.
                """
                return PyMenu(self.service, "/solve/report_definitions/add").execute(*args, **kwargs)
            def compute(self, *args, **kwargs):
                """
                Computes selected report definition.
                """
                return PyMenu(self.service, "/solve/report_definitions/compute").execute(*args, **kwargs)
            def copy(self, *args, **kwargs):
                """
                Makes a copy of selected report definition with new name.
                """
                return PyMenu(self.service, "/solve/report_definitions/copy").execute(*args, **kwargs)
            def delete_all(self, *args, **kwargs):
                """
                Delete all report definition objects.
                """
                return PyMenu(self.service, "/solve/report_definitions/delete_all").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an object.
                """
                return PyMenu(self.service, "/solve/report_definitions/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an object.
                """
                return PyMenu(self.service, "/solve/report_definitions/delete").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List objects.
                """
                return PyMenu(self.service, "/solve/report_definitions/list").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                List properties of an object.
                """
                return PyMenu(self.service, "/solve/report_definitions/list_properties").execute(*args, **kwargs)
            def rename(self, *args, **kwargs):
                """
                Rename selected report definition with new name.
                """
                return PyMenu(self.service, "/solve/report_definitions/rename").execute(*args, **kwargs)

        class report_plots(metaclass=PyMenuMeta):
            """
            Manage report plots.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def add(self, *args, **kwargs):
                """
                Add a new object.
                """
                return PyMenu(self.service, "/solve/report_plots/add").execute(*args, **kwargs)
            def axes(self, *args, **kwargs):
                """
                Set axes options of an object.
                """
                return PyMenu(self.service, "/solve/report_plots/axes").execute(*args, **kwargs)
            def clear_data(self, *args, **kwargs):
                """
                Clear report plot data.
                """
                return PyMenu(self.service, "/solve/report_plots/clear_data").execute(*args, **kwargs)
            def curves(self, *args, **kwargs):
                """
                Set curves options of an object.
                """
                return PyMenu(self.service, "/solve/report_plots/curves").execute(*args, **kwargs)
            def delete_all(self, *args, **kwargs):
                """
                Delete all plot objects.
                """
                return PyMenu(self.service, "/solve/report_plots/delete_all").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an object.
                """
                return PyMenu(self.service, "/solve/report_plots/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an object.
                """
                return PyMenu(self.service, "/solve/report_plots/delete").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List objects.
                """
                return PyMenu(self.service, "/solve/report_plots/list").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                List properties of an object.
                """
                return PyMenu(self.service, "/solve/report_plots/list_properties").execute(*args, **kwargs)
            def plot(self, *args, **kwargs):
                """
                Plot.
                """
                return PyMenu(self.service, "/solve/report_plots/plot").execute(*args, **kwargs)

        class cell_registers(metaclass=PyMenuMeta):
            """
            Manage Cell Registers.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def adapt(self, *args, **kwargs):
                """
                Adapt cell register objects.
                """
                return PyMenu(self.service, "/solve/cell_registers/adapt").execute(*args, **kwargs)
            def add(self, *args, **kwargs):
                """
                Add a new object.
                """
                return PyMenu(self.service, "/solve/cell_registers/add").execute(*args, **kwargs)
            def apply_poor_mesh_numerics(self, *args, **kwargs):
                """
                Apply poor mesh numerics to cell register objects.
                """
                return PyMenu(self.service, "/solve/cell_registers/apply_poor_mesh_numerics").execute(*args, **kwargs)
            def coarsen(self, *args, **kwargs):
                """
                Coarsen cell register objects.
                """
                return PyMenu(self.service, "/solve/cell_registers/coarsen").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                Display cell register objects.
                """
                return PyMenu(self.service, "/solve/cell_registers/display").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an object.
                """
                return PyMenu(self.service, "/solve/cell_registers/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an object.
                """
                return PyMenu(self.service, "/solve/cell_registers/delete").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List objects.
                """
                return PyMenu(self.service, "/solve/cell_registers/list").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                List properties of an object.
                """
                return PyMenu(self.service, "/solve/cell_registers/list_properties").execute(*args, **kwargs)
            def refine(self, *args, **kwargs):
                """
                Refine cell register objects.
                """
                return PyMenu(self.service, "/solve/cell_registers/refine").execute(*args, **kwargs)

        class cell_register_operations(metaclass=PyMenuMeta):
            """
            Manage Cell Register Operations.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def add(self, *args, **kwargs):
                """
                Add a new object.
                """
                return PyMenu(self.service, "/solve/cell_register_operations/add").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an object.
                """
                return PyMenu(self.service, "/solve/cell_register_operations/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an object.
                """
                return PyMenu(self.service, "/solve/cell_register_operations/delete").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List objects.
                """
                return PyMenu(self.service, "/solve/cell_register_operations/list").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                List properties of an object.
                """
                return PyMenu(self.service, "/solve/cell_register_operations/list_properties").execute(*args, **kwargs)

        class set(metaclass=PyMenuMeta):
            """
            Enter the set solution parameters menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.contact_solution_controls = self.__class__.contact_solution_controls(path + [("contact_solution_controls", None)], service)
                self.transient_controls = self.__class__.transient_controls(path + [("transient_controls", None)], service)
                self.data_sampling_options = self.__class__.data_sampling_options(path + [("data_sampling_options", None)], service)
                self.pseudo_time_method = self.__class__.pseudo_time_method(path + [("pseudo_time_method", None)], service)
                self.nita_expert_controls = self.__class__.nita_expert_controls(path + [("nita_expert_controls", None)], service)
                self.multiphase_numerics = self.__class__.multiphase_numerics(path + [("multiphase_numerics", None)], service)
                self.open_channel_wave_options = self.__class__.open_channel_wave_options(path + [("open_channel_wave_options", None)], service)
                self.high_order_term_relaxation = self.__class__.high_order_term_relaxation(path + [("high_order_term_relaxation", None)], service)
                self.poor_mesh_numerics = self.__class__.poor_mesh_numerics(path + [("poor_mesh_numerics", None)], service)
                self.amg_options = self.__class__.amg_options(path + [("amg_options", None)], service)
                self.warped_face_gradient_correction = self.__class__.warped_face_gradient_correction(path + [("warped_face_gradient_correction", None)], service)
                self.fast_transient_settings = self.__class__.fast_transient_settings(path + [("fast_transient_settings", None)], service)
                self.divergence_prevention = self.__class__.divergence_prevention(path + [("divergence_prevention", None)], service)
                self.advanced = self.__class__.advanced(path + [("advanced", None)], service)
                self.high_speed_numerics = self.__class__.high_speed_numerics(path + [("high_speed_numerics", None)], service)
                self.previous_defaults = self.__class__.previous_defaults(path + [("previous_defaults", None)], service)
                self.overset = self.__class__.overset(path + [("overset", None)], service)
                self.acoustics_wave_equation_controls = self.__class__.acoustics_wave_equation_controls(path + [("acoustics_wave_equation_controls", None)], service)
                self.p_v_controls_advanced = self.__class__.p_v_controls_advanced(path + [("p_v_controls_advanced", None)], service)
            def adaptive_time_stepping(self, *args, **kwargs):
                """
                Set Error-based adaptive time-stepping parameters.
                """
                return PyMenu(self.service, "/solve/set/adaptive_time_stepping").execute(*args, **kwargs)
            def cfl_based_adaptive_time_stepping(self, *args, **kwargs):
                """
                Set CFL-based adaptive time-stepping parameters.
                """
                return PyMenu(self.service, "/solve/set/cfl_based_adaptive_time_stepping").execute(*args, **kwargs)
            def variable_time_stepping(self, *args, **kwargs):
                """
                Set Multiphase-Specific Adaptive time stepping parameters.
                """
                return PyMenu(self.service, "/solve/set/variable_time_stepping").execute(*args, **kwargs)
            def bc_pressure_extrapolations(self, *args, **kwargs):
                """
                Setting pressure extrapolations schemes on boundaries.
                """
                return PyMenu(self.service, "/solve/set/bc_pressure_extrapolations").execute(*args, **kwargs)
            def correction_tolerance(self, *args, **kwargs):
                """
                Enter the correction tolerance menu.
                """
                return PyMenu(self.service, "/solve/set/correction_tolerance").execute(*args, **kwargs)
            def courant_number(self, *args, **kwargs):
                """
                Set the fine mesh Courant number (time step factor).
                """
                return PyMenu(self.service, "/solve/set/courant_number").execute(*args, **kwargs)
            def data_sampling(self, *args, **kwargs):
                """
                Set iteration options.
                """
                return PyMenu(self.service, "/solve/set/data_sampling").execute(*args, **kwargs)
            def disable_reconstruction(self, *args, **kwargs):
                """
                Enable/Disable reconstruction. When disabled, accuracy will be first-order.
                """
                return PyMenu(self.service, "/solve/set/disable_reconstruction").execute(*args, **kwargs)
            def discretization_scheme(self, *args, **kwargs):
                """
                Enter the discretization-scheme menu.
                """
                return PyMenu(self.service, "/solve/set/discretization_scheme").execute(*args, **kwargs)
            def flux_type(self, *args, **kwargs):
                """
                Enter the flux type.
                """
                return PyMenu(self.service, "/solve/set/flux_type").execute(*args, **kwargs)
            def equations(self, *args, **kwargs):
                """
                Enter the equations menu.
                """
                return PyMenu(self.service, "/solve/set/equations").execute(*args, **kwargs)
            def expert(self, *args, **kwargs):
                """
                Set expert options.
                """
                return PyMenu(self.service, "/solve/set/expert").execute(*args, **kwargs)
            def flow_warnings(self, *args, **kwargs):
                """
                Control the display of warning diagnostics for boundaries with reversed flow, etc.
                """
                return PyMenu(self.service, "/solve/set/flow_warnings").execute(*args, **kwargs)
            def gradient_scheme(self, *args, **kwargs):
                """
                Set gradient options.
                """
                return PyMenu(self.service, "/solve/set/gradient_scheme").execute(*args, **kwargs)
            def nb_gradient_boundary_option(self, *args, **kwargs):
                """
                Set ggnb options.
                """
                return PyMenu(self.service, "/solve/set/nb_gradient_boundary_option").execute(*args, **kwargs)
            def limits(self, *args, **kwargs):
                """
                Set solver limits for the values of various solution variables.
                """
                return PyMenu(self.service, "/solve/set/limits").execute(*args, **kwargs)
            def limiter_warnings(self, *args, **kwargs):
                """
                Control the display of limiter warning diagnostics.
                """
                return PyMenu(self.service, "/solve/set/limiter_warnings").execute(*args, **kwargs)
            def mp_mfluid_aniso_drag(self, *args, **kwargs):
                """
                Set anisotropic drag parameters for Eulerian multiphase.
                """
                return PyMenu(self.service, "/solve/set/mp_mfluid_aniso_drag").execute(*args, **kwargs)
            def material_property_warnings(self, *args, **kwargs):
                """
                Control the display of material property warning diagnostics:
                 0 - off (no messages)
                 1 - messages per material
                 2 - messages per material and per property.
                """
                return PyMenu(self.service, "/solve/set/material_property_warnings").execute(*args, **kwargs)
            def mp_reference_density(self, *args, **kwargs):
                """
                Set reference density option for Eulerian multiphase.
                """
                return PyMenu(self.service, "/solve/set/mp_reference_density").execute(*args, **kwargs)
            def max_corrections(self, *args, **kwargs):
                """
                Enter the max-corrections menu.
                """
                return PyMenu(self.service, "/solve/set/max_corrections").execute(*args, **kwargs)
            def multi_grid_amg(self, *args, **kwargs):
                """
                Set the parameters that govern the algebraic multigrid procedure.
                """
                return PyMenu(self.service, "/solve/set/multi_grid_amg").execute(*args, **kwargs)
            def multi_grid_fas(self, *args, **kwargs):
                """
                Set the coefficients that govern the FAS multigrid procedure.
                """
                return PyMenu(self.service, "/solve/set/multi_grid_fas").execute(*args, **kwargs)
            def multi_grid_controls(self, *args, **kwargs):
                """
                Enter the multi-grid-controls menu.
                """
                return PyMenu(self.service, "/solve/set/multi_grid_controls").execute(*args, **kwargs)
            def multi_stage(self, *args, **kwargs):
                """
                Set the multiple-stage time stepping scheme coefficients.
                """
                return PyMenu(self.service, "/solve/set/multi_stage").execute(*args, **kwargs)
            def number_of_iterations(self, *args, **kwargs):
                """
                Set number of iterations.
                """
                return PyMenu(self.service, "/solve/set/number_of_iterations").execute(*args, **kwargs)
            def numerics(self, *args, **kwargs):
                """
                Set numeric options.
                """
                return PyMenu(self.service, "/solve/set/numerics").execute(*args, **kwargs)
            def second_order_time_options(self, *args, **kwargs):
                """
                Set options for second-order time formulation.
                """
                return PyMenu(self.service, "/solve/set/second_order_time_options").execute(*args, **kwargs)
            def solution_steering(self, *args, **kwargs):
                """
                Enable solution steering for density-based solver.
                """
                return PyMenu(self.service, "/solve/set/solution_steering").execute(*args, **kwargs)
            def set_solution_steering(self, *args, **kwargs):
                """
                Set Solution Steering Parameters.
                """
                return PyMenu(self.service, "/solve/set/set_solution_steering").execute(*args, **kwargs)
            def p_v_coupling(self, *args, **kwargs):
                """
                Select the pressure velocity coupling scheme.
                """
                return PyMenu(self.service, "/solve/set/p_v_coupling").execute(*args, **kwargs)
            def p_v_controls(self, *args, **kwargs):
                """
                Set P-V-Controls.
                """
                return PyMenu(self.service, "/solve/set/p_v_controls").execute(*args, **kwargs)
            def phase_based_vof_discretization(self, *args, **kwargs):
                """
                Set phase based slope limiter for VOF compressive scheme.
                """
                return PyMenu(self.service, "/solve/set/phase_based_vof_discretization").execute(*args, **kwargs)
            def accelerated_non_iterative_time_marching(self, *args, **kwargs):
                """
                Enable/disable accelerated non-iterative time marching.
                """
                return PyMenu(self.service, "/solve/set/accelerated_non_iterative_time_marching").execute(*args, **kwargs)
            def relaxation_method(self, *args, **kwargs):
                """
                Set the solver relaxation method.
                """
                return PyMenu(self.service, "/solve/set/relaxation_method").execute(*args, **kwargs)
            def reactions(self, *args, **kwargs):
                """
                Enable/disable the species reaction sources and set relaxation factor.
                """
                return PyMenu(self.service, "/solve/set/reactions").execute(*args, **kwargs)
            def relaxation_factor(self, *args, **kwargs):
                """
                Enter the relaxation-factor menu.
                """
                return PyMenu(self.service, "/solve/set/relaxation_factor").execute(*args, **kwargs)
            def reporting_interval(self, *args, **kwargs):
                """
                Set number of solver iterations before returning to scheme.
                """
                return PyMenu(self.service, "/solve/set/reporting_interval").execute(*args, **kwargs)
            def residual_smoothing(self, *args, **kwargs):
                """
                Set residual smoothing factor and number of iterations.
                """
                return PyMenu(self.service, "/solve/set/residual_smoothing").execute(*args, **kwargs)
            def residual_tolerance(self, *args, **kwargs):
                """
                Enter the residual tolerance menu.
                """
                return PyMenu(self.service, "/solve/set/residual_tolerance").execute(*args, **kwargs)
            def residual_verbosity(self, *args, **kwargs):
                """
                Set the residual report verbosity.
                """
                return PyMenu(self.service, "/solve/set/residual_verbosity").execute(*args, **kwargs)
            def set_solution_methods_to_default(self, *args, **kwargs):
                """
                Set solution methods to default values.
                """
                return PyMenu(self.service, "/solve/set/set_solution_methods_to_default").execute(*args, **kwargs)
            def set_controls_to_default(self, *args, **kwargs):
                """
                Set controls to default values.
                """
                return PyMenu(self.service, "/solve/set/set_controls_to_default").execute(*args, **kwargs)
            def set_all_species_together(self, *args, **kwargs):
                """
                Set all species discretizations and URFs together.
                """
                return PyMenu(self.service, "/solve/set/set_all_species_together").execute(*args, **kwargs)
            def slope_limiter_set(self, *args, **kwargs):
                """
                Enter the slope limiter set menu.
                """
                return PyMenu(self.service, "/solve/set/slope_limiter_set").execute(*args, **kwargs)
            def vof_numerics(self, *args, **kwargs):
                """
                Set VOF numeric options.
                """
                return PyMenu(self.service, "/solve/set/vof_numerics").execute(*args, **kwargs)
            def vof_explicit_controls(self, *args, **kwargs):
                """
                Set Explicit VOF controls.
                """
                return PyMenu(self.service, "/solve/set/vof_explicit_controls").execute(*args, **kwargs)
            def surface_tension(self, *args, **kwargs):
                """
                Set surface-tension calculation options.
                """
                return PyMenu(self.service, "/solve/set/surface_tension").execute(*args, **kwargs)
            def surface_tension_expert(self, *args, **kwargs):
                """
                Set surface-tension expert options.
                """
                return PyMenu(self.service, "/solve/set/surface_tension_expert").execute(*args, **kwargs)
            def open_channel_controls(self, *args, **kwargs):
                """
                
                Set additional open channel controls.
                """
                return PyMenu(self.service, "/solve/set/open_channel_controls").execute(*args, **kwargs)
            def numerical_beach_controls(self, *args, **kwargs):
                """
                Set damping function in flow direction.
                """
                return PyMenu(self.service, "/solve/set/numerical_beach_controls").execute(*args, **kwargs)
            def heterogeneous_stiff_chemistry(self, *args, **kwargs):
                """
                Set heterogeneous stiff-chemistry solver.
                """
                return PyMenu(self.service, "/solve/set/heterogeneous_stiff_chemistry").execute(*args, **kwargs)
            def stiff_chemistry(self, *args, **kwargs):
                """
                Set solver options for stiff-chemistry solutions.
                """
                return PyMenu(self.service, "/solve/set/stiff_chemistry").execute(*args, **kwargs)
            def time_step(self, *args, **kwargs):
                """
                Set the time step.
                """
                return PyMenu(self.service, "/solve/set/time_step").execute(*args, **kwargs)
            def under_relaxation(self, *args, **kwargs):
                """
                Enter the under-relaxation menu.
                """
                return PyMenu(self.service, "/solve/set/under_relaxation").execute(*args, **kwargs)
            def convergence_acceleration_for_stretched_meshes(self, *args, **kwargs):
                """
                Enable convergence acceleration for stretched meshes to improve the convergence of the implicit density based solver on meshes with high cell stretching.
                """
                return PyMenu(self.service, "/solve/set/convergence_acceleration_for_stretched_meshes").execute(*args, **kwargs)
            def reduced_rank_extrapolation(self, *args, **kwargs):
                """
                Enable Reduced Rank Extrapolation method to accelerate solution time.
                """
                return PyMenu(self.service, "/solve/set/reduced_rank_extrapolation").execute(*args, **kwargs)
            def reduced_rank_extrapolation_options(self, *args, **kwargs):
                """
                Reduced Rank Extrapolation options.
                """
                return PyMenu(self.service, "/solve/set/reduced_rank_extrapolation_options").execute(*args, **kwargs)
            def moving_mesh_numerics(self, *args, **kwargs):
                """
                Transient options for sliding, moving, and/or dynamic mesh.
                """
                return PyMenu(self.service, "/solve/set/moving_mesh_numerics").execute(*args, **kwargs)
            def lock_solid_temperature(self, *args, **kwargs):
                """
                Lock the temperature for all solid and shell cell zones in the domain.
                """
                return PyMenu(self.service, "/solve/set/lock_solid_temperature").execute(*args, **kwargs)
            def enable_output_dp_dt(self, *args, **kwargs):
                """
                Enable postprocessing of pressure time derivative. Requires storage of pressure from the previous timesteps.
                """
                return PyMenu(self.service, "/solve/set/enable_output_dp_dt").execute(*args, **kwargs)
            def equation_ordering(self, *args, **kwargs):
                """
                Set the equation order.
                """
                return PyMenu(self.service, "/solve/set/equation_ordering").execute(*args, **kwargs)

            class contact_solution_controls(metaclass=PyMenuMeta):
                """
                Solver controls for contact marks method.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.parameters = self.__class__.parameters(path + [("parameters", None)], service)
                    self.spatial = self.__class__.spatial(path + [("spatial", None)], service)
                    self.transient = self.__class__.transient(path + [("transient", None)], service)
                    self.amg = self.__class__.amg(path + [("amg", None)], service)
                    self.models = self.__class__.models(path + [("models", None)], service)
                    self.methods = self.__class__.methods(path + [("methods", None)], service)
                    self.miscellaneous = self.__class__.miscellaneous(path + [("miscellaneous", None)], service)
                def solution_stabilization(self, *args, **kwargs):
                    """
                    Automatic solver settings adjustment for solution stabilization during contact process.
                    """
                    return PyMenu(self.service, "/solve/set/contact_solution_controls/solution_stabilization").execute(*args, **kwargs)
                def set_settings_to_default(self, *args, **kwargs):
                    """
                    Set contact solution stabilization to default.
                    """
                    return PyMenu(self.service, "/solve/set/contact_solution_controls/set_settings_to_default").execute(*args, **kwargs)
                def verbosity(self, *args, **kwargs):
                    """
                    Specify verbosity level for contact solution controls.
                    """
                    return PyMenu(self.service, "/solve/set/contact_solution_controls/verbosity").execute(*args, **kwargs)

                class parameters(metaclass=PyMenuMeta):
                    """
                    Parameters used in stabilization strategy.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def iterations(self, *args, **kwargs):
                        """
                        Specify additional iterations to accomodate contact solution stabilization.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/parameters/iterations").execute(*args, **kwargs)
                    def solution_stabilization_persistence(self, *args, **kwargs):
                        """
                        Persistence of the solution stabilization based on events [0-contact based, 1-always on].
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/parameters/solution_stabilization_persistence").execute(*args, **kwargs)
                    def persistence_fixed_time_steps(self, *args, **kwargs):
                        """
                        Specify fixed time-steps for solution stabilization persistence after trigger.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/parameters/persistence_fixed_time_steps").execute(*args, **kwargs)
                    def persistence_fixed_duration(self, *args, **kwargs):
                        """
                        Specify fixed time for solution stabilization persistence after trigger.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/parameters/persistence_fixed_duration").execute(*args, **kwargs)
                    def extrapolation_method(self, *args, **kwargs):
                        """
                        Solution extrapolation method for cells changing status from contact to non-contact [0-none, 1-local extrapolation].
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/parameters/extrapolation_method").execute(*args, **kwargs)

                class spatial(metaclass=PyMenuMeta):
                    """
                    Spatial discretization control options.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def first_to_second_order_blending(self, *args, **kwargs):
                        """
                        Set factor to control first order to second order blending.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/spatial/first_to_second_order_blending").execute(*args, **kwargs)
                    def first_to_second_order_blending_list(self, *args, **kwargs):
                        """
                        List set factor to control first order to second order blending.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/spatial/first_to_second_order_blending_list").execute(*args, **kwargs)
                    def scheme(self, *args, **kwargs):
                        """
                        Set advection scheme for contact event stability.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/spatial/scheme").execute(*args, **kwargs)
                    def flow_skew_diffusion_exclude(self, *args, **kwargs):
                        """
                        Exclude skew diffusion discretization contribution for momentum.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/spatial/flow_skew_diffusion_exclude").execute(*args, **kwargs)
                    def scalars_skew_diffusion_exclude(self, *args, **kwargs):
                        """
                        Exclude skew diffusion discretization contribution for scalars.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/spatial/scalars_skew_diffusion_exclude").execute(*args, **kwargs)
                    def rhie_chow_flux_specify(self, *args, **kwargs):
                        """
                        Allow specification of the the rhie-chow flux method.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/spatial/rhie_chow_flux_specify").execute(*args, **kwargs)
                    def rhie_chow_method(self, *args, **kwargs):
                        """
                        Enter the rhie-chow flux method.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/spatial/rhie_chow_method").execute(*args, **kwargs)

                class transient(metaclass=PyMenuMeta):
                    """
                    Transient discretization control options .
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def transient_parameters_specify(self, *args, **kwargs):
                        """
                        Allow transient parameter specification.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/transient/transient_parameters_specify").execute(*args, **kwargs)
                    def transient_scheme(self, *args, **kwargs):
                        """
                        Specify temporal scheme to be used.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/transient/transient_scheme").execute(*args, **kwargs)
                    def time_scale_modification_method(self, *args, **kwargs):
                        """
                        Enter time scale modification method.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/transient/time_scale_modification_method").execute(*args, **kwargs)
                    def time_scale_modification_factor(self, *args, **kwargs):
                        """
                        Specify time-scale modification factor.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/transient/time_scale_modification_factor").execute(*args, **kwargs)

                class amg(metaclass=PyMenuMeta):
                    """
                    AMG control options.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def enforce_laplace_coarsening(self, *args, **kwargs):
                        """
                        Enforce the use of laplace coarsening in AMG.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/amg/enforce_laplace_coarsening").execute(*args, **kwargs)
                    def increase_pre_sweeps(self, *args, **kwargs):
                        """
                        Allow increase in AMG pre-sweep.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/amg/increase_pre_sweeps").execute(*args, **kwargs)
                    def pre_sweeps(self, *args, **kwargs):
                        """
                        Specify the number of AMG pre-sweeps.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/amg/pre_sweeps").execute(*args, **kwargs)
                    def specify_coarsening_rate(self, *args, **kwargs):
                        """
                        Modify AMG coarsening rate.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/amg/specify_coarsening_rate").execute(*args, **kwargs)
                    def coarsen_rate(self, *args, **kwargs):
                        """
                        Specify AMG coarsening rate.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/amg/coarsen_rate").execute(*args, **kwargs)

                class models(metaclass=PyMenuMeta):
                    """
                    Model control options.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def model_ramping(self, *args, **kwargs):
                        """
                        Activate model ramping for solver stability and accuracy.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/models/model_ramping").execute(*args, **kwargs)
                    def ramp_flow(self, *args, **kwargs):
                        """
                        Ramp flow for solver stability and accuracy.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/models/ramp_flow").execute(*args, **kwargs)
                    def ramp_turbulence(self, *args, **kwargs):
                        """
                        Ramp turbulence for solver stability and accuracy.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/models/ramp_turbulence").execute(*args, **kwargs)
                    def ramp_scalars(self, *args, **kwargs):
                        """
                        Ramp all scalar transport equations for solver stability and accuracy.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/models/ramp_scalars").execute(*args, **kwargs)

                class methods(metaclass=PyMenuMeta):
                    """
                    Methods control options.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def pressure_velocity_coupling_controls(self, *args, **kwargs):
                        """
                        Enable pressure-velocity coupling method change for solver stability and accuracy.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/methods/pressure_velocity_coupling_controls").execute(*args, **kwargs)
                    def pressure_velocity_coupling_method(self, *args, **kwargs):
                        """
                        Specify pressure-velocity coupling method change for solver stability and accuracy.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/methods/pressure_velocity_coupling_method").execute(*args, **kwargs)
                    def gradient_controls(self, *args, **kwargs):
                        """
                        Modify gradient method for solver stability and accuracy.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/methods/gradient_controls").execute(*args, **kwargs)
                    def specify_gradient_method(self, *args, **kwargs):
                        """
                        Specify gradient method for solver stability and accuracy.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/methods/specify_gradient_method").execute(*args, **kwargs)

                class miscellaneous(metaclass=PyMenuMeta):
                    """
                    Miscellaneous.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def compute_statistics(self, *args, **kwargs):
                        """
                        Compute solution statistics for contact updates.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/miscellaneous/compute_statistics").execute(*args, **kwargs)
                    def statistics_level(self, *args, **kwargs):
                        """
                        Solution statistics level for contact updates.
                        """
                        return PyMenu(self.service, "/solve/set/contact_solution_controls/miscellaneous/statistics_level").execute(*args, **kwargs)

            class transient_controls(metaclass=PyMenuMeta):
                """
                Enter into the transient controls menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.multiphase_specific_time_constraints = self.__class__.multiphase_specific_time_constraints(path + [("multiphase_specific_time_constraints", None)], service)
                def specified_time_step(self, *args, **kwargs):
                    """
                    Use specified time step or courant number.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/specified_time_step").execute(*args, **kwargs)
                def fixed_user_specified(self, *args, **kwargs):
                    """
                    Enable user-specified fixed time stepping method.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/fixed_user_specified").execute(*args, **kwargs)
                def fixed_periodic(self, *args, **kwargs):
                    """
                    Set period- or frequency-based fixed time-stepping parameters.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/fixed_periodic").execute(*args, **kwargs)
                def duration_specification_method(self, *args, **kwargs):
                    """
                    Set Duration Specification Method: [0] Incremental Time Steps, [1] Total Time Steps, [2] Total Time, [3] Incremental Time.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/duration_specification_method").execute(*args, **kwargs)
                def incremental_time(self, *args, **kwargs):
                    """
                    Set Incremental Time.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/incremental_time").execute(*args, **kwargs)
                def max_iterations_per_time_step(self, *args, **kwargs):
                    """
                    Set Max Iterations/Time step.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/max_iterations_per_time_step").execute(*args, **kwargs)
                def number_of_time_steps(self, *args, **kwargs):
                    """
                    Set inceremtal number of Time steps.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/number_of_time_steps").execute(*args, **kwargs)
                def total_number_of_time_steps(self, *args, **kwargs):
                    """
                    Set total number of Time steps.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/total_number_of_time_steps").execute(*args, **kwargs)
                def total_time(self, *args, **kwargs):
                    """
                    Set Total Simulation Time.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/total_time").execute(*args, **kwargs)
                def time_step_size(self, *args, **kwargs):
                    """
                    Set the physical time step size.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/time_step_size").execute(*args, **kwargs)
                def solution_status(self, *args, **kwargs):
                    """
                    Activate the simulation status panel.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/solution_status").execute(*args, **kwargs)
                def extrapolate_vars(self, *args, **kwargs):
                    """
                    Applies a predictor algorithm for computing initial condition at time step n+1.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/extrapolate_vars").execute(*args, **kwargs)
                def extrapolate_eqn_vars(self, *args, **kwargs):
                    """
                    Enter the extrapolation menu.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/extrapolate_eqn_vars").execute(*args, **kwargs)
                def max_flow_time(self, *args, **kwargs):
                    """
                    Set maximum flow time.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/max_flow_time").execute(*args, **kwargs)
                def cfl_based_time_stepping_advanced_options(self, *args, **kwargs):
                    """
                    Set CFL-based adaptive time-stepping advanced parameters.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/cfl_based_time_stepping_advanced_options").execute(*args, **kwargs)
                def cfl_based_time_stepping(self, *args, **kwargs):
                    """
                    Set CFL-based adaptive time-stepping parameters.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/cfl_based_time_stepping").execute(*args, **kwargs)
                def multiphase_specific_time_stepping(self, *args, **kwargs):
                    """
                    Set Multiphase-specific adaptive time stepping parameters.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/multiphase_specific_time_stepping").execute(*args, **kwargs)
                def udf_based_time_stepping(self, *args, **kwargs):
                    """
                    Set the time-stepping parameters for user-defined time stepping method.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/udf_based_time_stepping").execute(*args, **kwargs)
                def error_based_time_stepping(self, *args, **kwargs):
                    """
                    Set Error-based adaptive time-stepping parameters.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/error_based_time_stepping").execute(*args, **kwargs)
                def undo_timestep(self, *args, **kwargs):
                    """
                    Undo the previous time step.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/undo_timestep").execute(*args, **kwargs)
                def predict_next_time(self, *args, **kwargs):
                    """
                    Applies a predictor algorithm for computing initial condition at time step n+1.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/predict_next_time").execute(*args, **kwargs)
                def rotating_mesh_flow_predictor(self, *args, **kwargs):
                    """
                    Improve prediction of flow field at time step n+1 for rotating mesh.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/rotating_mesh_flow_predictor").execute(*args, **kwargs)
                def solid_time_step_size(self, *args, **kwargs):
                    """
                    Specify a different time step size for solid zones.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/solid_time_step_size").execute(*args, **kwargs)
                def time_step_size_for_acoustic_export(self, *args, **kwargs):
                    """
                    Set number of time step size for acoustic export.
                    """
                    return PyMenu(self.service, "/solve/set/transient_controls/time_step_size_for_acoustic_export").execute(*args, **kwargs)

                class multiphase_specific_time_constraints(metaclass=PyMenuMeta):
                    """
                    Set Multiphase-specific time constraints.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.time_scale_options = self.__class__.time_scale_options(path + [("time_scale_options", None)], service)
                    def moving_mesh_cfl_constraint(self, *args, **kwargs):
                        """
                        Enable time step size constraints based on moving mesh courant number.
                        """
                        return PyMenu(self.service, "/solve/set/transient_controls/multiphase_specific_time_constraints/moving_mesh_cfl_constraint").execute(*args, **kwargs)
                    def physics_based_constraint(self, *args, **kwargs):
                        """
                        Include physics driven time-step constraints.
                        """
                        return PyMenu(self.service, "/solve/set/transient_controls/multiphase_specific_time_constraints/physics_based_constraint").execute(*args, **kwargs)
                    def verbosity(self, *args, **kwargs):
                        """
                        Set verbosity to print multiphase specific time scales.
                        """
                        return PyMenu(self.service, "/solve/set/transient_controls/multiphase_specific_time_constraints/verbosity").execute(*args, **kwargs)

                    class time_scale_options(metaclass=PyMenuMeta):
                        """
                        Set physics based time scale options.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def viscous_scale(self, *args, **kwargs):
                            """
                            Include viscous time scale.
                            """
                            return PyMenu(self.service, "/solve/set/transient_controls/multiphase_specific_time_constraints/time_scale_options/viscous_scale").execute(*args, **kwargs)
                        def gravity_scale(self, *args, **kwargs):
                            """
                            Include gravity based time scale.
                            """
                            return PyMenu(self.service, "/solve/set/transient_controls/multiphase_specific_time_constraints/time_scale_options/gravity_scale").execute(*args, **kwargs)
                        def surface_tension_scale(self, *args, **kwargs):
                            """
                            Include surface tension based time scale.
                            """
                            return PyMenu(self.service, "/solve/set/transient_controls/multiphase_specific_time_constraints/time_scale_options/surface_tension_scale").execute(*args, **kwargs)
                        def acoustic_scale(self, *args, **kwargs):
                            """
                            Include acoustic time scale.
                            """
                            return PyMenu(self.service, "/solve/set/transient_controls/multiphase_specific_time_constraints/time_scale_options/acoustic_scale").execute(*args, **kwargs)

            class data_sampling_options(metaclass=PyMenuMeta):
                """
                Data sampling options for statistics.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def add_datasets(self, *args, **kwargs):
                    """
                    Add a dataset. After providing the zones for a dataset, press [Enter] to move onto selecting quantities. Enter () to complete the quantity selection for this dataset.
                    """
                    return PyMenu(self.service, "/solve/set/data_sampling_options/add_datasets").execute(*args, **kwargs)
                def add_rtdft_datasets(self, *args, **kwargs):
                    """
                    Add a dataset. After providing the zones for a dataset, press [Enter] to move onto selecting quantities. Enter () to complete the quantity selection for this dataset.
                    """
                    return PyMenu(self.service, "/solve/set/data_sampling_options/add_rtdft_datasets").execute(*args, **kwargs)
                def remove_dataset(self, *args, **kwargs):
                    """
                    Remove dataset.
                    """
                    return PyMenu(self.service, "/solve/set/data_sampling_options/remove_dataset").execute(*args, **kwargs)
                def list_datasets(self, *args, **kwargs):
                    """
                    List dataset.
                    """
                    return PyMenu(self.service, "/solve/set/data_sampling_options/list_datasets").execute(*args, **kwargs)

            class pseudo_time_method(metaclass=PyMenuMeta):
                """
                Enter the pseudo time method menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def formulation(self, *args, **kwargs):
                    """
                    Select the pseudo time step size formulation for the pseudo time method.
                    """
                    return PyMenu(self.service, "/solve/set/pseudo_time_method/formulation").execute(*args, **kwargs)
                def local_time_step_settings(self, *args, **kwargs):
                    """
                    Adjust the settings for the local time step formulation.
                    """
                    return PyMenu(self.service, "/solve/set/pseudo_time_method/local_time_step_settings").execute(*args, **kwargs)
                def global_time_step_settings(self, *args, **kwargs):
                    """
                    Adjust the settings for the global time step formulation.
                    """
                    return PyMenu(self.service, "/solve/set/pseudo_time_method/global_time_step_settings").execute(*args, **kwargs)
                def advanced_options(self, *args, **kwargs):
                    """
                    Enter the advanced options menu to define pseudo time settings for equations.
                    """
                    return PyMenu(self.service, "/solve/set/pseudo_time_method/advanced_options").execute(*args, **kwargs)
                def relaxation_factors(self, *args, **kwargs):
                    """
                    Enter the relaxation factors menu to set the pseudo time explicit relaxation factors for equations.
                    """
                    return PyMenu(self.service, "/solve/set/pseudo_time_method/relaxation_factors").execute(*args, **kwargs)
                def relaxation_method(self, *args, **kwargs):
                    """
                    Select relaxation definition for pseudo time method.
                    """
                    return PyMenu(self.service, "/solve/set/pseudo_time_method/relaxation_method").execute(*args, **kwargs)
                def relaxation_bounds(self, *args, **kwargs):
                    """
                    Select relaxation bounding scheme for pseudo time method.
                    """
                    return PyMenu(self.service, "/solve/set/pseudo_time_method/relaxation_bounds").execute(*args, **kwargs)
                def verbosity(self, *args, **kwargs):
                    """
                    Set the verbosity for the pseudo time method.
                    """
                    return PyMenu(self.service, "/solve/set/pseudo_time_method/verbosity").execute(*args, **kwargs)

            class nita_expert_controls(metaclass=PyMenuMeta):
                """
                Enter the nita expert controls menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def set_verbosity(self, *args, **kwargs):
                    """
                    Set nita verbosity option.
                    """
                    return PyMenu(self.service, "/solve/set/nita_expert_controls/set_verbosity").execute(*args, **kwargs)
                def skewness_neighbor_coupling(self, *args, **kwargs):
                    """
                    Set skewness neighbor coupling for nita.
                    """
                    return PyMenu(self.service, "/solve/set/nita_expert_controls/skewness_neighbor_coupling").execute(*args, **kwargs)
                def hybrid_nita_settings(self, *args, **kwargs):
                    """
                    Select a hybrid NITA settings option for faster performance and better robustness.
                    """
                    return PyMenu(self.service, "/solve/set/nita_expert_controls/hybrid_nita_settings").execute(*args, **kwargs)

            class multiphase_numerics(metaclass=PyMenuMeta):
                """
                Enter the multiphase numerics options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.porous_media = self.__class__.porous_media(path + [("porous_media", None)], service)
                    self.compressible_flow = self.__class__.compressible_flow(path + [("compressible_flow", None)], service)
                    self.boiling_parameters = self.__class__.boiling_parameters(path + [("boiling_parameters", None)], service)
                    self.viscous_flow = self.__class__.viscous_flow(path + [("viscous_flow", None)], service)
                    self.heat_mass_transfer = self.__class__.heat_mass_transfer(path + [("heat_mass_transfer", None)], service)
                    self.advanced_stability_controls = self.__class__.advanced_stability_controls(path + [("advanced_stability_controls", None)], service)
                    self.default_controls = self.__class__.default_controls(path + [("default_controls", None)], service)
                    self.face_pressure_controls = self.__class__.face_pressure_controls(path + [("face_pressure_controls", None)], service)
                    self.solution_stabilization = self.__class__.solution_stabilization(path + [("solution_stabilization", None)], service)

                class porous_media(metaclass=PyMenuMeta):
                    """
                    Multiphase relative permeability numerics menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def relative_permeability(self, *args, **kwargs):
                        """
                        Multiphase relative permeability fix option.
                        """
                        return PyMenu(self.service, "/solve/set/multiphase_numerics/porous_media/relative_permeability").execute(*args, **kwargs)

                class compressible_flow(metaclass=PyMenuMeta):
                    """
                    Multiphase compressible numerics options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def enhanced_numerics(self, *args, **kwargs):
                        """
                        Multiphase enhanced compressible flow numerics options.
                        """
                        return PyMenu(self.service, "/solve/set/multiphase_numerics/compressible_flow/enhanced_numerics").execute(*args, **kwargs)
                    def alternate_bc_formulation(self, *args, **kwargs):
                        """
                        Multiphase compressible flow BC alternate method.
                        """
                        return PyMenu(self.service, "/solve/set/multiphase_numerics/compressible_flow/alternate_bc_formulation").execute(*args, **kwargs)

                class boiling_parameters(metaclass=PyMenuMeta):
                    """
                    Multiphase boiling parameters menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def thin_film(self, *args, **kwargs):
                        """
                        Multiphase boiling thin film effects.
                        """
                        return PyMenu(self.service, "/solve/set/multiphase_numerics/boiling_parameters/thin_film").execute(*args, **kwargs)
                    def liquid_vof_factor(self, *args, **kwargs):
                        """
                        Multiphase boiling liquid volume fraction effects.
                        """
                        return PyMenu(self.service, "/solve/set/multiphase_numerics/boiling_parameters/liquid_vof_factor").execute(*args, **kwargs)

                class viscous_flow(metaclass=PyMenuMeta):
                    """
                    Multiphase viscous flow numerics options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def viscosity_averaging(self, *args, **kwargs):
                        """
                        Multiphase options for viscosity averaging.
                        """
                        return PyMenu(self.service, "/solve/set/multiphase_numerics/viscous_flow/viscosity_averaging").execute(*args, **kwargs)
                    def turb_visc_based_damping(self, *args, **kwargs):
                        """
                        Turbulence viscosity based damping controls.
                        """
                        return PyMenu(self.service, "/solve/set/multiphase_numerics/viscous_flow/turb_visc_based_damping").execute(*args, **kwargs)
                    def interfacial_artificial_viscosity(self, *args, **kwargs):
                        """
                        Interfacial artifical viscosity controls.
                        """
                        return PyMenu(self.service, "/solve/set/multiphase_numerics/viscous_flow/interfacial_artificial_viscosity").execute(*args, **kwargs)

                class heat_mass_transfer(metaclass=PyMenuMeta):
                    """
                    Multiphase interphase heat and mass transfer numerics options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.cavitation = self.__class__.cavitation(path + [("cavitation", None)], service)
                        self.evaporation_condensation = self.__class__.evaporation_condensation(path + [("evaporation_condensation", None)], service)
                        self.boiling = self.__class__.boiling(path + [("boiling", None)], service)
                        self.area_density = self.__class__.area_density(path + [("area_density", None)], service)
                    def alternative_energy_treatment(self, *args, **kwargs):
                        """
                        Alternative treatment of latent heat source due to mass transfer.
                        """
                        return PyMenu(self.service, "/solve/set/multiphase_numerics/heat_mass_transfer/alternative_energy_treatment").execute(*args, **kwargs)

                    class cavitation(metaclass=PyMenuMeta):
                        """
                        Cavitation numerics options menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def schnerr_evap_coeff(self, *args, **kwargs):
                            """
                            Evaporation coefficient for Schnerr-Sauer model.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/heat_mass_transfer/cavitation/schnerr_evap_coeff").execute(*args, **kwargs)
                        def schnerr_cond_coeff(self, *args, **kwargs):
                            """
                            Condensation coefficient for Schnerr-Sauer model.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/heat_mass_transfer/cavitation/schnerr_cond_coeff").execute(*args, **kwargs)
                        def max_vapor_pressure_ratio(self, *args, **kwargs):
                            """
                            Maximum limit on vapor pressure after turbulence and thermal correction.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/heat_mass_transfer/cavitation/max_vapor_pressure_ratio").execute(*args, **kwargs)
                        def min_vapor_pressure(self, *args, **kwargs):
                            """
                            Minimum vapor pressure limit for cavitation model.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/heat_mass_transfer/cavitation/min_vapor_pressure").execute(*args, **kwargs)
                        def display_clipped_pressure(self, *args, **kwargs):
                            """
                            Clipped pressure is just used for the properties evaluation. Mass Transfer Rate uses unclipped pressure.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/heat_mass_transfer/cavitation/display_clipped_pressure").execute(*args, **kwargs)
                        def turbulent_diffusion(self, *args, **kwargs):
                            """
                            Enable/disable turbulent diffusion treatment between phases participating in cavitation.
                            This treatment is generally recommended for better solution stability.
                            However, in case of numerical difficulties, it can be disabled.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/heat_mass_transfer/cavitation/turbulent_diffusion").execute(*args, **kwargs)

                    class evaporation_condensation(metaclass=PyMenuMeta):
                        """
                        Evaporation-condensation advanced options menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def vof_from_min_limit(self, *args, **kwargs):
                            """
                            Minimum volume fraction below which mass transfer rate is set to zero.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/heat_mass_transfer/evaporation_condensation/vof_from_min_limit").execute(*args, **kwargs)
                        def vof_from_max_limit(self, *args, **kwargs):
                            """
                            Maximum volume fraction above which mass transfer rate is set to zero.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/heat_mass_transfer/evaporation_condensation/vof_from_max_limit").execute(*args, **kwargs)
                        def vof_to_min_limit(self, *args, **kwargs):
                            """
                            Minimum volume fraction below which mass transfer rate is set to zero.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/heat_mass_transfer/evaporation_condensation/vof_to_min_limit").execute(*args, **kwargs)
                        def vof_to_max_limit(self, *args, **kwargs):
                            """
                            Maximum volume fraction above which mass transfer rate is set to zero.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/heat_mass_transfer/evaporation_condensation/vof_to_max_limit").execute(*args, **kwargs)
                        def ia_norm_min_limit(self, *args, **kwargs):
                            """
                            Minimum normalized area density below which mass transfer rate is set to zero.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/heat_mass_transfer/evaporation_condensation/ia_norm_min_limit").execute(*args, **kwargs)
                        def max_rel_humidity(self, *args, **kwargs):
                            """
                            Maximum value of relative humidity to limit condensation rate.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/heat_mass_transfer/evaporation_condensation/max_rel_humidity").execute(*args, **kwargs)

                    class boiling(metaclass=PyMenuMeta):
                        """
                        Boiling advanced options menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def heat_flux_relaxation_factor(self, *args, **kwargs):
                            """
                            Under-relaxation factor for boiling heat flux.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/heat_mass_transfer/boiling/heat_flux_relaxation_factor").execute(*args, **kwargs)
                        def show_expert_options(self, *args, **kwargs):
                            """
                            Exposes expert options of min/max superheat along with wetting fraction controls.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/heat_mass_transfer/boiling/show_expert_options").execute(*args, **kwargs)
                        def two_resistance_boiling_framework(self, *args, **kwargs):
                            """
                            Allow generalized two-resistance framework for boiling model.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/heat_mass_transfer/boiling/two_resistance_boiling_framework").execute(*args, **kwargs)

                    class area_density(metaclass=PyMenuMeta):
                        """
                        Interfacial area density menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def vof_min_seeding(self, *args, **kwargs):
                            """
                            Minimum vof seeding for non-zero area density in heat and mass transfer.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/heat_mass_transfer/area_density/vof_min_seeding").execute(*args, **kwargs)
                        def ia_grad_sym(self, *args, **kwargs):
                            """
                            Interfacial area density gradient-symmetric mechanism.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/heat_mass_transfer/area_density/ia_grad_sym").execute(*args, **kwargs)

                class advanced_stability_controls(metaclass=PyMenuMeta):
                    """
                    Stability controls for multiphase flow.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.pseudo_time = self.__class__.pseudo_time(path + [("pseudo_time", None)], service)
                        self.p_v_coupling = self.__class__.p_v_coupling(path + [("p_v_coupling", None)], service)
                        self.hybrid_nita = self.__class__.hybrid_nita(path + [("hybrid_nita", None)], service)
                        self.equation_order = self.__class__.equation_order(path + [("equation_order", None)], service)
                        self.anti_diffusion = self.__class__.anti_diffusion(path + [("anti_diffusion", None)], service)

                    class pseudo_time(metaclass=PyMenuMeta):
                        """
                        Pseudo-Time stability controls for multiphase flow.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.auto_dt_advanced_controls = self.__class__.auto_dt_advanced_controls(path + [("auto_dt_advanced_controls", None)], service)
                        def smoothed_density_stabilization_method(self, *args, **kwargs):
                            """
                            Set smoothed density stabilization method.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_time/smoothed_density_stabilization_method").execute(*args, **kwargs)
                        def false_time_step_linearization(self, *args, **kwargs):
                            """
                            Set false time-step linearization for added stability.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_time/false_time_step_linearization").execute(*args, **kwargs)

                        class auto_dt_advanced_controls(metaclass=PyMenuMeta):
                            """
                            Set automatic time-stepping controls for better solution stability.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def enable(self, *args, **kwargs):
                                """
                                Enable advanced automatic time stepping for better stability.
                                """
                                return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_time/auto_dt_advanced_controls/enable").execute(*args, **kwargs)
                            def dt_init_limit(self, *args, **kwargs):
                                """
                                Set maximum value for pseudo time step size during first iteration.
                                """
                                return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_time/auto_dt_advanced_controls/dt_init_limit").execute(*args, **kwargs)
                            def dt_max(self, *args, **kwargs):
                                """
                                Set maximum value for pseudo time step size.
                                """
                                return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_time/auto_dt_advanced_controls/dt_max").execute(*args, **kwargs)
                            def dt_factor_min(self, *args, **kwargs):
                                """
                                Set minimum limit for reduction in pseudo time step size.
                                """
                                return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_time/auto_dt_advanced_controls/dt_factor_min").execute(*args, **kwargs)
                            def dt_factor_max(self, *args, **kwargs):
                                """
                                Set maximum limit for increase in pseudo time step size.
                                """
                                return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_time/auto_dt_advanced_controls/dt_factor_max").execute(*args, **kwargs)
                            def max_velocity_ratio(self, *args, **kwargs):
                                """
                                Set velocity ratio to freeze the time step size for better solution stability.
                                """
                                return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/pseudo_time/auto_dt_advanced_controls/max_velocity_ratio").execute(*args, **kwargs)

                    class p_v_coupling(metaclass=PyMenuMeta):
                        """
                        Pressure velocity coupling controls for multiphase flow.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.coupled_vof = self.__class__.coupled_vof(path + [("coupled_vof", None)], service)
                            self.rhie_chow_flux = self.__class__.rhie_chow_flux(path + [("rhie_chow_flux", None)], service)
                            self.skewness_correction = self.__class__.skewness_correction(path + [("skewness_correction", None)], service)

                        class coupled_vof(metaclass=PyMenuMeta):
                            """
                            Set Coupled VOF stability controls.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def buoyancy_force_linearization(self, *args, **kwargs):
                                """
                                Set buoynacy force linerization options in coupled vof.
                                """
                                return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/p_v_coupling/coupled_vof/buoyancy_force_linearization").execute(*args, **kwargs)

                        class rhie_chow_flux(metaclass=PyMenuMeta):
                            """
                            Set Rhie-Chow related stability controls.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def low_order_rhie_chow(self, *args, **kwargs):
                                """
                                Use low order velocity interpolation in flux calculation.
                                """
                                return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/p_v_coupling/rhie_chow_flux/low_order_rhie_chow").execute(*args, **kwargs)

                        class skewness_correction(metaclass=PyMenuMeta):
                            """
                            Skewness correction related stabiity controls for multiphase flow.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def limit_pressure_correction_gradient(self, *args, **kwargs):
                                """
                                Use limited pressure correction gradient in skewness corrections for better stability.
                                """
                                return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/p_v_coupling/skewness_correction/limit_pressure_correction_gradient").execute(*args, **kwargs)

                    class hybrid_nita(metaclass=PyMenuMeta):
                        """
                        Hybrid NITA stability controls for multiphase flow.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.instability_detector = self.__class__.instability_detector(path + [("instability_detector", None)], service)
                        def outer_iterations(self, *args, **kwargs):
                            """
                            Set number of outer iterations in hybrid nita.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/hybrid_nita/outer_iterations").execute(*args, **kwargs)
                        def initial_outer_iterations(self, *args, **kwargs):
                            """
                            Set hybrid nita start-up controls.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/hybrid_nita/initial_outer_iterations").execute(*args, **kwargs)

                        class instability_detector(metaclass=PyMenuMeta):
                            """
                            Set Hybrid NITA instability detector controls.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def enable_instability_detector(self, *args, **kwargs):
                                """
                                Enable instability detector for better stability.
                                """
                                return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/enable_instability_detector").execute(*args, **kwargs)
                            def set_cfl_limit(self, *args, **kwargs):
                                """
                                Set Courant Number limit for detection of unstable event.
                                """
                                return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/set_cfl_limit").execute(*args, **kwargs)
                            def set_cfl_type(self, *args, **kwargs):
                                """
                                Set Courant Number type for detection of unstable event.
                                """
                                return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/set_cfl_type").execute(*args, **kwargs)
                            def set_velocity_limit(self, *args, **kwargs):
                                """
                                Set velocity limit for detection of unstable event.
                                """
                                return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/set_velocity_limit").execute(*args, **kwargs)
                            def unstable_event_outer_iterations(self, *args, **kwargs):
                                """
                                Set number of outer iterations for unstable event.
                                """
                                return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/hybrid_nita/instability_detector/unstable_event_outer_iterations").execute(*args, **kwargs)

                    class equation_order(metaclass=PyMenuMeta):
                        """
                        Equation Order Menu for Homogeneous Multiphase Flow Models.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def solve_flow_last(self, *args, **kwargs):
                            """
                            Solve flow equation at the end of iteration as an alternative.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/equation_order/solve_flow_last").execute(*args, **kwargs)
                        def solve_exp_vof_at_end(self, *args, **kwargs):
                            """
                            Solve Explicit VOF at the end of time-step as an alternative.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/equation_order/solve_exp_vof_at_end").execute(*args, **kwargs)

                    class anti_diffusion(metaclass=PyMenuMeta):
                        """
                        Anti Diffusion Menu for VOF/Multi-Fluid VOF Models.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def enable_dynamic_strength(self, *args, **kwargs):
                            """
                            Enable dynamic strength to reduce compression in the tangential direction to the interface.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/anti_diffusion/enable_dynamic_strength").execute(*args, **kwargs)
                        def set_dynamic_strength_exponent(self, *args, **kwargs):
                            """
                            Set cosine exponent in dynamic strength treatment.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/anti_diffusion/set_dynamic_strength_exponent").execute(*args, **kwargs)
                        def set_maximum_dynamic_strength(self, *args, **kwargs):
                            """
                            Set maximum value of dynamic anti-diffusion strength.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/advanced_stability_controls/anti_diffusion/set_maximum_dynamic_strength").execute(*args, **kwargs)

                class default_controls(metaclass=PyMenuMeta):
                    """
                    Multiphase default controls menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def recommended_defaults_for_existing_cases(self, *args, **kwargs):
                        """
                        Activate multiphase defaults for loaded case.
                        """
                        return PyMenu(self.service, "/solve/set/multiphase_numerics/default_controls/recommended_defaults_for_existing_cases").execute(*args, **kwargs)
                    def revert_to_pre_r20_point_1_default_settings(self, *args, **kwargs):
                        """
                        Revert to pre-R20.1 multiphase flow default settings.
                        """
                        return PyMenu(self.service, "/solve/set/multiphase_numerics/default_controls/revert_to_pre_r20_point_1_default_settings").execute(*args, **kwargs)

                class face_pressure_controls(metaclass=PyMenuMeta):
                    """
                    Enter the face pressure expert controls menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def face_pressure_options(self, *args, **kwargs):
                        """
                        Set face pressure options.
                        """
                        return PyMenu(self.service, "/solve/set/multiphase_numerics/face_pressure_controls/face_pressure_options").execute(*args, **kwargs)

                class solution_stabilization(metaclass=PyMenuMeta):
                    """
                    VOF solution stabilization menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.additional_stabilization_controls = self.__class__.additional_stabilization_controls(path + [("additional_stabilization_controls", None)], service)
                        self.velocity_limiting_treatment = self.__class__.velocity_limiting_treatment(path + [("velocity_limiting_treatment", None)], service)
                    def execute_settings_optimization(self, *args, **kwargs):
                        """
                        Execute optimized settings for VOF.
                        """
                        return PyMenu(self.service, "/solve/set/multiphase_numerics/solution_stabilization/execute_settings_optimization").execute(*args, **kwargs)
                    def execute_advanced_stabilization(self, *args, **kwargs):
                        """
                        Execute advanced stabilization for VOF.
                        """
                        return PyMenu(self.service, "/solve/set/multiphase_numerics/solution_stabilization/execute_advanced_stabilization").execute(*args, **kwargs)
                    def execute_additional_stability_controls(self, *args, **kwargs):
                        """
                        Execute additional stability controls for VOF.
                        """
                        return PyMenu(self.service, "/solve/set/multiphase_numerics/solution_stabilization/execute_additional_stability_controls").execute(*args, **kwargs)

                    class additional_stabilization_controls(metaclass=PyMenuMeta):
                        """
                        Additional advanced stability controls for VOF.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def blended_compressive_scheme(self, *args, **kwargs):
                            """
                            Blended Compressive discretization scheme for VOF.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/solution_stabilization/additional_stabilization_controls/blended_compressive_scheme").execute(*args, **kwargs)
                        def pseudo_time_stabilization(self, *args, **kwargs):
                            """
                            Pseudo-Time Momentum stabilization and False Time Step Linearization methods for VOF.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/solution_stabilization/additional_stabilization_controls/pseudo_time_stabilization").execute(*args, **kwargs)

                    class velocity_limiting_treatment(metaclass=PyMenuMeta):
                        """
                        Velocity limiting related stabiity controls for VOF.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def enable_velocity_limiting(self, *args, **kwargs):
                            """
                            Enable velocity limiting treatment.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/enable_velocity_limiting").execute(*args, **kwargs)
                        def set_velocity_and_vof_cutoffs(self, *args, **kwargs):
                            """
                            Set phase based velocity limiting controls.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_velocity_and_vof_cutoffs").execute(*args, **kwargs)
                        def set_damping_strengths(self, *args, **kwargs):
                            """
                            Set phase based damping strength.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_damping_strengths").execute(*args, **kwargs)
                        def set_velocity_cutoff(self, *args, **kwargs):
                            """
                            Enter max velocity magnitude.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_velocity_cutoff").execute(*args, **kwargs)
                        def set_damping_strength(self, *args, **kwargs):
                            """
                            Enter damping strength.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/set_damping_strength").execute(*args, **kwargs)
                        def verbosity(self, *args, **kwargs):
                            """
                            Enable verbosity to print number of velocity limited cells during iterations.
                            """
                            return PyMenu(self.service, "/solve/set/multiphase_numerics/solution_stabilization/velocity_limiting_treatment/verbosity").execute(*args, **kwargs)

            class open_channel_wave_options(metaclass=PyMenuMeta):
                """
                Enter the open-channel-wave-options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def set_verbosity(self, *args, **kwargs):
                    """
                    Set open channel wave verbosity.
                    """
                    return PyMenu(self.service, "/solve/set/open_channel_wave_options/set_verbosity").execute(*args, **kwargs)
                def stokes_wave_variants(self, *args, **kwargs):
                    """
                    Set stokes wave theory variants.
                    """
                    return PyMenu(self.service, "/solve/set/open_channel_wave_options/stokes_wave_variants").execute(*args, **kwargs)
                def set_buffer_layer_ht(self, *args, **kwargs):
                    """
                    Set bufer layer height between phases for segregated velocity inputs.
                    """
                    return PyMenu(self.service, "/solve/set/open_channel_wave_options/set_buffer_layer_ht").execute(*args, **kwargs)

            class high_order_term_relaxation(metaclass=PyMenuMeta):
                """
                Enter High Order Relaxation Menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.options = self.__class__.options(path + [("options", None)], service)
                def enable(self, *args, **kwargs):
                    """
                    Enable/Disable High Order Term Relaxation.
                    """
                    return PyMenu(self.service, "/solve/set/high_order_term_relaxation/enable").execute(*args, **kwargs)

                class options(metaclass=PyMenuMeta):
                    """
                    High Order Term Relaxation Options.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.variables = self.__class__.variables(path + [("variables", None)], service)
                    def relaxation_factor(self, *args, **kwargs):
                        """
                        Sets relaxation factor.
                        """
                        return PyMenu(self.service, "/solve/set/high_order_term_relaxation/options/relaxation_factor").execute(*args, **kwargs)
                    def expert(self, *args, **kwargs):
                        """
                        Enter high order relaxation option with respect to diffusion gradient.
                        """
                        return PyMenu(self.service, "/solve/set/high_order_term_relaxation/options/expert").execute(*args, **kwargs)

                    class variables(metaclass=PyMenuMeta):
                        """
                        Select Variables.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def select(self, *args, **kwargs):
                            """
                            Select variables for high order term relaxation.
                            """
                            return PyMenu(self.service, "/solve/set/high_order_term_relaxation/options/variables/select").execute(*args, **kwargs)

            class poor_mesh_numerics(metaclass=PyMenuMeta):
                """
                Enter Poor Mesh Numerics Menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.solution_based_pmn = self.__class__.solution_based_pmn(path + [("solution_based_pmn", None)], service)
                def enable(self, *args, **kwargs):
                    """
                    Solution correction on meshes of poor quality.
                    """
                    return PyMenu(self.service, "/solve/set/poor_mesh_numerics/enable").execute(*args, **kwargs)
                def cell_quality_based(self, *args, **kwargs):
                    """
                    Enable/disable poor mesh numerics on cells with low quality.
                    """
                    return PyMenu(self.service, "/solve/set/poor_mesh_numerics/cell_quality_based").execute(*args, **kwargs)
                def set_quality_threshold(self, *args, **kwargs):
                    """
                    Set quality threshold.
                    """
                    return PyMenu(self.service, "/solve/set/poor_mesh_numerics/set_quality_threshold").execute(*args, **kwargs)
                def solution_and_quality_based(self, *args, **kwargs):
                    """
                    Enable/disable poor mesh numerics based on solution and cell quality.
                    """
                    return PyMenu(self.service, "/solve/set/poor_mesh_numerics/solution_and_quality_based").execute(*args, **kwargs)
                def gradient_quality_based(self, *args, **kwargs):
                    """
                    Enable/disable poor mesh numerics based on cell gradient quality.
                    """
                    return PyMenu(self.service, "/solve/set/poor_mesh_numerics/gradient_quality_based").execute(*args, **kwargs)
                def orthogonality_enhancing_cell_centroids(self, *args, **kwargs):
                    """
                    Relocate select cell centroids, to improve orthogonality metrics and solution stability.
                    """
                    return PyMenu(self.service, "/solve/set/poor_mesh_numerics/orthogonality_enhancing_cell_centroids").execute(*args, **kwargs)
                def user_defined_on_register(self, *args, **kwargs):
                    """
                    Include cells in register in poor mesh numerics.
                    """
                    return PyMenu(self.service, "/solve/set/poor_mesh_numerics/user_defined_on_register").execute(*args, **kwargs)
                def reset_poor_elements(self, *args, **kwargs):
                    """
                    Reset marking of poor cell elements.
                    """
                    return PyMenu(self.service, "/solve/set/poor_mesh_numerics/reset_poor_elements").execute(*args, **kwargs)
                def print_poor_elements_count(self, *args, **kwargs):
                    """
                    Print poor cells count.
                    """
                    return PyMenu(self.service, "/solve/set/poor_mesh_numerics/print_poor_elements_count").execute(*args, **kwargs)
                def enhanced_pmn(self, *args, **kwargs):
                    """
                    This option is available with the density-based solver. When enabled, it will apply quality-based poor-mesh-numerics order=1 on any cells with a quality-measure below 0.2. In addition, their CFL number is limited to 1.0.
                    """
                    return PyMenu(self.service, "/solve/set/poor_mesh_numerics/enhanced_pmn").execute(*args, **kwargs)

                class solution_based_pmn(metaclass=PyMenuMeta):
                    """
                    Solution based poor-mesh numerics menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def enable(self, *args, **kwargs):
                        """
                        Enable solution based treatment.
                        """
                        return PyMenu(self.service, "/solve/set/poor_mesh_numerics/solution_based_pmn/enable").execute(*args, **kwargs)
                    def mark_primary_solution_limits(self, *args, **kwargs):
                        """
                        Mark cells violating solution limits.
                        """
                        return PyMenu(self.service, "/solve/set/poor_mesh_numerics/solution_based_pmn/mark_primary_solution_limits").execute(*args, **kwargs)
                    def mark_velocity_limit(self, *args, **kwargs):
                        """
                        Mark cells exceeding velocity limit.
                        """
                        return PyMenu(self.service, "/solve/set/poor_mesh_numerics/solution_based_pmn/mark_velocity_limit").execute(*args, **kwargs)
                    def mark_cfl_limit(self, *args, **kwargs):
                        """
                        Mark cells exceeding cfl limit.
                        """
                        return PyMenu(self.service, "/solve/set/poor_mesh_numerics/solution_based_pmn/mark_cfl_limit").execute(*args, **kwargs)
                    def mark_cfl_jump(self, *args, **kwargs):
                        """
                        Mark cells exceeding cfl jump in neighborhood.
                        """
                        return PyMenu(self.service, "/solve/set/poor_mesh_numerics/solution_based_pmn/mark_cfl_jump").execute(*args, **kwargs)

            class amg_options(metaclass=PyMenuMeta):
                """
                Enter AMG options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def laplace_coarsening(self, *args, **kwargs):
                    """
                    Set AMG laplace coarsening options.
                    """
                    return PyMenu(self.service, "/solve/set/amg_options/laplace_coarsening").execute(*args, **kwargs)
                def conservative_amg_coarsening(self, *args, **kwargs):
                    """
                    Use conservative AMG coarsening?.
                    """
                    return PyMenu(self.service, "/solve/set/amg_options/conservative_amg_coarsening").execute(*args, **kwargs)
                def aggressive_amg_coarsening(self, *args, **kwargs):
                    """
                    Use aggressive AMG coarsening.
                    """
                    return PyMenu(self.service, "/solve/set/amg_options/aggressive_amg_coarsening").execute(*args, **kwargs)
                def amg_gpgpu_options(self, *args, **kwargs):
                    """
                    Set GPGPU AMG solver options.
                    """
                    return PyMenu(self.service, "/solve/set/amg_options/amg_gpgpu_options").execute(*args, **kwargs)

            class warped_face_gradient_correction(metaclass=PyMenuMeta):
                """
                Enter warped-face-gradient-correction menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def enable(self, *args, **kwargs):
                    """
                    Enable Warped-Face Gradient Correction.
                    """
                    return PyMenu(self.service, "/solve/set/warped_face_gradient_correction/enable").execute(*args, **kwargs)
                def turbulence_options(self, *args, **kwargs):
                    """
                    Set turbulence Warped Face Gradient Correction.
                    """
                    return PyMenu(self.service, "/solve/set/warped_face_gradient_correction/turbulence_options").execute(*args, **kwargs)

            class fast_transient_settings(metaclass=PyMenuMeta):
                """
                Enter the fast transient settings menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def rk2(self, *args, **kwargs):
                    """
                    Enable the use of a two-stage Runge-Kutta scheme for time integration.
                    """
                    return PyMenu(self.service, "/solve/set/fast_transient_settings/rk2").execute(*args, **kwargs)

            class divergence_prevention(metaclass=PyMenuMeta):
                """
                Enter the divergence prevention menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def enable(self, *args, **kwargs):
                    """
                    Enable divergence prevention.
                    """
                    return PyMenu(self.service, "/solve/set/divergence_prevention/enable").execute(*args, **kwargs)

            class advanced(metaclass=PyMenuMeta):
                """
                Enter the advanced settings menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.non_reflecting_boundary_treatment = self.__class__.non_reflecting_boundary_treatment(path + [("non_reflecting_boundary_treatment", None)], service)
                    self.secondary_gradient_limiting = self.__class__.secondary_gradient_limiting(path + [("secondary_gradient_limiting", None)], service)
                    self.turbo_solver_options = self.__class__.turbo_solver_options(path + [("turbo_solver_options", None)], service)
                def energy_numerical_noise_filter(self, *args, **kwargs):
                    """
                    The energy equation numerical noise filter can be enabled to eliminate non-physical numerical noise in the energy field.
                    The numerical noise can appear in solution fields where large variations in specific heat or combustion with phase change are present.
                    Using the energy equation numerical noise filter increases robustness, but may make the solution slightly more diffusive.
                    """
                    return PyMenu(self.service, "/solve/set/advanced/energy_numerical_noise_filter").execute(*args, **kwargs)
                def linearized_mass_transfer_udf(self, *args, **kwargs):
                    """
                    Use linearized mass transfer UDFs?.
                    """
                    return PyMenu(self.service, "/solve/set/advanced/linearized_mass_transfer_udf").execute(*args, **kwargs)
                def singhal_et_al_cavitation_model(self, *args, **kwargs):
                    """
                    Use Singhal-et-al cavitation model?.
                    """
                    return PyMenu(self.service, "/solve/set/advanced/singhal_et_al_cavitation_model").execute(*args, **kwargs)
                def alternate_wall_temp_formulation(self, *args, **kwargs):
                    """
                    Alternate formulation for wall temperatures?.
                    """
                    return PyMenu(self.service, "/solve/set/advanced/alternate_wall_temp_formulation").execute(*args, **kwargs)
                def retain_cell_residuals(self, *args, **kwargs):
                    """
                    Retain cell residuals for postprocessing?.
                    """
                    return PyMenu(self.service, "/solve/set/advanced/retain_cell_residuals").execute(*args, **kwargs)
                def retain_temporary_solver_mem(self, *args, **kwargs):
                    """
                    Retain temporary solver memory?.
                    """
                    return PyMenu(self.service, "/solve/set/advanced/retain_temporary_solver_mem").execute(*args, **kwargs)
                def show_all_discretization_schemes(self, *args, **kwargs):
                    """
                    Allow selection of all applicable discretization schemes?.
                    """
                    return PyMenu(self.service, "/solve/set/advanced/show_all_discretization_schemes").execute(*args, **kwargs)
                def explicit_under_relaxation_value(self, *args, **kwargs):
                    """
                    Explicit under-relaxation value.
                    """
                    return PyMenu(self.service, "/solve/set/advanced/explicit_under_relaxation_value").execute(*args, **kwargs)
                def correction_form(self, *args, **kwargs):
                    """
                    Discretize momentum equations in correction form for the pressure-based solver.
                    """
                    return PyMenu(self.service, "/solve/set/advanced/correction_form").execute(*args, **kwargs)
                def energy_reconstruction_gradient_limiting(self, *args, **kwargs):
                    """
                    Enable limiting of reconstruction gradient for the energy equation.
                    """
                    return PyMenu(self.service, "/solve/set/advanced/energy_reconstruction_gradient_limiting").execute(*args, **kwargs)
                def bcd_boundedness(self, *args, **kwargs):
                    """
                    BCD scheme boundedness strength, constant or expression (0 to 1).
                    """
                    return PyMenu(self.service, "/solve/set/advanced/bcd_boundedness").execute(*args, **kwargs)
                def bcd_weights_freeze(self, *args, **kwargs):
                    """
                    At each timestep, freeze BCD scheme weights after specified iteration
                    in order to improve timestep convergence.
                    """
                    return PyMenu(self.service, "/solve/set/advanced/bcd_weights_freeze").execute(*args, **kwargs)
                def anisotropic_heat_flux(self, *args, **kwargs):
                    """
                    Select the heat flux calculation methods.
                    """
                    return PyMenu(self.service, "/solve/set/advanced/anisotropic_heat_flux").execute(*args, **kwargs)
                def skewness_correction_enhanced(self, *args, **kwargs):
                    """
                    Enable enhanced skewness correction scheme.
                    """
                    return PyMenu(self.service, "/solve/set/advanced/skewness_correction_enhanced").execute(*args, **kwargs)

                class non_reflecting_boundary_treatment(metaclass=PyMenuMeta):
                    """
                    Enter non reflecting boundary treatment using minimal pressure reflection approach menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def pressure_inlet(self, *args, **kwargs):
                        """
                        Enabling the use of minimal pressure reflection treatment. This treatment will minimize pressure wave reflections from the boundaries on which this option is active, but not necessarily fully eliminating them. The reflections would be of an acceptable limit in order to not contaminate the solution, the simulation will gain from the robustness of the new algorithm compared to traditional non-reflecting boundary condition treatment.
                        """
                        return PyMenu(self.service, "/solve/set/advanced/non_reflecting_boundary_treatment/pressure_inlet").execute(*args, **kwargs)
                    def pressure_outlet(self, *args, **kwargs):
                        """
                        Enabling the use of minimal pressure reflection treatment. This treatment will minimize pressure wave reflections from the boundaries on which this option is active, but not necessarily fully eliminating them. The reflections would be of an acceptable limit in order to not contaminate the solution, the simulation will gain from the robustness of the new algorithm compared to traditional non-reflecting boundary condition treatment.
                        """
                        return PyMenu(self.service, "/solve/set/advanced/non_reflecting_boundary_treatment/pressure_outlet").execute(*args, **kwargs)
                    def velocity_inlet(self, *args, **kwargs):
                        """
                        Enabling the use of minimal pressure reflection treatment. This treatment will minimize pressure wave reflections from the boundaries on which this option is active, but not necessarily fully eliminating them. The reflections would be of an acceptable limit in order to not contaminate the solution, the simulation will gain from the robustness of the new algorithm compared to traditional non-reflecting boundary condition treatment.
                        """
                        return PyMenu(self.service, "/solve/set/advanced/non_reflecting_boundary_treatment/velocity_inlet").execute(*args, **kwargs)

                class secondary_gradient_limiting(metaclass=PyMenuMeta):
                    """
                    Enter the Secondary Gradient Limiting Menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def energy(self, *args, **kwargs):
                        """
                        Enable/disable secondary gradient limiting at coupled walls for energy equation.
                        """
                        return PyMenu(self.service, "/solve/set/advanced/secondary_gradient_limiting/energy").execute(*args, **kwargs)
                    def uds(self, *args, **kwargs):
                        """
                        Enable/disable secondary gradient limiting at coupled walls for user-defined scalars.
                        """
                        return PyMenu(self.service, "/solve/set/advanced/secondary_gradient_limiting/uds").execute(*args, **kwargs)
                    def mesh_quality_limits(self, *args, **kwargs):
                        """
                        Specify minimum and maximum mesh quality limits.
                        """
                        return PyMenu(self.service, "/solve/set/advanced/secondary_gradient_limiting/mesh_quality_limits").execute(*args, **kwargs)

                class turbo_solver_options(metaclass=PyMenuMeta):
                    """
                    Enter turbo expert solver options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def enable(self, *args, **kwargs):
                        """
                        Enable/disable turbomachinery expert solver options.
                        """
                        return PyMenu(self.service, "/solve/set/advanced/turbo_solver_options/enable").execute(*args, **kwargs)
                    def continuity_relaxation_at_walls(self, *args, **kwargs):
                        """
                        Enable and specify options for continuity relaxation at wall boundaries.
                        """
                        return PyMenu(self.service, "/solve/set/advanced/turbo_solver_options/continuity_relaxation_at_walls").execute(*args, **kwargs)

            class high_speed_numerics(metaclass=PyMenuMeta):
                """
                Enter high-speed-numerics menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def enable(self, *args, **kwargs):
                    """
                    Enable/disable high-speed-numerics.
                    """
                    return PyMenu(self.service, "/solve/set/high_speed_numerics/enable").execute(*args, **kwargs)
                def expert(self, *args, **kwargs):
                    """
                    Expert high-speed-numerics.
                    """
                    return PyMenu(self.service, "/solve/set/high_speed_numerics/expert").execute(*args, **kwargs)
                def visualize_pressure_discontinuity_sensor(self, *args, **kwargs):
                    """
                    Enable/disable pressure-discontinuity-sensor visualization.
                    """
                    return PyMenu(self.service, "/solve/set/high_speed_numerics/visualize_pressure_discontinuity_sensor").execute(*args, **kwargs)

            class previous_defaults(metaclass=PyMenuMeta):
                """
                Enter previous defaults menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def undo_r19_point_0_default_changes(self, *args, **kwargs):
                    """
                    Undo default changes introduced in R19.0.
                    """
                    return PyMenu(self.service, "/solve/set/previous_defaults/undo_r19_point_0_default_changes").execute(*args, **kwargs)
                def undo_2019r1_default_changes(self, *args, **kwargs):
                    """
                    Undo default changes introduced in 2019R1.
                    """
                    return PyMenu(self.service, "/solve/set/previous_defaults/undo_2019r1_default_changes").execute(*args, **kwargs)
                def undo_2019r3_default_changes(self, *args, **kwargs):
                    """
                    Undo default changes introduced in 2019R3.
                    """
                    return PyMenu(self.service, "/solve/set/previous_defaults/undo_2019r3_default_changes").execute(*args, **kwargs)
                def undo_2021r1_default_changes(self, *args, **kwargs):
                    """
                    Undo default changes introduced in 2021R1.
                    """
                    return PyMenu(self.service, "/solve/set/previous_defaults/undo_2021r1_default_changes").execute(*args, **kwargs)
                def undo_2021r2_default_changes(self, *args, **kwargs):
                    """
                    Undo default changes introduced in 2021R2.
                    """
                    return PyMenu(self.service, "/solve/set/previous_defaults/undo_2021r2_default_changes").execute(*args, **kwargs)
                def undo_2022r1_default_changes(self, *args, **kwargs):
                    """
                    Undo default changes introduced in 2022R1.
                    """
                    return PyMenu(self.service, "/solve/set/previous_defaults/undo_2022r1_default_changes").execute(*args, **kwargs)

            class overset(metaclass=PyMenuMeta):
                """
                Enter overset solver options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.expert = self.__class__.expert(path + [("expert", None)], service)
                def high_order_pressure(self, *args, **kwargs):
                    """
                    High order pressure extrapolation at overset interface.
                    """
                    return PyMenu(self.service, "/solve/set/overset/high_order_pressure").execute(*args, **kwargs)
                def interpolation_method(self, *args, **kwargs):
                    """
                    Choose the interpolation method for overset interface(s).
                    """
                    return PyMenu(self.service, "/solve/set/overset/interpolation_method").execute(*args, **kwargs)
                def orphan_cell_treatment(self, *args, **kwargs):
                    """
                    Enable solver to run with orphans present.
                    """
                    return PyMenu(self.service, "/solve/set/overset/orphan_cell_treatment").execute(*args, **kwargs)

                class expert(metaclass=PyMenuMeta):
                    """
                    Enter overset expert solver options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def mass_flux_correction_method(self, *args, **kwargs):
                        """
                        Enter mass flux correction option at overset interfaces.
                        """
                        return PyMenu(self.service, "/solve/set/overset/expert/mass_flux_correction_method").execute(*args, **kwargs)
                    def hybrid_mode_selection(self, *args, **kwargs):
                        """
                        Mode for hybrid interpolation.
                        """
                        return PyMenu(self.service, "/solve/set/overset/expert/hybrid_mode_selection").execute(*args, **kwargs)

            class acoustics_wave_equation_controls(metaclass=PyMenuMeta):
                """
                Enter menu for acoustics wave equation solver controls.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.expert = self.__class__.expert(path + [("expert", None)], service)
                def relative_convergence_criterion(self, *args, **kwargs):
                    """
                    Specify convergence tolerance for the timestep iterations
                    as the target residual reduction factor.
                    """
                    return PyMenu(self.service, "/solve/set/acoustics_wave_equation_controls/relative_convergence_criterion").execute(*args, **kwargs)
                def max_iterations_per_timestep(self, *args, **kwargs):
                    """
                    Specify maximum number of iterations per timestep.
                    """
                    return PyMenu(self.service, "/solve/set/acoustics_wave_equation_controls/max_iterations_per_timestep").execute(*args, **kwargs)

                class expert(metaclass=PyMenuMeta):
                    """
                    Enter menu for expert controls.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def under_relaxation_factor(self, *args, **kwargs):
                        """
                        Specify under-relaxation factor to be used in 
                        the diagonal matrix elements of implicit solver.
                        """
                        return PyMenu(self.service, "/solve/set/acoustics_wave_equation_controls/expert/under_relaxation_factor").execute(*args, **kwargs)
                    def explicit_relaxation_factor(self, *args, **kwargs):
                        """
                        Specify explicit relaxation factor to be applied to
                        the solution correction when updating solution in the timestep iterations.
                        """
                        return PyMenu(self.service, "/solve/set/acoustics_wave_equation_controls/expert/explicit_relaxation_factor").execute(*args, **kwargs)

            class p_v_controls_advanced(metaclass=PyMenuMeta):
                """
                Set advanced pressure-velocity coupling controls.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def pp_face_gradient_linearization(self, *args, **kwargs):
                    """
                    End of pp-face-gradient-linearization.
                    """
                    return PyMenu(self.service, "/solve/set/p_v_controls_advanced/pp_face_gradient_linearization").execute(*args, **kwargs)
                def pp_face_interpolation(self, *args, **kwargs):
                    """
                    End of pp-face-interpolation.
                    """
                    return PyMenu(self.service, "/solve/set/p_v_controls_advanced/pp_face_interpolation").execute(*args, **kwargs)
                def pp_node_based_grad(self, *args, **kwargs):
                    """
                    End of pp-node-based-grad.
                    """
                    return PyMenu(self.service, "/solve/set/p_v_controls_advanced/pp_node_based_grad").execute(*args, **kwargs)

        class execute_commands(metaclass=PyMenuMeta):
            """
            Enter the execute-monitor-commands menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def add_edit(self, *args, **kwargs):
                """
                Add or edit execute-commands.
                """
                return PyMenu(self.service, "/solve/execute_commands/add_edit").execute(*args, **kwargs)
            def enable(self, *args, **kwargs):
                """
                Enable an execute-command.
                """
                return PyMenu(self.service, "/solve/execute_commands/enable").execute(*args, **kwargs)
            def disable(self, *args, **kwargs):
                """
                Disable an execute-command.
                """
                return PyMenu(self.service, "/solve/execute_commands/disable").execute(*args, **kwargs)
            def copy(self, *args, **kwargs):
                """
                Copy an execute-command.
                """
                return PyMenu(self.service, "/solve/execute_commands/copy").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an execute-command.
                """
                return PyMenu(self.service, "/solve/execute_commands/delete").execute(*args, **kwargs)
            def export(self, *args, **kwargs):
                """
                Export execute-commands to a TSV file.
                """
                return PyMenu(self.service, "/solve/execute_commands/export").execute(*args, **kwargs)
            def import_(self, *args, **kwargs):
                """
                Import execute-commands from a TSV file.
                """
                return PyMenu(self.service, "/solve/execute_commands/import").execute(*args, **kwargs)

    class setup(metaclass=PyMenuMeta):
        """
        Enter setup menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
            self.boundary_conditions = self.__class__.boundary_conditions(path + [("boundary_conditions", None)], service)
            self.dynamic_mesh = self.__class__.dynamic_mesh(path + [("dynamic_mesh", None)], service)
            self.expert = self.__class__.expert(path + [("expert", None)], service)
            self.gap_model = self.__class__.gap_model(path + [("gap_model", None)], service)
            self.materials = self.__class__.materials(path + [("materials", None)], service)
            self.mesh_interfaces = self.__class__.mesh_interfaces(path + [("mesh_interfaces", None)], service)
            self.mixing_planes = self.__class__.mixing_planes(path + [("mixing_planes", None)], service)
            self.models = self.__class__.models(path + [("models", None)], service)
            self.named_expressions = self.__class__.named_expressions(path + [("named_expressions", None)], service)
            self.operating_conditions = self.__class__.operating_conditions(path + [("operating_conditions", None)], service)
            self.overset_interfaces = self.__class__.overset_interfaces(path + [("overset_interfaces", None)], service)
            self.reference_frames = self.__class__.reference_frames(path + [("reference_frames", None)], service)
            self.reference_values = self.__class__.reference_values(path + [("reference_values", None)], service)
            self.turbo_model = self.__class__.turbo_model(path + [("turbo_model", None)], service)

        class boundary_conditions(metaclass=PyMenuMeta):
            """
            Enter the boudary conditions menu.
            """
            is_extended_tui = True
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.bc_settings = self.__class__.bc_settings(path + [("bc_settings", None)], service)
                self.expert = self.__class__.expert(path + [("expert", None)], service)
                self.mass_flow_inlet = self.__class__.mass_flow_inlet(path + [("mass_flow_inlet", None)], None, service)
                self.modify_zones = self.__class__.modify_zones(path + [("modify_zones", None)], service)
                self.periodic = self.__class__.periodic(path + [("periodic", None)], None, service)
                self.pressure_far_field = self.__class__.pressure_far_field(path + [("pressure_far_field", None)], None, service)
                self.pressure_inlet = self.__class__.pressure_inlet(path + [("pressure_inlet", None)], None, service)
                self.pressure_outlet = self.__class__.pressure_outlet(path + [("pressure_outlet", None)], None, service)
                self.profiles = self.__class__.profiles(path + [("profiles", None)], service)
                self.query = self.__class__.query(path + [("query", None)], service)
                self.rename_zone = self.__class__.rename_zone(path + [("rename_zone", None)], service)
                self.set = self.__class__.set(path + [("set", None)], service)
                self.symmetry = self.__class__.symmetry(path + [("symmetry", None)], None, service)
                self.velocity_inlet = self.__class__.velocity_inlet(path + [("velocity_inlet", None)], None, service)
                self.wall = self.__class__.wall(path + [("wall", None)], None, service)
            def axis(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/axis").execute(*args, **kwargs)
            def copy_bc(self, *args, **kwargs):
                """
                Copy boundary conditions to another zone.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/copy_bc").execute(*args, **kwargs)
            def degassing(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/degassing").execute(*args, **kwargs)
            def exhaust_fan(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/exhaust_fan").execute(*args, **kwargs)
            def fan(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/fan").execute(*args, **kwargs)
            def fluid(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/fluid").execute(*args, **kwargs)
            def geometry(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/geometry").execute(*args, **kwargs)
            def inlet_vent(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/inlet_vent").execute(*args, **kwargs)
            def intake_fan(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/intake_fan").execute(*args, **kwargs)
            def interface(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/interface").execute(*args, **kwargs)
            def interior(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/interior").execute(*args, **kwargs)
            def list_zones(self, *args, **kwargs):
                """
                List zone IDs, types, kinds, and names.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/list_zones").execute(*args, **kwargs)
            def mass_flow_outlet(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/mass_flow_outlet").execute(*args, **kwargs)
            def network(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/network").execute(*args, **kwargs)
            def network_end(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/network_end").execute(*args, **kwargs)
            def outflow(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/outflow").execute(*args, **kwargs)
            def outlet_vent(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/outlet_vent").execute(*args, **kwargs)
            def overset(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/overset").execute(*args, **kwargs)
            def porous_jump(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/porous_jump").execute(*args, **kwargs)
            def radiator(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/radiator").execute(*args, **kwargs)
            def rans_les_interface(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/rans_les_interface").execute(*args, **kwargs)
            def recirculation_inlet(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/recirculation_inlet").execute(*args, **kwargs)
            def recirculation_outlet(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/recirculation_outlet").execute(*args, **kwargs)
            def shadow(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/shadow").execute(*args, **kwargs)
            def solid(self, *args, **kwargs):
                """
                Set boundary conditions for a zone of this type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/solid").execute(*args, **kwargs)
            def zone_name(self, *args, **kwargs):
                """
                Give a zone a new name.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/zone_name").execute(*args, **kwargs)
            def zone_type(self, *args, **kwargs):
                """
                Set a zone's type.
                """
                return PyMenu(self.service, "/setup/boundary_conditions/zone_type").execute(*args, **kwargs)

            class bc_settings(metaclass=PyMenuMeta):
                """
                .
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.pressure_far_field = self.__class__.pressure_far_field(path + [("pressure_far_field", None)], service)
                def mass_flow(self, *args, **kwargs):
                    """
                    Select method for setting the mass flow rate.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/bc_settings/mass_flow").execute(*args, **kwargs)
                def pressure_outlet(self, *args, **kwargs):
                    """
                    Select pressure specification method on pressure-outlet boundaries.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/bc_settings/pressure_outlet").execute(*args, **kwargs)

                class pressure_far_field(metaclass=PyMenuMeta):
                    """
                    Select presure-far-field boundary-condition options.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def riemann_invariants_tangency_correction(self, *args, **kwargs):
                        """
                        Apply a local correction where the flow is tangential to the boundary.
                        """
                        return PyMenu(self.service, "/setup/boundary_conditions/bc_settings/pressure_far_field/riemann_invariants_tangency_correction").execute(*args, **kwargs)
                    def type_flag(self, *args, **kwargs):
                        """
                        Choose pressure-far-field boundary-condition type.
                        """
                        return PyMenu(self.service, "/setup/boundary_conditions/bc_settings/pressure_far_field/type_flag").execute(*args, **kwargs)

            class expert(metaclass=PyMenuMeta):
                """
                Enter expert bc menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.impedance_data_fitting = self.__class__.impedance_data_fitting(path + [("impedance_data_fitting", None)], service)
                    self.non_reflecting_bc = self.__class__.non_reflecting_bc(path + [("non_reflecting_bc", None)], service)
                    self.perforated_walls = self.__class__.perforated_walls(path + [("perforated_walls", None)], service)
                    self.periodic_conditions = self.__class__.periodic_conditions(path + [("periodic_conditions", None)], service)
                def non_overlapping_zone_name(self, *args, **kwargs):
                    """
                    Get non-overlapping zone name from the associated interface zone.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/expert/non_overlapping_zone_name").execute(*args, **kwargs)
                def openchannel_threads(self, *args, **kwargs):
                    """
                    List open channel group IDs, names, types, and variables.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/expert/openchannel_threads").execute(*args, **kwargs)
                def open_channel_wave_settings(self, *args, **kwargs):
                    """
                    Open channel wave input analysis.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/expert/open_channel_wave_settings").execute(*args, **kwargs)
                def target_mass_flow_rate_settings(self, *args, **kwargs):
                    """
                    Enter the targeted mass flow rate setting menu.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/expert/target_mass_flow_rate_settings").execute(*args, **kwargs)

                class impedance_data_fitting(metaclass=PyMenuMeta):
                    """
                    Enter the impedance data fitting menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def impedance_data(self, *args, **kwargs):
                        """
                        Read experimental impedance data and output impedance parameters for a boundary condition.
                        """
                        return PyMenu(self.service, "/setup/boundary_conditions/expert/impedance_data_fitting/impedance_data").execute(*args, **kwargs)
                    def reflection_data(self, *args, **kwargs):
                        """
                        Read experimental reflection coefficient data and output impedance parameters for a boundary condition.
                        """
                        return PyMenu(self.service, "/setup/boundary_conditions/expert/impedance_data_fitting/reflection_data").execute(*args, **kwargs)
                    def absorption_data(self, *args, **kwargs):
                        """
                        Read experimental absorption coefficient data and output impedance parameters for a boundary condition.
                        """
                        return PyMenu(self.service, "/setup/boundary_conditions/expert/impedance_data_fitting/absorption_data").execute(*args, **kwargs)
                    def iterations(self, *args, **kwargs):
                        """
                        Set the number of iterations for the fitting algorithm.
                        """
                        return PyMenu(self.service, "/setup/boundary_conditions/expert/impedance_data_fitting/iterations").execute(*args, **kwargs)
                    def convergence_tolerance(self, *args, **kwargs):
                        """
                        Set the convergence tolerance for the fitting algorithm.
                        """
                        return PyMenu(self.service, "/setup/boundary_conditions/expert/impedance_data_fitting/convergence_tolerance").execute(*args, **kwargs)
                    def residue_tolerance(self, *args, **kwargs):
                        """
                        Set the residue tolerance for the fitting algorithm.
                        """
                        return PyMenu(self.service, "/setup/boundary_conditions/expert/impedance_data_fitting/residue_tolerance").execute(*args, **kwargs)
                    def verbosity(self, *args, **kwargs):
                        """
                        Set verbosity level [0, 1] for fitting algorithm.
                        """
                        return PyMenu(self.service, "/setup/boundary_conditions/expert/impedance_data_fitting/verbosity").execute(*args, **kwargs)
                    def import_parameters(self, *args, **kwargs):
                        """
                        Import impedance parameters into boundary condition.
                        """
                        return PyMenu(self.service, "/setup/boundary_conditions/expert/impedance_data_fitting/import_parameters").execute(*args, **kwargs)

                class non_reflecting_bc(metaclass=PyMenuMeta):
                    """
                    Enter the non-reflecting b.c. menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.general_nrbc = self.__class__.general_nrbc(path + [("general_nrbc", None)], service)
                        self.turbo_specific_nrbc = self.__class__.turbo_specific_nrbc(path + [("turbo_specific_nrbc", None)], service)

                    class general_nrbc(metaclass=PyMenuMeta):
                        """
                        Enter the menu for setting general non-reflecting boundary conditions.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.set = self.__class__.set(path + [("set", None)], service)

                        class set(metaclass=PyMenuMeta):
                            """
                            Enter the general non-reflecting b.c. menu.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def sigma(self, *args, **kwargs):
                                """
                                Set nrbc sigma factor (default value 0.15).
                                """
                                return PyMenu(self.service, "/setup/boundary_conditions/expert/non_reflecting_bc/general_nrbc/set/sigma").execute(*args, **kwargs)
                            def sigma2(self, *args, **kwargs):
                                """
                                Set nrbc sigma2 factor (default value 5.0).
                                """
                                return PyMenu(self.service, "/setup/boundary_conditions/expert/non_reflecting_bc/general_nrbc/set/sigma2").execute(*args, **kwargs)
                            def relax(self, *args, **kwargs):
                                """
                                Set NRBC relaxation factor (default value 0.5).
                                """
                                return PyMenu(self.service, "/setup/boundary_conditions/expert/non_reflecting_bc/general_nrbc/set/relax").execute(*args, **kwargs)
                            def tangential_source(self, *args, **kwargs):
                                """
                                Include or not NRBC tangential source (default value #t).
                                """
                                return PyMenu(self.service, "/setup/boundary_conditions/expert/non_reflecting_bc/general_nrbc/set/tangential_source").execute(*args, **kwargs)
                            def verbosity(self, *args, **kwargs):
                                """
                                Print boundary equations convergence info.
                                """
                                return PyMenu(self.service, "/setup/boundary_conditions/expert/non_reflecting_bc/general_nrbc/set/verbosity").execute(*args, **kwargs)

                    class turbo_specific_nrbc(metaclass=PyMenuMeta):
                        """
                        Enter the turbo-specific n.r.b.c. menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.set = self.__class__.set(path + [("set", None)], service)
                        def enable(self, *args, **kwargs):
                            """
                            Enable/disable turbo-specific non-reflecting b.c.'s.
                            """
                            return PyMenu(self.service, "/setup/boundary_conditions/expert/non_reflecting_bc/turbo_specific_nrbc/enable").execute(*args, **kwargs)
                        def initialize(self, *args, **kwargs):
                            """
                            Initialize turbo-specific non-reflecting b.c.'s.
                            """
                            return PyMenu(self.service, "/setup/boundary_conditions/expert/non_reflecting_bc/turbo_specific_nrbc/initialize").execute(*args, **kwargs)
                        def show_status(self, *args, **kwargs):
                            """
                            Show current status of turbo-specific non-reflecting b.c.'s.
                            """
                            return PyMenu(self.service, "/setup/boundary_conditions/expert/non_reflecting_bc/turbo_specific_nrbc/show_status").execute(*args, **kwargs)

                        class set(metaclass=PyMenuMeta):
                            """
                            Enter the set menu for turbo-specific non-reflecting b.c. parameters.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def discretization(self, *args, **kwargs):
                                """
                                Enable use of higher-order reconstruction at boundaries if available.
                                """
                                return PyMenu(self.service, "/setup/boundary_conditions/expert/non_reflecting_bc/turbo_specific_nrbc/set/discretization").execute(*args, **kwargs)
                            def under_relaxation(self, *args, **kwargs):
                                """
                                Set turbo-specific non-reflecting b.c. under-relaxation factor.
                                 specify < 0 => use P/a_ave
                                 specify = 0 => use 1/N    
                                 specify > 0 => use specified.
                                """
                                return PyMenu(self.service, "/setup/boundary_conditions/expert/non_reflecting_bc/turbo_specific_nrbc/set/under_relaxation").execute(*args, **kwargs)
                            def verbosity(self, *args, **kwargs):
                                """
                                Set turbo-specific non-reflecting b.c. verbosity level.
                                 0 : silent
                                 1 : basic info. default 
                                 2 : detailed info. for debugging 
                                .
                                """
                                return PyMenu(self.service, "/setup/boundary_conditions/expert/non_reflecting_bc/turbo_specific_nrbc/set/verbosity").execute(*args, **kwargs)

                class perforated_walls(metaclass=PyMenuMeta):
                    """
                    Enter the perforated walls setting menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def read_input_file(self, *args, **kwargs):
                        """
                        Read an input file.
                        """
                        return PyMenu(self.service, "/setup/boundary_conditions/expert/perforated_walls/read_input_file").execute(*args, **kwargs)
                    def model_setup(self, *args, **kwargs):
                        """
                        Set up perforated walls.
                        """
                        return PyMenu(self.service, "/setup/boundary_conditions/expert/perforated_walls/model_setup").execute(*args, **kwargs)

                class periodic_conditions(metaclass=PyMenuMeta):
                    """
                    Enter the periodic conditions menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def massflow_rate_specification(self, *args, **kwargs):
                        """
                        Enable/disable specification of mass flow rate at the periodic boundary.
                        """
                        return PyMenu(self.service, "/setup/boundary_conditions/expert/periodic_conditions/massflow_rate_specification").execute(*args, **kwargs)
                    def pressure_gradient_specification(self, *args, **kwargs):
                        """
                        Enable/disable specification of pressure gradient at the periodic boundary.
                        """
                        return PyMenu(self.service, "/setup/boundary_conditions/expert/periodic_conditions/pressure_gradient_specification").execute(*args, **kwargs)

            class mass_flow_inlet(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.flow_spec = self.__class__.flow_spec(path + [("flow_spec", None)], service)
                    self.mass_flow = self.__class__.mass_flow(path + [("mass_flow", None)], service)
                    self.ec_mass_flow = self.__class__.ec_mass_flow(path + [("ec_mass_flow", None)], service)
                    self.mass_flux = self.__class__.mass_flux(path + [("mass_flux", None)], service)
                    self.mass_flux_ave = self.__class__.mass_flux_ave(path + [("mass_flux_ave", None)], service)
                    self.tref = self.__class__.tref(path + [("tref", None)], service)
                    self.pref = self.__class__.pref(path + [("pref", None)], service)
                    self.p = self.__class__.p(path + [("p", None)], service)
                    self.direction_spec = self.__class__.direction_spec(path + [("direction_spec", None)], service)
                    self.impedance_0 = self.__class__.impedance_0(path + [("impedance_0", None)], service)
                    self.frame_of_reference = self.__class__.frame_of_reference(path + [("frame_of_reference", None)], service)
                    self.coordinate_system = self.__class__.coordinate_system(path + [("coordinate_system", None)], service)
                    self.ni = self.__class__.ni(path + [("ni", None)], service)
                    self.nj = self.__class__.nj(path + [("nj", None)], service)
                    self.nk = self.__class__.nk(path + [("nk", None)], service)
                    self.ni2 = self.__class__.ni2(path + [("ni2", None)], service)
                    self.nj2 = self.__class__.nj2(path + [("nj2", None)], service)
                    self.nk2 = self.__class__.nk2(path + [("nk2", None)], service)
                    self.ai = self.__class__.ai(path + [("ai", None)], service)
                    self.aj = self.__class__.aj(path + [("aj", None)], service)
                    self.ak = self.__class__.ak(path + [("ak", None)], service)
                    self.x_origin = self.__class__.x_origin(path + [("x_origin", None)], service)
                    self.y_origin = self.__class__.y_origin(path + [("y_origin", None)], service)
                    self.z_origin = self.__class__.z_origin(path + [("z_origin", None)], service)
                    self.ke_spec = self.__class__.ke_spec(path + [("ke_spec", None)], service)
                    self.nut = self.__class__.nut(path + [("nut", None)], service)
                    self.kl = self.__class__.kl(path + [("kl", None)], service)
                    self.intermit = self.__class__.intermit(path + [("intermit", None)], service)
                    self.k = self.__class__.k(path + [("k", None)], service)
                    self.e = self.__class__.e(path + [("e", None)], service)
                    self.o = self.__class__.o(path + [("o", None)], service)
                    self.v2 = self.__class__.v2(path + [("v2", None)], service)
                    self.turb_intensity = self.__class__.turb_intensity(path + [("turb_intensity", None)], service)
                    self.turb_length_scale = self.__class__.turb_length_scale(path + [("turb_length_scale", None)], service)
                    self.turb_hydraulic_diam = self.__class__.turb_hydraulic_diam(path + [("turb_hydraulic_diam", None)], service)
                    self.turb_viscosity_ratio = self.__class__.turb_viscosity_ratio(path + [("turb_viscosity_ratio", None)], service)
                    self.turb_viscosity_ratio_profile = self.__class__.turb_viscosity_ratio_profile(path + [("turb_viscosity_ratio_profile", None)], service)
                    self.rst_spec = self.__class__.rst_spec(path + [("rst_spec", None)], service)
                    self.uu = self.__class__.uu(path + [("uu", None)], service)
                    self.vv = self.__class__.vv(path + [("vv", None)], service)
                    self.ww = self.__class__.ww(path + [("ww", None)], service)
                    self.uv = self.__class__.uv(path + [("uv", None)], service)
                    self.vw = self.__class__.vw(path + [("vw", None)], service)
                    self.uw = self.__class__.uw(path + [("uw", None)], service)
                    self.ksgs_spec = self.__class__.ksgs_spec(path + [("ksgs_spec", None)], service)
                    self.ksgs = self.__class__.ksgs(path + [("ksgs", None)], service)
                    self.sgs_turb_intensity = self.__class__.sgs_turb_intensity(path + [("sgs_turb_intensity", None)], service)
                    self.swirl_model = self.__class__.swirl_model(path + [("swirl_model", None)], service)
                    self.swirl_factor = self.__class__.swirl_factor(path + [("swirl_factor", None)], service)
                    self.x_fan_origin = self.__class__.x_fan_origin(path + [("x_fan_origin", None)], service)
                    self.y_fan_origin = self.__class__.y_fan_origin(path + [("y_fan_origin", None)], service)
                    self.z_fan_origin = self.__class__.z_fan_origin(path + [("z_fan_origin", None)], service)
                    self.wsf = self.__class__.wsf(path + [("wsf", None)], service)
                    self.wsb = self.__class__.wsb(path + [("wsb", None)], service)
                    self.wsn = self.__class__.wsn(path + [("wsn", None)], service)
                    self.slip_velocity = self.__class__.slip_velocity(path + [("slip_velocity", None)], service)
                    self.velocity_ratio = self.__class__.velocity_ratio(path + [("velocity_ratio", None)], service)
                    self.volume_frac = self.__class__.volume_frac(path + [("volume_frac", None)], service)
                    self.granular_temperature = self.__class__.granular_temperature(path + [("granular_temperature", None)], service)
                    self.ac_options = self.__class__.ac_options(path + [("ac_options", None)], service)
                    self.ac_wave = self.__class__.ac_wave(path + [("ac_wave", None)], service)
                    self.t0 = self.__class__.t0(path + [("t0", None)], service)

                class flow_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class mass_flow(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ec_mass_flow(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class mass_flux(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class mass_flux_ave(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class tref(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class pref(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class p(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class direction_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class impedance_0(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class frame_of_reference(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class coordinate_system(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ni(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nk(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ni2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nj2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nk2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ai(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class aj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ak(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class x_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class y_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class z_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ke_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nut(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class kl(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class intermit(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class k(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class e(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class o(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class v2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_length_scale(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_hydraulic_diam(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio_profile(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class rst_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uu(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ww(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class sgs_turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class swirl_model(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class swirl_factor(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class x_fan_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class y_fan_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class z_fan_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wsf(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wsb(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wsn(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class slip_velocity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class velocity_ratio(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class volume_frac(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class granular_temperature(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ac_options(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ac_wave(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class t0(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

            class modify_zones(metaclass=PyMenuMeta):
                """
                Enter the modify zones menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def activate_cell_zone(self, *args, **kwargs):
                    """
                    Activate a cell thread.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/activate_cell_zone").execute(*args, **kwargs)
                def append_mesh(self, *args, **kwargs):
                    """
                    Append new mesh.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/append_mesh").execute(*args, **kwargs)
                def append_mesh_data(self, *args, **kwargs):
                    """
                    Append new mesh with data.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/append_mesh_data").execute(*args, **kwargs)
                def copy_move_cell_zone(self, *args, **kwargs):
                    """
                    Copy and translate or rotate a cell zone.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/copy_move_cell_zone").execute(*args, **kwargs)
                def create_all_shell_threads(self, *args, **kwargs):
                    """
                    Mark all finite thickness wall for shell creation. Shell zones will be created at the start of iterations.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/create_all_shell_threads").execute(*args, **kwargs)
                def deactivate_cell_zone(self, *args, **kwargs):
                    """
                    Deactivate cell thread.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/deactivate_cell_zone").execute(*args, **kwargs)
                def recreate_all_shells(self, *args, **kwargs):
                    """
                    Create shell on all the walls where which were deleted using the command delete-all-shells.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/recreate_all_shells").execute(*args, **kwargs)
                def delete_all_shells(self, *args, **kwargs):
                    """
                    Delete all shell zones and switch off shell conduction on all the walls. These zones can be recreated using the command recreate-all-shells.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/delete_all_shells").execute(*args, **kwargs)
                def delete_cell_zone(self, *args, **kwargs):
                    """
                    Delete a cell thread.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/delete_cell_zone").execute(*args, **kwargs)
                def extrude_face_zone_delta(self, *args, **kwargs):
                    """
                    Extrude a face thread a specified distance based on a list of deltas.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/extrude_face_zone_delta").execute(*args, **kwargs)
                def extrude_face_zone_para(self, *args, **kwargs):
                    """
                    Extrude a face thread a specified distance based on a distance and a list of parametric locations between 0 and 1 (eg. 0 0.2 0.4 0.8 1.0).
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/extrude_face_zone_para").execute(*args, **kwargs)
                def fuse_face_zones(self, *args, **kwargs):
                    """
                    Attempt to fuse zones by removing duplicate faces and nodes.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/fuse_face_zones").execute(*args, **kwargs)
                def list_zones(self, *args, **kwargs):
                    """
                    List zone IDs, types, kinds, and names.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/list_zones").execute(*args, **kwargs)
                def make_periodic(self, *args, **kwargs):
                    """
                    Attempt to establish periodic/shadow face zone connectivity.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/make_periodic").execute(*args, **kwargs)
                def create_periodic_interface(self, *args, **kwargs):
                    """
                    Create a conformal or non-conformal periodic interface.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/create_periodic_interface").execute(*args, **kwargs)
                def scale_zone(self, *args, **kwargs):
                    """
                    Scale nodal coordinates of input cell zones.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/scale_zone").execute(*args, **kwargs)
                def rotate_zone(self, *args, **kwargs):
                    """
                    Rotate nodal coordinates of input cell zones.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/rotate_zone").execute(*args, **kwargs)
                def translate_zone(self, *args, **kwargs):
                    """
                    Translate nodal coordinates of input cell zones.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/translate_zone").execute(*args, **kwargs)
                def matching_tolerance(self, *args, **kwargs):
                    """
                    Set the normalized tolerance used for finding coincident nodes.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/matching_tolerance").execute(*args, **kwargs)
                def merge_zones(self, *args, **kwargs):
                    """
                    Merge zones of the same type and condition into one.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/merge_zones").execute(*args, **kwargs)
                def mrf_to_sliding_mesh(self, *args, **kwargs):
                    """
                    Change motion specification from MRF to moving mesh.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/mrf_to_sliding_mesh").execute(*args, **kwargs)
                def convert_all_solid_mrf_to_solid_motion(self, *args, **kwargs):
                    """
                    Change all solid zones motion specification from MRF to solid motion.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/convert_all_solid_mrf_to_solid_motion").execute(*args, **kwargs)
                def orient_face_zone(self, *args, **kwargs):
                    """
                    Orient the face zone.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/orient_face_zone").execute(*args, **kwargs)
                def replace_zone(self, *args, **kwargs):
                    """
                    Replace a cell zone.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/replace_zone").execute(*args, **kwargs)
                def sep_cell_zone_mark(self, *args, **kwargs):
                    """
                    Separate a cell zone based on cell marking.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/sep_cell_zone_mark").execute(*args, **kwargs)
                def sep_cell_zone_region(self, *args, **kwargs):
                    """
                    Separate a cell zone based on contiguous regions.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/sep_cell_zone_region").execute(*args, **kwargs)
                def sep_face_zone_angle(self, *args, **kwargs):
                    """
                    Separate a face zone based on significant angle.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/sep_face_zone_angle").execute(*args, **kwargs)
                def sep_face_zone_face(self, *args, **kwargs):
                    """
                    Separate each face in a zone into unique zone.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/sep_face_zone_face").execute(*args, **kwargs)
                def sep_face_zone_mark(self, *args, **kwargs):
                    """
                    Separate a face zone based on cell marking.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/sep_face_zone_mark").execute(*args, **kwargs)
                def sep_face_zone_region(self, *args, **kwargs):
                    """
                    Separate a face zone based on contiguous regions.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/sep_face_zone_region").execute(*args, **kwargs)
                def slit_periodic(self, *args, **kwargs):
                    """
                    Slit a periodic zone into two symmetry zones.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/slit_periodic").execute(*args, **kwargs)
                def slit_face_zone(self, *args, **kwargs):
                    """
                    Slit a two-sided wall into two connected wall zones.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/slit_face_zone").execute(*args, **kwargs)
                def slit_interior_between_diff_solids(self, *args, **kwargs):
                    """
                    Slit interior created between different solids into coupled walls.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/slit_interior_between_diff_solids").execute(*args, **kwargs)
                def zone_name(self, *args, **kwargs):
                    """
                    Give a zone a new name.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/zone_name").execute(*args, **kwargs)
                def zone_type(self, *args, **kwargs):
                    """
                    Set a zone's type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/zone_type").execute(*args, **kwargs)
                def copy_mrf_to_mesh_motion(self, *args, **kwargs):
                    """
                    Copy motion variable values for origin, axis and velocities from Frame Motion to Mesh Motion.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/copy_mrf_to_mesh_motion").execute(*args, **kwargs)
                def copy_mesh_to_mrf_motion(self, *args, **kwargs):
                    """
                    Copy motion variable values for origin, axis and velocities from Mesh Motion to Frame Motion.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/copy_mesh_to_mrf_motion").execute(*args, **kwargs)
                def change_zone_state(self, *args, **kwargs):
                    """
                    Change the realgas material state for a zone.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/change_zone_state").execute(*args, **kwargs)
                def change_zone_phase(self, *args, **kwargs):
                    """
                    Change the realgas phase for a zone.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/modify_zones/change_zone_phase").execute(*args, **kwargs)

            class periodic(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service

            class pressure_far_field(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.p = self.__class__.p(path + [("p", None)], service)
                    self.m = self.__class__.m(path + [("m", None)], service)
                    self.coordinate_system = self.__class__.coordinate_system(path + [("coordinate_system", None)], service)
                    self.ni = self.__class__.ni(path + [("ni", None)], service)
                    self.nj = self.__class__.nj(path + [("nj", None)], service)
                    self.nk = self.__class__.nk(path + [("nk", None)], service)
                    self.ai = self.__class__.ai(path + [("ai", None)], service)
                    self.aj = self.__class__.aj(path + [("aj", None)], service)
                    self.ak = self.__class__.ak(path + [("ak", None)], service)
                    self.x_origin = self.__class__.x_origin(path + [("x_origin", None)], service)
                    self.y_origin = self.__class__.y_origin(path + [("y_origin", None)], service)
                    self.z_origin = self.__class__.z_origin(path + [("z_origin", None)], service)
                    self.ke_spec = self.__class__.ke_spec(path + [("ke_spec", None)], service)
                    self.nut = self.__class__.nut(path + [("nut", None)], service)
                    self.kl = self.__class__.kl(path + [("kl", None)], service)
                    self.intermit = self.__class__.intermit(path + [("intermit", None)], service)
                    self.k = self.__class__.k(path + [("k", None)], service)
                    self.e = self.__class__.e(path + [("e", None)], service)
                    self.o = self.__class__.o(path + [("o", None)], service)
                    self.v2 = self.__class__.v2(path + [("v2", None)], service)
                    self.turb_intensity = self.__class__.turb_intensity(path + [("turb_intensity", None)], service)
                    self.turb_length_scale = self.__class__.turb_length_scale(path + [("turb_length_scale", None)], service)
                    self.turb_hydraulic_diam = self.__class__.turb_hydraulic_diam(path + [("turb_hydraulic_diam", None)], service)
                    self.turb_viscosity_ratio = self.__class__.turb_viscosity_ratio(path + [("turb_viscosity_ratio", None)], service)
                    self.turb_viscosity_ratio_profile = self.__class__.turb_viscosity_ratio_profile(path + [("turb_viscosity_ratio_profile", None)], service)
                    self.rst_spec = self.__class__.rst_spec(path + [("rst_spec", None)], service)
                    self.uu = self.__class__.uu(path + [("uu", None)], service)
                    self.vv = self.__class__.vv(path + [("vv", None)], service)
                    self.ww = self.__class__.ww(path + [("ww", None)], service)
                    self.uv = self.__class__.uv(path + [("uv", None)], service)
                    self.vw = self.__class__.vw(path + [("vw", None)], service)
                    self.uw = self.__class__.uw(path + [("uw", None)], service)
                    self.ksgs_spec = self.__class__.ksgs_spec(path + [("ksgs_spec", None)], service)
                    self.ksgs = self.__class__.ksgs(path + [("ksgs", None)], service)
                    self.sgs_turb_intensity = self.__class__.sgs_turb_intensity(path + [("sgs_turb_intensity", None)], service)
                    self.geom_disable = self.__class__.geom_disable(path + [("geom_disable", None)], service)
                    self.geom_dir_spec = self.__class__.geom_dir_spec(path + [("geom_dir_spec", None)], service)
                    self.geom_dir_x = self.__class__.geom_dir_x(path + [("geom_dir_x", None)], service)
                    self.geom_dir_y = self.__class__.geom_dir_y(path + [("geom_dir_y", None)], service)
                    self.geom_dir_z = self.__class__.geom_dir_z(path + [("geom_dir_z", None)], service)
                    self.geom_levels = self.__class__.geom_levels(path + [("geom_levels", None)], service)
                    self.geom_bgthread = self.__class__.geom_bgthread(path + [("geom_bgthread", None)], service)
                    self.t = self.__class__.t(path + [("t", None)], service)
                    self.non_equil_boundary = self.__class__.non_equil_boundary(path + [("non_equil_boundary", None)], service)
                    self.tve = self.__class__.tve(path + [("tve", None)], service)

                class p(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class m(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class coordinate_system(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ni(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nk(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ai(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class aj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ak(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class x_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class y_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class z_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ke_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nut(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class kl(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class intermit(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class k(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class e(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class o(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class v2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_length_scale(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_hydraulic_diam(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio_profile(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class rst_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uu(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ww(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class sgs_turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geom_disable(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geom_dir_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geom_dir_x(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geom_dir_y(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geom_dir_z(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geom_levels(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class geom_bgthread(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class t(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class non_equil_boundary(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class tve(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

            class pressure_inlet(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.frame_of_reference = self.__class__.frame_of_reference(path + [("frame_of_reference", None)], service)
                    self.p0 = self.__class__.p0(path + [("p0", None)], service)
                    self.p = self.__class__.p(path + [("p", None)], service)
                    self.direction_spec = self.__class__.direction_spec(path + [("direction_spec", None)], service)
                    self.coordinate_system = self.__class__.coordinate_system(path + [("coordinate_system", None)], service)
                    self.ni = self.__class__.ni(path + [("ni", None)], service)
                    self.nj = self.__class__.nj(path + [("nj", None)], service)
                    self.nk = self.__class__.nk(path + [("nk", None)], service)
                    self.ni2 = self.__class__.ni2(path + [("ni2", None)], service)
                    self.nj2 = self.__class__.nj2(path + [("nj2", None)], service)
                    self.nk2 = self.__class__.nk2(path + [("nk2", None)], service)
                    self.ai = self.__class__.ai(path + [("ai", None)], service)
                    self.aj = self.__class__.aj(path + [("aj", None)], service)
                    self.ak = self.__class__.ak(path + [("ak", None)], service)
                    self.x_origin = self.__class__.x_origin(path + [("x_origin", None)], service)
                    self.y_origin = self.__class__.y_origin(path + [("y_origin", None)], service)
                    self.z_origin = self.__class__.z_origin(path + [("z_origin", None)], service)
                    self.vm_number_of_vortices = self.__class__.vm_number_of_vortices(path + [("vm_number_of_vortices", None)], service)
                    self.vm_streamwise_fluct = self.__class__.vm_streamwise_fluct(path + [("vm_streamwise_fluct", None)], service)
                    self.vm_mass_conservation = self.__class__.vm_mass_conservation(path + [("vm_mass_conservation", None)], service)
                    self.volumetric_synthetic_turbulence_generator = self.__class__.volumetric_synthetic_turbulence_generator(path + [("volumetric_synthetic_turbulence_generator", None)], service)
                    self.volumetric_synthetic_turbulence_generator_option = self.__class__.volumetric_synthetic_turbulence_generator_option(path + [("volumetric_synthetic_turbulence_generator_option", None)], service)
                    self.volumetric_synthetic_turbulence_generator_option_thickness = self.__class__.volumetric_synthetic_turbulence_generator_option_thickness(path + [("volumetric_synthetic_turbulence_generator_option_thickness", None)], service)
                    self.prevent_reverse_flow = self.__class__.prevent_reverse_flow(path + [("prevent_reverse_flow", None)], service)
                    self.ke_spec = self.__class__.ke_spec(path + [("ke_spec", None)], service)
                    self.nut = self.__class__.nut(path + [("nut", None)], service)
                    self.kl = self.__class__.kl(path + [("kl", None)], service)
                    self.intermit = self.__class__.intermit(path + [("intermit", None)], service)
                    self.k = self.__class__.k(path + [("k", None)], service)
                    self.e = self.__class__.e(path + [("e", None)], service)
                    self.o = self.__class__.o(path + [("o", None)], service)
                    self.v2 = self.__class__.v2(path + [("v2", None)], service)
                    self.turb_intensity = self.__class__.turb_intensity(path + [("turb_intensity", None)], service)
                    self.turb_length_scale = self.__class__.turb_length_scale(path + [("turb_length_scale", None)], service)
                    self.turb_hydraulic_diam = self.__class__.turb_hydraulic_diam(path + [("turb_hydraulic_diam", None)], service)
                    self.turb_viscosity_ratio = self.__class__.turb_viscosity_ratio(path + [("turb_viscosity_ratio", None)], service)
                    self.turb_viscosity_ratio_profile = self.__class__.turb_viscosity_ratio_profile(path + [("turb_viscosity_ratio_profile", None)], service)
                    self.rst_spec = self.__class__.rst_spec(path + [("rst_spec", None)], service)
                    self.uu = self.__class__.uu(path + [("uu", None)], service)
                    self.vv = self.__class__.vv(path + [("vv", None)], service)
                    self.ww = self.__class__.ww(path + [("ww", None)], service)
                    self.uv = self.__class__.uv(path + [("uv", None)], service)
                    self.vw = self.__class__.vw(path + [("vw", None)], service)
                    self.uw = self.__class__.uw(path + [("uw", None)], service)
                    self.ksgs_spec = self.__class__.ksgs_spec(path + [("ksgs_spec", None)], service)
                    self.ksgs = self.__class__.ksgs(path + [("ksgs", None)], service)
                    self.sgs_turb_intensity = self.__class__.sgs_turb_intensity(path + [("sgs_turb_intensity", None)], service)
                    self.les_spec_name = self.__class__.les_spec_name(path + [("les_spec_name", None)], service)
                    self.wsf = self.__class__.wsf(path + [("wsf", None)], service)
                    self.wsb = self.__class__.wsb(path + [("wsb", None)], service)
                    self.wsn = self.__class__.wsn(path + [("wsn", None)], service)
                    self.ac_options = self.__class__.ac_options(path + [("ac_options", None)], service)
                    self.ac_wave = self.__class__.ac_wave(path + [("ac_wave", None)], service)
                    self.impedance_0 = self.__class__.impedance_0(path + [("impedance_0", None)], service)
                    self.t0 = self.__class__.t0(path + [("t0", None)], service)

                class frame_of_reference(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class p0(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class p(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class direction_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class coordinate_system(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ni(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nk(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ni2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nj2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nk2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ai(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class aj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ak(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class x_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class y_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class z_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vm_number_of_vortices(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vm_streamwise_fluct(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vm_mass_conservation(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class volumetric_synthetic_turbulence_generator(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class volumetric_synthetic_turbulence_generator_option(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class volumetric_synthetic_turbulence_generator_option_thickness(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class prevent_reverse_flow(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ke_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nut(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class kl(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class intermit(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class k(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class e(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class o(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class v2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_length_scale(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_hydraulic_diam(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio_profile(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class rst_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uu(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ww(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class sgs_turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class les_spec_name(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wsf(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wsb(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wsn(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ac_options(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ac_wave(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class impedance_0(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class t0(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

            class pressure_outlet(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.prevent_reverse_flow = self.__class__.prevent_reverse_flow(path + [("prevent_reverse_flow", None)], service)
                    self.radial = self.__class__.radial(path + [("radial", None)], service)
                    self.gen_nrbc_spec = self.__class__.gen_nrbc_spec(path + [("gen_nrbc_spec", None)], service)
                    self.avg_press_spec = self.__class__.avg_press_spec(path + [("avg_press_spec", None)], service)
                    self.avg_option = self.__class__.avg_option(path + [("avg_option", None)], service)
                    self.targeted_mf_boundary = self.__class__.targeted_mf_boundary(path + [("targeted_mf_boundary", None)], service)
                    self.targeted_mf = self.__class__.targeted_mf(path + [("targeted_mf", None)], service)
                    self.targeted_mf_pmax = self.__class__.targeted_mf_pmax(path + [("targeted_mf_pmax", None)], service)
                    self.targeted_mf_pmin = self.__class__.targeted_mf_pmin(path + [("targeted_mf_pmin", None)], service)
                    self.press_spec_gen = self.__class__.press_spec_gen(path + [("press_spec_gen", None)], service)
                    self.p_backflow_spec = self.__class__.p_backflow_spec(path + [("p_backflow_spec", None)], service)
                    self.p_backflow_spec_gen = self.__class__.p_backflow_spec_gen(path + [("p_backflow_spec_gen", None)], service)
                    self.ac_options = self.__class__.ac_options(path + [("ac_options", None)], service)
                    self.ac_wave = self.__class__.ac_wave(path + [("ac_wave", None)], service)
                    self.impedance_0 = self.__class__.impedance_0(path + [("impedance_0", None)], service)
                    self.p = self.__class__.p(path + [("p", None)], service)
                    self.p_profile_multiplier = self.__class__.p_profile_multiplier(path + [("p_profile_multiplier", None)], service)
                    self.direction_spec = self.__class__.direction_spec(path + [("direction_spec", None)], service)
                    self.frame_of_reference = self.__class__.frame_of_reference(path + [("frame_of_reference", None)], service)
                    self.coordinate_system = self.__class__.coordinate_system(path + [("coordinate_system", None)], service)
                    self.ni = self.__class__.ni(path + [("ni", None)], service)
                    self.nj = self.__class__.nj(path + [("nj", None)], service)
                    self.nk = self.__class__.nk(path + [("nk", None)], service)
                    self.ai = self.__class__.ai(path + [("ai", None)], service)
                    self.aj = self.__class__.aj(path + [("aj", None)], service)
                    self.ak = self.__class__.ak(path + [("ak", None)], service)
                    self.x_origin = self.__class__.x_origin(path + [("x_origin", None)], service)
                    self.y_origin = self.__class__.y_origin(path + [("y_origin", None)], service)
                    self.z_origin = self.__class__.z_origin(path + [("z_origin", None)], service)
                    self.ke_spec = self.__class__.ke_spec(path + [("ke_spec", None)], service)
                    self.nut = self.__class__.nut(path + [("nut", None)], service)
                    self.kl = self.__class__.kl(path + [("kl", None)], service)
                    self.intermit = self.__class__.intermit(path + [("intermit", None)], service)
                    self.k = self.__class__.k(path + [("k", None)], service)
                    self.e = self.__class__.e(path + [("e", None)], service)
                    self.o = self.__class__.o(path + [("o", None)], service)
                    self.v2 = self.__class__.v2(path + [("v2", None)], service)
                    self.turb_intensity = self.__class__.turb_intensity(path + [("turb_intensity", None)], service)
                    self.turb_length_scale = self.__class__.turb_length_scale(path + [("turb_length_scale", None)], service)
                    self.turb_hydraulic_diam = self.__class__.turb_hydraulic_diam(path + [("turb_hydraulic_diam", None)], service)
                    self.turb_viscosity_ratio = self.__class__.turb_viscosity_ratio(path + [("turb_viscosity_ratio", None)], service)
                    self.turb_viscosity_ratio_profile = self.__class__.turb_viscosity_ratio_profile(path + [("turb_viscosity_ratio_profile", None)], service)
                    self.rst_spec = self.__class__.rst_spec(path + [("rst_spec", None)], service)
                    self.uu = self.__class__.uu(path + [("uu", None)], service)
                    self.vv = self.__class__.vv(path + [("vv", None)], service)
                    self.ww = self.__class__.ww(path + [("ww", None)], service)
                    self.uv = self.__class__.uv(path + [("uv", None)], service)
                    self.vw = self.__class__.vw(path + [("vw", None)], service)
                    self.uw = self.__class__.uw(path + [("uw", None)], service)
                    self.ksgs_spec = self.__class__.ksgs_spec(path + [("ksgs_spec", None)], service)
                    self.ksgs = self.__class__.ksgs(path + [("ksgs", None)], service)
                    self.sgs_turb_intensity = self.__class__.sgs_turb_intensity(path + [("sgs_turb_intensity", None)], service)
                    self.wsf = self.__class__.wsf(path + [("wsf", None)], service)
                    self.wsb = self.__class__.wsb(path + [("wsb", None)], service)
                    self.wsn = self.__class__.wsn(path + [("wsn", None)], service)
                    self.t0 = self.__class__.t0(path + [("t0", None)], service)

                class prevent_reverse_flow(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class radial(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class gen_nrbc_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class avg_press_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class avg_option(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class targeted_mf_boundary(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class targeted_mf(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class targeted_mf_pmax(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class targeted_mf_pmin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class press_spec_gen(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class p_backflow_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class p_backflow_spec_gen(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ac_options(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ac_wave(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class impedance_0(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class p(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class p_profile_multiplier(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class direction_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class frame_of_reference(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class coordinate_system(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ni(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nk(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ai(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class aj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ak(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class x_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class y_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class z_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ke_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nut(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class kl(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class intermit(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class k(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class e(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class o(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class v2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_length_scale(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_hydraulic_diam(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio_profile(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class rst_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uu(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ww(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class sgs_turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wsf(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wsb(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wsn(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class t0(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

            class profiles(metaclass=PyMenuMeta):
                """
                Enter the boundary profiles menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def display_profile_surface(self, *args, **kwargs):
                    """
                    Display a profile.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/profiles/display_profile_surface").execute(*args, **kwargs)
                def display_profile_point_cloud_data(self, *args, **kwargs):
                    """
                    Display Profile Point Cloud Data.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/profiles/display_profile_point_cloud_data").execute(*args, **kwargs)
                def overlay_profile_surface(self, *args, **kwargs):
                    """
                    Overlay Profile Surface.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/profiles/overlay_profile_surface").execute(*args, **kwargs)
                def overlay_profile_point_cloud_data(self, *args, **kwargs):
                    """
                    Overlay Profile Point Cloud Data.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/profiles/overlay_profile_point_cloud_data").execute(*args, **kwargs)
                def set_preference_profile_point_cloud_data(self, *args, **kwargs):
                    """
                    Set Preference Profile Point Cloud Data e.g., Point marker symbol,size,color.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/profiles/set_preference_profile_point_cloud_data").execute(*args, **kwargs)
                def list_profile_parameters(self, *args, **kwargs):
                    """
                    List the parameters of a particular profile.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/profiles/list_profile_parameters").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete a profile.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/profiles/delete").execute(*args, **kwargs)
                def delete_all(self, *args, **kwargs):
                    """
                    Delete all boundary-profiles.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/profiles/delete_all").execute(*args, **kwargs)
                def list_profiles(self, *args, **kwargs):
                    """
                    List all profiles.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/profiles/list_profiles").execute(*args, **kwargs)
                def list_profile_fields(self, *args, **kwargs):
                    """
                    List the fields of a particular profile.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/profiles/list_profile_fields").execute(*args, **kwargs)
                def interpolation_method(self, *args, **kwargs):
                    """
                    Choose the method for interpolation of profiles.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/profiles/interpolation_method").execute(*args, **kwargs)
                def morphing(self, *args, **kwargs):
                    """
                    Enable/disable profile morphing options in Orient Profile panel.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/profiles/morphing").execute(*args, **kwargs)
                def update_interval(self, *args, **kwargs):
                    """
                    Set interval between updates of dynamic profiles.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/profiles/update_interval").execute(*args, **kwargs)
                def link_profile_to_reference_frame(self, *args, **kwargs):
                    """
                    Link profile to a reference frame.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/profiles/link_profile_to_reference_frame").execute(*args, **kwargs)
                def replicate_profile(self, *args, **kwargs):
                    """
                    Replicate Profile.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/profiles/replicate_profile").execute(*args, **kwargs)
                def orient_profile(self, *args, **kwargs):
                    """
                    Orient Profile.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/profiles/orient_profile").execute(*args, **kwargs)

            class query(metaclass=PyMenuMeta):
                """
                Enter zone query menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def axis(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/axis").execute(*args, **kwargs)
                def degassing(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/degassing").execute(*args, **kwargs)
                def delete_query(self, *args, **kwargs):
                    """
                    Delete saved query.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/delete_query").execute(*args, **kwargs)
                def exhaust_fan(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/exhaust_fan").execute(*args, **kwargs)
                def fan(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/fan").execute(*args, **kwargs)
                def fluid(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/fluid").execute(*args, **kwargs)
                def geometry(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/geometry").execute(*args, **kwargs)
                def inlet_vent(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/inlet_vent").execute(*args, **kwargs)
                def intake_fan(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/intake_fan").execute(*args, **kwargs)
                def interface(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/interface").execute(*args, **kwargs)
                def interior(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/interior").execute(*args, **kwargs)
                def list_boundary_conditions(self, *args, **kwargs):
                    """
                    List boundary conditions.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/list_boundary_conditions").execute(*args, **kwargs)
                def list_cell_zone_conditions(self, *args, **kwargs):
                    """
                    List cell zone conditions.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/list_cell_zone_conditions").execute(*args, **kwargs)
                def mass_flow_inlet(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/mass_flow_inlet").execute(*args, **kwargs)
                def mass_flow_outlet(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/mass_flow_outlet").execute(*args, **kwargs)
                def named_zone_list(self, *args, **kwargs):
                    """
                    Create named list of zones.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/named_zone_list").execute(*args, **kwargs)
                def list_named_selection(self, *args, **kwargs):
                    """
                    List named selection of zone type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/list_named_selection").execute(*args, **kwargs)
                def list_queries(self, *args, **kwargs):
                    """
                    List all saved queries.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/list_queries").execute(*args, **kwargs)
                def network(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/network").execute(*args, **kwargs)
                def network_end(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/network_end").execute(*args, **kwargs)
                def outflow(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/outflow").execute(*args, **kwargs)
                def outlet_vent(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/outlet_vent").execute(*args, **kwargs)
                def overset(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/overset").execute(*args, **kwargs)
                def periodic(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/periodic").execute(*args, **kwargs)
                def porous_jump(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/porous_jump").execute(*args, **kwargs)
                def pressure_far_field(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/pressure_far_field").execute(*args, **kwargs)
                def pressure_inlet(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/pressure_inlet").execute(*args, **kwargs)
                def pressure_outlet(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/pressure_outlet").execute(*args, **kwargs)
                def radiator(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/radiator").execute(*args, **kwargs)
                def rans_les_interface(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/rans_les_interface").execute(*args, **kwargs)
                def recirculation_inlet(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/recirculation_inlet").execute(*args, **kwargs)
                def recirculation_outlet(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/recirculation_outlet").execute(*args, **kwargs)
                def shadow(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/shadow").execute(*args, **kwargs)
                def solid(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/solid").execute(*args, **kwargs)
                def symmetry(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/symmetry").execute(*args, **kwargs)
                def velocity_inlet(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/velocity_inlet").execute(*args, **kwargs)
                def wall(self, *args, **kwargs):
                    """
                    Show boundary conditions for a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/query/wall").execute(*args, **kwargs)

            class rename_zone(metaclass=PyMenuMeta):
                """
                Enter zone rename menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def rename_by_adjacency(self, *args, **kwargs):
                    """
                    Rename zone to adjacent zones.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/rename_zone/rename_by_adjacency").execute(*args, **kwargs)
                def rename_to_default(self, *args, **kwargs):
                    """
                    Rename zone to default name.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/rename_zone/rename_to_default").execute(*args, **kwargs)
                def add_suffix_or_prefix(self, *args, **kwargs):
                    """
                    Add suffix or prefix to zone name.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/rename_zone/add_suffix_or_prefix").execute(*args, **kwargs)

            class set(metaclass=PyMenuMeta):
                """
                Enter the set boundary conditions menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def axis(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/axis").execute(*args, **kwargs)
                def degassing(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/degassing").execute(*args, **kwargs)
                def exhaust_fan(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/exhaust_fan").execute(*args, **kwargs)
                def fan(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/fan").execute(*args, **kwargs)
                def fluid(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/fluid").execute(*args, **kwargs)
                def geometry(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/geometry").execute(*args, **kwargs)
                def inlet_vent(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/inlet_vent").execute(*args, **kwargs)
                def intake_fan(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/intake_fan").execute(*args, **kwargs)
                def interface(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/interface").execute(*args, **kwargs)
                def interior(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/interior").execute(*args, **kwargs)
                def mass_flow_inlet(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/mass_flow_inlet").execute(*args, **kwargs)
                def mass_flow_outlet(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/mass_flow_outlet").execute(*args, **kwargs)
                def network(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/network").execute(*args, **kwargs)
                def network_end(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/network_end").execute(*args, **kwargs)
                def outflow(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/outflow").execute(*args, **kwargs)
                def outlet_vent(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/outlet_vent").execute(*args, **kwargs)
                def overset(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/overset").execute(*args, **kwargs)
                def periodic(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/periodic").execute(*args, **kwargs)
                def porous_jump(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/porous_jump").execute(*args, **kwargs)
                def pressure_far_field(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/pressure_far_field").execute(*args, **kwargs)
                def pressure_inlet(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/pressure_inlet").execute(*args, **kwargs)
                def pressure_outlet(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/pressure_outlet").execute(*args, **kwargs)
                def radiator(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/radiator").execute(*args, **kwargs)
                def rans_les_interface(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/rans_les_interface").execute(*args, **kwargs)
                def recirculation_inlet(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/recirculation_inlet").execute(*args, **kwargs)
                def recirculation_outlet(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/recirculation_outlet").execute(*args, **kwargs)
                def shadow(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/shadow").execute(*args, **kwargs)
                def solid(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/solid").execute(*args, **kwargs)
                def symmetry(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/symmetry").execute(*args, **kwargs)
                def velocity_inlet(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/velocity_inlet").execute(*args, **kwargs)
                def wall(self, *args, **kwargs):
                    """
                    Set boundary conditions for a zone or multiple zones of this type.
                    """
                    return PyMenu(self.service, "/setup/boundary_conditions/set/wall").execute(*args, **kwargs)

            class symmetry(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service

            class velocity_inlet(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.vmag = self.__class__.vmag(path + [("vmag", None)], service)
                    self.p_sup = self.__class__.p_sup(path + [("p_sup", None)], service)
                    self.velocity_spec = self.__class__.velocity_spec(path + [("velocity_spec", None)], service)
                    self.wave_velocity_spec = self.__class__.wave_velocity_spec(path + [("wave_velocity_spec", None)], service)
                    self.wave_vmag = self.__class__.wave_vmag(path + [("wave_vmag", None)], service)
                    self.wave_u = self.__class__.wave_u(path + [("wave_u", None)], service)
                    self.wave_v = self.__class__.wave_v(path + [("wave_v", None)], service)
                    self.wave_w = self.__class__.wave_w(path + [("wave_w", None)], service)
                    self.ocw_ship_vel_spec = self.__class__.ocw_ship_vel_spec(path + [("ocw_ship_vel_spec", None)], service)
                    self.ocw_ship_vmag = self.__class__.ocw_ship_vmag(path + [("ocw_ship_vmag", None)], service)
                    self.ocw_ship_ni = self.__class__.ocw_ship_ni(path + [("ocw_ship_ni", None)], service)
                    self.ocw_ship_nj = self.__class__.ocw_ship_nj(path + [("ocw_ship_nj", None)], service)
                    self.ocw_ship_nk = self.__class__.ocw_ship_nk(path + [("ocw_ship_nk", None)], service)
                    self.ocw_sp_vel_spec = self.__class__.ocw_sp_vel_spec(path + [("ocw_sp_vel_spec", None)], service)
                    self.ocw_sp_vmag = self.__class__.ocw_sp_vmag(path + [("ocw_sp_vmag", None)], service)
                    self.ocw_sp_ni = self.__class__.ocw_sp_ni(path + [("ocw_sp_ni", None)], service)
                    self.ocw_sp_nj = self.__class__.ocw_sp_nj(path + [("ocw_sp_nj", None)], service)
                    self.ocw_sp_nk = self.__class__.ocw_sp_nk(path + [("ocw_sp_nk", None)], service)
                    self.ocw_pp_vel_spec = self.__class__.ocw_pp_vel_spec(path + [("ocw_pp_vel_spec", None)], service)
                    self.ocw_pp_vmag = self.__class__.ocw_pp_vmag(path + [("ocw_pp_vmag", None)], service)
                    self.ocw_pp_vmag_ref = self.__class__.ocw_pp_vmag_ref(path + [("ocw_pp_vmag_ref", None)], service)
                    self.ocw_pp_ref_ht = self.__class__.ocw_pp_ref_ht(path + [("ocw_pp_ref_ht", None)], service)
                    self.ocw_pp_power_coeff = self.__class__.ocw_pp_power_coeff(path + [("ocw_pp_power_coeff", None)], service)
                    self.ocw_pp_ni = self.__class__.ocw_pp_ni(path + [("ocw_pp_ni", None)], service)
                    self.ocw_pp_nj = self.__class__.ocw_pp_nj(path + [("ocw_pp_nj", None)], service)
                    self.ocw_pp_nk = self.__class__.ocw_pp_nk(path + [("ocw_pp_nk", None)], service)
                    self.p = self.__class__.p(path + [("p", None)], service)
                    self.omega_swirl = self.__class__.omega_swirl(path + [("omega_swirl", None)], service)
                    self.turb_intensity = self.__class__.turb_intensity(path + [("turb_intensity", None)], service)
                    self.turb_length_scale = self.__class__.turb_length_scale(path + [("turb_length_scale", None)], service)
                    self.turb_hydraulic_diam = self.__class__.turb_hydraulic_diam(path + [("turb_hydraulic_diam", None)], service)
                    self.turb_viscosity_ratio = self.__class__.turb_viscosity_ratio(path + [("turb_viscosity_ratio", None)], service)
                    self.turb_viscosity_ratio_profile = self.__class__.turb_viscosity_ratio_profile(path + [("turb_viscosity_ratio_profile", None)], service)
                    self.frame_of_reference = self.__class__.frame_of_reference(path + [("frame_of_reference", None)], service)
                    self.coordinate_system = self.__class__.coordinate_system(path + [("coordinate_system", None)], service)
                    self.ni = self.__class__.ni(path + [("ni", None)], service)
                    self.nj = self.__class__.nj(path + [("nj", None)], service)
                    self.nk = self.__class__.nk(path + [("nk", None)], service)
                    self.u = self.__class__.u(path + [("u", None)], service)
                    self.v = self.__class__.v(path + [("v", None)], service)
                    self.w = self.__class__.w(path + [("w", None)], service)
                    self.ai = self.__class__.ai(path + [("ai", None)], service)
                    self.aj = self.__class__.aj(path + [("aj", None)], service)
                    self.ak = self.__class__.ak(path + [("ak", None)], service)
                    self.x_origin = self.__class__.x_origin(path + [("x_origin", None)], service)
                    self.y_origin = self.__class__.y_origin(path + [("y_origin", None)], service)
                    self.z_origin = self.__class__.z_origin(path + [("z_origin", None)], service)
                    self.vm_number_of_vortices = self.__class__.vm_number_of_vortices(path + [("vm_number_of_vortices", None)], service)
                    self.vm_streamwise_fluct = self.__class__.vm_streamwise_fluct(path + [("vm_streamwise_fluct", None)], service)
                    self.vm_mass_conservation = self.__class__.vm_mass_conservation(path + [("vm_mass_conservation", None)], service)
                    self.volumetric_synthetic_turbulence_generator = self.__class__.volumetric_synthetic_turbulence_generator(path + [("volumetric_synthetic_turbulence_generator", None)], service)
                    self.volumetric_synthetic_turbulence_generator_option = self.__class__.volumetric_synthetic_turbulence_generator_option(path + [("volumetric_synthetic_turbulence_generator_option", None)], service)
                    self.volumetric_synthetic_turbulence_generator_option_thickness = self.__class__.volumetric_synthetic_turbulence_generator_option_thickness(path + [("volumetric_synthetic_turbulence_generator_option_thickness", None)], service)
                    self.ke_spec = self.__class__.ke_spec(path + [("ke_spec", None)], service)
                    self.nut = self.__class__.nut(path + [("nut", None)], service)
                    self.kl = self.__class__.kl(path + [("kl", None)], service)
                    self.intermit = self.__class__.intermit(path + [("intermit", None)], service)
                    self.k = self.__class__.k(path + [("k", None)], service)
                    self.e = self.__class__.e(path + [("e", None)], service)
                    self.o = self.__class__.o(path + [("o", None)], service)
                    self.v2 = self.__class__.v2(path + [("v2", None)], service)
                    self.rst_spec = self.__class__.rst_spec(path + [("rst_spec", None)], service)
                    self.uu = self.__class__.uu(path + [("uu", None)], service)
                    self.vv = self.__class__.vv(path + [("vv", None)], service)
                    self.ww = self.__class__.ww(path + [("ww", None)], service)
                    self.uv = self.__class__.uv(path + [("uv", None)], service)
                    self.vw = self.__class__.vw(path + [("vw", None)], service)
                    self.uw = self.__class__.uw(path + [("uw", None)], service)
                    self.ksgs_spec = self.__class__.ksgs_spec(path + [("ksgs_spec", None)], service)
                    self.ksgs = self.__class__.ksgs(path + [("ksgs", None)], service)
                    self.sgs_turb_intensity = self.__class__.sgs_turb_intensity(path + [("sgs_turb_intensity", None)], service)
                    self.les_spec_name = self.__class__.les_spec_name(path + [("les_spec_name", None)], service)
                    self.granular_temperature = self.__class__.granular_temperature(path + [("granular_temperature", None)], service)
                    self.ac_options = self.__class__.ac_options(path + [("ac_options", None)], service)
                    self.ac_wave = self.__class__.ac_wave(path + [("ac_wave", None)], service)
                    self.impedance_0 = self.__class__.impedance_0(path + [("impedance_0", None)], service)
                    self.t = self.__class__.t(path + [("t", None)], service)
                    self.non_equil_boundary = self.__class__.non_equil_boundary(path + [("non_equil_boundary", None)], service)
                    self.tve = self.__class__.tve(path + [("tve", None)], service)

                class vmag(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class p_sup(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class velocity_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wave_velocity_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wave_vmag(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wave_u(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wave_v(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class wave_w(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_ship_vel_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_ship_vmag(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_ship_ni(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_ship_nj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_ship_nk(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_sp_vel_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_sp_vmag(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_sp_ni(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_sp_nj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_sp_nk(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_pp_vel_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_pp_vmag(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_pp_vmag_ref(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_pp_ref_ht(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_pp_power_coeff(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_pp_ni(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_pp_nj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ocw_pp_nk(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class p(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class omega_swirl(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_length_scale(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_hydraulic_diam(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class turb_viscosity_ratio_profile(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class frame_of_reference(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class coordinate_system(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ni(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nk(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class u(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class v(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class w(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ai(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class aj(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ak(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class x_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class y_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class z_origin(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vm_number_of_vortices(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vm_streamwise_fluct(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vm_mass_conservation(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class volumetric_synthetic_turbulence_generator(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class volumetric_synthetic_turbulence_generator_option(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class volumetric_synthetic_turbulence_generator_option_thickness(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ke_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class nut(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class kl(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class intermit(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class k(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class e(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class o(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class v2(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class rst_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uu(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ww(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uv(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class vw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class uw(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs_spec(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ksgs(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class sgs_turb_intensity(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class les_spec_name(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class granular_temperature(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ac_options(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class ac_wave(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class impedance_0(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class t(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class non_equil_boundary(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

                class tve(metaclass=PyMenuMeta):
                    """
                    """
                    is_extended_tui = True
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service

            class wall(metaclass=PyNamedObjectMeta):
                """
                """
                is_extended_tui = True
                def __init__(self, path, service):
                    self.path = path
                    self.service = service

        class dynamic_mesh(metaclass=PyMenuMeta):
            """
            Enter the dynamic mesh menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.controls = self.__class__.controls(path + [("controls", None)], service)
                self.events = self.__class__.events(path + [("events", None)], service)
                self.zones = self.__class__.zones(path + [("zones", None)], service)
                self.actions = self.__class__.actions(path + [("actions", None)], service)
                self.transient_settings = self.__class__.transient_settings(path + [("transient_settings", None)], service)
            def dynamic_mesh(self, *args, **kwargs):
                """
                Enable/disable the dynamic mesh solver and options.
                """
                return PyMenu(self.service, "/setup/dynamic_mesh/dynamic_mesh").execute(*args, **kwargs)

            class controls(metaclass=PyMenuMeta):
                """
                Enter the dynamic mesh control menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.smoothing_parameters = self.__class__.smoothing_parameters(path + [("smoothing_parameters", None)], service)
                    self.layering_parameters = self.__class__.layering_parameters(path + [("layering_parameters", None)], service)
                    self.remeshing_parameters = self.__class__.remeshing_parameters(path + [("remeshing_parameters", None)], service)
                    self.in_cylinder_parameters = self.__class__.in_cylinder_parameters(path + [("in_cylinder_parameters", None)], service)
                    self.implicit_update_parameters = self.__class__.implicit_update_parameters(path + [("implicit_update_parameters", None)], service)
                    self.six_dof_parameters = self.__class__.six_dof_parameters(path + [("six_dof_parameters", None)], service)
                    self.periodic_displacement_parameters = self.__class__.periodic_displacement_parameters(path + [("periodic_displacement_parameters", None)], service)
                    self.contact_parameters = self.__class__.contact_parameters(path + [("contact_parameters", None)], service)
                def in_cylinder_output(self, *args, **kwargs):
                    """
                    Enable/disable in-cylinder output.
                    """
                    return PyMenu(self.service, "/setup/dynamic_mesh/controls/in_cylinder_output").execute(*args, **kwargs)
                def smoothing(self, *args, **kwargs):
                    """
                    Enable/disable dynamic mesh smoothing.
                    """
                    return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing").execute(*args, **kwargs)
                def layering(self, *args, **kwargs):
                    """
                    Enable/disable dynamic-layering in quad/hex cell zones.
                    """
                    return PyMenu(self.service, "/setup/dynamic_mesh/controls/layering").execute(*args, **kwargs)
                def remeshing(self, *args, **kwargs):
                    """
                    Enable/disable local remeshing in tri/tet and mixed cell zones.
                    """
                    return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing").execute(*args, **kwargs)
                def steady_pseudo_time_control(self, *args, **kwargs):
                    """
                    Enable/disable pseudo time step control in user interface.
                    """
                    return PyMenu(self.service, "/setup/dynamic_mesh/controls/steady_pseudo_time_control").execute(*args, **kwargs)

                class smoothing_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the dynamic mesh smoothing menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def smoothing_method(self, *args, **kwargs):
                        """
                        Specify the smoothing method used by the dynamic mesh model.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/smoothing_method").execute(*args, **kwargs)
                    def constant_factor(self, *args, **kwargs):
                        """
                        Set the spring constant relaxation factor.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/constant_factor").execute(*args, **kwargs)
                    def bnd_node_relaxation(self, *args, **kwargs):
                        """
                        Set the spring boundary node relaxation factor.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/bnd_node_relaxation").execute(*args, **kwargs)
                    def bnd_stiffness_factor(self, *args, **kwargs):
                        """
                        Set the stiffness factor for springs connected to boundary nodes.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/bnd_stiffness_factor").execute(*args, **kwargs)
                    def convergence_tolerance(self, *args, **kwargs):
                        """
                        Set the convergence tolerance for spring-based solver.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/convergence_tolerance").execute(*args, **kwargs)
                    def max_iter(self, *args, **kwargs):
                        """
                        Set the maximum number of iterations for spring-based solver.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/max_iter").execute(*args, **kwargs)
                    def spring_on_all_elements(self, *args, **kwargs):
                        """
                        Enable/disable spring-based smoothing for all cell shapes.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/spring_on_all_elements").execute(*args, **kwargs)
                    def spring_on_simplex_elements(self, *args, **kwargs):
                        """
                        Enable/disable spring-based smoothing for tri/tet elements in mixed element zones.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/spring_on_simplex_elements").execute(*args, **kwargs)
                    def skew_smooth_niter(self, *args, **kwargs):
                        """
                        Set the number of skewness-based smoothing cycles.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/skew_smooth_niter").execute(*args, **kwargs)
                    def skew_smooth_cell_skew_max(self, *args, **kwargs):
                        """
                        Set the cell skewness threshold above which cells will be smoothed 
                        using the skewness method.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/skew_smooth_cell_skew_max").execute(*args, **kwargs)
                    def skew_smooth_face_skew_max(self, *args, **kwargs):
                        """
                        Set the face skewness threshold above which deforming boundary faces 
                        will be smoothed using the skewness method.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/skew_smooth_face_skew_max").execute(*args, **kwargs)
                    def skew_smooth_all_deforming_boundaries(self, *args, **kwargs):
                        """
                        Enable/disable skewness smoothing for all deforming 
                        dynamic boundary zones. If disabled, only the deforming dynamic boundary zones are 
                        smoothed which have smoothing explicitly enabled or use local face remeshing.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/skew_smooth_all_deforming_boundaries").execute(*args, **kwargs)
                    def laplace_node_relaxation(self, *args, **kwargs):
                        """
                        Set the Laplace boundary node relaxation factor.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/laplace_node_relaxation").execute(*args, **kwargs)
                    def diffusion_coeff_function(self, *args, **kwargs):
                        """
                        Specify whether the diffusion coefficient is based on the 
                        boundary distance or the cell volume.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/diffusion_coeff_function").execute(*args, **kwargs)
                    def diffusion_coeff_parameter(self, *args, **kwargs):
                        """
                        Set the diffusion coefficient parameter used for diffusion-based smoothing.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/diffusion_coeff_parameter").execute(*args, **kwargs)
                    def diffusion_fvm(self, *args, **kwargs):
                        """
                        Set the numerical method used for diffusion-based smoothing.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/diffusion_fvm").execute(*args, **kwargs)
                    def poisson_ratio(self, *args, **kwargs):
                        """
                        Set the Poisson's ratio used by the linearly elastic solid model.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/poisson_ratio").execute(*args, **kwargs)
                    def smooth_from_reference_position(self, *args, **kwargs):
                        """
                        Enable smoothing from reference position.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/smooth_from_reference_position").execute(*args, **kwargs)
                    def relative_convergence_tolerance(self, *args, **kwargs):
                        """
                        Set the relative residual convergence tolerance for diffusion-based (FVM) smoothing.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/relative_convergence_tolerance").execute(*args, **kwargs)
                    def amg_stabilization(self, *args, **kwargs):
                        """
                        Set the AMG stabilization method for mesh smoothing (FEM).
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/amg_stabilization").execute(*args, **kwargs)
                    def verbosity(self, *args, **kwargs):
                        """
                        Set the verbosity for spring smoothing.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/verbosity").execute(*args, **kwargs)
                    def boundary_distance_method(self, *args, **kwargs):
                        """
                        Set the method used to evaluate the boundary distance for the 
                        diffusion coefficient calculation.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/smoothing_parameters/boundary_distance_method").execute(*args, **kwargs)

                class layering_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the dynamic mesh layering menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def split_factor(self, *args, **kwargs):
                        """
                        Set the factor determining when to split dynamic layers.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/layering_parameters/split_factor").execute(*args, **kwargs)
                    def collapse_factor(self, *args, **kwargs):
                        """
                        Set the factor determining when to collapse dynamic layers.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/layering_parameters/collapse_factor").execute(*args, **kwargs)
                    def constant_height(self, *args, **kwargs):
                        """
                        Enable/disable layering based on constant height, else layering based on constant ratio.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/layering_parameters/constant_height").execute(*args, **kwargs)

                class remeshing_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the dynamic mesh remeshing menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.prism_controls = self.__class__.prism_controls(path + [("prism_controls", None)], service)
                        self.sizing_controls = self.__class__.sizing_controls(path + [("sizing_controls", None)], service)
                        self.prism_layer_parameters = self.__class__.prism_layer_parameters(path + [("prism_layer_parameters", None)], service)
                    def unified_remeshing(self, *args, **kwargs):
                        """
                        Enable/disable unified remeshing.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/unified_remeshing").execute(*args, **kwargs)
                    def retain_size_distribution(self, *args, **kwargs):
                        """
                        Enable/disable retaining of size distribution.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/retain_size_distribution").execute(*args, **kwargs)
                    def poly_remeshing(self, *args, **kwargs):
                        """
                        Enable/disable poly remeshing.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/poly_remeshing").execute(*args, **kwargs)
                    def remeshing_methods(self, *args, **kwargs):
                        """
                        Enable/disable remeshing methods.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/remeshing_methods").execute(*args, **kwargs)
                    def zone_remeshing(self, *args, **kwargs):
                        """
                        Enable/disable cell zone remeshing method.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/zone_remeshing").execute(*args, **kwargs)
                    def length_min(self, *args, **kwargs):
                        """
                        Set the length threshold below which cells will be remeshed.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/length_min").execute(*args, **kwargs)
                    def length_max(self, *args, **kwargs):
                        """
                        Set the length threshold above which cells will be remeshed.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/length_max").execute(*args, **kwargs)
                    def cell_skew_max(self, *args, **kwargs):
                        """
                        Set the cell skewness threshold above which cells will be remeshed.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/cell_skew_max").execute(*args, **kwargs)
                    def face_skew_max(self, *args, **kwargs):
                        """
                        Set the face skewness threshold above which faces will be remeshed.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/face_skew_max").execute(*args, **kwargs)
                    def size_remesh_interval(self, *args, **kwargs):
                        """
                        Set the interval (in time steps) when remeshing based on size is done.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/size_remesh_interval").execute(*args, **kwargs)
                    def sizing_function(self, *args, **kwargs):
                        """
                        Enable/disable sizing function to control size based remeshing.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/sizing_function").execute(*args, **kwargs)
                    def sizing_funct_defaults(self, *args, **kwargs):
                        """
                        Set sizing function defaults.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/sizing_funct_defaults").execute(*args, **kwargs)
                    def sizing_funct_resolution(self, *args, **kwargs):
                        """
                        Set the sizing function resolution with respect to shortest boundary.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/sizing_funct_resolution").execute(*args, **kwargs)
                    def sizing_funct_variation(self, *args, **kwargs):
                        """
                        Set the maximum sizing function increase/decrease in the interior.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/sizing_funct_variation").execute(*args, **kwargs)
                    def sizing_funct_rate(self, *args, **kwargs):
                        """
                        Determine how far from the boundary the increase/decrease happens.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/sizing_funct_rate").execute(*args, **kwargs)
                    def parallel_remeshing(self, *args, **kwargs):
                        """
                        Enable/disable parallel remeshing for zone remeshing.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/parallel_remeshing").execute(*args, **kwargs)
                    def remeshing_after_moving(self, *args, **kwargs):
                        """
                        Enable/disable optional remeshing after mesh motion to meet skewness threshold.
                        Steady state dynamic mesh only.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/remeshing_after_moving").execute(*args, **kwargs)

                    class prism_controls(metaclass=PyMenuMeta):
                        """
                        Specify optional prism controls.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def add(self, *args, **kwargs):
                            """
                            Add a new object.
                            """
                            return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/prism_controls/add").execute(*args, **kwargs)
                        def edit(self, *args, **kwargs):
                            """
                            Edit an object.
                            """
                            return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/prism_controls/edit").execute(*args, **kwargs)
                        def delete(self, *args, **kwargs):
                            """
                            Delete an object.
                            """
                            return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/prism_controls/delete").execute(*args, **kwargs)
                        def list(self, *args, **kwargs):
                            """
                            List objects.
                            """
                            return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/prism_controls/list").execute(*args, **kwargs)
                        def list_properties(self, *args, **kwargs):
                            """
                            List properties of an object.
                            """
                            return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/prism_controls/list_properties").execute(*args, **kwargs)

                    class sizing_controls(metaclass=PyMenuMeta):
                        """
                        Specify optional sizing controls.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def add(self, *args, **kwargs):
                            """
                            Add a new object.
                            """
                            return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/sizing_controls/add").execute(*args, **kwargs)
                        def edit(self, *args, **kwargs):
                            """
                            Edit an object.
                            """
                            return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/sizing_controls/edit").execute(*args, **kwargs)
                        def delete(self, *args, **kwargs):
                            """
                            Delete an object.
                            """
                            return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/sizing_controls/delete").execute(*args, **kwargs)
                        def list(self, *args, **kwargs):
                            """
                            List objects.
                            """
                            return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/sizing_controls/list").execute(*args, **kwargs)
                        def list_properties(self, *args, **kwargs):
                            """
                            List properties of an object.
                            """
                            return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/sizing_controls/list_properties").execute(*args, **kwargs)

                    class prism_layer_parameters(metaclass=PyMenuMeta):
                        """
                        Enter the dynamic mesh prism remeshing menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def first_height(self, *args, **kwargs):
                            """
                            Set first cell height in the prism layer.
                            """
                            return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/prism_layer_parameters/first_height").execute(*args, **kwargs)
                        def growth_rate(self, *args, **kwargs):
                            """
                            Set the geometric growth rate of the prism layer.
                            """
                            return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/prism_layer_parameters/growth_rate").execute(*args, **kwargs)
                        def number_of_layers(self, *args, **kwargs):
                            """
                            Set the number of elements in the prism layer.
                            """
                            return PyMenu(self.service, "/setup/dynamic_mesh/controls/remeshing_parameters/prism_layer_parameters/number_of_layers").execute(*args, **kwargs)

                class in_cylinder_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the dynamic mesh in-cylinder menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def starting_crank_angle(self, *args, **kwargs):
                        """
                        Specify the starting crank angle.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/in_cylinder_parameters/starting_crank_angle").execute(*args, **kwargs)
                    def crank_angle_step(self, *args, **kwargs):
                        """
                        Specify the crank angle step size.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/in_cylinder_parameters/crank_angle_step").execute(*args, **kwargs)
                    def crank_period(self, *args, **kwargs):
                        """
                        Specify the crank period.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/in_cylinder_parameters/crank_period").execute(*args, **kwargs)
                    def max_crank_angle_step(self, *args, **kwargs):
                        """
                        Specify the maximum crank angle step size.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/in_cylinder_parameters/max_crank_angle_step").execute(*args, **kwargs)
                    def piston_data(self, *args, **kwargs):
                        """
                        Specify the crank radius, connecting rod length, and piston pin offset.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/in_cylinder_parameters/piston_data").execute(*args, **kwargs)
                    def piston_stroke_cutoff(self, *args, **kwargs):
                        """
                        Specify the cut off point for in-cylinder piston.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/in_cylinder_parameters/piston_stroke_cutoff").execute(*args, **kwargs)
                    def minimum_lift(self, *args, **kwargs):
                        """
                        Specify the minimum lift for in-cylinder valves.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/in_cylinder_parameters/minimum_lift").execute(*args, **kwargs)
                    def print_plot_lift(self, *args, **kwargs):
                        """
                        Print or plot valve lift curve.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/in_cylinder_parameters/print_plot_lift").execute(*args, **kwargs)
                    def modify_lift(self, *args, **kwargs):
                        """
                        Modify the lift curve (shift or scale).
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/in_cylinder_parameters/modify_lift").execute(*args, **kwargs)
                    def position_starting_mesh(self, *args, **kwargs):
                        """
                        Move mesh from top dead center to starting crank angle.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/in_cylinder_parameters/position_starting_mesh").execute(*args, **kwargs)

                class implicit_update_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the dynamic mesh implicit update menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def update_interval(self, *args, **kwargs):
                        """
                        Specify update interval of implicit update.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/implicit_update_parameters/update_interval").execute(*args, **kwargs)
                    def motion_relaxation(self, *args, **kwargs):
                        """
                        Specify motion relaxation of implicit update.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/implicit_update_parameters/motion_relaxation").execute(*args, **kwargs)
                    def residual_criteria(self, *args, **kwargs):
                        """
                        Specify residual criteria of implicit update.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/implicit_update_parameters/residual_criteria").execute(*args, **kwargs)

                class six_dof_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the dynamic mesh six-dof menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def create_properties(self, *args, **kwargs):
                        """
                        Create a set of Six DOF Properties.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/six_dof_parameters/create_properties").execute(*args, **kwargs)
                    def delete_properties(self, *args, **kwargs):
                        """
                        Delete a set of Six DOF Properties.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/six_dof_parameters/delete_properties").execute(*args, **kwargs)
                    def list_properties(self, *args, **kwargs):
                        """
                        List Six DOF Properties.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/six_dof_parameters/list_properties").execute(*args, **kwargs)
                    def x_component_of_gravity(self, *args, **kwargs):
                        """
                        Specify x-component-of-gravity.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/six_dof_parameters/x_component_of_gravity").execute(*args, **kwargs)
                    def y_component_of_gravity(self, *args, **kwargs):
                        """
                        Specify y-component-of-gravity.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/six_dof_parameters/y_component_of_gravity").execute(*args, **kwargs)
                    def z_component_of_gravity(self, *args, **kwargs):
                        """
                        Specify z-component-of-gravity.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/six_dof_parameters/z_component_of_gravity").execute(*args, **kwargs)
                    def second_order(self, *args, **kwargs):
                        """
                        Enable/disable second order six DOF solver.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/six_dof_parameters/second_order").execute(*args, **kwargs)
                    def motion_history(self, *args, **kwargs):
                        """
                        Enable/disable writing position/orientation of six DOF zones to file.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/six_dof_parameters/motion_history").execute(*args, **kwargs)
                    def motion_history_file_name(self, *args, **kwargs):
                        """
                        Location of six DOF motion history file.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/six_dof_parameters/motion_history_file_name").execute(*args, **kwargs)

                class periodic_displacement_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the dynamic mesh periodic displacement menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def list_displacements(self, *args, **kwargs):
                        """
                        List Periodic Displacements.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/periodic_displacement_parameters/list_displacements").execute(*args, **kwargs)
                    def create_displacement(self, *args, **kwargs):
                        """
                        Create Periodic Displacement.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/periodic_displacement_parameters/create_displacement").execute(*args, **kwargs)
                    def edit_displacement(self, *args, **kwargs):
                        """
                        Edit Periodic Displacement.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/periodic_displacement_parameters/edit_displacement").execute(*args, **kwargs)
                    def copy_displacement(self, *args, **kwargs):
                        """
                        Copy Periodic Displacement.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/periodic_displacement_parameters/copy_displacement").execute(*args, **kwargs)
                    def delete_displacement(self, *args, **kwargs):
                        """
                        Delete Periodic Displacement.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/periodic_displacement_parameters/delete_displacement").execute(*args, **kwargs)
                    def delete_all_displacements(self, *args, **kwargs):
                        """
                        Delete All Periodic Displacements.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/periodic_displacement_parameters/delete_all_displacements").execute(*args, **kwargs)
                    def create_group(self, *args, **kwargs):
                        """
                        Create Periodic Displacement Group.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/periodic_displacement_parameters/create_group").execute(*args, **kwargs)
                    def list_groups(self, *args, **kwargs):
                        """
                        List Periodic Displacement Groups.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/periodic_displacement_parameters/list_groups").execute(*args, **kwargs)
                    def edit_group(self, *args, **kwargs):
                        """
                        Edit Periodic Displacement Group.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/periodic_displacement_parameters/edit_group").execute(*args, **kwargs)
                    def delete_group(self, *args, **kwargs):
                        """
                        Delete Periodic Displacement Group.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/periodic_displacement_parameters/delete_group").execute(*args, **kwargs)
                    def delete_all_groups(self, *args, **kwargs):
                        """
                        Delete All Periodic Displacement Groups.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/periodic_displacement_parameters/delete_all_groups").execute(*args, **kwargs)
                    def set_active_displacement(self, *args, **kwargs):
                        """
                        Set Active Periodic Displacement in Group.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/periodic_displacement_parameters/set_active_displacement").execute(*args, **kwargs)

                class contact_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the dynamic mesh contact detection menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.flow_control_parameters = self.__class__.flow_control_parameters(path + [("flow_control_parameters", None)], service)
                    def contact_face_zones(self, *args, **kwargs):
                        """
                        Select face zones involved in contact detection.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/contact_parameters/contact_face_zones").execute(*args, **kwargs)
                    def contact_udf(self, *args, **kwargs):
                        """
                        Select UDF to be invoked when contact is detected.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/contact_parameters/contact_udf").execute(*args, **kwargs)
                    def contact_threshold(self, *args, **kwargs):
                        """
                        Specify threshold distance for contact detection.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/contact_parameters/contact_threshold").execute(*args, **kwargs)
                    def update_contact_marks(self, *args, **kwargs):
                        """
                        Update which cells are marked in order to block flow in the contact region.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/contact_parameters/update_contact_marks").execute(*args, **kwargs)
                    def flow_control(self, *args, **kwargs):
                        """
                        Enable/disable flow control.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/contact_parameters/flow_control").execute(*args, **kwargs)
                    def contact_method(self, *args, **kwargs):
                        """
                        Select the method used for flow control in the contact region.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/contact_parameters/contact_method").execute(*args, **kwargs)
                    def render_contact_cells(self, *args, **kwargs):
                        """
                        Set the option to include contact-cells in post-processing.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/contact_parameters/render_contact_cells").execute(*args, **kwargs)
                    def verbosity(self, *args, **kwargs):
                        """
                        Set the verbosity for contact-detection.
                        """
                        return PyMenu(self.service, "/setup/dynamic_mesh/controls/contact_parameters/verbosity").execute(*args, **kwargs)

                    class flow_control_parameters(metaclass=PyMenuMeta):
                        """
                        Enter the flow control menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def solution_stabilization(self, *args, **kwargs):
                            """
                            Enable/disable the performance of additional iterations per time step and 
                                the application of solution controls to improve the stability of the solver.
                            """
                            return PyMenu(self.service, "/setup/dynamic_mesh/controls/contact_parameters/flow_control_parameters/solution_stabilization").execute(*args, **kwargs)
                        def create_flow_control_zone(self, *args, **kwargs):
                            """
                            Create a flow control zone.
                            """
                            return PyMenu(self.service, "/setup/dynamic_mesh/controls/contact_parameters/flow_control_parameters/create_flow_control_zone").execute(*args, **kwargs)
                        def delete_flow_control_zone(self, *args, **kwargs):
                            """
                            Delete a flow control zone.
                            """
                            return PyMenu(self.service, "/setup/dynamic_mesh/controls/contact_parameters/flow_control_parameters/delete_flow_control_zone").execute(*args, **kwargs)

            class events(metaclass=PyMenuMeta):
                """
                Enter the dynamic mesh events menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def import_event_file(self, *args, **kwargs):
                    """
                    Import dynamic mesh event file.
                    """
                    return PyMenu(self.service, "/setup/dynamic_mesh/events/import_event_file").execute(*args, **kwargs)
                def export_event_file(self, *args, **kwargs):
                    """
                    Export dynamic mesh events to file.
                    """
                    return PyMenu(self.service, "/setup/dynamic_mesh/events/export_event_file").execute(*args, **kwargs)

            class zones(metaclass=PyMenuMeta):
                """
                Enter the dynamic mesh zones menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def create(self, *args, **kwargs):
                    """
                    Create dynamic zone.
                    """
                    return PyMenu(self.service, "/setup/dynamic_mesh/zones/create").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete dynamic zone.
                    """
                    return PyMenu(self.service, "/setup/dynamic_mesh/zones/delete").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    List dynamic zones.
                    """
                    return PyMenu(self.service, "/setup/dynamic_mesh/zones/list").execute(*args, **kwargs)
                def insert_boundary_layer(self, *args, **kwargs):
                    """
                    Insert new cell zone.
                    """
                    return PyMenu(self.service, "/setup/dynamic_mesh/zones/insert_boundary_layer").execute(*args, **kwargs)
                def remove_boundary_layer(self, *args, **kwargs):
                    """
                    Remove cell zone.
                    """
                    return PyMenu(self.service, "/setup/dynamic_mesh/zones/remove_boundary_layer").execute(*args, **kwargs)
                def insert_interior_layer(self, *args, **kwargs):
                    """
                    Insert new layer cell zone at specified location.
                    """
                    return PyMenu(self.service, "/setup/dynamic_mesh/zones/insert_interior_layer").execute(*args, **kwargs)
                def remove_interior_layer(self, *args, **kwargs):
                    """
                    Remove interior layer cell zone.
                    """
                    return PyMenu(self.service, "/setup/dynamic_mesh/zones/remove_interior_layer").execute(*args, **kwargs)

            class actions(metaclass=PyMenuMeta):
                """
                Enter the dynamic mesh actions menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def remesh_cell_zone(self, *args, **kwargs):
                    """
                    Manually remesh cell zone with option to remesh adjacent dynamic face zones.
                    """
                    return PyMenu(self.service, "/setup/dynamic_mesh/actions/remesh_cell_zone").execute(*args, **kwargs)

            class transient_settings(metaclass=PyMenuMeta):
                """
                Enter the dynamic mesh transient settings menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def verbosity(self, *args, **kwargs):
                    """
                    Enable/disable transient scheme verbosity for dynamic mesh cases.
                    """
                    return PyMenu(self.service, "/setup/dynamic_mesh/transient_settings/verbosity").execute(*args, **kwargs)
                def allow_second_order(self, *args, **kwargs):
                    """
                    Enable/disable 2nd order transient scheme for dynamic mesh cases.
                    """
                    return PyMenu(self.service, "/setup/dynamic_mesh/transient_settings/allow_second_order").execute(*args, **kwargs)

        class expert(metaclass=PyMenuMeta):
            """
            Enter expert setup menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.spectral = self.__class__.spectral(path + [("spectral", None)], service)
            def beta_feature_access(self, *args, **kwargs):
                """
                Enable access to beta features in the interface.
                """
                return PyMenu(self.service, "/setup/expert/beta_feature_access").execute(*args, **kwargs)
            def enable_mesh_morpher_optimizer(self, *args, **kwargs):
                """
                Enable use of mesh morpher/optimizer.
                """
                return PyMenu(self.service, "/setup/expert/enable_mesh_morpher_optimizer").execute(*args, **kwargs)
            def heterogeneous_stiff_chemistry(self, *args, **kwargs):
                """
                Set heterogeneous stiff-chemistry solver.
                """
                return PyMenu(self.service, "/setup/expert/heterogeneous_stiff_chemistry").execute(*args, **kwargs)
            def stiff_chemistry(self, *args, **kwargs):
                """
                Set solver options for stiff-chemistry solutions.
                """
                return PyMenu(self.service, "/setup/expert/stiff_chemistry").execute(*args, **kwargs)

            class spectral(metaclass=PyMenuMeta):
                """
                Enter the Spectral menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def calculate_fourier_coefficients(self, *args, **kwargs):
                    """
                    Calculates Fourier coefficient data.
                    """
                    return PyMenu(self.service, "/setup/expert/spectral/calculate_fourier_coefficients").execute(*args, **kwargs)
                def delete_fourier_coefficients(self, *args, **kwargs):
                    """
                    Deletes Fourier coefficient data.
                    """
                    return PyMenu(self.service, "/setup/expert/spectral/delete_fourier_coefficients").execute(*args, **kwargs)
                def calculate_harmonic_exports(self, *args, **kwargs):
                    """
                    Calculates Harmonic Export data.
                    """
                    return PyMenu(self.service, "/setup/expert/spectral/calculate_harmonic_exports").execute(*args, **kwargs)
                def delete_harmonic_exports(self, *args, **kwargs):
                    """
                    Deletes Harmonic Export data.
                    """
                    return PyMenu(self.service, "/setup/expert/spectral/delete_harmonic_exports").execute(*args, **kwargs)

        class gap_model(metaclass=PyMenuMeta):
            """
            Enter the narrow-gaps menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.advanced_options = self.__class__.advanced_options(path + [("advanced_options", None)], service)
            def enable(self, *args, **kwargs):
                """
                Enable/Disable gap model.
                """
                return PyMenu(self.service, "/setup/gap_model/enable").execute(*args, **kwargs)
            def create(self, *args, **kwargs):
                """
                Create a gap object.
                """
                return PyMenu(self.service, "/setup/gap_model/create").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an exiting gap object.
                """
                return PyMenu(self.service, "/setup/gap_model/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an exiting gap object.
                """
                return PyMenu(self.service, "/setup/gap_model/delete").execute(*args, **kwargs)
            def delete_all(self, *args, **kwargs):
                """
                Delete all of the exiting gap objects.
                """
                return PyMenu(self.service, "/setup/gap_model/delete_all").execute(*args, **kwargs)
            def list_gap_regions(self, *args, **kwargs):
                """
                List gap regions.
                """
                return PyMenu(self.service, "/setup/gap_model/list_gap_regions").execute(*args, **kwargs)
            def list_gap_face_zones(self, *args, **kwargs):
                """
                List name of the gap face zones that can be used for gaps creation.
                """
                return PyMenu(self.service, "/setup/gap_model/list_gap_face_zones").execute(*args, **kwargs)
            def list_gap_cell_zones(self, *args, **kwargs):
                """
                List name of the gap cells zones that can be used as exclided cell zones in gaps creation.
                """
                return PyMenu(self.service, "/setup/gap_model/list_gap_cell_zones").execute(*args, **kwargs)
            def render_gap_regions(self, *args, **kwargs):
                """
                Update gap regions for postprocessing.
                """
                return PyMenu(self.service, "/setup/gap_model/render_gap_regions").execute(*args, **kwargs)

            class advanced_options(metaclass=PyMenuMeta):
                """
                Show options.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def expert(self, *args, **kwargs):
                    """
                    Enable expert options for gap model.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/expert").execute(*args, **kwargs)
                def alternative_marking(self, *args, **kwargs):
                    """
                    Mark gap regions using an alternative marking algorithm.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/alternative_marking").execute(*args, **kwargs)
                def cell_check_distance_factor(self, *args, **kwargs):
                    """
                    Enter value of the cell distance factor.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/cell_check_distance_factor").execute(*args, **kwargs)
                def flow_blocking_stabilization_parameters(self, *args, **kwargs):
                    """
                    Adjust stabilization settings for the sponge layer used for blocked gap regions.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/flow_blocking_stabilization_parameters").execute(*args, **kwargs)
                def update_gap_regions(self, *args, **kwargs):
                    """
                    Update gap regions and gap model solution information.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/update_gap_regions").execute(*args, **kwargs)
                def clear_gap_regions(self, *args, **kwargs):
                    """
                    Clear gap model solution information and marks.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/clear_gap_regions").execute(*args, **kwargs)
                def precise_gap_marking(self, *args, **kwargs):
                    """
                    Mark cells in gap regions using more accurate search algorithm.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/precise_gap_marking").execute(*args, **kwargs)
                def render_flow_modeling_gaps(self, *args, **kwargs):
                    """
                    Render solution inside flow modeling gap cells.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/render_flow_modeling_gaps").execute(*args, **kwargs)
                def reduce_gap_regions(self, *args, **kwargs):
                    """
                    Using a more restrictive algorithm for marking cells in gap regions.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/reduce_gap_regions").execute(*args, **kwargs)
                def fill_data_in_gap_regions(self, *args, **kwargs):
                    """
                    Interpolate solution data into the whole gap regions.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/fill_data_in_gap_regions").execute(*args, **kwargs)
                def enhanced_data_interpolation(self, *args, **kwargs):
                    """
                    Use enhanced data interpolation for updating information in gap regions.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/enhanced_data_interpolation").execute(*args, **kwargs)
                def sponge_layer(self, *args, **kwargs):
                    """
                    Set advanced settings for gap sponge layer.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/sponge_layer").execute(*args, **kwargs)
                def solution_stabilization(self, *args, **kwargs):
                    """
                    Set solution stabilization level for gap model.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/solution_stabilization").execute(*args, **kwargs)
                def include_coupled_walls(self, *args, **kwargs):
                    """
                    Include coupled walls in gap face zones.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/include_coupled_walls").execute(*args, **kwargs)
                def check_cfl_condition(self, *args, **kwargs):
                    """
                    Check time step size for better convergence.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/check_cfl_condition").execute(*args, **kwargs)
                def extend_gap_regions(self, *args, **kwargs):
                    """
                    Extend gap regions for better convergence.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/extend_gap_regions").execute(*args, **kwargs)
                def revert_controls_to_default(self, *args, **kwargs):
                    """
                    Revert gap stabilization and any related solver settings to default.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/revert_controls_to_default").execute(*args, **kwargs)
                def verbosity(self, *args, **kwargs):
                    """
                    Set the verbosity for gap model.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/verbosity").execute(*args, **kwargs)
                def render_gap_interface(self, *args, **kwargs):
                    """
                    Render gap interface.
                    """
                    return PyMenu(self.service, "/setup/gap_model/advanced_options/render_gap_interface").execute(*args, **kwargs)

        class materials(metaclass=PyMenuMeta):
            """
            Enter the materials menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.data_base = self.__class__.data_base(path + [("data_base", None)], service)
            def change_create(self, *args, **kwargs):
                """
                Change the properties of a locally-stored material or create a new material.
                """
                return PyMenu(self.service, "/setup/materials/change_create").execute(*args, **kwargs)
            def copy(self, *args, **kwargs):
                """
                Copy a material from the database.
                """
                return PyMenu(self.service, "/setup/materials/copy").execute(*args, **kwargs)
            def copy_by_formula(self, *args, **kwargs):
                """
                Copy a material from the database by formula.
                """
                return PyMenu(self.service, "/setup/materials/copy_by_formula").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete a material from local storage.
                """
                return PyMenu(self.service, "/setup/materials/delete").execute(*args, **kwargs)
            def list_materials(self, *args, **kwargs):
                """
                List all locally-stored materials.
                """
                return PyMenu(self.service, "/setup/materials/list_materials").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                List the properties of a locally-stored material.
                """
                return PyMenu(self.service, "/setup/materials/list_properties").execute(*args, **kwargs)

            class data_base(metaclass=PyMenuMeta):
                """
                Enter the database menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def database_type(self, *args, **kwargs):
                    """
                    Set the database type.
                    """
                    return PyMenu(self.service, "/setup/materials/data_base/database_type").execute(*args, **kwargs)
                def edit(self, *args, **kwargs):
                    """
                    Edit a material.
                    """
                    return PyMenu(self.service, "/setup/materials/data_base/edit").execute(*args, **kwargs)
                def list_materials(self, *args, **kwargs):
                    """
                    List all materials in the database.
                    """
                    return PyMenu(self.service, "/setup/materials/data_base/list_materials").execute(*args, **kwargs)
                def list_properties(self, *args, **kwargs):
                    """
                    List the properties of a material in the database.
                    """
                    return PyMenu(self.service, "/setup/materials/data_base/list_properties").execute(*args, **kwargs)
                def new(self, *args, **kwargs):
                    """
                    Define a new material.
                    """
                    return PyMenu(self.service, "/setup/materials/data_base/new").execute(*args, **kwargs)
                def save(self, *args, **kwargs):
                    """
                    Save user-defined database.
                    """
                    return PyMenu(self.service, "/setup/materials/data_base/save").execute(*args, **kwargs)

        class mesh_interfaces(metaclass=PyMenuMeta):
            """
            Enter the mesh-interfaces menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.non_conformal_interface_numerics = self.__class__.non_conformal_interface_numerics(path + [("non_conformal_interface_numerics", None)], service)
                self.mapped_interface_options = self.__class__.mapped_interface_options(path + [("mapped_interface_options", None)], service)
                self.auto_options = self.__class__.auto_options(path + [("auto_options", None)], service)
            def create(self, *args, **kwargs):
                """
                Create a mesh interface.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/create").execute(*args, **kwargs)
            def turbo_create(self, *args, **kwargs):
                """
                Create a general turbo interface.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/turbo_create").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit a mesh interface.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete a mesh interface.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/delete").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                Display specified mesh interface zone.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/display").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List all mesh-interfaces.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/list").execute(*args, **kwargs)
            def make_periodic(self, *args, **kwargs):
                """
                Make interface zones periodic.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/make_periodic").execute(*args, **kwargs)
            def make_phaselag_from_boundaries(self, *args, **kwargs):
                """
                Make interface zones phase lagged.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/make_phaselag_from_boundaries").execute(*args, **kwargs)
            def make_phaselag_from_periodic(self, *args, **kwargs):
                """
                Convert periodic interface to phase lagged.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/make_phaselag_from_periodic").execute(*args, **kwargs)
            def delete_all(self, *args, **kwargs):
                """
                Delete all mesh interfaces.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/delete_all").execute(*args, **kwargs)
            def enforce_continuity_after_bc(self, *args, **kwargs):
                """
                Across the interface, enforces continuity over boundary condition.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/enforce_continuity_after_bc").execute(*args, **kwargs)
            def verbosity(self, *args, **kwargs):
                """
                Set mesh interface verbosity.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/verbosity").execute(*args, **kwargs)
            def enable_si_with_nodes(self, *args, **kwargs):
                """
                Enable sliding interfaces with nodes.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/enable_si_with_nodes").execute(*args, **kwargs)
            def enforce_coupled_wall_between_solids(self, *args, **kwargs):
                """
                Create coupled wall interface between solids.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/enforce_coupled_wall_between_solids").execute(*args, **kwargs)
            def improve_quality(self, *args, **kwargs):
                """
                Improve mesh interface quality.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/improve_quality").execute(*args, **kwargs)
            def one_to_one_pairing(self, *args, **kwargs):
                """
                Use the default one-to-one interface creation method?.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/one_to_one_pairing").execute(*args, **kwargs)
            def auto_pairing(self, *args, **kwargs):
                """
                Automatically pair and create mesh interfaces for some or all interface zones.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/auto_pairing").execute(*args, **kwargs)
            def enable_visualization_of_interfaces(self, *args, **kwargs):
                """
                Display facets on mesh interfaces.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/enable_visualization_of_interfaces").execute(*args, **kwargs)
            def transfer_motion_across_interfaces(self, *args, **kwargs):
                """
                Transfer motion from one side of the interface to the other when only one side undergoes user-defined or system-coupling motion.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/transfer_motion_across_interfaces").execute(*args, **kwargs)
            def non_overlapping_zone_name(self, *args, **kwargs):
                """
                Get non-overlapping zone name from the associated interface zone.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/non_overlapping_zone_name").execute(*args, **kwargs)
            def remove_left_handed_interface_faces(self, *args, **kwargs):
                """
                Remove left-handed faces during mesh interface creation.
                """
                return PyMenu(self.service, "/setup/mesh_interfaces/remove_left_handed_interface_faces").execute(*args, **kwargs)

            class non_conformal_interface_numerics(metaclass=PyMenuMeta):
                """
                Setting non-conformal numerics options.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def change_numerics(self, *args, **kwargs):
                    """
                    Enable modified non-conformal interface numerics.
                    """
                    return PyMenu(self.service, "/setup/mesh_interfaces/non_conformal_interface_numerics/change_numerics").execute(*args, **kwargs)

            class mapped_interface_options(metaclass=PyMenuMeta):
                """
                Enter the mapped-interface-options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def solution_controls(self, *args, **kwargs):
                    """
                    Specification of mapped frequency and under-relaxation factor for mapped interfaces.
                    """
                    return PyMenu(self.service, "/setup/mesh_interfaces/mapped_interface_options/solution_controls").execute(*args, **kwargs)
                def tolerance(self, *args, **kwargs):
                    """
                    Specification of mapped interface tolerance.
                    """
                    return PyMenu(self.service, "/setup/mesh_interfaces/mapped_interface_options/tolerance").execute(*args, **kwargs)
                def convert_to_mapped_interface(self, *args, **kwargs):
                    """
                    Convert non-conformal mesh interface to mapped mesh interfaces.
                    """
                    return PyMenu(self.service, "/setup/mesh_interfaces/mapped_interface_options/convert_to_mapped_interface").execute(*args, **kwargs)

            class auto_options(metaclass=PyMenuMeta):
                """
                Enter auto-options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def proximity_tolerance(self, *args, **kwargs):
                    """
                    Specification of auto pairing tolerance.
                    """
                    return PyMenu(self.service, "/setup/mesh_interfaces/auto_options/proximity_tolerance").execute(*args, **kwargs)
                def naming_option(self, *args, **kwargs):
                    """
                    Specify whether or not to include an informative suffix to the mesh interface name.
                    """
                    return PyMenu(self.service, "/setup/mesh_interfaces/auto_options/naming_option").execute(*args, **kwargs)
                def set_default_name_prefix(self, *args, **kwargs):
                    """
                    Specification of auto pairing default name prefix.
                    """
                    return PyMenu(self.service, "/setup/mesh_interfaces/auto_options/set_default_name_prefix").execute(*args, **kwargs)
                def set_one_to_one_pairing_tolerance(self, *args, **kwargs):
                    """
                    Enable/disable one-to-one auto pairing tolerance.
                    """
                    return PyMenu(self.service, "/setup/mesh_interfaces/auto_options/set_one_to_one_pairing_tolerance").execute(*args, **kwargs)
                def pairing_between_different_cell_zones_only(self, *args, **kwargs):
                    """
                    Pairing between interface zones from different cell zones only.
                    """
                    return PyMenu(self.service, "/setup/mesh_interfaces/auto_options/pairing_between_different_cell_zones_only").execute(*args, **kwargs)
                def pairing_between_interface_zones_only(self, *args, **kwargs):
                    """
                    Pairing between interface zones only.
                    """
                    return PyMenu(self.service, "/setup/mesh_interfaces/auto_options/pairing_between_interface_zones_only").execute(*args, **kwargs)
                def keep_empty_interface(self, *args, **kwargs):
                    """
                    Keep empty interfaces during one-to-one mesh interface creation.
                    """
                    return PyMenu(self.service, "/setup/mesh_interfaces/auto_options/keep_empty_interface").execute(*args, **kwargs)

        class mixing_planes(metaclass=PyMenuMeta):
            """
            Enter the mixing planes menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.set = self.__class__.set(path + [("set", None)], service)
            def create(self, *args, **kwargs):
                """
                Create a mixing plane.
                """
                return PyMenu(self.service, "/setup/mixing_planes/create").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete a mixing plane.
                """
                return PyMenu(self.service, "/setup/mixing_planes/delete").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List defined mixing plane(s).
                """
                return PyMenu(self.service, "/setup/mixing_planes/list").execute(*args, **kwargs)

            class set(metaclass=PyMenuMeta):
                """
                Enter the mixing plane set menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.conserve_swirl = self.__class__.conserve_swirl(path + [("conserve_swirl", None)], service)
                    self.conserve_total_enthalpy = self.__class__.conserve_total_enthalpy(path + [("conserve_total_enthalpy", None)], service)
                def under_relaxation(self, *args, **kwargs):
                    """
                    Set mixing plane under-relaxation factor.
                    """
                    return PyMenu(self.service, "/setup/mixing_planes/set/under_relaxation").execute(*args, **kwargs)
                def averaging_method(self, *args, **kwargs):
                    """
                    Set mixing plane profile averaging method.
                    """
                    return PyMenu(self.service, "/setup/mixing_planes/set/averaging_method").execute(*args, **kwargs)
                def fix_pressure_level(self, *args, **kwargs):
                    """
                    Set fix pressure level using define/reference-pressure-location.
                    """
                    return PyMenu(self.service, "/setup/mixing_planes/set/fix_pressure_level").execute(*args, **kwargs)

                class conserve_swirl(metaclass=PyMenuMeta):
                    """
                    Enter the mixing plane conserve-swirl menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def enable(self, *args, **kwargs):
                        """
                        Enable/disable swirl conservation in mixing plane.
                        """
                        return PyMenu(self.service, "/setup/mixing_planes/set/conserve_swirl/enable").execute(*args, **kwargs)
                    def verbosity(self, *args, **kwargs):
                        """
                        Enable/disable verbosity in swirl conservation calculations.
                        """
                        return PyMenu(self.service, "/setup/mixing_planes/set/conserve_swirl/verbosity").execute(*args, **kwargs)
                    def report_swirl_integration(self, *args, **kwargs):
                        """
                        Report swirl integration (torque) on inflow and outflow zones.
                        """
                        return PyMenu(self.service, "/setup/mixing_planes/set/conserve_swirl/report_swirl_integration").execute(*args, **kwargs)

                class conserve_total_enthalpy(metaclass=PyMenuMeta):
                    """
                    Enter the menu to set total enthalpy conservation in mixing plane menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def enable(self, *args, **kwargs):
                        """
                        Enable/disable total enthalpy conservation in mixing plane.
                        """
                        return PyMenu(self.service, "/setup/mixing_planes/set/conserve_total_enthalpy/enable").execute(*args, **kwargs)
                    def verbosity(self, *args, **kwargs):
                        """
                        Enable/disable verbosity in total-enthalpy conservation calculations.
                        """
                        return PyMenu(self.service, "/setup/mixing_planes/set/conserve_total_enthalpy/verbosity").execute(*args, **kwargs)

        class models(metaclass=PyMenuMeta):
            """
            Enter the models menu to configure the solver.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.acoustics = self.__class__.acoustics(path + [("acoustics", None)], service)
                self.optics = self.__class__.optics(path + [("optics", None)], service)
                self.eulerian_wallfilm = self.__class__.eulerian_wallfilm(path + [("eulerian_wallfilm", None)], service)
                self.dpm = self.__class__.dpm(path + [("dpm", None)], service)
                self.shell_conduction = self.__class__.shell_conduction(path + [("shell_conduction", None)], service)
                self.system_coupling_settings = self.__class__.system_coupling_settings(path + [("system_coupling_settings", None)], service)
                self.cht = self.__class__.cht(path + [("cht", None)], service)
                self.two_temperature = self.__class__.two_temperature(path + [("two_temperature", None)], service)
                self.multiphase = self.__class__.multiphase(path + [("multiphase", None)], service)
                self.nox_parameters = self.__class__.nox_parameters(path + [("nox_parameters", None)], service)
                self.soot_parameters = self.__class__.soot_parameters(path + [("soot_parameters", None)], service)
                self.radiation = self.__class__.radiation(path + [("radiation", None)], service)
                self.solver = self.__class__.solver(path + [("solver", None)], service)
                self.species = self.__class__.species(path + [("species", None)], service)
                self.viscous = self.__class__.viscous(path + [("viscous", None)], service)
                self.structure = self.__class__.structure(path + [("structure", None)], service)
                self.heat_exchanger = self.__class__.heat_exchanger(path + [("heat_exchanger", None)], service)
                self.electrolysis_setup = self.__class__.electrolysis_setup(path + [("electrolysis_setup", None)], service)
            def addon_module(self, *args, **kwargs):
                """
                Load addon module.
                """
                return PyMenu(self.service, "/setup/models/addon_module").execute(*args, **kwargs)
            def axisymmetric(self, *args, **kwargs):
                """
                Enable/disable the axisymmetric model.
                """
                return PyMenu(self.service, "/setup/models/axisymmetric").execute(*args, **kwargs)
            def solidification_melting(self, *args, **kwargs):
                """
                Enable/disable the solidification and melting model.
                """
                return PyMenu(self.service, "/setup/models/solidification_melting").execute(*args, **kwargs)
            def crevice_model(self, *args, **kwargs):
                """
                Enable/disable the crevice model.
                """
                return PyMenu(self.service, "/setup/models/crevice_model").execute(*args, **kwargs)
            def crevice_model_controls(self, *args, **kwargs):
                """
                Enter the crevice model controls menu.
                """
                return PyMenu(self.service, "/setup/models/crevice_model_controls").execute(*args, **kwargs)
            def energy(self, *args, **kwargs):
                """
                Enable/disable the energy model.
                """
                return PyMenu(self.service, "/setup/models/energy").execute(*args, **kwargs)
            def noniterative_time_advance(self, *args, **kwargs):
                """
                Enable/disable the noniterative time advancement scheme.
                """
                return PyMenu(self.service, "/setup/models/noniterative_time_advance").execute(*args, **kwargs)
            def nox(self, *args, **kwargs):
                """
                Enable/disable the NOx model.
                """
                return PyMenu(self.service, "/setup/models/nox").execute(*args, **kwargs)
            def soot(self, *args, **kwargs):
                """
                Enable/disable the soot model.
                """
                return PyMenu(self.service, "/setup/models/soot").execute(*args, **kwargs)
            def steady(self, *args, **kwargs):
                """
                Enable/disable the steady solution model.
                """
                return PyMenu(self.service, "/setup/models/steady").execute(*args, **kwargs)
            def swirl(self, *args, **kwargs):
                """
                Enable/disable axisymmetric swirl velocity.
                """
                return PyMenu(self.service, "/setup/models/swirl").execute(*args, **kwargs)
            def unsteady_1st_order(self, *args, **kwargs):
                """
                Enable/disable first-order unsteady solution model.
                """
                return PyMenu(self.service, "/setup/models/unsteady_1st_order").execute(*args, **kwargs)
            def frozen_flux(self, *args, **kwargs):
                """
                Enable/disable frozen flux formulation for transient flows.
                """
                return PyMenu(self.service, "/setup/models/frozen_flux").execute(*args, **kwargs)
            def unsteady_2nd_order(self, *args, **kwargs):
                """
                Enable/disable the second-order unsteady solution model.
                """
                return PyMenu(self.service, "/setup/models/unsteady_2nd_order").execute(*args, **kwargs)
            def unsteady_2nd_order_bounded(self, *args, **kwargs):
                """
                Enable/disable bounded second-order unsteady formulation.
                """
                return PyMenu(self.service, "/setup/models/unsteady_2nd_order_bounded").execute(*args, **kwargs)
            def unsteady_global_time(self, *args, **kwargs):
                """
                Enable/disable the unsteady global-time-step solution model.
                """
                return PyMenu(self.service, "/setup/models/unsteady_global_time").execute(*args, **kwargs)
            def unsteady_structure_newmark(self, *args, **kwargs):
                """
                Enable/disable Newmark unsteady solution model.
                """
                return PyMenu(self.service, "/setup/models/unsteady_structure_newmark").execute(*args, **kwargs)
            def unsteady_structure_euler(self, *args, **kwargs):
                """
                Enable/disable Backward Euler unsteady solution model.
                """
                return PyMenu(self.service, "/setup/models/unsteady_structure_euler").execute(*args, **kwargs)
            def battery_model(self, *args, **kwargs):
                """
                Enter battery model menu.
                """
                return PyMenu(self.service, "/setup/models/battery_model").execute(*args, **kwargs)
            def ablation(self, *args, **kwargs):
                """
                Enable/disable ablation model.
                """
                return PyMenu(self.service, "/setup/models/ablation").execute(*args, **kwargs)
            def potential_and_li_ion_battery(self, *args, **kwargs):
                """
                Enable/disable the electric-potential model.
                """
                return PyMenu(self.service, "/setup/models/potential_and_li_ion_battery").execute(*args, **kwargs)

            class acoustics(metaclass=PyMenuMeta):
                """
                Enter the acoustics model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.far_field_parameters = self.__class__.far_field_parameters(path + [("far_field_parameters", None)], service)
                    self.wave_equation_options = self.__class__.wave_equation_options(path + [("wave_equation_options", None)], service)
                    self.sources_fft = self.__class__.sources_fft(path + [("sources_fft", None)], service)
                    self.sponge_layers = self.__class__.sponge_layers(path + [("sponge_layers", None)], service)
                def off(self, *args, **kwargs):
                    """
                    Enable/disable the acoustics model.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/off").execute(*args, **kwargs)
                def ffowcs_williams(self, *args, **kwargs):
                    """
                    Enable/disable the Ffowcs-Williams-and-Hawkings model.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/ffowcs_williams").execute(*args, **kwargs)
                def broad_band_noise(self, *args, **kwargs):
                    """
                    Enable/disable the broadband noise model.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/broad_band_noise").execute(*args, **kwargs)
                def modal_analysis(self, *args, **kwargs):
                    """
                    Enable/disable the modal analysis model.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/modal_analysis").execute(*args, **kwargs)
                def wave_equation(self, *args, **kwargs):
                    """
                    Enable/disable the wave equation model.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/wave_equation").execute(*args, **kwargs)
                def receivers(self, *args, **kwargs):
                    """
                    Set acoustic receivers.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/receivers").execute(*args, **kwargs)
                def export_source_data(self, *args, **kwargs):
                    """
                    Enable export acoustic source data in ASD format during the wave equation model run.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/export_source_data").execute(*args, **kwargs)
                def export_source_data_cgns(self, *args, **kwargs):
                    """
                    Export acoustic source data in CGNS format.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/export_source_data_cgns").execute(*args, **kwargs)
                def sources(self, *args, **kwargs):
                    """
                    Set acoustic sources.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/sources").execute(*args, **kwargs)
                def read_compute_write(self, *args, **kwargs):
                    """
                    Read acoustic source data files and compute sound pressure.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/read_compute_write").execute(*args, **kwargs)
                def write_acoustic_signals(self, *args, **kwargs):
                    """
                    Write on-the-fly sound pressure.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/write_acoustic_signals").execute(*args, **kwargs)
                def compute_write(self, *args, **kwargs):
                    """
                    Compute sound pressure.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/compute_write").execute(*args, **kwargs)
                def write_centroid_info(self, *args, **kwargs):
                    """
                    Write centroid info.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/write_centroid_info").execute(*args, **kwargs)
                def acoustic_modal_analysis(self, *args, **kwargs):
                    """
                    Iterate linear acoustic solver to compute the resonance frequencies and the acoustic modes.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/acoustic_modal_analysis").execute(*args, **kwargs)
                def export_volumetric_sources(self, *args, **kwargs):
                    """
                    Enable/disable the export of fluid zones.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/export_volumetric_sources").execute(*args, **kwargs)
                def export_volumetric_sources_cgns(self, *args, **kwargs):
                    """
                    Enable/disable the export of fluid zones.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/export_volumetric_sources_cgns").execute(*args, **kwargs)
                def display_flow_time(self, *args, **kwargs):
                    """
                    Enable/disable the display of flow time during read-and-compute.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/display_flow_time").execute(*args, **kwargs)
                def cylindrical_export(self, *args, **kwargs):
                    """
                    Enable/disable the export data in cylindrical coordinates.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/cylindrical_export").execute(*args, **kwargs)
                def auto_prune(self, *args, **kwargs):
                    """
                    Enable/disable auto prune of the receiver signal(s) during read-and-compute.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/auto_prune").execute(*args, **kwargs)
                def moving_receiver(self, *args, **kwargs):
                    """
                    Enable/disable moving receiver option.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/moving_receiver").execute(*args, **kwargs)
                def convective_effects(self, *args, **kwargs):
                    """
                    Enable/disable convective effects option.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/convective_effects").execute(*args, **kwargs)
                def display_frequencies(self, *args, **kwargs):
                    """
                    Display resonance frequencies.
                    """
                    return PyMenu(self.service, "/setup/models/acoustics/display_frequencies").execute(*args, **kwargs)

                class far_field_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the far field parameters menu for the wave equation model.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def far_field_density(self, *args, **kwargs):
                        """
                        Specify far field density.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/far_field_parameters/far_field_density").execute(*args, **kwargs)
                    def far_field_sound_speed(self, *args, **kwargs):
                        """
                        Specify far field speed of sound.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/far_field_parameters/far_field_sound_speed").execute(*args, **kwargs)

                class wave_equation_options(metaclass=PyMenuMeta):
                    """
                    Enter the options menu for the wave equation model.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.basic_shapes = self.__class__.basic_shapes(path + [("basic_shapes", None)], service)
                        self.remote_receivers_options = self.__class__.remote_receivers_options(path + [("remote_receivers_options", None)], service)
                    def time_filter_source(self, *args, **kwargs):
                        """
                        Activate time-filtering of sound sources.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/wave_equation_options/time_filter_source").execute(*args, **kwargs)
                    def sponge_layer_factor(self, *args, **kwargs):
                        """
                        Specify artificial viscosity factor for sponge layer.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/wave_equation_options/sponge_layer_factor").execute(*args, **kwargs)
                    def sponge_layer_base_level(self, *args, **kwargs):
                        """
                        Specify artificial viscosity base level applied everywhere.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/wave_equation_options/sponge_layer_base_level").execute(*args, **kwargs)
                    def source_mask_udf(self, *args, **kwargs):
                        """
                        Select user-defined function for sound source masking.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/wave_equation_options/source_mask_udf").execute(*args, **kwargs)
                    def sponge_layer_udf(self, *args, **kwargs):
                        """
                        Select user-defined function for sponge layer.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/wave_equation_options/sponge_layer_udf").execute(*args, **kwargs)
                    def remote_receivers(self, *args, **kwargs):
                        """
                        Activate the Kirchhoff's integral method for remote receivers.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/wave_equation_options/remote_receivers").execute(*args, **kwargs)

                    class basic_shapes(metaclass=PyMenuMeta):
                        """
                        Enter the basic shapes menu to build source mask and sponge layer
                        geometry shapes using cell registers.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def list_region_registers(self, *args, **kwargs):
                            """
                            List all available region registers (hex/cylinder/sphere).
                            """
                            return PyMenu(self.service, "/setup/models/acoustics/wave_equation_options/basic_shapes/list_region_registers").execute(*args, **kwargs)
                        def list_source_mask_shapes(self, *args, **kwargs):
                            """
                            List all active source mask registers.
                            """
                            return PyMenu(self.service, "/setup/models/acoustics/wave_equation_options/basic_shapes/list_source_mask_shapes").execute(*args, **kwargs)
                        def list_sponge_layer_shapes(self, *args, **kwargs):
                            """
                            List all active sponge layer registers.
                            """
                            return PyMenu(self.service, "/setup/models/acoustics/wave_equation_options/basic_shapes/list_sponge_layer_shapes").execute(*args, **kwargs)
                        def add_source_mask_shape(self, *args, **kwargs):
                            """
                            Add a region register for the source mask.
                            """
                            return PyMenu(self.service, "/setup/models/acoustics/wave_equation_options/basic_shapes/add_source_mask_shape").execute(*args, **kwargs)
                        def add_sponge_layer_shape(self, *args, **kwargs):
                            """
                            Add a region register for the sponge layer.
                            """
                            return PyMenu(self.service, "/setup/models/acoustics/wave_equation_options/basic_shapes/add_sponge_layer_shape").execute(*args, **kwargs)
                        def remove_source_mask_shape(self, *args, **kwargs):
                            """
                            Remove a region register from the source mask.
                            """
                            return PyMenu(self.service, "/setup/models/acoustics/wave_equation_options/basic_shapes/remove_source_mask_shape").execute(*args, **kwargs)
                        def remove_sponge_layer_shape(self, *args, **kwargs):
                            """
                            Remove a region register from the sponge layer.
                            """
                            return PyMenu(self.service, "/setup/models/acoustics/wave_equation_options/basic_shapes/remove_sponge_layer_shape").execute(*args, **kwargs)

                    class remote_receivers_options(metaclass=PyMenuMeta):
                        """
                        Enter the menu to set up the Kirchhoff's integral method and output its results.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def integration_surface(self, *args, **kwargs):
                            """
                            Select Kirchhoff's integration surface.
                            """
                            return PyMenu(self.service, "/setup/models/acoustics/wave_equation_options/remote_receivers_options/integration_surface").execute(*args, **kwargs)
                        def write_signals(self, *args, **kwargs):
                            """
                            Write signals calculated at receiver locations.
                            """
                            return PyMenu(self.service, "/setup/models/acoustics/wave_equation_options/remote_receivers_options/write_signals").execute(*args, **kwargs)

                class sources_fft(metaclass=PyMenuMeta):
                    """
                    Enter the acoustic sources FFT menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.fft_surface_variables = self.__class__.fft_surface_variables(path + [("fft_surface_variables", None)], service)
                    def read_asd_files(self, *args, **kwargs):
                        """
                        Read ASD files.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/sources_fft/read_asd_files").execute(*args, **kwargs)
                    def compute_fft_fields(self, *args, **kwargs):
                        """
                        Compute FFT fields.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/sources_fft/compute_fft_fields").execute(*args, **kwargs)
                    def write_cgns_files(self, *args, **kwargs):
                        """
                        Write CGNS files.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/sources_fft/write_cgns_files").execute(*args, **kwargs)
                    def clean_up_storage_area(self, *args, **kwargs):
                        """
                        Clean up storage area.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/sources_fft/clean_up_storage_area").execute(*args, **kwargs)

                    class fft_surface_variables(metaclass=PyMenuMeta):
                        """
                        Enter the FFT surface variables menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def create_octave_bands(self, *args, **kwargs):
                            """
                            Create octave bands.
                            """
                            return PyMenu(self.service, "/setup/models/acoustics/sources_fft/fft_surface_variables/create_octave_bands").execute(*args, **kwargs)
                        def create_third_bands(self, *args, **kwargs):
                            """
                            Create third bands.
                            """
                            return PyMenu(self.service, "/setup/models/acoustics/sources_fft/fft_surface_variables/create_third_bands").execute(*args, **kwargs)
                        def create_constant_width_bands(self, *args, **kwargs):
                            """
                            Create constant-width bands.
                            """
                            return PyMenu(self.service, "/setup/models/acoustics/sources_fft/fft_surface_variables/create_constant_width_bands").execute(*args, **kwargs)
                        def create_set_of_modes(self, *args, **kwargs):
                            """
                            Create set of modes.
                            """
                            return PyMenu(self.service, "/setup/models/acoustics/sources_fft/fft_surface_variables/create_set_of_modes").execute(*args, **kwargs)
                        def remove_variables(self, *args, **kwargs):
                            """
                            Remove variables.
                            """
                            return PyMenu(self.service, "/setup/models/acoustics/sources_fft/fft_surface_variables/remove_variables").execute(*args, **kwargs)

                class sponge_layers(metaclass=PyMenuMeta):
                    """
                    Manage sponge layers where density is blended to eliminate reflections from boundary zones.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def activate(self, *args, **kwargs):
                        """
                        Activate a sponge object.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/sponge_layers/activate").execute(*args, **kwargs)
                    def add(self, *args, **kwargs):
                        """
                        Add a new sponge layer definition.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/sponge_layers/add").execute(*args, **kwargs)
                    def deactivate(self, *args, **kwargs):
                        """
                        Deactivate a sponge layer definition.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/sponge_layers/deactivate").execute(*args, **kwargs)
                    def edit(self, *args, **kwargs):
                        """
                        Edit a sponge layer definition.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/sponge_layers/edit").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete a sponge layer definition.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/sponge_layers/delete").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        List the names of the sponge layer definitions.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/sponge_layers/list").execute(*args, **kwargs)
                    def list_active(self, *args, **kwargs):
                        """
                        List the names of the active sponge layer definitions.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/sponge_layers/list_active").execute(*args, **kwargs)
                    def list_properties(self, *args, **kwargs):
                        """
                        List the properties of a sponge layer definition.
                        """
                        return PyMenu(self.service, "/setup/models/acoustics/sponge_layers/list_properties").execute(*args, **kwargs)

            class optics(metaclass=PyMenuMeta):
                """
                Enter the optics model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.set = self.__class__.set(path + [("set", None)], service)
                def enable(self, *args, **kwargs):
                    """
                    Enable/disable optics model.
                    """
                    return PyMenu(self.service, "/setup/models/optics/enable").execute(*args, **kwargs)
                def add_beam(self, *args, **kwargs):
                    """
                    Add optical beam grid.
                    """
                    return PyMenu(self.service, "/setup/models/optics/add_beam").execute(*args, **kwargs)

                class set(metaclass=PyMenuMeta):
                    """
                    Enter the set menu for optics model.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def sampling(self, *args, **kwargs):
                        """
                        Specify when the fluid density field is sampled.
                        """
                        return PyMenu(self.service, "/setup/models/optics/set/sampling").execute(*args, **kwargs)
                    def index_of_refraction(self, *args, **kwargs):
                        """
                        Specify the model parameters of index of refraction.
                        """
                        return PyMenu(self.service, "/setup/models/optics/set/index_of_refraction").execute(*args, **kwargs)
                    def running_average(self, *args, **kwargs):
                        """
                        Setup the running average of the collected density field.
                        """
                        return PyMenu(self.service, "/setup/models/optics/set/running_average").execute(*args, **kwargs)

            class eulerian_wallfilm(metaclass=PyMenuMeta):
                """
                Enter the Eulerian wall film model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.coupled_solution = self.__class__.coupled_solution(path + [("coupled_solution", None)], service)
                    self.implicit_options = self.__class__.implicit_options(path + [("implicit_options", None)], service)
                def enable_wallfilm_model(self, *args, **kwargs):
                    """
                    Enable Eulerian wall film model.
                    """
                    return PyMenu(self.service, "/setup/models/eulerian_wallfilm/enable_wallfilm_model").execute(*args, **kwargs)
                def initialize_wallfilm_model(self, *args, **kwargs):
                    """
                    Initialize Eulerian wall film model.
                    """
                    return PyMenu(self.service, "/setup/models/eulerian_wallfilm/initialize_wallfilm_model").execute(*args, **kwargs)
                def solve_wallfilm_equation(self, *args, **kwargs):
                    """
                    Activate Eulerian wall film equations.
                    """
                    return PyMenu(self.service, "/setup/models/eulerian_wallfilm/solve_wallfilm_equation").execute(*args, **kwargs)
                def model_options(self, *args, **kwargs):
                    """
                    Set Eulerian wall film model options.
                    """
                    return PyMenu(self.service, "/setup/models/eulerian_wallfilm/model_options").execute(*args, **kwargs)
                def film_material(self, *args, **kwargs):
                    """
                    Set film material and properties.
                    """
                    return PyMenu(self.service, "/setup/models/eulerian_wallfilm/film_material").execute(*args, **kwargs)
                def solution_options(self, *args, **kwargs):
                    """
                    Set Eulerian wall film model solution options.
                    """
                    return PyMenu(self.service, "/setup/models/eulerian_wallfilm/solution_options").execute(*args, **kwargs)

                class coupled_solution(metaclass=PyMenuMeta):
                    """
                    Enter Eulerian wall film coupled solution menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def enable_coupled_solution(self, *args, **kwargs):
                        """
                        Enable Eulerian wall film coupled solution.
                        """
                        return PyMenu(self.service, "/setup/models/eulerian_wallfilm/coupled_solution/enable_coupled_solution").execute(*args, **kwargs)
                    def enable_curvature_smoothing(self, *args, **kwargs):
                        """
                        Enable Eulerian wall film curvature smoothing.
                        """
                        return PyMenu(self.service, "/setup/models/eulerian_wallfilm/coupled_solution/enable_curvature_smoothing").execute(*args, **kwargs)

                class implicit_options(metaclass=PyMenuMeta):
                    """
                    Enter Implicit Scheme Option (beta).
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def new_implicit_scheme(self, *args, **kwargs):
                        """
                        Enable alternative implicit scheme.
                        """
                        return PyMenu(self.service, "/setup/models/eulerian_wallfilm/implicit_options/new_implicit_scheme").execute(*args, **kwargs)
                    def relative_error_residual(self, *args, **kwargs):
                        """
                        Enable relative error residual.
                        """
                        return PyMenu(self.service, "/setup/models/eulerian_wallfilm/implicit_options/relative_error_residual").execute(*args, **kwargs)

            class dpm(metaclass=PyMenuMeta):
                """
                Enter the dispersed phase model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.collisions = self.__class__.collisions(path + [("collisions", None)], service)
                    self.erosion_dynamic_mesh = self.__class__.erosion_dynamic_mesh(path + [("erosion_dynamic_mesh", None)], service)
                    self.interaction = self.__class__.interaction(path + [("interaction", None)], service)
                    self.numerics = self.__class__.numerics(path + [("numerics", None)], service)
                    self.options = self.__class__.options(path + [("options", None)], service)
                    self.parallel = self.__class__.parallel(path + [("parallel", None)], service)
                    self.splash_options = self.__class__.splash_options(path + [("splash_options", None)], service)
                    self.stripping_options = self.__class__.stripping_options(path + [("stripping_options", None)], service)
                def clear_particles_from_domain(self, *args, **kwargs):
                    """
                    Remove/keep all particles currently in the domain.
                    """
                    return PyMenu(self.service, "/setup/models/dpm/clear_particles_from_domain").execute(*args, **kwargs)
                def fill_injection_material_sources(self, *args, **kwargs):
                    """
                    Initialize the DPM sources corresponding to each material.
                    """
                    return PyMenu(self.service, "/setup/models/dpm/fill_injection_material_sources").execute(*args, **kwargs)
                def injections(self, *args, **kwargs):
                    """
                    Enter the injections menu.
                    """
                    return PyMenu(self.service, "/setup/models/dpm/injections").execute(*args, **kwargs)
                def unsteady_tracking(self, *args, **kwargs):
                    """
                    Enable/disable unsteady particle tracking.
                    """
                    return PyMenu(self.service, "/setup/models/dpm/unsteady_tracking").execute(*args, **kwargs)
                def spray_model(self, *args, **kwargs):
                    """
                    Enter the spray model menu.
                    """
                    return PyMenu(self.service, "/setup/models/dpm/spray_model").execute(*args, **kwargs)
                def user_defined(self, *args, **kwargs):
                    """
                    Set DPM user-defined functions.
                    """
                    return PyMenu(self.service, "/setup/models/dpm/user_defined").execute(*args, **kwargs)

                class collisions(metaclass=PyMenuMeta):
                    """
                    Enter the DEM collisions menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.collision_partners = self.__class__.collision_partners(path + [("collision_partners", None)], service)
                    def collision_pair_settings(self, *args, **kwargs):
                        """
                        Supply settings for collisions to a pair of collision partners.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/collisions/collision_pair_settings").execute(*args, **kwargs)
                    def list_all_pair_settings(self, *args, **kwargs):
                        """
                        For each pair of collision partners, lists the collision laws and their parameters.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/collisions/list_all_pair_settings").execute(*args, **kwargs)
                    def dem_collisions(self, *args, **kwargs):
                        """
                        Enable/disable the DEM collision model.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/collisions/dem_collisions").execute(*args, **kwargs)
                    def collision_mesh(self, *args, **kwargs):
                        """
                        Input for the collision mesh.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/collisions/collision_mesh").execute(*args, **kwargs)
                    def max_particle_velocity(self, *args, **kwargs):
                        """
                        Set the maximum particle velocity that may arise from collisions.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/collisions/max_particle_velocity").execute(*args, **kwargs)

                    class collision_partners(metaclass=PyMenuMeta):
                        """
                        Manage collision partners.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def create(self, *args, **kwargs):
                            """
                            Create a collision partner.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/collisions/collision_partners/create").execute(*args, **kwargs)
                        def delete(self, *args, **kwargs):
                            """
                            Delete a collision partner.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/collisions/collision_partners/delete").execute(*args, **kwargs)
                        def copy(self, *args, **kwargs):
                            """
                            Copy a collision partner.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/collisions/collision_partners/copy").execute(*args, **kwargs)
                        def rename(self, *args, **kwargs):
                            """
                            Rename a collision partner.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/collisions/collision_partners/rename").execute(*args, **kwargs)
                        def list(self, *args, **kwargs):
                            """
                            Lists all known collision partners.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/collisions/collision_partners/list").execute(*args, **kwargs)

                class erosion_dynamic_mesh(metaclass=PyMenuMeta):
                    """
                    Enter the erosion-dynamic mesh interactions menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.general_parameters = self.__class__.general_parameters(path + [("general_parameters", None)], service)
                        self.run_parameters = self.__class__.run_parameters(path + [("run_parameters", None)], service)
                    def enable_erosion_dynamic_mesh_coupling(self, *args, **kwargs):
                        """
                        Enable mesh deformation due to wall erosion.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/erosion_dynamic_mesh/enable_erosion_dynamic_mesh_coupling").execute(*args, **kwargs)
                    def run_simulation(self, *args, **kwargs):
                        """
                        Perform coupled erosion-dynamic mesh simulation.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/erosion_dynamic_mesh/run_simulation").execute(*args, **kwargs)

                    class general_parameters(metaclass=PyMenuMeta):
                        """
                        Enter the erosion-dynamic mesh setup menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def erosion_settings(self, *args, **kwargs):
                            """
                            Set erosion modelling specific settings.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/erosion_dynamic_mesh/general_parameters/erosion_settings").execute(*args, **kwargs)
                        def dynamic_mesh_settings(self, *args, **kwargs):
                            """
                            Perform dynamic mesh related setup.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/erosion_dynamic_mesh/general_parameters/dynamic_mesh_settings").execute(*args, **kwargs)
                        def participating_walls(self, *args, **kwargs):
                            """
                            Specify all participating walls.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/erosion_dynamic_mesh/general_parameters/participating_walls").execute(*args, **kwargs)

                    class run_parameters(metaclass=PyMenuMeta):
                        """
                        Enter the erosion-dynamic mesh run menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def mesh_motion_time_step(self, *args, **kwargs):
                            """
                            Set the mesh motion time stepping parameters and method.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/erosion_dynamic_mesh/run_parameters/mesh_motion_time_step").execute(*args, **kwargs)
                        def simulation_termination(self, *args, **kwargs):
                            """
                            Set total time of erosion.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/erosion_dynamic_mesh/run_parameters/simulation_termination").execute(*args, **kwargs)
                        def flow_simulation_control(self, *args, **kwargs):
                            """
                            Set number of iterations per flow simulation step.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/erosion_dynamic_mesh/run_parameters/flow_simulation_control").execute(*args, **kwargs)
                        def autosave_files(self, *args, **kwargs):
                            """
                            Set the iteration increment to save data files.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/erosion_dynamic_mesh/run_parameters/autosave_files").execute(*args, **kwargs)
                        def autosave_graphics(self, *args, **kwargs):
                            """
                            Set the iteration increment to save graphics files.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/erosion_dynamic_mesh/run_parameters/autosave_graphics").execute(*args, **kwargs)

                class interaction(metaclass=PyMenuMeta):
                    """
                    Enter the interaction menu to set parameters for coupled discrete phase calculations.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def choice_of_eulerian_phase_for_interaction(self, *args, **kwargs):
                        """
                        Enable/disable the option to choose for every injection the Eulerian phase for the DPM continuous phase interaction.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/choice_of_eulerian_phase_for_interaction").execute(*args, **kwargs)
                    def coupled_calculations(self, *args, **kwargs):
                        """
                        Enable/disable coupling of continuous and discrete phase calculations.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/coupled_calculations").execute(*args, **kwargs)
                    def dpm_iteration_interval(self, *args, **kwargs):
                        """
                        Set the number of continuous phase iterations per DPM iteration.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/dpm_iteration_interval").execute(*args, **kwargs)
                    def underrelaxation_factor(self, *args, **kwargs):
                        """
                        Set the under-relaxation factor.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/underrelaxation_factor").execute(*args, **kwargs)
                    def implicit_momentum_coupling(self, *args, **kwargs):
                        """
                        Enable/disable implicit treatment for the DPM momentum source terms.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/implicit_momentum_coupling").execute(*args, **kwargs)
                    def implicit_source_term_coupling(self, *args, **kwargs):
                        """
                        Enable/disable implicit treatment for all DPM source terms.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/implicit_source_term_coupling").execute(*args, **kwargs)
                    def linearized_dpm_source_terms(self, *args, **kwargs):
                        """
                        Perform a linearization of all DPM source terms to increase numerical robustness.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/linearized_dpm_source_terms").execute(*args, **kwargs)
                    def replace_dpm_mass_source_by_mixture_fraction(self, *args, **kwargs):
                        """
                        Recalculate the mixture fraction source terms as function of the primary mixture fraction?.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/replace_dpm_mass_source_by_mixture_fraction").execute(*args, **kwargs)
                    def linearized_dpm_mixture_fraction_source_terms(self, *args, **kwargs):
                        """
                        Perform a linearization of mixture fraction source terms.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/linearized_dpm_mixture_fraction_source_terms").execute(*args, **kwargs)
                    def linearized_dpm_species_source_terms(self, *args, **kwargs):
                        """
                        Perform linearization of species source terms.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/linearized_dpm_species_source_terms").execute(*args, **kwargs)
                    def keep_linearized_dpm_source_terms_constant(self, *args, **kwargs):
                        """
                        Keep linearized DPM source terms constant until the next DPM Update.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/keep_linearized_dpm_source_terms_constant").execute(*args, **kwargs)
                    def linearized_dpm_source_terms_limiter(self, *args, **kwargs):
                        """
                        Relative limit for DPM source linear coefficient with respect to fluid linear Ap coefficient.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/linearized_dpm_source_terms_limiter").execute(*args, **kwargs)
                    def update_dpm_sources_every_flow_iteration(self, *args, **kwargs):
                        """
                        Enable/disable the update of DPM source terms every flow iteration. 
                        
                              (if not, the terms will be updated every DPM iteration).
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/update_dpm_sources_every_flow_iteration").execute(*args, **kwargs)
                    def linear_growth_of_dpm_source_term(self, *args, **kwargs):
                        """
                        Enable/disable the linear growth of DPM source terms every DPM iteration. 
                        .
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/linear_growth_of_dpm_source_term").execute(*args, **kwargs)
                    def reset_sources_at_timestep_flag(self, *args, **kwargs):
                        """
                        Enable/disable flush of DPM source terms at beginning of every time step.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/reset_sources_at_timestep_flag").execute(*args, **kwargs)
                    def enable_flow_blocking_by_particles_flag(self, *args, **kwargs):
                        """
                        Enable/disable inclusion of DPM volume fraction in continuous flow.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/enable_flow_blocking_by_particles_flag").execute(*args, **kwargs)
                    def enable_source_scaling_due_to_flow_blocking_flag(self, *args, **kwargs):
                        """
                        Enable/disable scaling of DPM source terms due to inclusion of DPM volume fraction in continuous flow.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/enable_source_scaling_due_to_flow_blocking_flag").execute(*args, **kwargs)
                    def enable_drag_scaling_due_to_flow_blocking_flag(self, *args, **kwargs):
                        """
                        Enable/disable scaling of DPM drag coefficient due to inclusion of DPM volume fraction in continuous flow.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/enable_drag_scaling_due_to_flow_blocking_flag").execute(*args, **kwargs)
                    def max_vf_allowed_for_blocking(self, *args, **kwargs):
                        """
                        Maximum DPM volume fraction used in continuous flow.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/max_vf_allowed_for_blocking").execute(*args, **kwargs)
                    def min_vf_threshold_for_dpm_src_scaling(self, *args, **kwargs):
                        """
                        Minimum DPM volume fraction below which no DPM source scaling is applied.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/min_vf_threshold_for_dpm_src_scaling").execute(*args, **kwargs)
                    def ddpm_iad_particle(self, *args, **kwargs):
                        """
                        Enable/disable the non-default interfacial area method IA-particle.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/interaction/ddpm_iad_particle").execute(*args, **kwargs)

                class numerics(metaclass=PyMenuMeta):
                    """
                    Enter the numerics menu to set numerical solution parameters.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.high_resolution_tracking = self.__class__.high_resolution_tracking(path + [("high_resolution_tracking", None)], service)
                    def coupled_heat_mass_update(self, *args, **kwargs):
                        """
                        Enable/disable coupled heat and mass update.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/coupled_heat_mass_update").execute(*args, **kwargs)
                    def minimum_liquid_fraction(self, *args, **kwargs):
                        """
                        Evaporate droplet completely when the remaining mass is below this fraction of initial mass.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/minimum_liquid_fraction").execute(*args, **kwargs)
                    def underrelax_film_height(self, *args, **kwargs):
                        """
                        Define underrelaxation factor for film height.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/underrelax_film_height").execute(*args, **kwargs)
                    def vaporization_limiting_factors(self, *args, **kwargs):
                        """
                        Set Vaporization Fractional Change Limits.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/vaporization_limiting_factors").execute(*args, **kwargs)
                    def tracking_parameters(self, *args, **kwargs):
                        """
                        Set parameters for the (initial) tracking step length.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/tracking_parameters").execute(*args, **kwargs)
                    def tracking_scheme(self, *args, **kwargs):
                        """
                        Specify a tracking scheme.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/tracking_scheme").execute(*args, **kwargs)
                    def tracking_statistics(self, *args, **kwargs):
                        """
                        Control the format of the one-line tracking statistics printed after every DPM tracking pass.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/tracking_statistics").execute(*args, **kwargs)
                    def verbosity(self, *args, **kwargs):
                        """
                        Adjust the DPM tracker's verbosity level.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/verbosity").execute(*args, **kwargs)
                    def error_control(self, *args, **kwargs):
                        """
                        Set the adapt integration step length based on a maximum error.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/error_control").execute(*args, **kwargs)
                    def automated_scheme_selection(self, *args, **kwargs):
                        """
                        Enable/disable the adaptation of integration step length based on a maximum error.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/automated_scheme_selection").execute(*args, **kwargs)
                    def drag_law(self, *args, **kwargs):
                        """
                        Set the drag law.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/drag_law").execute(*args, **kwargs)
                    def enable_node_based_averaging(self, *args, **kwargs):
                        """
                        Enable node based averaging of DPM variables.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/enable_node_based_averaging").execute(*args, **kwargs)
                    def average_source_terms(self, *args, **kwargs):
                        """
                        Average DPM source terms on nodes.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/average_source_terms").execute(*args, **kwargs)
                    def average_DDPM_variables(self, *args, **kwargs):
                        """
                        Average DDPM specific variables like volume fractions and velocities on nodes.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/average_DDPM_variables").execute(*args, **kwargs)
                    def average_each_step(self, *args, **kwargs):
                        """
                        Do the averaging after each integration step for higher accuracy at a higher cost.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/average_each_step").execute(*args, **kwargs)
                    def average_kernel(self, *args, **kwargs):
                        """
                        Specify a kernel for the averaging.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/average_kernel").execute(*args, **kwargs)
                    def gaussian_factor(self, *args, **kwargs):
                        """
                        Set a factor for the gaussian kernel for node-based averaging.~%Large values give small size, small values give large size of kernel.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/gaussian_factor").execute(*args, **kwargs)
                    def mppic_settings(self, *args, **kwargs):
                        """
                        Enable PIC and MPPIC to compute DPM and DDPM source terms.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/mppic_settings").execute(*args, **kwargs)
                    def enhanced_packing_limit_numerics(self, *args, **kwargs):
                        """
                        Enable enhanced packing limit numerics to avoid exceeding of packing limit for granular phases.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/numerics/enhanced_packing_limit_numerics").execute(*args, **kwargs)

                    class high_resolution_tracking(metaclass=PyMenuMeta):
                        """
                        Enter the high resolution tracking menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.barycentric_interpolation = self.__class__.barycentric_interpolation(path + [("barycentric_interpolation", None)], service)
                            self.particle_relocation = self.__class__.particle_relocation(path + [("particle_relocation", None)], service)
                        def enable_high_resolution_tracking(self, *args, **kwargs):
                            """
                            Enable high resolution tracking.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/enable_high_resolution_tracking").execute(*args, **kwargs)
                        def enable_barycentric_intersections(self, *args, **kwargs):
                            """
                            Use barycentric coordinates for intersection calculations.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/enable_barycentric_intersections").execute(*args, **kwargs)
                        def use_barycentric_sampling(self, *args, **kwargs):
                            """
                            Use barycentric coordinates when sampling at planes.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/use_barycentric_sampling").execute(*args, **kwargs)
                        def use_velocity_based_error_control(self, *args, **kwargs):
                            """
                            Use adaptive time stepping based upon the particle velocity.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/use_velocity_based_error_control").execute(*args, **kwargs)
                        def use_quad_face_centroid(self, *args, **kwargs):
                            """
                            Use quad face centroids when creating subtets.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/use_quad_face_centroid").execute(*args, **kwargs)
                        def check_subtet_validity(self, *args, **kwargs):
                            """
                            Test for inverted subtets due to warped cells.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/check_subtet_validity").execute(*args, **kwargs)
                        def always_use_face_centroid_with_periodics(self, *args, **kwargs):
                            """
                            Use quad face centroids when creating subtets if the case contains periodic boundaries.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/always_use_face_centroid_with_periodics").execute(*args, **kwargs)
                        def boundary_layer_tracking(self, *args, **kwargs):
                            """
                            Adjust the particle timestep to account for high aspect ratio cells.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/boundary_layer_tracking").execute(*args, **kwargs)
                        def sliding_interface_crossover_fraction(self, *args, **kwargs):
                            """
                            Move the particle a fraction of the distance to the subtet center when crossing a sliding interface.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/sliding_interface_crossover_fraction").execute(*args, **kwargs)
                        def project_wall_film_particles_to_film(self, *args, **kwargs):
                            """
                            Project existing particles to film to track using high resolution tracking?.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/project_wall_film_particles_to_film").execute(*args, **kwargs)
                        def use_particle_timestep_for_intersection_tolerance(self, *args, **kwargs):
                            """
                            Use the particle timestep for the axisymmetric subtet intersection tolerance.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/use_particle_timestep_for_intersection_tolerance").execute(*args, **kwargs)
                        def enable_automatic_intersection_tolerance(self, *args, **kwargs):
                            """
                            Enable automatic scaling of subtet intersection tolerance.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/enable_automatic_intersection_tolerance").execute(*args, **kwargs)
                        def set_film_spreading_parameter(self, *args, **kwargs):
                            """
                            Set the spreading parameter for Lagrangian wallfilm particles.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/set_film_spreading_parameter").execute(*args, **kwargs)
                        def set_subtet_intersection_tolerance(self, *args, **kwargs):
                            """
                            Set the tolerance for subtet intersection calculations.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/set_subtet_intersection_tolerance").execute(*args, **kwargs)

                        class barycentric_interpolation(metaclass=PyMenuMeta):
                            """
                            Enter the barycentric interpolation menu.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def interpolate_flow_solution_gradients(self, *args, **kwargs):
                                """
                                Enable interpolation of flow solution gradients.
                                """
                                return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/interpolate_flow_solution_gradients").execute(*args, **kwargs)
                            def interpolate_temperature(self, *args, **kwargs):
                                """
                                Enable interpolation of temperature to the particle position.
                                """
                                return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/interpolate_temperature").execute(*args, **kwargs)
                            def interpolate_flow_density(self, *args, **kwargs):
                                """
                                Enable interpolation of flow density to the particle position.
                                """
                                return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/interpolate_flow_density").execute(*args, **kwargs)
                            def interpolate_flow_cp(self, *args, **kwargs):
                                """
                                Enable interpolation of flow specific heat to the particle position.
                                """
                                return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/interpolate_flow_cp").execute(*args, **kwargs)
                            def interpolate_flow_viscosity(self, *args, **kwargs):
                                """
                                Enable interpolation of flow viscosity to the particle position.
                                """
                                return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/interpolate_flow_viscosity").execute(*args, **kwargs)
                            def interpolate_wallfilm_properties(self, *args, **kwargs):
                                """
                                Enable interpolation of wallfilm properties to the particle position.
                                """
                                return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/interpolate_wallfilm_properties").execute(*args, **kwargs)
                            def precompute_pdf_species(self, *args, **kwargs):
                                """
                                Precompute cell values of PDF species mass fractions prior to particle tracking.
                                """
                                return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/precompute_pdf_species").execute(*args, **kwargs)
                            def zero_nodal_velocity_on_walls(self, *args, **kwargs):
                                """
                                Set the nodal velocity on all walls to zero.
                                """
                                return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/zero_nodal_velocity_on_walls").execute(*args, **kwargs)
                            def enable_transient_variable_interpolation(self, *args, **kwargs):
                                """
                                Enable transient variable interpolation.
                                """
                                return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/enable_transient_variable_interpolation").execute(*args, **kwargs)
                            def nodal_reconstruction_frequency(self, *args, **kwargs):
                                """
                                Update nodal reconstruction every N'th DPM iteration.
                                """
                                return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/nodal_reconstruction_frequency").execute(*args, **kwargs)
                            def user_interpolation_function(self, *args, **kwargs):
                                """
                                Enter user interpolation function.
                                """
                                return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/barycentric_interpolation/user_interpolation_function").execute(*args, **kwargs)

                        class particle_relocation(metaclass=PyMenuMeta):
                            """
                            Enter the particle relocation menu.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def wallfilm_relocation_tolerance_scale_factor(self, *args, **kwargs):
                                """
                                Set the relocation tolerance scaling factor for wallfilm particles after remeshing.
                                """
                                return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/particle_relocation/wallfilm_relocation_tolerance_scale_factor").execute(*args, **kwargs)
                            def use_legacy_particle_location_method(self, *args, **kwargs):
                                """
                                Enable legacy method of locating particles in cells.
                                """
                                return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/particle_relocation/use_legacy_particle_location_method").execute(*args, **kwargs)
                            def load_legacy_particles(self, *args, **kwargs):
                                """
                                Load particles that were tracked without high-resolution tracking enabled.
                                """
                                return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/particle_relocation/load_legacy_particles").execute(*args, **kwargs)
                            def enhanced_cell_relocation_method(self, *args, **kwargs):
                                """
                                Enable enhanced method of locating particles in cells.
                                """
                                return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/particle_relocation/enhanced_cell_relocation_method").execute(*args, **kwargs)
                            def overset_relocation_robustness_level(self, *args, **kwargs):
                                """
                                Set the robustness level for particle relocation in overset meshes.
                                """
                                return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/particle_relocation/overset_relocation_robustness_level").execute(*args, **kwargs)
                            def enhanced_wallfilm_location_method(self, *args, **kwargs):
                                """
                                Enable enhanced method of locating film particles on faces.
                                """
                                return PyMenu(self.service, "/setup/models/dpm/numerics/high_resolution_tracking/particle_relocation/enhanced_wallfilm_location_method").execute(*args, **kwargs)

                class options(metaclass=PyMenuMeta):
                    """
                    Enter the options menu to set optional DPM models.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def enable_contour_plots(self, *args, **kwargs):
                        """
                        Enable contour and vector plots of particle data.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/enable_contour_plots").execute(*args, **kwargs)
                    def ensemble_average(self, *args, **kwargs):
                        """
                        Set ensemble average cloud properties.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/ensemble_average").execute(*args, **kwargs)
                    def particle_radiation(self, *args, **kwargs):
                        """
                        Enable/disable particle radiation.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/particle_radiation").execute(*args, **kwargs)
                    def track_in_absolute_frame(self, *args, **kwargs):
                        """
                        Enable/disable tracking in absolute frame.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/track_in_absolute_frame").execute(*args, **kwargs)
                    def thermophoretic_force(self, *args, **kwargs):
                        """
                        Enable/disable thermophoretic force.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/thermophoretic_force").execute(*args, **kwargs)
                    def convective_film_heat_transfer(self, *args, **kwargs):
                        """
                        Enable/disable convection/conduction film to wall heat transfer model.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/convective_film_heat_transfer").execute(*args, **kwargs)
                    def saffman_lift_force(self, *args, **kwargs):
                        """
                        Enable/disable Saffman lift force.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/saffman_lift_force").execute(*args, **kwargs)
                    def pressure_gradient_force(self, *args, **kwargs):
                        """
                        Enable/disable pressure gradient force.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/pressure_gradient_force").execute(*args, **kwargs)
                    def virtual_mass_force(self, *args, **kwargs):
                        """
                        Enable/disable virtual mass force.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/virtual_mass_force").execute(*args, **kwargs)
                    def two_way_coupling(self, *args, **kwargs):
                        """
                        Enable/disable calculation of DPM sources in TKE equation.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/two_way_coupling").execute(*args, **kwargs)
                    def remove_wall_film_temperature_limiter(self, *args, **kwargs):
                        """
                        Remove the wall film temperature limiter.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/remove_wall_film_temperature_limiter").execute(*args, **kwargs)
                    def maximum_udf_species(self, *args, **kwargs):
                        """
                        Maximum number of species that can interact with particles in the DPM UDFs.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/maximum_udf_species").execute(*args, **kwargs)
                    def brownian_motion(self, *args, **kwargs):
                        """
                        Enable/disable Brownian motion of particles.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/brownian_motion").execute(*args, **kwargs)
                    def stagger_spatially_standard_injections(self, *args, **kwargs):
                        """
                        Spatially stagger non-atomizer injections?.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/stagger_spatially_standard_injections").execute(*args, **kwargs)
                    def stagger_spatially_atomizer_injections(self, *args, **kwargs):
                        """
                        Spatially stagger atomizer injections?.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/stagger_spatially_atomizer_injections").execute(*args, **kwargs)
                    def stagger_temporally(self, *args, **kwargs):
                        """
                        Stagger transient parcels for their first time step?.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/stagger_temporally").execute(*args, **kwargs)
                    def staggering_factor(self, *args, **kwargs):
                        """
                        Set the staggering factor between 0 and 1 to control the amount of staggering.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/staggering_factor").execute(*args, **kwargs)
                    def stagger_radius(self, *args, **kwargs):
                        """
                        Provide a stagger radius for non atomizer injections.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/stagger_radius").execute(*args, **kwargs)
                    def uniform_mass_distribution_for_injections(self, *args, **kwargs):
                        """
                        A uniform mass distribution will be enabled for all solid cone and atomizer injections.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/uniform_mass_distribution_for_injections").execute(*args, **kwargs)
                    def use_absolute_pressure_for_vaporization(self, *args, **kwargs):
                        """
                        Enable/disable using Absolute Pressure for Vaporization.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/use_absolute_pressure_for_vaporization").execute(*args, **kwargs)
                    def vaporization_options(self, *args, **kwargs):
                        """
                        Set Vaporization options.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/vaporization_options").execute(*args, **kwargs)
                    def vaporization_heat_transfer_averaging(self, *args, **kwargs):
                        """
                        Enable/disable correction for Vaporization heat transfer.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/vaporization_heat_transfer_averaging").execute(*args, **kwargs)
                    def allow_supercritical_pressure_vaporization(self, *args, **kwargs):
                        """
                        Skip the pressure dependent boiling point calculation to allow supercritical pressure conditions for vaporization.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/allow_supercritical_pressure_vaporization").execute(*args, **kwargs)
                    def treat_multicomponent_saturation_temperature_failure(self, *args, **kwargs):
                        """
                        Dump multicomponent particle mass if the saturation temperature cannot be determined.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/treat_multicomponent_saturation_temperature_failure").execute(*args, **kwargs)
                    def set_thermolysis_limit(self, *args, **kwargs):
                        """
                        Set the thermolysis limit.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/set_thermolysis_limit").execute(*args, **kwargs)
                    def lowest_volatiles_mass_fraction(self, *args, **kwargs):
                        """
                        Set the lowest volatiles mass fraction.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/lowest_volatiles_mass_fraction").execute(*args, **kwargs)
                    def erosion_accretion(self, *args, **kwargs):
                        """
                        Enable/disable erosion/accretion.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/erosion_accretion").execute(*args, **kwargs)
                    def init_erosion_accretion_rate(self, *args, **kwargs):
                        """
                        Initialize erosion/accretion rates with Zero.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/init_erosion_accretion_rate").execute(*args, **kwargs)
                    def step_report_sig_figures(self, *args, **kwargs):
                        """
                        Set significant figures in the step-by-step report.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/step_report_sig_figures").execute(*args, **kwargs)
                    def include_lwf_particles_in_dpm_concentration(self, *args, **kwargs):
                        """
                        Include LWF particle mass in DPM Concentration.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/include_lwf_particles_in_dpm_concentration").execute(*args, **kwargs)
                    def current_positions_in_sample_file_format(self, *args, **kwargs):
                        """
                        Write the current positions (step-by-step history report for unsteady tracking) in the sampling file format.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/current_positions_in_sample_file_format").execute(*args, **kwargs)
                    def scr_urea_deposition_risk_analysis(self, *args, **kwargs):
                        """
                        Options to activate and configure the SCR urea deposition risk analysis.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/options/scr_urea_deposition_risk_analysis").execute(*args, **kwargs)

                class parallel(metaclass=PyMenuMeta):
                    """
                    Enter the parallel menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.expert = self.__class__.expert(path + [("expert", None)], service)
                    def enable_workpile(self, *args, **kwargs):
                        """
                        Enable/disable the particle workpile algorithm.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/parallel/enable_workpile").execute(*args, **kwargs)
                    def n_threads(self, *args, **kwargs):
                        """
                        Set the number of processors to use for DPM.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/parallel/n_threads").execute(*args, **kwargs)
                    def report(self, *args, **kwargs):
                        """
                        Print particle workpile statistics.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/parallel/report").execute(*args, **kwargs)
                    def use_shared_memory(self, *args, **kwargs):
                        """
                        Set DPM parallel-mode to shared memory.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/parallel/use_shared_memory").execute(*args, **kwargs)
                    def use_message_passing(self, *args, **kwargs):
                        """
                        Set DPM parallel-mode to message passing.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/parallel/use_message_passing").execute(*args, **kwargs)
                    def use_hybrid(self, *args, **kwargs):
                        """
                        Set DPM parallel-mode to hybrid.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/parallel/use_hybrid").execute(*args, **kwargs)
                    def fix_source_term_accumulation_order(self, *args, **kwargs):
                        """
                        Enforce deterministic order of source term accumulation.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/parallel/fix_source_term_accumulation_order").execute(*args, **kwargs)
                    def hybrid_2domain(self, *args, **kwargs):
                        """
                        Use DPM domain to simulate particles.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/parallel/hybrid_2domain").execute(*args, **kwargs)
                    def hybrid_workpile(self, *args, **kwargs):
                        """
                        Optimize multi-thread load balancing within each partition in hybrid-parallel DPM tracking.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/parallel/hybrid_workpile").execute(*args, **kwargs)
                    def hybrid_collision_model(self, *args, **kwargs):
                        """
                        An EXPERIMENTAL feature to allow 'hybrid' DPM parallel tracking with the collision / coalescence model.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/parallel/hybrid_collision_model").execute(*args, **kwargs)
                    def hybrid_collision_unidirectional(self, *args, **kwargs):
                        """
                        A faster, yet potentially somewhat less accurate, modification to the beta feature
                        that allows 'hybrid' DPM parallel tracking with the collision / coalescence model.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/parallel/hybrid_collision_unidirectional").execute(*args, **kwargs)
                    def hybrid_collision_variant(self, *args, **kwargs):
                        """
                        Further reduce the residual risk of dead-locks in the experimental feature that
                        allows 'hybrid' DPM parallel tracking with the collision / coalescence model.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/parallel/hybrid_collision_variant").execute(*args, **kwargs)

                    class expert(metaclass=PyMenuMeta):
                        """
                        Enter the menu to set expert DPM parallel options.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def partition_method_hybrid_2domain(self, *args, **kwargs):
                            """
                            Set DPM Domain partition method.
                            """
                            return PyMenu(self.service, "/setup/models/dpm/parallel/expert/partition_method_hybrid_2domain").execute(*args, **kwargs)

                class splash_options(metaclass=PyMenuMeta):
                    """
                    Enter the splash options menu to set optional parameters.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def orourke_splash_fraction(self, *args, **kwargs):
                        """
                        Select splash fraction method.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/splash_options/orourke_splash_fraction").execute(*args, **kwargs)
                    def splash_pdf_limiting(self, *args, **kwargs):
                        """
                        Select splash pdf limiting method.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/splash_options/splash_pdf_limiting").execute(*args, **kwargs)

                class stripping_options(metaclass=PyMenuMeta):
                    """
                    Enter the stripping options menu to set optional parameters.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def mass_coefficient(self, *args, **kwargs):
                        """
                        Set the stripping mass coefficient.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/stripping_options/mass_coefficient").execute(*args, **kwargs)
                    def diameter_coefficient(self, *args, **kwargs):
                        """
                        Set the stripping diameter coefficient.
                        """
                        return PyMenu(self.service, "/setup/models/dpm/stripping_options/diameter_coefficient").execute(*args, **kwargs)

            class shell_conduction(metaclass=PyMenuMeta):
                """
                Enter the shell conduction model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def multi_layer_shell(self, *args, **kwargs):
                    """
                    Enable/disable multi layer shell conduction model.
                    """
                    return PyMenu(self.service, "/setup/models/shell_conduction/multi_layer_shell").execute(*args, **kwargs)
                def enhanced_encapsulation(self, *args, **kwargs):
                    """
                    Enable/disable enhanced encapsulation for shell conduction and S2S models. This is not applicable if coupled sliding interface walls exists.
                    """
                    return PyMenu(self.service, "/setup/models/shell_conduction/enhanced_encapsulation").execute(*args, **kwargs)
                def read_csv(self, *args, **kwargs):
                    """
                    Read shell conduction settings from a csv file.
                    """
                    return PyMenu(self.service, "/setup/models/shell_conduction/read_csv").execute(*args, **kwargs)
                def write_csv(self, *args, **kwargs):
                    """
                    Write shell conduction settings to a csv file.
                    """
                    return PyMenu(self.service, "/setup/models/shell_conduction/write_csv").execute(*args, **kwargs)
                def settings(self, *args, **kwargs):
                    """
                    Enter Multi-layer Shell Conduction data.
                    """
                    return PyMenu(self.service, "/setup/models/shell_conduction/settings").execute(*args, **kwargs)
                def save_shell_zones(self, *args, **kwargs):
                    """
                    Enable/Disable saving shell zones to case file.
                    """
                    return PyMenu(self.service, "/setup/models/shell_conduction/save_shell_zones").execute(*args, **kwargs)

            class system_coupling_settings(metaclass=PyMenuMeta):
                """
                Enter the system coupling model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.htc = self.__class__.htc(path + [("htc", None)], service)
                def use_face_or_element_based_data_transfer(self, *args, **kwargs):
                    """
                    Enable/disable face based data transfer.
                    """
                    return PyMenu(self.service, "/setup/models/system_coupling_settings/use_face_or_element_based_data_transfer").execute(*args, **kwargs)
                def update_rigid_body_mesh_motion_before_mesh_transfer(self, *args, **kwargs):
                    """
                    SC Enable/disable mesh motion.
                    """
                    return PyMenu(self.service, "/setup/models/system_coupling_settings/update_rigid_body_mesh_motion_before_mesh_transfer").execute(*args, **kwargs)
                def specify_system_coupling_volumetric_cell_zones(self, *args, **kwargs):
                    """
                    Enable/disable volumetric cell zones.
                    """
                    return PyMenu(self.service, "/setup/models/system_coupling_settings/specify_system_coupling_volumetric_cell_zones").execute(*args, **kwargs)

                class htc(metaclass=PyMenuMeta):
                    """
                    Enter the heat transfer coeficient menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.unsteady_statistics = self.__class__.unsteady_statistics(path + [("unsteady_statistics", None)], service)
                        self.htc_calculation_method = self.__class__.htc_calculation_method(path + [("htc_calculation_method", None)], service)

                    class unsteady_statistics(metaclass=PyMenuMeta):
                        """
                        Enter the unsteady statistics menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def sc_enable_sub_stepping_option_per_coupling_step(self, *args, **kwargs):
                            """
                            Enable/disable sub stepping option per coupling step.
                            """
                            return PyMenu(self.service, "/setup/models/system_coupling_settings/htc/unsteady_statistics/sc_enable_sub_stepping_option_per_coupling_step").execute(*args, **kwargs)

                    class htc_calculation_method(metaclass=PyMenuMeta):
                        """
                        Enter the htc calculation menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def use_tref_in_htc_calculation(self, *args, **kwargs):
                            """
                            Enable/disable tref in htc computation.
                            """
                            return PyMenu(self.service, "/setup/models/system_coupling_settings/htc/htc_calculation_method/use_tref_in_htc_calculation").execute(*args, **kwargs)
                        def use_yplus_based_htc_calculation(self, *args, **kwargs):
                            """
                            Enable/disable yplus in htc computation.
                            """
                            return PyMenu(self.service, "/setup/models/system_coupling_settings/htc/htc_calculation_method/use_yplus_based_htc_calculation").execute(*args, **kwargs)
                        def use_wall_function_based_htc(self, *args, **kwargs):
                            """
                            Enable/disable wall function based htc computation.
                            """
                            return PyMenu(self.service, "/setup/models/system_coupling_settings/htc/htc_calculation_method/use_wall_function_based_htc").execute(*args, **kwargs)

            class cht(metaclass=PyMenuMeta):
                """
                Enter the mapped interface model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.explicit_time_averaged_coupling = self.__class__.explicit_time_averaged_coupling(path + [("explicit_time_averaged_coupling", None)], service)
                def read_mi_type_wall(self, *args, **kwargs):
                    """
                    Read mapped interface data settings from a csv file.
                    """
                    return PyMenu(self.service, "/setup/models/cht/read_mi_type_wall").execute(*args, **kwargs)
                def write_mi_type_wall(self, *args, **kwargs):
                    """
                    Write mapped interface settings to a scv file.
                    """
                    return PyMenu(self.service, "/setup/models/cht/write_mi_type_wall").execute(*args, **kwargs)
                def implicit_coupling(self, *args, **kwargs):
                    """
                    Enable/disable implicit coupling for mapped interface.
                    """
                    return PyMenu(self.service, "/setup/models/cht/implicit_coupling").execute(*args, **kwargs)

                class explicit_time_averaged_coupling(metaclass=PyMenuMeta):
                    """
                    Enter the explcit time averaged thermal coupling menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def conformal_coupled_walls(self, *args, **kwargs):
                        """
                        Select fluid-solid coupled walls (without shell) for explicit coupling using time averaged thermal variables.
                        """
                        return PyMenu(self.service, "/setup/models/cht/explicit_time_averaged_coupling/conformal_coupled_walls").execute(*args, **kwargs)
                    def mapped_interfaces(self, *args, **kwargs):
                        """
                        Select fluid-solid mapped interfaces for explicit coupling using time averaged thermal variables.
                        """
                        return PyMenu(self.service, "/setup/models/cht/explicit_time_averaged_coupling/mapped_interfaces").execute(*args, **kwargs)
                    def coupling_controls(self, *args, **kwargs):
                        """
                        Specify explcit coupling controls.
                        """
                        return PyMenu(self.service, "/setup/models/cht/explicit_time_averaged_coupling/coupling_controls").execute(*args, **kwargs)
                    def fuse_explicit_cht_zones(self, *args, **kwargs):
                        """
                        Fuse slitted conformal coupled walls marked for transient explicit thermal coupling.
                        """
                        return PyMenu(self.service, "/setup/models/cht/explicit_time_averaged_coupling/fuse_explicit_cht_zones").execute(*args, **kwargs)

            class two_temperature(metaclass=PyMenuMeta):
                """
                Define two-temperature model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def enable(self, *args, **kwargs):
                    """
                    Enable/disable the two-temperature model.
                    """
                    return PyMenu(self.service, "/setup/models/two_temperature/enable").execute(*args, **kwargs)
                def robustness_enhancement(self, *args, **kwargs):
                    """
                    Apply robustness enhancements in the two-temperature model.
                    """
                    return PyMenu(self.service, "/setup/models/two_temperature/robustness_enhancement").execute(*args, **kwargs)
                def nasa9_enhancement(self, *args, **kwargs):
                    """
                    Apply nasa9 robustness enhancements in the two-temperature model.
                    """
                    return PyMenu(self.service, "/setup/models/two_temperature/nasa9_enhancement").execute(*args, **kwargs)
                def set_verbosity(self, *args, **kwargs):
                    """
                    Set two-temperature model verbosity option.
                    """
                    return PyMenu(self.service, "/setup/models/two_temperature/set_verbosity").execute(*args, **kwargs)

            class multiphase(metaclass=PyMenuMeta):
                """
                Define multiphase model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.phases = self.__class__.phases(path + [("phases", None)], service)
                    self.wet_steam = self.__class__.wet_steam(path + [("wet_steam", None)], service)
                    self.population_balance = self.__class__.population_balance(path + [("population_balance", None)], service)
                    self.explicit_expert_options = self.__class__.explicit_expert_options(path + [("explicit_expert_options", None)], service)
                def model(self, *args, **kwargs):
                    """
                    Specify multiphase model.
                    """
                    return PyMenu(self.service, "/setup/models/multiphase/model").execute(*args, **kwargs)
                def number_of_phases(self, *args, **kwargs):
                    """
                    Specify the number of phases.
                    """
                    return PyMenu(self.service, "/setup/models/multiphase/number_of_phases").execute(*args, **kwargs)
                def regime_transition_modeling(self, *args, **kwargs):
                    """
                    Regime-transition-modeling-options.
                    """
                    return PyMenu(self.service, "/setup/models/multiphase/regime_transition_modeling").execute(*args, **kwargs)
                def eulerian_parameters(self, *args, **kwargs):
                    """
                    Eulerian parameters.
                    """
                    return PyMenu(self.service, "/setup/models/multiphase/eulerian_parameters").execute(*args, **kwargs)
                def volume_fraction_parameters(self, *args, **kwargs):
                    """
                    Volume fraction parameters.
                    """
                    return PyMenu(self.service, "/setup/models/multiphase/volume_fraction_parameters").execute(*args, **kwargs)
                def boiling_model_options(self, *args, **kwargs):
                    """
                    Boiling model options.
                    """
                    return PyMenu(self.service, "/setup/models/multiphase/boiling_model_options").execute(*args, **kwargs)
                def mixture_parameters(self, *args, **kwargs):
                    """
                    Mixture parameters.
                    """
                    return PyMenu(self.service, "/setup/models/multiphase/mixture_parameters").execute(*args, **kwargs)
                def body_force_formulation(self, *args, **kwargs):
                    """
                    Body force formulation.
                    """
                    return PyMenu(self.service, "/setup/models/multiphase/body_force_formulation").execute(*args, **kwargs)
                def coupled_level_set(self, *args, **kwargs):
                    """
                    Coupled level set.
                    """
                    return PyMenu(self.service, "/setup/models/multiphase/coupled_level_set").execute(*args, **kwargs)
                def vof_sub_models(self, *args, **kwargs):
                    """
                    VOF sub-models.
                    """
                    return PyMenu(self.service, "/setup/models/multiphase/vof_sub_models").execute(*args, **kwargs)
                def interface_modeling_options(self, *args, **kwargs):
                    """
                    Interface Modeling Options.
                    """
                    return PyMenu(self.service, "/setup/models/multiphase/interface_modeling_options").execute(*args, **kwargs)
                def expert_options(self, *args, **kwargs):
                    """
                    Expert Options.
                    """
                    return PyMenu(self.service, "/setup/models/multiphase/expert_options").execute(*args, **kwargs)

                class phases(metaclass=PyMenuMeta):
                    """
                    Enter the phases menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.set_domain_properties = self.__class__.set_domain_properties(path + [("set_domain_properties", None)], service)
                        self.iac_expert = self.__class__.iac_expert(path + [("iac_expert", None)], service)

                    class set_domain_properties(metaclass=PyMenuMeta):
                        """
                        Enter the menu to set domain properties.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.interaction_domain = self.__class__.interaction_domain(path + [("interaction_domain", None)], service)
                        def change_phases_names(self, *args, **kwargs):
                            """
                            Change names for all defined phases?.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/change_phases_names").execute(*args, **kwargs)
                        def phase_domains(self, *args, **kwargs):
                            """
                            Enter the menu to select a specific phase domain.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/phase_domains").execute(*args, **kwargs)

                        class interaction_domain(metaclass=PyMenuMeta):
                            """
                            Enter the menu to set the interaction domain properties.
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                                self.forces = self.__class__.forces(path + [("forces", None)], service)
                                self.heat_mass_reactions = self.__class__.heat_mass_reactions(path + [("heat_mass_reactions", None)], service)
                                self.interfacial_area = self.__class__.interfacial_area(path + [("interfacial_area", None)], service)
                                self.model_transition = self.__class__.model_transition(path + [("model_transition", None)], service)
                                self.numerics = self.__class__.numerics(path + [("numerics", None)], service)

                            class forces(metaclass=PyMenuMeta):
                                """
                                Enter the menu to set interfacial forces related models.
                                """
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service
                                    self.cavitation = self.__class__.cavitation(path + [("cavitation", None)], service)
                                    self.interphase_discretization = self.__class__.interphase_discretization(path + [("interphase_discretization", None)], service)
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(path + [("interphase_viscous_dissipation", None)], service)
                                    self.lift = self.__class__.lift(path + [("lift", None)], service)
                                    self.surface_tension = self.__class__.surface_tension(path + [("surface_tension", None)], service)
                                    self.virtual_mass = self.__class__.virtual_mass(path + [("virtual_mass", None)], service)
                                def drag(self, *args, **kwargs):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/drag").execute(*args, **kwargs)
                                def heat_coeff(self, *args, **kwargs):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/heat_coeff").execute(*args, **kwargs)
                                def interfacial_area(self, *args, **kwargs):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interfacial_area").execute(*args, **kwargs)
                                def mass_transfer(self, *args, **kwargs):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/mass_transfer").execute(*args, **kwargs)
                                def model_transition(self, *args, **kwargs):
                                    """
                                    Set the model transition mechanism.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/model_transition").execute(*args, **kwargs)
                                def reactions(self, *args, **kwargs):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/reactions").execute(*args, **kwargs)
                                def restitution(self, *args, **kwargs):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/restitution").execute(*args, **kwargs)
                                def slip_velocity(self, *args, **kwargs):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/slip_velocity").execute(*args, **kwargs)
                                def turbulence_interaction(self, *args, **kwargs):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/turbulence_interaction").execute(*args, **kwargs)
                                def turbulent_dispersion(self, *args, **kwargs):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/turbulent_dispersion").execute(*args, **kwargs)
                                def wall_lubrication(self, *args, **kwargs):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/wall_lubrication").execute(*args, **kwargs)

                                class cavitation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/cavitation/wall_adhesion").execute(*args, **kwargs)

                                class interphase_discretization(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_discretization/wall_adhesion").execute(*args, **kwargs)

                                class interphase_viscous_dissipation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)

                                class lift(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/lift/wall_adhesion").execute(*args, **kwargs)

                                class surface_tension(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/surface_tension/wall_adhesion").execute(*args, **kwargs)

                                class virtual_mass(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/forces/virtual_mass/wall_adhesion").execute(*args, **kwargs)

                            class heat_mass_reactions(metaclass=PyMenuMeta):
                                """
                                Enter the menu to set heat, mass-transfer, or reaction related models.
                                """
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service
                                    self.cavitation = self.__class__.cavitation(path + [("cavitation", None)], service)
                                    self.interphase_discretization = self.__class__.interphase_discretization(path + [("interphase_discretization", None)], service)
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(path + [("interphase_viscous_dissipation", None)], service)
                                    self.lift = self.__class__.lift(path + [("lift", None)], service)
                                    self.surface_tension = self.__class__.surface_tension(path + [("surface_tension", None)], service)
                                    self.virtual_mass = self.__class__.virtual_mass(path + [("virtual_mass", None)], service)
                                def drag(self, *args, **kwargs):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/drag").execute(*args, **kwargs)
                                def heat_coeff(self, *args, **kwargs):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/heat_coeff").execute(*args, **kwargs)
                                def interfacial_area(self, *args, **kwargs):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interfacial_area").execute(*args, **kwargs)
                                def mass_transfer(self, *args, **kwargs):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/mass_transfer").execute(*args, **kwargs)
                                def model_transition(self, *args, **kwargs):
                                    """
                                    Set the model transition mechanism.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/model_transition").execute(*args, **kwargs)
                                def reactions(self, *args, **kwargs):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/reactions").execute(*args, **kwargs)
                                def restitution(self, *args, **kwargs):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/restitution").execute(*args, **kwargs)
                                def slip_velocity(self, *args, **kwargs):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/slip_velocity").execute(*args, **kwargs)
                                def turbulence_interaction(self, *args, **kwargs):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/turbulence_interaction").execute(*args, **kwargs)
                                def turbulent_dispersion(self, *args, **kwargs):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/turbulent_dispersion").execute(*args, **kwargs)
                                def wall_lubrication(self, *args, **kwargs):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/wall_lubrication").execute(*args, **kwargs)

                                class cavitation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/cavitation/wall_adhesion").execute(*args, **kwargs)

                                class interphase_discretization(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_discretization/wall_adhesion").execute(*args, **kwargs)

                                class interphase_viscous_dissipation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)

                                class lift(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/lift/wall_adhesion").execute(*args, **kwargs)

                                class surface_tension(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/surface_tension/wall_adhesion").execute(*args, **kwargs)

                                class virtual_mass(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/heat_mass_reactions/virtual_mass/wall_adhesion").execute(*args, **kwargs)

                            class interfacial_area(metaclass=PyMenuMeta):
                                """
                                Enter the menu to set interfacial area models.
                                """
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service
                                    self.cavitation = self.__class__.cavitation(path + [("cavitation", None)], service)
                                    self.interphase_discretization = self.__class__.interphase_discretization(path + [("interphase_discretization", None)], service)
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(path + [("interphase_viscous_dissipation", None)], service)
                                    self.lift = self.__class__.lift(path + [("lift", None)], service)
                                    self.surface_tension = self.__class__.surface_tension(path + [("surface_tension", None)], service)
                                    self.virtual_mass = self.__class__.virtual_mass(path + [("virtual_mass", None)], service)
                                def drag(self, *args, **kwargs):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/drag").execute(*args, **kwargs)
                                def heat_coeff(self, *args, **kwargs):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/heat_coeff").execute(*args, **kwargs)
                                def interfacial_area(self, *args, **kwargs):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interfacial_area").execute(*args, **kwargs)
                                def mass_transfer(self, *args, **kwargs):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/mass_transfer").execute(*args, **kwargs)
                                def model_transition(self, *args, **kwargs):
                                    """
                                    Set the model transition mechanism.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/model_transition").execute(*args, **kwargs)
                                def reactions(self, *args, **kwargs):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/reactions").execute(*args, **kwargs)
                                def restitution(self, *args, **kwargs):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/restitution").execute(*args, **kwargs)
                                def slip_velocity(self, *args, **kwargs):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/slip_velocity").execute(*args, **kwargs)
                                def turbulence_interaction(self, *args, **kwargs):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/turbulence_interaction").execute(*args, **kwargs)
                                def turbulent_dispersion(self, *args, **kwargs):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/turbulent_dispersion").execute(*args, **kwargs)
                                def wall_lubrication(self, *args, **kwargs):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/wall_lubrication").execute(*args, **kwargs)

                                class cavitation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/cavitation/wall_adhesion").execute(*args, **kwargs)

                                class interphase_discretization(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_discretization/wall_adhesion").execute(*args, **kwargs)

                                class interphase_viscous_dissipation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)

                                class lift(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/lift/wall_adhesion").execute(*args, **kwargs)

                                class surface_tension(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/surface_tension/wall_adhesion").execute(*args, **kwargs)

                                class virtual_mass(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/interfacial_area/virtual_mass/wall_adhesion").execute(*args, **kwargs)

                            class model_transition(metaclass=PyMenuMeta):
                                """
                                Enter the menu to set model transition mechanisms.
                                """
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service
                                    self.cavitation = self.__class__.cavitation(path + [("cavitation", None)], service)
                                    self.interphase_discretization = self.__class__.interphase_discretization(path + [("interphase_discretization", None)], service)
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(path + [("interphase_viscous_dissipation", None)], service)
                                    self.lift = self.__class__.lift(path + [("lift", None)], service)
                                    self.surface_tension = self.__class__.surface_tension(path + [("surface_tension", None)], service)
                                    self.virtual_mass = self.__class__.virtual_mass(path + [("virtual_mass", None)], service)
                                def drag(self, *args, **kwargs):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/drag").execute(*args, **kwargs)
                                def heat_coeff(self, *args, **kwargs):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/heat_coeff").execute(*args, **kwargs)
                                def interfacial_area(self, *args, **kwargs):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interfacial_area").execute(*args, **kwargs)
                                def mass_transfer(self, *args, **kwargs):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/mass_transfer").execute(*args, **kwargs)
                                def model_transition(self, *args, **kwargs):
                                    """
                                    Set the model transition mechanism.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/model_transition").execute(*args, **kwargs)
                                def reactions(self, *args, **kwargs):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/reactions").execute(*args, **kwargs)
                                def restitution(self, *args, **kwargs):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/restitution").execute(*args, **kwargs)
                                def slip_velocity(self, *args, **kwargs):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/slip_velocity").execute(*args, **kwargs)
                                def turbulence_interaction(self, *args, **kwargs):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/turbulence_interaction").execute(*args, **kwargs)
                                def turbulent_dispersion(self, *args, **kwargs):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/turbulent_dispersion").execute(*args, **kwargs)
                                def wall_lubrication(self, *args, **kwargs):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/wall_lubrication").execute(*args, **kwargs)

                                class cavitation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/cavitation/wall_adhesion").execute(*args, **kwargs)

                                class interphase_discretization(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_discretization/wall_adhesion").execute(*args, **kwargs)

                                class interphase_viscous_dissipation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)

                                class lift(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/lift/wall_adhesion").execute(*args, **kwargs)

                                class surface_tension(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/surface_tension/wall_adhesion").execute(*args, **kwargs)

                                class virtual_mass(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/model_transition/virtual_mass/wall_adhesion").execute(*args, **kwargs)

                            class numerics(metaclass=PyMenuMeta):
                                """
                                Enter the menu to set numerics models.
                                """
                                def __init__(self, path, service):
                                    self.path = path
                                    self.service = service
                                    self.cavitation = self.__class__.cavitation(path + [("cavitation", None)], service)
                                    self.interphase_discretization = self.__class__.interphase_discretization(path + [("interphase_discretization", None)], service)
                                    self.interphase_viscous_dissipation = self.__class__.interphase_viscous_dissipation(path + [("interphase_viscous_dissipation", None)], service)
                                    self.lift = self.__class__.lift(path + [("lift", None)], service)
                                    self.surface_tension = self.__class__.surface_tension(path + [("surface_tension", None)], service)
                                    self.virtual_mass = self.__class__.virtual_mass(path + [("virtual_mass", None)], service)
                                def drag(self, *args, **kwargs):
                                    """
                                    Specify the drag function for each pair of phases. It also enables drag modification and allow specifying the drag factor.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/drag").execute(*args, **kwargs)
                                def heat_coeff(self, *args, **kwargs):
                                    """
                                    Specify the heat transfer coefficient function between each pair of phases.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/heat_coeff").execute(*args, **kwargs)
                                def interfacial_area(self, *args, **kwargs):
                                    """
                                    Set the interfacial area parameters for each pair of phases.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interfacial_area").execute(*args, **kwargs)
                                def mass_transfer(self, *args, **kwargs):
                                    """
                                    Specify the mass transfer mechanisms.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/mass_transfer").execute(*args, **kwargs)
                                def model_transition(self, *args, **kwargs):
                                    """
                                    Set the model transition mechanism.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/model_transition").execute(*args, **kwargs)
                                def reactions(self, *args, **kwargs):
                                    """
                                    Define multiple heterogeneous reactions and stoichiometry.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/reactions").execute(*args, **kwargs)
                                def restitution(self, *args, **kwargs):
                                    """
                                    Specify the restitution coefficient for collisions between each pair of granular phases and for collisions between particles of the same granular phase.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/restitution").execute(*args, **kwargs)
                                def slip_velocity(self, *args, **kwargs):
                                    """
                                    Specify the slip velocity function for each secondary phase with respect to the primary phase.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/slip_velocity").execute(*args, **kwargs)
                                def turbulence_interaction(self, *args, **kwargs):
                                    """
                                    Specify the turbulence interaction model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/turbulence_interaction").execute(*args, **kwargs)
                                def turbulent_dispersion(self, *args, **kwargs):
                                    """
                                    Specify the turbulent dispersion model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/turbulent_dispersion").execute(*args, **kwargs)
                                def wall_lubrication(self, *args, **kwargs):
                                    """
                                    Specify the wall lubrication model for each primary-secondary phase pair.
                                    """
                                    return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/wall_lubrication").execute(*args, **kwargs)

                                class cavitation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set cavitation models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/cavitation/wall_adhesion").execute(*args, **kwargs)

                                class interphase_discretization(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase discretization models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_discretization/wall_adhesion").execute(*args, **kwargs)

                                class interphase_viscous_dissipation(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set interphase viscous dissipation related models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/interphase_viscous_dissipation/wall_adhesion").execute(*args, **kwargs)

                                class lift(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set lift models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/lift/wall_adhesion").execute(*args, **kwargs)

                                class surface_tension(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set surface tension models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/surface_tension/wall_adhesion").execute(*args, **kwargs)

                                class virtual_mass(metaclass=PyMenuMeta):
                                    """
                                    Enter the menu to set virtual mass models.
                                    """
                                    def __init__(self, path, service):
                                        self.path = path
                                        self.service = service
                                    def cavitation(self, *args, **kwargs):
                                        """
                                        Set the vaporization pressure, the surface tension coefficient, and the non-condensable gas mass fraction.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/cavitation").execute(*args, **kwargs)
                                    def interphase_discr(self, *args, **kwargs):
                                        """
                                        Enable the phase localized compressive discretization scheme where the degree of diffusion/sharpness is controlled through the value of the slope limiters?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/interphase_discr").execute(*args, **kwargs)
                                    def interphase_visc_disp(self, *args, **kwargs):
                                        """
                                        Enable the interfacial viscous dissipation method, which introduces an artificial viscous damping term in the momentum equation?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/interphase_visc_disp").execute(*args, **kwargs)
                                    def jump_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the treatment of the contact angle specification at the porous jump boundary?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/jump_adhesion").execute(*args, **kwargs)
                                    def lift(self, *args, **kwargs):
                                        """
                                        .
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/lift").execute(*args, **kwargs)
                                    def lift_montoya(self, *args, **kwargs):
                                        """
                                        Include the Montoya correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/lift_montoya").execute(*args, **kwargs)
                                    def lift_shaver_podowski(self, *args, **kwargs):
                                        """
                                        Include the Shaver-Podowski correction for Lift.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/lift_shaver_podowski").execute(*args, **kwargs)
                                    def sfc_model_type(self, *args, **kwargs):
                                        """
                                        Select the surface tension model.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/sfc_model_type").execute(*args, **kwargs)
                                    def sfc_modeling(self, *args, **kwargs):
                                        """
                                        Include the effects of surface tension along the fluid-fluid interface?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/sfc_modeling").execute(*args, **kwargs)
                                    def sfc_tension_coeff(self, *args, **kwargs):
                                        """
                                        Specify the surface tension coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/sfc_tension_coeff").execute(*args, **kwargs)
                                    def slope_limiter(self, *args, **kwargs):
                                        """
                                        Specify the slope limiter to set a specific discretization scheme. 0: first order upwind, 1: second order reconstruction bounded by the global minimum/maximum of the volume fraction, 2: compressive. Value between 0 and 2: blended scheme.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/slope_limiter").execute(*args, **kwargs)
                                    def virtual_mass(self, *args, **kwargs):
                                        """
                                        Include the virtual mass force that is present when a secondary phase accelerates relative to the primary phase?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/virtual_mass").execute(*args, **kwargs)
                                    def visc_disp_factor(self, *args, **kwargs):
                                        """
                                        Set the dissipation intensity.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/visc_disp_factor").execute(*args, **kwargs)
                                    def vmass_coeff(self, *args, **kwargs):
                                        """
                                        Specify the virtual mass coefficient for each pair of phases.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/vmass_coeff").execute(*args, **kwargs)
                                    def vmass_implicit_options(self, *args, **kwargs):
                                        """
                                        Select the virtual mass implicit option.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/vmass_implicit_options").execute(*args, **kwargs)
                                    def vmass_implicit(self, *args, **kwargs):
                                        """
                                        Enable the implicit method for the virtual mass force?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/vmass_implicit").execute(*args, **kwargs)
                                    def wall_adhesion(self, *args, **kwargs):
                                        """
                                        Enable the specification for a wall adhesion angle?.
                                        """
                                        return PyMenu(self.service, "/setup/models/multiphase/phases/set_domain_properties/interaction_domain/numerics/virtual_mass/wall_adhesion").execute(*args, **kwargs)

                    class iac_expert(metaclass=PyMenuMeta):
                        """
                        Enter the IAC expert setting menu.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def ishii_kim_model(self, *args, **kwargs):
                            """
                            Set ik model coefficients.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/phases/iac_expert/ishii_kim_model").execute(*args, **kwargs)
                        def hibiki_ishii_model(self, *args, **kwargs):
                            """
                            Set hi model coefficients.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/phases/iac_expert/hibiki_ishii_model").execute(*args, **kwargs)
                        def yao_morel_model(self, *args, **kwargs):
                            """
                            Set ym model coefficients.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/phases/iac_expert/yao_morel_model").execute(*args, **kwargs)
                        def iac_pseudo_time_step(self, *args, **kwargs):
                            """
                            Set iac pseudo-time.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/phases/iac_expert/iac_pseudo_time_step").execute(*args, **kwargs)

                class wet_steam(metaclass=PyMenuMeta):
                    """
                    Enter the wet steam model menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.set = self.__class__.set(path + [("set", None)], service)
                    def enable(self, *args, **kwargs):
                        """
                        Enable/disable the wet steam model.
                        """
                        return PyMenu(self.service, "/setup/models/multiphase/wet_steam/enable").execute(*args, **kwargs)
                    def compile_user_defined_wetsteam_functions(self, *args, **kwargs):
                        """
                        Compile user-defined wet steam library.
                        """
                        return PyMenu(self.service, "/setup/models/multiphase/wet_steam/compile_user_defined_wetsteam_functions").execute(*args, **kwargs)
                    def load_unload_user_defined_wetsteam_library(self, *args, **kwargs):
                        """
                        Load or unload user-defined wet steam library.
                        """
                        return PyMenu(self.service, "/setup/models/multiphase/wet_steam/load_unload_user_defined_wetsteam_library").execute(*args, **kwargs)

                    class set(metaclass=PyMenuMeta):
                        """
                        Enter the set menu for setting wet steam model options.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def max_liquid_mass_fraction(self, *args, **kwargs):
                            """
                            Set the maximum limit on the condensed liquid-phase mass-fraction to prevent divergence.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/wet_steam/set/max_liquid_mass_fraction").execute(*args, **kwargs)
                        def droplet_growth_rate(self, *args, **kwargs):
                            """
                            Select the formula to model the droplet growth rate.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/wet_steam/set/droplet_growth_rate").execute(*args, **kwargs)
                        def virial_equation(self, *args, **kwargs):
                            """
                            Select the formulation of the virial equation of state and associated equations for thermodynamic properties of steam.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/wet_steam/set/virial_equation").execute(*args, **kwargs)
                        def rgp_tables(self, *args, **kwargs):
                            """
                            Select which properties to use: build-in or from RGP tables.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/wet_steam/set/rgp_tables").execute(*args, **kwargs)
                        def stagnation_conditions(self, *args, **kwargs):
                            """
                            If the gas phase is selected, zero wetness is assumed when evaluating total or static values of pressure and temperature.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/wet_steam/set/stagnation_conditions").execute(*args, **kwargs)

                class population_balance(metaclass=PyMenuMeta):
                    """
                    Enter the population balance model menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.phenomena = self.__class__.phenomena(path + [("phenomena", None)], service)
                        self.expert = self.__class__.expert(path + [("expert", None)], service)
                    def model(self, *args, **kwargs):
                        """
                        Select the population balance model.
                        """
                        return PyMenu(self.service, "/setup/models/multiphase/population_balance/model").execute(*args, **kwargs)
                    def include_expansion(self, *args, **kwargs):
                        """
                        Set expansion.
                        """
                        return PyMenu(self.service, "/setup/models/multiphase/population_balance/include_expansion").execute(*args, **kwargs)
                    def size_calculator(self, *args, **kwargs):
                        """
                        Calculate fluid particle diameters using different methods.
                        """
                        return PyMenu(self.service, "/setup/models/multiphase/population_balance/size_calculator").execute(*args, **kwargs)

                    class phenomena(metaclass=PyMenuMeta):
                        """
                        Enter the phenomena menu for population balance.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def nucleation(self, *args, **kwargs):
                            """
                            Set the nucleantion rate.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/population_balance/phenomena/nucleation").execute(*args, **kwargs)
                        def growth(self, *args, **kwargs):
                            """
                            Set the growth rate.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/population_balance/phenomena/growth").execute(*args, **kwargs)
                        def aggregation(self, *args, **kwargs):
                            """
                            Set the aggregation kernel.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/population_balance/phenomena/aggregation").execute(*args, **kwargs)
                        def breakage(self, *args, **kwargs):
                            """
                            Set the breakage kernel.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/population_balance/phenomena/breakage").execute(*args, **kwargs)
                        def aggregation_factor(self, *args, **kwargs):
                            """
                            Set a factor which controls the intensity of the selected aggregation kernel.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/population_balance/phenomena/aggregation_factor").execute(*args, **kwargs)
                        def breakage_factor(self, *args, **kwargs):
                            """
                            Set a factor which controls the intensity of the selected breakage kernel.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/population_balance/phenomena/breakage_factor").execute(*args, **kwargs)
                        def breakage_aggregation_vof_cutoff(self, *args, **kwargs):
                            """
                            Control vof cut-off for breakage and aggregation.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/population_balance/phenomena/breakage_aggregation_vof_cutoff").execute(*args, **kwargs)

                    class expert(metaclass=PyMenuMeta):
                        """
                        Enter the expert menu for quadrature-based population balance method.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                            self.qmom = self.__class__.qmom(path + [("qmom", None)], service)

                        class qmom(metaclass=PyMenuMeta):
                            """
                            .
                            """
                            def __init__(self, path, service):
                                self.path = path
                                self.service = service
                            def retain_qmom_sources_for_low_vof(self, *args, **kwargs):
                                """
                                Retain qmom source calculation for low secondary phase vof.
                                """
                                return PyMenu(self.service, "/setup/models/multiphase/population_balance/expert/qmom/retain_qmom_sources_for_low_vof").execute(*args, **kwargs)
                            def realizable_moments(self, *args, **kwargs):
                                """
                                Set the population balance model.
                                """
                                return PyMenu(self.service, "/setup/models/multiphase/population_balance/expert/qmom/realizable_moments").execute(*args, **kwargs)
                            def print_realizable_moment_warning(self, *args, **kwargs):
                                """
                                Print the information for realizable moments in the population balance model.
                                """
                                return PyMenu(self.service, "/setup/models/multiphase/population_balance/expert/qmom/print_realizable_moment_warning").execute(*args, **kwargs)
                            def inversion_algorithm(self, *args, **kwargs):
                                """
                                Select the inversion algorithm for quadrature-based population balance method.
                                """
                                return PyMenu(self.service, "/setup/models/multiphase/population_balance/expert/qmom/inversion_algorithm").execute(*args, **kwargs)

                class explicit_expert_options(metaclass=PyMenuMeta):
                    """
                    Expert options for explicit formulation.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.volume_fraction_filtering = self.__class__.volume_fraction_filtering(path + [("volume_fraction_filtering", None)], service)
                    def sub_time_step_method(self, *args, **kwargs):
                        """
                        Select sub-time step method for the time integration in explicit formulation.
                        """
                        return PyMenu(self.service, "/setup/models/multiphase/explicit_expert_options/sub_time_step_method").execute(*args, **kwargs)
                    def solve_vof_every_iter(self, *args, **kwargs):
                        """
                        Solve volume fraction equation every iteration for explicit formulation.
                        """
                        return PyMenu(self.service, "/setup/models/multiphase/explicit_expert_options/solve_vof_every_iter").execute(*args, **kwargs)

                    class volume_fraction_filtering(metaclass=PyMenuMeta):
                        """
                        Advanced volume fraction filtering controls for explicit formulation.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def enable(self, *args, **kwargs):
                            """
                            Enable volume fraction filtering treatment.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/explicit_expert_options/volume_fraction_filtering/enable").execute(*args, **kwargs)
                        def filtering_options(self, *args, **kwargs):
                            """
                            Select volume fraction filtering method.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/explicit_expert_options/volume_fraction_filtering/filtering_options").execute(*args, **kwargs)
                        def vol_frac_cutoff(self, *args, **kwargs):
                            """
                            Enter node-averaged volume fraction cutoff.
                            """
                            return PyMenu(self.service, "/setup/models/multiphase/explicit_expert_options/volume_fraction_filtering/vol_frac_cutoff").execute(*args, **kwargs)

            class nox_parameters(metaclass=PyMenuMeta):
                """
                Enter the NOx parameters menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def nox_chemistry(self, *args, **kwargs):
                    """
                    Select NOx chemistry model.
                    """
                    return PyMenu(self.service, "/setup/models/nox_parameters/nox_chemistry").execute(*args, **kwargs)
                def nox_turbulence_interaction(self, *args, **kwargs):
                    """
                    Set NOx-turbulence interaction model.
                    """
                    return PyMenu(self.service, "/setup/models/nox_parameters/nox_turbulence_interaction").execute(*args, **kwargs)
                def inlet_diffusion(self, *args, **kwargs):
                    """
                    Enable/disable inclusion of diffusion at inlets.
                    """
                    return PyMenu(self.service, "/setup/models/nox_parameters/inlet_diffusion").execute(*args, **kwargs)
                def nox_expert(self, *args, **kwargs):
                    """
                    Select additional nox equations.
                    """
                    return PyMenu(self.service, "/setup/models/nox_parameters/nox_expert").execute(*args, **kwargs)

            class soot_parameters(metaclass=PyMenuMeta):
                """
                Enter the soot parameters menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def soot_model_parameters(self, *args, **kwargs):
                    """
                    Enter the soot model parameters menu.
                    """
                    return PyMenu(self.service, "/setup/models/soot_parameters/soot_model_parameters").execute(*args, **kwargs)
                def soot_process_parameters(self, *args, **kwargs):
                    """
                    Set soot process parameters.
                    """
                    return PyMenu(self.service, "/setup/models/soot_parameters/soot_process_parameters").execute(*args, **kwargs)
                def soot_radiation_interaction(self, *args, **kwargs):
                    """
                    Enable/disable the soot-radiation interaction model.
                    """
                    return PyMenu(self.service, "/setup/models/soot_parameters/soot_radiation_interaction").execute(*args, **kwargs)
                def soot_turbulence_interaction(self, *args, **kwargs):
                    """
                    Set Soot-turbulence interaction model.
                    """
                    return PyMenu(self.service, "/setup/models/soot_parameters/soot_turbulence_interaction").execute(*args, **kwargs)
                def modify_schmidt_number(self, *args, **kwargs):
                    """
                    Change Turbulent Schmidt Number for Soot/Nuclei Equations.
                    """
                    return PyMenu(self.service, "/setup/models/soot_parameters/modify_schmidt_number").execute(*args, **kwargs)
                def inlet_diffusion(self, *args, **kwargs):
                    """
                    Enable/disable inclusion of diffusion at inlets.
                    """
                    return PyMenu(self.service, "/setup/models/soot_parameters/inlet_diffusion").execute(*args, **kwargs)
                def soot_model_udfs(self, *args, **kwargs):
                    """
                    User defined functions for soot model.
                    """
                    return PyMenu(self.service, "/setup/models/soot_parameters/soot_model_udfs").execute(*args, **kwargs)

            class radiation(metaclass=PyMenuMeta):
                """
                Enter the radiation models menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.s2s_parameters = self.__class__.s2s_parameters(path + [("s2s_parameters", None)], service)
                    self.dtrm_parameters = self.__class__.dtrm_parameters(path + [("dtrm_parameters", None)], service)
                    self.solar_parameters = self.__class__.solar_parameters(path + [("solar_parameters", None)], service)
                def discrete_ordinates(self, *args, **kwargs):
                    """
                    Enable/disable the discrete ordinates radiation model.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/discrete_ordinates").execute(*args, **kwargs)
                def do_acceleration(self, *args, **kwargs):
                    """
                    Enable/disable acceleration of computation of DO model.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/do_acceleration").execute(*args, **kwargs)
                def non_gray_model_parameters(self, *args, **kwargs):
                    """
                    Set parameters for non-gray model.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/non_gray_model_parameters").execute(*args, **kwargs)
                def montecarlo(self, *args, **kwargs):
                    """
                    Enable/disable the Monte Carlo radiation model.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/montecarlo").execute(*args, **kwargs)
                def target_cells_per_volume_cluster(self, *args, **kwargs):
                    """
                    Enter cells per volume cluster for Monte Carlo radiation model.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/target_cells_per_volume_cluster").execute(*args, **kwargs)
                def s2s(self, *args, **kwargs):
                    """
                    Enable/disable the S2S radiation model.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/s2s").execute(*args, **kwargs)
                def discrete_transfer(self, *args, **kwargs):
                    """
                    Enable/disable discrete the transfer radiation model.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/discrete_transfer").execute(*args, **kwargs)
                def p1(self, *args, **kwargs):
                    """
                    Enable/disable the P1 radiation model.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/p1").execute(*args, **kwargs)
                def radiation_model_parameters(self, *args, **kwargs):
                    """
                    Set parameters for radiation models.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/radiation_model_parameters").execute(*args, **kwargs)
                def radiation_iteration_parameters(self, *args, **kwargs):
                    """
                    Set iteration parameters for radiation models.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/radiation_iteration_parameters").execute(*args, **kwargs)
                def mc_model_parameters(self, *args, **kwargs):
                    """
                    Set parameters for montecarlo radiation model.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/mc_model_parameters").execute(*args, **kwargs)
                def mc_under_relaxation(self, *args, **kwargs):
                    """
                    Set under-relaxation factor for montecarlo radiation sources used in the energy equation.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/mc_under_relaxation").execute(*args, **kwargs)
                def rosseland(self, *args, **kwargs):
                    """
                    Enable/disable the Rosseland radiation model.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/rosseland").execute(*args, **kwargs)
                def solar(self, *args, **kwargs):
                    """
                    Enable/disable the solar model.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/solar").execute(*args, **kwargs)
                def solar_irradiation(self, *args, **kwargs):
                    """
                    Enable/disable the Solar irradiation model.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/solar_irradiation").execute(*args, **kwargs)
                def solar_calculator(self, *args, **kwargs):
                    """
                    Calculate sun direction and intensity.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/solar_calculator").execute(*args, **kwargs)
                def apply_full_solar_irradiation(self, *args, **kwargs):
                    """
                    Enable/disable application of solar irradiation to first band with DO model.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/apply_full_solar_irradiation").execute(*args, **kwargs)
                def wsggm_cell_based(self, *args, **kwargs):
                    """
                    Enable/disable WSGGM cell based method.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/wsggm_cell_based").execute(*args, **kwargs)
                def fast_second_order_discrete_ordinate(self, *args, **kwargs):
                    """
                    Enable/disable the fast-second-order option for Discrete Ordinate Model.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/fast_second_order_discrete_ordinate").execute(*args, **kwargs)
                def do_coupling(self, *args, **kwargs):
                    """
                    Enabled DO Energy Coupling.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/do_coupling").execute(*args, **kwargs)
                def solution_method_for_do_coupling(self, *args, **kwargs):
                    """
                    Enable the solution method for DO/Energy  Coupling.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/solution_method_for_do_coupling").execute(*args, **kwargs)
                def beta_radiation_features(self, *args, **kwargs):
                    """
                    Enable Radiation Models with Non-Iterative Time Advancement (NITA) as Beta features in FL12.0.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/beta_radiation_features").execute(*args, **kwargs)
                def method_partially_specular_wall(self, *args, **kwargs):
                    """
                    Set method for partially specular wall with discrete ordinate model.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/method_partially_specular_wall").execute(*args, **kwargs)
                def blending_factor(self, *args, **kwargs):
                    """
                    Set numeric option for Discrete Ordinate model.
                    """
                    return PyMenu(self.service, "/setup/models/radiation/blending_factor").execute(*args, **kwargs)

                class s2s_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the S2S parameters menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def compute_vf_only(self, *args, **kwargs):
                        """
                        Compute/write view factors only.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/s2s_parameters/compute_vf_only").execute(*args, **kwargs)
                    def compute_write_vf(self, *args, **kwargs):
                        """
                        Compute/write surface clusters and view factors for S2S radiation model.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/s2s_parameters/compute_write_vf").execute(*args, **kwargs)
                    def compute_vf_accelerated(self, *args, **kwargs):
                        """
                        Compute/Write view factors from existing surface clusters.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/s2s_parameters/compute_vf_accelerated").execute(*args, **kwargs)
                    def compute_clusters_and_vf_accelerated(self, *args, **kwargs):
                        """
                        Compute/Write surface cluster first and then view factors.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/s2s_parameters/compute_clusters_and_vf_accelerated").execute(*args, **kwargs)
                    def non_participating_boundary_zones_temperature(self, *args, **kwargs):
                        """
                        Set temperature for the non-participating boundary zones.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/s2s_parameters/non_participating_boundary_zones_temperature").execute(*args, **kwargs)
                    def read_vf_file(self, *args, **kwargs):
                        """
                        Read an S2S file.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/s2s_parameters/read_vf_file").execute(*args, **kwargs)
                    def set_vf_parameters(self, *args, **kwargs):
                        """
                        Set the parameters needed for the view factor calculations.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/s2s_parameters/set_vf_parameters").execute(*args, **kwargs)
                    def split_angle(self, *args, **kwargs):
                        """
                        Set the split angle for the clustering algorithm.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/s2s_parameters/split_angle").execute(*args, **kwargs)
                    def set_global_faces_per_surface_cluster(self, *args, **kwargs):
                        """
                        Set global value of faces per surface cluster for all boundary zones.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/s2s_parameters/set_global_faces_per_surface_cluster").execute(*args, **kwargs)
                    def print_thread_clusters(self, *args, **kwargs):
                        """
                        Prints the following for all boundary threads: thread-id, number of faces, faces per surface cluster, and the number of surface clusters.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/s2s_parameters/print_thread_clusters").execute(*args, **kwargs)
                    def print_zonewise_radiation(self, *args, **kwargs):
                        """
                        Prints the zonewise incoming radiation, viewfactors, and average temperature.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/s2s_parameters/print_zonewise_radiation").execute(*args, **kwargs)
                    def use_old_cluster_algorithm(self, *args, **kwargs):
                        """
                        Use the old surface clustering algorithm.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/s2s_parameters/use_old_cluster_algorithm").execute(*args, **kwargs)
                    def use_new_cluster_algorithm(self, *args, **kwargs):
                        """
                        Use the new surface clustering algorithm.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/s2s_parameters/use_new_cluster_algorithm").execute(*args, **kwargs)
                    def compute_fpsc_values(self, *args, **kwargs):
                        """
                        Compute only fpsc values based on current settings.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/s2s_parameters/compute_fpsc_values").execute(*args, **kwargs)
                    def enable_mesh_interface_clustering(self, *args, **kwargs):
                        """
                        Enable clustering on mesh interfaces?.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/s2s_parameters/enable_mesh_interface_clustering").execute(*args, **kwargs)

                class dtrm_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the DTRM parameters menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def controls(self, *args, **kwargs):
                        """
                        Set DTRM solution controls.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/dtrm_parameters/controls").execute(*args, **kwargs)
                    def make_globs(self, *args, **kwargs):
                        """
                        Make globs (coarser mesh) for radiation.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/dtrm_parameters/make_globs").execute(*args, **kwargs)
                    def ray_trace(self, *args, **kwargs):
                        """
                        Create DTRM rays for radiation.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/dtrm_parameters/ray_trace").execute(*args, **kwargs)
                    def check_ray_file(self, *args, **kwargs):
                        """
                        Read DTRM rays file.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/dtrm_parameters/check_ray_file").execute(*args, **kwargs)

                class solar_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the solar parameters menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def autosave_solar_data(self, *args, **kwargs):
                        """
                        Set autosave solar data parameters.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/solar_parameters/autosave_solar_data").execute(*args, **kwargs)
                    def autoread_solar_data(self, *args, **kwargs):
                        """
                        Set autoread solar data parameters.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/solar_parameters/autoread_solar_data").execute(*args, **kwargs)
                    def sun_direction_vector(self, *args, **kwargs):
                        """
                        Set sun direction vector.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/solar_parameters/sun_direction_vector").execute(*args, **kwargs)
                    def illumination_parameters(self, *args, **kwargs):
                        """
                        Set illumination parameters.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/solar_parameters/illumination_parameters").execute(*args, **kwargs)
                    def iteration_parameters(self, *args, **kwargs):
                        """
                        Set update parameters.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/solar_parameters/iteration_parameters").execute(*args, **kwargs)
                    def quad_tree_parameters(self, *args, **kwargs):
                        """
                        Set quad-tree refinement parameters.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/solar_parameters/quad_tree_parameters").execute(*args, **kwargs)
                    def ground_reflectivity(self, *args, **kwargs):
                        """
                        Set ground reflectivity parameters.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/solar_parameters/ground_reflectivity").execute(*args, **kwargs)
                    def scattering_fraction(self, *args, **kwargs):
                        """
                        Set scattering fraction parameters.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/solar_parameters/scattering_fraction").execute(*args, **kwargs)
                    def sol_on_demand(self, *args, **kwargs):
                        """
                        Enable  solar load on demand.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/solar_parameters/sol_on_demand").execute(*args, **kwargs)
                    def sol_camera_pos(self, *args, **kwargs):
                        """
                        Set camera position based on sun direction vector.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/solar_parameters/sol_camera_pos").execute(*args, **kwargs)
                    def sol_adjacent_fluidcells(self, *args, **kwargs):
                        """
                        Enable solar load for adjacent fluid cells.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/solar_parameters/sol_adjacent_fluidcells").execute(*args, **kwargs)
                    def use_direction_from_sol_calc(self, *args, **kwargs):
                        """
                        Set direction computed from solar calculator.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/solar_parameters/use_direction_from_sol_calc").execute(*args, **kwargs)
                    def solar_thread_control(self, *args, **kwargs):
                        """
                        Solar thread control.
                        """
                        return PyMenu(self.service, "/setup/models/radiation/solar_parameters/solar_thread_control").execute(*args, **kwargs)

            class solver(metaclass=PyMenuMeta):
                """
                Enter the menu to select the solver.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def pressure_based(self, *args, **kwargs):
                    """
                    Enable/disable the segregated solver.
                    """
                    return PyMenu(self.service, "/setup/models/solver/pressure_based").execute(*args, **kwargs)
                def density_based_explicit(self, *args, **kwargs):
                    """
                    Enable/disable the coupled-explicit solver.
                    """
                    return PyMenu(self.service, "/setup/models/solver/density_based_explicit").execute(*args, **kwargs)
                def density_based_implicit(self, *args, **kwargs):
                    """
                    Enable/disable the coupled-implicit solver.
                    """
                    return PyMenu(self.service, "/setup/models/solver/density_based_implicit").execute(*args, **kwargs)
                def adjust_solver_defaults_based_on_setup(self, *args, **kwargs):
                    """
                    Enable/disable adjustment of solver defaults based on setup.
                    """
                    return PyMenu(self.service, "/setup/models/solver/adjust_solver_defaults_based_on_setup").execute(*args, **kwargs)

            class species(metaclass=PyMenuMeta):
                """
                Enter the species models menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.CHEMKIN_CFD_parameters = self.__class__.CHEMKIN_CFD_parameters(path + [("CHEMKIN_CFD_parameters", None)], service)
                def off(self, *args, **kwargs):
                    """
                    Enable/disable solution of species models.
                    """
                    return PyMenu(self.service, "/setup/models/species/off").execute(*args, **kwargs)
                def species_transport(self, *args, **kwargs):
                    """
                    Enable/disable the species transport model.
                    """
                    return PyMenu(self.service, "/setup/models/species/species_transport").execute(*args, **kwargs)
                def non_premixed_combustion(self, *args, **kwargs):
                    """
                    Enable/disable the non-premixed combustion model.
                    """
                    return PyMenu(self.service, "/setup/models/species/non_premixed_combustion").execute(*args, **kwargs)
                def premixed_combustion(self, *args, **kwargs):
                    """
                    Enable/disable the premixed combustion model.
                    """
                    return PyMenu(self.service, "/setup/models/species/premixed_combustion").execute(*args, **kwargs)
                def partially_premixed_combustion(self, *args, **kwargs):
                    """
                    Enable/disable partially premixed combustion model.
                    """
                    return PyMenu(self.service, "/setup/models/species/partially_premixed_combustion").execute(*args, **kwargs)
                def premixed_model(self, *args, **kwargs):
                    """
                    Set premixed combustion model.
                    """
                    return PyMenu(self.service, "/setup/models/species/premixed_model").execute(*args, **kwargs)
                def pdf_transport(self, *args, **kwargs):
                    """
                    Enable/disable the composition PDF transport combustion model.
                    """
                    return PyMenu(self.service, "/setup/models/species/pdf_transport").execute(*args, **kwargs)
                def save_gradients(self, *args, **kwargs):
                    """
                    Enable/disable storage of species mass fraction gradients.
                    """
                    return PyMenu(self.service, "/setup/models/species/save_gradients").execute(*args, **kwargs)
                def liquid_energy_diffusion(self, *args, **kwargs):
                    """
                    Enable/disable energy diffusion for liquid regime.
                    """
                    return PyMenu(self.service, "/setup/models/species/liquid_energy_diffusion").execute(*args, **kwargs)
                def volumetric_reactions(self, *args, **kwargs):
                    """
                    Enable/disable volumetric reactions.
                    """
                    return PyMenu(self.service, "/setup/models/species/volumetric_reactions").execute(*args, **kwargs)
                def species_transport_expert(self, *args, **kwargs):
                    """
                    Set species transport expert options.
                    """
                    return PyMenu(self.service, "/setup/models/species/species_transport_expert").execute(*args, **kwargs)
                def coal_calculator(self, *args, **kwargs):
                    """
                    Set up coal modeling inputs.
                    """
                    return PyMenu(self.service, "/setup/models/species/coal_calculator").execute(*args, **kwargs)
                def mixing_model(self, *args, **kwargs):
                    """
                    Set PDF transport mixing model.
                    """
                    return PyMenu(self.service, "/setup/models/species/mixing_model").execute(*args, **kwargs)
                def stiff_chemistry(self, *args, **kwargs):
                    """
                    Enable/disable stiff chemistry option.
                    """
                    return PyMenu(self.service, "/setup/models/species/stiff_chemistry").execute(*args, **kwargs)
                def liquid_micro_mixing(self, *args, **kwargs):
                    """
                    Enable/disable liquid micro mixing option.
                    """
                    return PyMenu(self.service, "/setup/models/species/liquid_micro_mixing").execute(*args, **kwargs)
                def epdf_energy(self, *args, **kwargs):
                    """
                    Enable/disable EPDF energy  option.
                    """
                    return PyMenu(self.service, "/setup/models/species/epdf_energy").execute(*args, **kwargs)
                def integration_parameters(self, *args, **kwargs):
                    """
                    Set ISAT parameters.
                    """
                    return PyMenu(self.service, "/setup/models/species/integration_parameters").execute(*args, **kwargs)
                def clear_isat_table(self, *args, **kwargs):
                    """
                    Clear the ISAT table.
                    """
                    return PyMenu(self.service, "/setup/models/species/clear_isat_table").execute(*args, **kwargs)
                def pdf_transport_expert(self, *args, **kwargs):
                    """
                    Enable/disable PDF transport expert user.
                    """
                    return PyMenu(self.service, "/setup/models/species/pdf_transport_expert").execute(*args, **kwargs)
                def set_turb_chem_interaction(self, *args, **kwargs):
                    """
                    Set Eddy-Dissipation Concept model constants.
                    """
                    return PyMenu(self.service, "/setup/models/species/set_turb_chem_interaction").execute(*args, **kwargs)
                def spark_model(self, *args, **kwargs):
                    """
                    Set spark model parameters.
                    """
                    return PyMenu(self.service, "/setup/models/species/spark_model").execute(*args, **kwargs)
                def ignition_model(self, *args, **kwargs):
                    """
                    Enable/disable the ignition model.
                    """
                    return PyMenu(self.service, "/setup/models/species/ignition_model").execute(*args, **kwargs)
                def ignition_model_controls(self, *args, **kwargs):
                    """
                    Set ignition model parameters.
                    """
                    return PyMenu(self.service, "/setup/models/species/ignition_model_controls").execute(*args, **kwargs)
                def inert_transport_model(self, *args, **kwargs):
                    """
                    Enable/disable the inert transport model.
                    """
                    return PyMenu(self.service, "/setup/models/species/inert_transport_model").execute(*args, **kwargs)
                def inert_transport_controls(self, *args, **kwargs):
                    """
                    Set inert transport model parameters.
                    """
                    return PyMenu(self.service, "/setup/models/species/inert_transport_controls").execute(*args, **kwargs)
                def particle_surface_reactions(self, *args, **kwargs):
                    """
                    Enable/disable particle surface reactions.
                    """
                    return PyMenu(self.service, "/setup/models/species/particle_surface_reactions").execute(*args, **kwargs)
                def wall_surface_reactions(self, *args, **kwargs):
                    """
                    Enable/disable wall surface reactions.
                    """
                    return PyMenu(self.service, "/setup/models/species/wall_surface_reactions").execute(*args, **kwargs)
                def heat_of_surface_reactions(self, *args, **kwargs):
                    """
                    Enable/disable heat of surface reactions.
                    """
                    return PyMenu(self.service, "/setup/models/species/heat_of_surface_reactions").execute(*args, **kwargs)
                def mass_deposition_source(self, *args, **kwargs):
                    """
                    Enable/disable mass deposition source due to surface reactions.
                    """
                    return PyMenu(self.service, "/setup/models/species/mass_deposition_source").execute(*args, **kwargs)
                def electro_chemical_surface_reactions(self, *args, **kwargs):
                    """
                    Enable/disable electrochemical surface reactions.
                    """
                    return PyMenu(self.service, "/setup/models/species/electro_chemical_surface_reactions").execute(*args, **kwargs)
                def species_migration(self, *args, **kwargs):
                    """
                    Enable/disable ion species migration in electric field.
                    """
                    return PyMenu(self.service, "/setup/models/species/species_migration").execute(*args, **kwargs)
                def reaction_diffusion_balance(self, *args, **kwargs):
                    """
                    Enable/disable reaction diffusion balance at reacting surface for surface reactions.
                    """
                    return PyMenu(self.service, "/setup/models/species/reaction_diffusion_balance").execute(*args, **kwargs)
                def surf_reaction_aggressiveness_factor(self, *args, **kwargs):
                    """
                    Set the surface reaction aggressiveness factor.
                    """
                    return PyMenu(self.service, "/setup/models/species/surf_reaction_aggressiveness_factor").execute(*args, **kwargs)
                def surf_reaction_netm_params(self, *args, **kwargs):
                    """
                    Set the surface reaction parameters for the Non-Equilibrium Thermal Model.
                    """
                    return PyMenu(self.service, "/setup/models/species/surf_reaction_netm_params").execute(*args, **kwargs)
                def inlet_diffusion(self, *args, **kwargs):
                    """
                    Enable/disable inclusion of diffusion at inlets.
                    """
                    return PyMenu(self.service, "/setup/models/species/inlet_diffusion").execute(*args, **kwargs)
                def diffusion_energy_source(self, *args, **kwargs):
                    """
                    Enable/disable diffusion energy source.
                    """
                    return PyMenu(self.service, "/setup/models/species/diffusion_energy_source").execute(*args, **kwargs)
                def multicomponent_diffusion(self, *args, **kwargs):
                    """
                    Enable/disable multicomponent diffusion.
                    """
                    return PyMenu(self.service, "/setup/models/species/multicomponent_diffusion").execute(*args, **kwargs)
                def thermal_diffusion(self, *args, **kwargs):
                    """
                    Enable/disable thermal diffusion.
                    """
                    return PyMenu(self.service, "/setup/models/species/thermal_diffusion").execute(*args, **kwargs)
                def CHEMKIN_CFD(self, *args, **kwargs):
                    """
                    Enable/disable CHEMKIN-CFD.
                    """
                    return PyMenu(self.service, "/setup/models/species/CHEMKIN_CFD").execute(*args, **kwargs)
                def non_premixed_combustion_parameters(self, *args, **kwargs):
                    """
                    Set PDF parameters.
                    """
                    return PyMenu(self.service, "/setup/models/species/non_premixed_combustion_parameters").execute(*args, **kwargs)
                def partially_premixed_combustion_parameters(self, *args, **kwargs):
                    """
                    Set PDF parameters.
                    """
                    return PyMenu(self.service, "/setup/models/species/partially_premixed_combustion_parameters").execute(*args, **kwargs)
                def partially_premixed_properties(self, *args, **kwargs):
                    """
                    Set/Change partially premixed mixture properties.
                    """
                    return PyMenu(self.service, "/setup/models/species/partially_premixed_properties").execute(*args, **kwargs)
                def re_calc_par_premix_props(self, *args, **kwargs):
                    """
                    Re-calculate partially-premixed properties.
                    """
                    return PyMenu(self.service, "/setup/models/species/re_calc_par_premix_props").execute(*args, **kwargs)
                def full_tabulation(self, *args, **kwargs):
                    """
                    Enable/disable building of a full 2 mixture fraction table.
                    """
                    return PyMenu(self.service, "/setup/models/species/full_tabulation").execute(*args, **kwargs)
                def init_unsteady_flamelet_prob(self, *args, **kwargs):
                    """
                    Initialize Unsteady Flamelet Probability.
                    """
                    return PyMenu(self.service, "/setup/models/species/init_unsteady_flamelet_prob").execute(*args, **kwargs)
                def import_flamelet_for_restart(self, *args, **kwargs):
                    """
                    Import Flamelet File for Restart.
                    """
                    return PyMenu(self.service, "/setup/models/species/import_flamelet_for_restart").execute(*args, **kwargs)
                def non_premixed_combustion_expert(self, *args, **kwargs):
                    """
                    Set PDF expert parameters.
                    """
                    return PyMenu(self.service, "/setup/models/species/non_premixed_combustion_expert").execute(*args, **kwargs)
                def partially_premixed_combustion_expert(self, *args, **kwargs):
                    """
                    Set PDF expert parameters.
                    """
                    return PyMenu(self.service, "/setup/models/species/partially_premixed_combustion_expert").execute(*args, **kwargs)
                def partially_premixed_combustion_grids(self, *args, **kwargs):
                    """
                    Set user specified grid parameters for PDF and flamelet.
                    """
                    return PyMenu(self.service, "/setup/models/species/partially_premixed_combustion_grids").execute(*args, **kwargs)
                def flamelet_expert(self, *args, **kwargs):
                    """
                    Set flamelet expert parameters.
                    """
                    return PyMenu(self.service, "/setup/models/species/flamelet_expert").execute(*args, **kwargs)
                def combustion_expert(self, *args, **kwargs):
                    """
                    Set combustion expert parameters.
                    """
                    return PyMenu(self.service, "/setup/models/species/combustion_expert").execute(*args, **kwargs)
                def set_premixed_combustion(self, *args, **kwargs):
                    """
                    Set premixed combustion parameters.
                    """
                    return PyMenu(self.service, "/setup/models/species/set_premixed_combustion").execute(*args, **kwargs)
                def set_multi_regime_fgm(self, *args, **kwargs):
                    """
                    Set-multi-regim-fgm-parameters.
                    """
                    return PyMenu(self.service, "/setup/models/species/set_multi_regime_fgm").execute(*args, **kwargs)
                def relax_to_equil(self, *args, **kwargs):
                    """
                    Enable/disable the Relaxation to Chemical Equilibrium model.
                    """
                    return PyMenu(self.service, "/setup/models/species/relax_to_equil").execute(*args, **kwargs)
                def thickened_flame_model(self, *args, **kwargs):
                    """
                    Enable/disable the Relaxation to Chemical Equilibrium model.
                    """
                    return PyMenu(self.service, "/setup/models/species/thickened_flame_model").execute(*args, **kwargs)
                def decoupled_detailed_chemistry(self, *args, **kwargs):
                    """
                    Enable/disable the Decoupled Detailed Chemistry model.
                    """
                    return PyMenu(self.service, "/setup/models/species/decoupled_detailed_chemistry").execute(*args, **kwargs)
                def reactor_network_model(self, *args, **kwargs):
                    """
                    Enable/disable the Reactor Network model.
                    """
                    return PyMenu(self.service, "/setup/models/species/reactor_network_model").execute(*args, **kwargs)
                def reacting_channel_model(self, *args, **kwargs):
                    """
                    Enable/Disable the Reacting Channel Model.
                    """
                    return PyMenu(self.service, "/setup/models/species/reacting_channel_model").execute(*args, **kwargs)
                def reacting_channel_model_options(self, *args, **kwargs):
                    """
                    Set Reacting Channel Model parameters.
                    """
                    return PyMenu(self.service, "/setup/models/species/reacting_channel_model_options").execute(*args, **kwargs)
                def combustion_numerics(self, *args, **kwargs):
                    """
                    Set combustion numerics options.
                    """
                    return PyMenu(self.service, "/setup/models/species/combustion_numerics").execute(*args, **kwargs)

                class CHEMKIN_CFD_parameters(metaclass=PyMenuMeta):
                    """
                    Enter the expert CHEMKIN-CFD parameters menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def basic_options(self, *args, **kwargs):
                        """
                        Set basic parameter options.
                        """
                        return PyMenu(self.service, "/setup/models/species/CHEMKIN_CFD_parameters/basic_options").execute(*args, **kwargs)
                    def advanced_options(self, *args, **kwargs):
                        """
                        Set advanced parameter options.
                        """
                        return PyMenu(self.service, "/setup/models/species/CHEMKIN_CFD_parameters/advanced_options").execute(*args, **kwargs)
                    def add_cell_monitor(self, *args, **kwargs):
                        """
                        Add a monitor cell for debug output.
                        """
                        return PyMenu(self.service, "/setup/models/species/CHEMKIN_CFD_parameters/add_cell_monitor").execute(*args, **kwargs)
                    def list_cell_monitors(self, *args, **kwargs):
                        """
                        List cell monitors.
                        """
                        return PyMenu(self.service, "/setup/models/species/CHEMKIN_CFD_parameters/list_cell_monitors").execute(*args, **kwargs)
                    def delete_cell_monitors(self, *args, **kwargs):
                        """
                        Delete cell monitors.
                        """
                        return PyMenu(self.service, "/setup/models/species/CHEMKIN_CFD_parameters/delete_cell_monitors").execute(*args, **kwargs)

            class viscous(metaclass=PyMenuMeta):
                """
                Enter the viscous model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.near_wall_treatment = self.__class__.near_wall_treatment(path + [("near_wall_treatment", None)], service)
                    self.multiphase_turbulence = self.__class__.multiphase_turbulence(path + [("multiphase_turbulence", None)], service)
                    self.turbulence_expert = self.__class__.turbulence_expert(path + [("turbulence_expert", None)], service)
                    self.geko_options = self.__class__.geko_options(path + [("geko_options", None)], service)
                    self.transition_model_options = self.__class__.transition_model_options(path + [("transition_model_options", None)], service)
                def inviscid(self, *args, **kwargs):
                    """
                    Enable/disable the inviscid flow model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/inviscid").execute(*args, **kwargs)
                def laminar(self, *args, **kwargs):
                    """
                    Enable/disable the laminar flow model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/laminar").execute(*args, **kwargs)
                def low_pressure_boundary_slip(self, *args, **kwargs):
                    """
                    Enable/disable the slip boundary formulation for low-pressure gas systems.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/low_pressure_boundary_slip").execute(*args, **kwargs)
                def mixing_length(self, *args, **kwargs):
                    """
                    Enable/disable the mixing-length (algebraic) turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/mixing_length").execute(*args, **kwargs)
                def zero_equation_hvac(self, *args, **kwargs):
                    """
                    Enable/disable the zero-equation HVAC turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/zero_equation_hvac").execute(*args, **kwargs)
                def spalart_allmaras(self, *args, **kwargs):
                    """
                    Enable/disable the Spalart-Allmaras turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/spalart_allmaras").execute(*args, **kwargs)
                def ke1e(self, *args, **kwargs):
                    """
                    Enable/disable the KE1E turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/ke1e").execute(*args, **kwargs)
                def sa_enhanced_wall_treatment(self, *args, **kwargs):
                    """
                    Enable/disable the enhanced wall treatment for the Spalart-Allmaras model.
                    If disabled, no smooth blending between the viscous sublayer and the
                    log-law formulation is employed, as was done in versions previous to Fluent14.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/sa_enhanced_wall_treatment").execute(*args, **kwargs)
                def sa_alternate_prod(self, *args, **kwargs):
                    """
                    Enable/disable strain/vorticity production in Spalart-Allmaras model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/sa_alternate_prod").execute(*args, **kwargs)
                def sa_damping(self, *args, **kwargs):
                    """
                    Enable/disable the full low-Reynolds number form of Spalart-Allmaras model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/sa_damping").execute(*args, **kwargs)
                def ke_standard(self, *args, **kwargs):
                    """
                    Enable/disable the standard k-epsilon turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/ke_standard").execute(*args, **kwargs)
                def ke_easm(self, *args, **kwargs):
                    """
                    Enable/disable the EASM k-epsilon turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/ke_easm").execute(*args, **kwargs)
                def ke_realizable(self, *args, **kwargs):
                    """
                    Enable/disable the realizable k-epsilon turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/ke_realizable").execute(*args, **kwargs)
                def ke_rng(self, *args, **kwargs):
                    """
                    Enable/disable the RNG k-epsilon turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/ke_rng").execute(*args, **kwargs)
                def rng_differential_visc(self, *args, **kwargs):
                    """
                    Enable/disable the differential-viscosity model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/rng_differential_visc").execute(*args, **kwargs)
                def rng_swirl_model(self, *args, **kwargs):
                    """
                    Enable/disable swirl corrections for rng-model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/rng_swirl_model").execute(*args, **kwargs)
                def kw_standard(self, *args, **kwargs):
                    """
                    Enable/disable the standard k-omega turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/kw_standard").execute(*args, **kwargs)
                def kw_easm(self, *args, **kwargs):
                    """
                    Enable/disable the EASM k-omega turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/kw_easm").execute(*args, **kwargs)
                def kw_bsl(self, *args, **kwargs):
                    """
                    Enable/disable the BSL k-omega turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/kw_bsl").execute(*args, **kwargs)
                def kw_geko(self, *args, **kwargs):
                    """
                    Enable/disable the GEKO turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/kw_geko").execute(*args, **kwargs)
                def kw_sst(self, *args, **kwargs):
                    """
                    Enable/disable the SST k-omega turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/kw_sst").execute(*args, **kwargs)
                def kw_wj_bsl_earsm(self, *args, **kwargs):
                    """
                    Enable/disable the EASM k-omega turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/kw_wj_bsl_earsm").execute(*args, **kwargs)
                def kw_low_re_correction(self, *args, **kwargs):
                    """
                    Enable/disable the k-omega low Re option.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/kw_low_re_correction").execute(*args, **kwargs)
                def kw_shear_correction(self, *args, **kwargs):
                    """
                    Enable/disable the k-omega shear-flow correction option.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/kw_shear_correction").execute(*args, **kwargs)
                def turb_compressibility(self, *args, **kwargs):
                    """
                    Enable/disable the compressibility correction option.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/turb_compressibility").execute(*args, **kwargs)
                def k_kl_w(self, *args, **kwargs):
                    """
                    Enable/disable the k-kl-omega turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/k_kl_w").execute(*args, **kwargs)
                def transition_sst(self, *args, **kwargs):
                    """
                    Enable/disable the transition SST turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/transition_sst").execute(*args, **kwargs)
                def v2f(self, *args, **kwargs):
                    """
                    Enable/disable the V2F turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/v2f").execute(*args, **kwargs)
                def reynolds_stress_model(self, *args, **kwargs):
                    """
                    Enable/disable the RSM turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/reynolds_stress_model").execute(*args, **kwargs)
                def rsm_solve_tke(self, *args, **kwargs):
                    """
                    Enable/disable the solution of T.K.E. in RSM model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/rsm_solve_tke").execute(*args, **kwargs)
                def rsm_wall_echo(self, *args, **kwargs):
                    """
                    Enable/disable wall-echo effects in RSM model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/rsm_wall_echo").execute(*args, **kwargs)
                def rsm_linear_pressure_strain(self, *args, **kwargs):
                    """
                    Enable/disable the linear pressure-strain model in RSM.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/rsm_linear_pressure_strain").execute(*args, **kwargs)
                def rsm_ssg_pressure_strain(self, *args, **kwargs):
                    """
                    Enable/disable the quadratic pressure-strain model in RSM.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/rsm_ssg_pressure_strain").execute(*args, **kwargs)
                def rsm_omega_based(self, *args, **kwargs):
                    """
                    Enable/disable the Stress-omega model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/rsm_omega_based").execute(*args, **kwargs)
                def rsm_bsl_based(self, *args, **kwargs):
                    """
                    Enable/disable the Stress-BSL model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/rsm_bsl_based").execute(*args, **kwargs)
                def sas(self, *args, **kwargs):
                    """
                    Enable/disable the SAS turbulence model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/sas").execute(*args, **kwargs)
                def detached_eddy_simulation(self, *args, **kwargs):
                    """
                    Enable/disable detached eddy simulation.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/detached_eddy_simulation").execute(*args, **kwargs)
                def des_limiter_option(self, *args, **kwargs):
                    """
                    Select DES limiter option.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/des_limiter_option").execute(*args, **kwargs)
                def large_eddy_simulation(self, *args, **kwargs):
                    """
                    Enable/disable large eddy simulation.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/large_eddy_simulation").execute(*args, **kwargs)
                def les_subgrid_smagorinsky(self, *args, **kwargs):
                    """
                    Enable/disable the Smagorinsky-Lilly subgrid-scale model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/les_subgrid_smagorinsky").execute(*args, **kwargs)
                def les_dynamic_energy_flux(self, *args, **kwargs):
                    """
                    Enable/disable the dynamic sub-grid scale turbulent Prandtl Number.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/les_dynamic_energy_flux").execute(*args, **kwargs)
                def les_dynamic_scalar_flux(self, *args, **kwargs):
                    """
                    Enable/disable the dynamic sub-grid scale turbulent Schmidt Number.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/les_dynamic_scalar_flux").execute(*args, **kwargs)
                def les_subgrid_dynamic_fvar(self, *args, **kwargs):
                    """
                    Enable/disable the dynamic subgrid-scale mixture fraction variance model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/les_subgrid_dynamic_fvar").execute(*args, **kwargs)
                def les_subgrid_rng(self, *args, **kwargs):
                    """
                    Enable/disable the RNG subgrid-scale model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/les_subgrid_rng").execute(*args, **kwargs)
                def les_subgrid_wale(self, *args, **kwargs):
                    """
                    Enable/disable the WALE subgrid-scale model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/les_subgrid_wale").execute(*args, **kwargs)
                def les_subgrid_wmles(self, *args, **kwargs):
                    """
                    Enable/disable the WMLES subgrid-scale model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/les_subgrid_wmles").execute(*args, **kwargs)
                def les_subgrid_wmles_s_minus_omega(self, *args, **kwargs):
                    """
                    Enable/disable the WMLES S-Omega subgrid-scale model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/les_subgrid_wmles_s_minus_omega").execute(*args, **kwargs)
                def les_subgrid_tke(self, *args, **kwargs):
                    """
                    Enable/disable the kinetic energy transport subgrid-scale model.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/les_subgrid_tke").execute(*args, **kwargs)
                def turb_buoyancy_effects(self, *args, **kwargs):
                    """
                    Select buoyancy effects on turbulence.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/turb_buoyancy_effects").execute(*args, **kwargs)
                def curvature_correction(self, *args, **kwargs):
                    """
                    Enable/disable the curvature correction.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/curvature_correction").execute(*args, **kwargs)
                def curvature_correction_ccurv(self, *args, **kwargs):
                    """
                    Set the curvature correction coefficient CCURV.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/curvature_correction_ccurv").execute(*args, **kwargs)
                def corner_flow_correction(self, *args, **kwargs):
                    """
                    Enable/disable the corner flow correction.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/corner_flow_correction").execute(*args, **kwargs)
                def corner_flow_correction_ccorner(self, *args, **kwargs):
                    """
                    Set the corner flow correction coefficient CCORNER.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/corner_flow_correction_ccorner").execute(*args, **kwargs)
                def rsm_or_earsm_geko_option(self, *args, **kwargs):
                    """
                    Enable/disable the GEKO option for RSM or EARSM.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/rsm_or_earsm_geko_option").execute(*args, **kwargs)
                def add_transition_model(self, *args, **kwargs):
                    """
                    Enable/disable a transition model to account for transitional effects.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/add_transition_model").execute(*args, **kwargs)
                def user_defined(self, *args, **kwargs):
                    """
                    Select user-defined functions to define the turbulent viscosity and the turbulent Prandtl and Schmidt numbers.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/user_defined").execute(*args, **kwargs)
                def user_defined_transition(self, *args, **kwargs):
                    """
                    Set user-defined transition correlations.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/user_defined_transition").execute(*args, **kwargs)
                def trans_sst_roughness_correlation(self, *args, **kwargs):
                    """
                    Enable/disable the Transition-SST roughness correlation option.
                    """
                    return PyMenu(self.service, "/setup/models/viscous/trans_sst_roughness_correlation").execute(*args, **kwargs)

                class near_wall_treatment(metaclass=PyMenuMeta):
                    """
                    Enter the near wall treatment menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def non_equilibrium_wall_fn(self, *args, **kwargs):
                        """
                        Enable/disable non-equilibrium wall functions.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/near_wall_treatment/non_equilibrium_wall_fn").execute(*args, **kwargs)
                    def enhanced_wall_treatment(self, *args, **kwargs):
                        """
                        Enable/disable enhanced wall functions.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/near_wall_treatment/enhanced_wall_treatment").execute(*args, **kwargs)
                    def menter_lechner(self, *args, **kwargs):
                        """
                        Enable/disable near wall treatment Menter-Lechner.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/near_wall_treatment/menter_lechner").execute(*args, **kwargs)
                    def scalable_wall_functions(self, *args, **kwargs):
                        """
                        Enable/disable scalable wall functions.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/near_wall_treatment/scalable_wall_functions").execute(*args, **kwargs)
                    def user_defined_wall_functions(self, *args, **kwargs):
                        """
                        Enable user defined wall functions.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/near_wall_treatment/user_defined_wall_functions").execute(*args, **kwargs)
                    def werner_wengle_wall_fn(self, *args, **kwargs):
                        """
                        Enable/disable Werner-Wengle wall functions.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/near_wall_treatment/werner_wengle_wall_fn").execute(*args, **kwargs)
                    def wf_pressure_gradient_effects(self, *args, **kwargs):
                        """
                        Enable/disable wall function pressure-gradient effects.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/near_wall_treatment/wf_pressure_gradient_effects").execute(*args, **kwargs)
                    def wf_thermal_effects(self, *args, **kwargs):
                        """
                        Enable/disable wall function thermal effects.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/near_wall_treatment/wf_thermal_effects").execute(*args, **kwargs)

                class multiphase_turbulence(metaclass=PyMenuMeta):
                    """
                    Enter the multiphase turbulence menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def multiphase_options(self, *args, **kwargs):
                        """
                        Enable/disable multiphase options.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/multiphase_turbulence/multiphase_options").execute(*args, **kwargs)
                    def turbulence_multiphase_models(self, *args, **kwargs):
                        """
                        Select the k-epsilon multiphase model.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/multiphase_turbulence/turbulence_multiphase_models").execute(*args, **kwargs)
                    def rsm_multiphase_models(self, *args, **kwargs):
                        """
                        Enable/disable the Reynolds Stress multiphase model.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/multiphase_turbulence/rsm_multiphase_models").execute(*args, **kwargs)
                    def subgrid_turbulence_contribution_aiad(self, *args, **kwargs):
                        """
                        Enable/disable the Subgrid Turbulence Contribution for the AIAD model.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/multiphase_turbulence/subgrid_turbulence_contribution_aiad").execute(*args, **kwargs)

                class turbulence_expert(metaclass=PyMenuMeta):
                    """
                    Enter the turbulence expert menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def low_re_ke(self, *args, **kwargs):
                        """
                        Enable/disable the low-Re k-epsilon turbulence model.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/low_re_ke").execute(*args, **kwargs)
                    def low_re_ke_index(self, *args, **kwargs):
                        """
                        Enable/disable the low-Re k-epsilon model version.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/low_re_ke_index").execute(*args, **kwargs)
                    def kato_launder_model(self, *args, **kwargs):
                        """
                        Enable/disable Kato-Launder modification for production.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/kato_launder_model").execute(*args, **kwargs)
                    def production_limiter(self, *args, **kwargs):
                        """
                        Enable/disable the Production Limiter.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/production_limiter").execute(*args, **kwargs)
                    def kw_vorticity_based_production(self, *args, **kwargs):
                        """
                        Enable/disable vorticity based production.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/kw_vorticity_based_production").execute(*args, **kwargs)
                    def kw_add_sas(self, *args, **kwargs):
                        """
                        Enable/disable the SAS-mode with the current turbulence model.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/kw_add_sas").execute(*args, **kwargs)
                    def kw_add_des(self, *args, **kwargs):
                        """
                        Enable/disable DES-mode with the current turbulence model.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/kw_add_des").execute(*args, **kwargs)
                    def turb_add_sbes_sdes(self, *args, **kwargs):
                        """
                        Enable/disable SBES / SDES with the current turbulence model.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/turb_add_sbes_sdes").execute(*args, **kwargs)
                    def sbes_sdes_hybrid_model(self, *args, **kwargs):
                        """
                        Select the SBES / SDES hybrid model.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/sbes_sdes_hybrid_model").execute(*args, **kwargs)
                    def sbes_update_interval_k_omega(self, *args, **kwargs):
                        """
                        Set an integer value how often the k and omega equations are updated in a transient SBES run.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/sbes_update_interval_k_omega").execute(*args, **kwargs)
                    def sbes_sgs_option(self, *args, **kwargs):
                        """
                        Select SBES subgrid-scale model.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/sbes_sgs_option").execute(*args, **kwargs)
                    def sbes_les_subgrid_dynamic_fvar(self, *args, **kwargs):
                        """
                        Enable/disable the dynamic subgrid-scale mixture fraction variance model.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/sbes_les_subgrid_dynamic_fvar").execute(*args, **kwargs)
                    def turbulence_damping(self, *args, **kwargs):
                        """
                        Enable/disable turbulence damping and set turbulence damping parameters.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/turbulence_damping").execute(*args, **kwargs)
                    def rke_cmu_rotation_term(self, *args, **kwargs):
                        """
                        Enable/disable inclusion of omega in the Cmu definition.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/rke_cmu_rotation_term").execute(*args, **kwargs)
                    def turb_non_newtonian(self, *args, **kwargs):
                        """
                        Enable/disable turbulence for non-Newtonian fluids.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/turb_non_newtonian").execute(*args, **kwargs)
                    def non_newtonian_modification(self, *args, **kwargs):
                        """
                        Enable/disable non-Newtonian modification for Lam-Bremhorst model.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/non_newtonian_modification").execute(*args, **kwargs)
                    def turb_pk_compressible(self, *args, **kwargs):
                        """
                        Enable/disable turbulent production due to compressible divergence.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/turb_pk_compressible").execute(*args, **kwargs)
                    def thermal_p_function(self, *args, **kwargs):
                        """
                        Enable/disable the Jayatilleke P function.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/thermal_p_function").execute(*args, **kwargs)
                    def restore_sst_v61(self, *args, **kwargs):
                        """
                        Enable/disable SST formulation of v6.1.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/restore_sst_v61").execute(*args, **kwargs)
                    def stg_set_ti_and_tvr_limiters(self, *args, **kwargs):
                        """
                        
                        Specify minimum Turbulence Intensity (TI) and Turbulent Viscosity Ratio (TVR)
                        to search STG scales only at inlet areas where TVR > TVR_min and TI > TI_min.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/turbulence_expert/stg_set_ti_and_tvr_limiters").execute(*args, **kwargs)

                class geko_options(metaclass=PyMenuMeta):
                    """
                    Enter the GEKO options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def wall_distance_free(self, *args, **kwargs):
                        """
                        Enable/disable wall-distance-free version of GEKO model.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/geko_options/wall_distance_free").execute(*args, **kwargs)
                    def csep(self, *args, **kwargs):
                        """
                        Set the GEKO model coefficient CSEP.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/geko_options/csep").execute(*args, **kwargs)
                    def cnw(self, *args, **kwargs):
                        """
                        Set the GEKO model coefficient CNW.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/geko_options/cnw").execute(*args, **kwargs)
                    def cmix(self, *args, **kwargs):
                        """
                        Set the GEKO model coefficient CMIX.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/geko_options/cmix").execute(*args, **kwargs)
                    def cjet(self, *args, **kwargs):
                        """
                        Set the GEKO model coefficient CJET.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/geko_options/cjet").execute(*args, **kwargs)
                    def blending_function(self, *args, **kwargs):
                        """
                        Set the GEKO model blending function.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/geko_options/blending_function").execute(*args, **kwargs)
                    def creal(self, *args, **kwargs):
                        """
                        Set the GEKO model coefficient CREAL.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/geko_options/creal").execute(*args, **kwargs)
                    def cnw_sub(self, *args, **kwargs):
                        """
                        Set the GEKO model coefficient CNW_SUB.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/geko_options/cnw_sub").execute(*args, **kwargs)
                    def cjet_aux(self, *args, **kwargs):
                        """
                        Set the GEKO model coefficient CJET_AUX.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/geko_options/cjet_aux").execute(*args, **kwargs)
                    def cbf_lam(self, *args, **kwargs):
                        """
                        Set the GEKO model coefficient CBF_LAM.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/geko_options/cbf_lam").execute(*args, **kwargs)
                    def cbf_tur(self, *args, **kwargs):
                        """
                        Set the GEKO model coefficient CBF_TUR.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/geko_options/cbf_tur").execute(*args, **kwargs)
                    def geko_defaults(self, *args, **kwargs):
                        """
                        Set GEKO options to default.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/geko_options/geko_defaults").execute(*args, **kwargs)

                class transition_model_options(metaclass=PyMenuMeta):
                    """
                    Enter the transition model options menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def crossflow_transition(self, *args, **kwargs):
                        """
                        Enable/disable crossflow transition for the intermittency transition model.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/transition_model_options/crossflow_transition").execute(*args, **kwargs)
                    def critical_reynolds_number_correlation(self, *args, **kwargs):
                        """
                        Set the critical Reynolds number correlation.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/transition_model_options/critical_reynolds_number_correlation").execute(*args, **kwargs)
                    def clambda_scale(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient CLAMBDA_SCALE.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/transition_model_options/clambda_scale").execute(*args, **kwargs)
                    def capg_hightu(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient CAPG_HIGHTU.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/transition_model_options/capg_hightu").execute(*args, **kwargs)
                    def cfpg_hightu(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient CFPG_HIGHTU.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/transition_model_options/cfpg_hightu").execute(*args, **kwargs)
                    def capg_lowtu(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient CAPG_LOWTU.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/transition_model_options/capg_lowtu").execute(*args, **kwargs)
                    def cfpg_lowtu(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient CFPG_LOWTU.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/transition_model_options/cfpg_lowtu").execute(*args, **kwargs)
                    def ctu_hightu(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient CTU_HIGHTU.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/transition_model_options/ctu_hightu").execute(*args, **kwargs)
                    def ctu_lowtu(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient CTU_LOWTU.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/transition_model_options/ctu_lowtu").execute(*args, **kwargs)
                    def rec_max(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient REC_MAX.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/transition_model_options/rec_max").execute(*args, **kwargs)
                    def rec_c1(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient REC_C1.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/transition_model_options/rec_c1").execute(*args, **kwargs)
                    def rec_c2(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient REC_C2.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/transition_model_options/rec_c2").execute(*args, **kwargs)
                    def cbubble_c1(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient CBUBBLE_C1.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/transition_model_options/cbubble_c1").execute(*args, **kwargs)
                    def cbubble_c2(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient CBUBBLE_C2.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/transition_model_options/cbubble_c2").execute(*args, **kwargs)
                    def rv1_switch(self, *args, **kwargs):
                        """
                        Set the algebraic transition model coefficient RV1_SWITCH.
                        """
                        return PyMenu(self.service, "/setup/models/viscous/transition_model_options/rv1_switch").execute(*args, **kwargs)

            class structure(metaclass=PyMenuMeta):
                """
                Enter the structure model menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.controls = self.__class__.controls(path + [("controls", None)], service)
                    self.expert = self.__class__.expert(path + [("expert", None)], service)
                def structure_off(self, *args, **kwargs):
                    """
                    Disable the structural model.
                    """
                    return PyMenu(self.service, "/setup/models/structure/structure_off").execute(*args, **kwargs)
                def linear_elasticity(self, *args, **kwargs):
                    """
                    Enable the linear elasticity model.
                    """
                    return PyMenu(self.service, "/setup/models/structure/linear_elasticity").execute(*args, **kwargs)
                def nonlinear_elasticity(self, *args, **kwargs):
                    """
                    Enable the nonlinear elasticity model.
                    """
                    return PyMenu(self.service, "/setup/models/structure/nonlinear_elasticity").execute(*args, **kwargs)
                def thermal_effects(self, *args, **kwargs):
                    """
                    Enable structure thermal effects.
                    """
                    return PyMenu(self.service, "/setup/models/structure/thermal_effects").execute(*args, **kwargs)

                class controls(metaclass=PyMenuMeta):
                    """
                    Enter the structure controls menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def numerical_damping_factor(self, *args, **kwargs):
                        """
                        Set structure damping parameters.
                        """
                        return PyMenu(self.service, "/setup/models/structure/controls/numerical_damping_factor").execute(*args, **kwargs)
                    def enhanced_strain(self, *args, **kwargs):
                        """
                        Enable enhanced strain element.
                        """
                        return PyMenu(self.service, "/setup/models/structure/controls/enhanced_strain").execute(*args, **kwargs)
                    def unsteady_damping_rayleigh(self, *args, **kwargs):
                        """
                        Enable/disable Newmark unsteady solution model.
                        """
                        return PyMenu(self.service, "/setup/models/structure/controls/unsteady_damping_rayleigh").execute(*args, **kwargs)
                    def amg_stabilization(self, *args, **kwargs):
                        """
                        Set the AMG stabilization method for structural solver.
                        """
                        return PyMenu(self.service, "/setup/models/structure/controls/amg_stabilization").execute(*args, **kwargs)
                    def max_iter(self, *args, **kwargs):
                        """
                        Set the maximum number of iterations for structural solver.
                        """
                        return PyMenu(self.service, "/setup/models/structure/controls/max_iter").execute(*args, **kwargs)

                class expert(metaclass=PyMenuMeta):
                    """
                    Enter the structure expert menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def include_pop_in_fsi_force(self, *args, **kwargs):
                        """
                        Enable inclusion of operating p into fsi force.
                        """
                        return PyMenu(self.service, "/setup/models/structure/expert/include_pop_in_fsi_force").execute(*args, **kwargs)
                    def steady_2way_fsi(self, *args, **kwargs):
                        """
                        Enable steady 2-way fsi workflow.
                        """
                        return PyMenu(self.service, "/setup/models/structure/expert/steady_2way_fsi").execute(*args, **kwargs)
                    def include_viscous_fsi_force(self, *args, **kwargs):
                        """
                        Enable inclusion of viscous fsi force.
                        """
                        return PyMenu(self.service, "/setup/models/structure/expert/include_viscous_fsi_force").execute(*args, **kwargs)
                    def explicit_fsi_force(self, *args, **kwargs):
                        """
                        Enable explicit fsi force.
                        """
                        return PyMenu(self.service, "/setup/models/structure/expert/explicit_fsi_force").execute(*args, **kwargs)

            class heat_exchanger(metaclass=PyMenuMeta):
                """
                Enter the heat exchanger menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.macro_model = self.__class__.macro_model(path + [("macro_model", None)], service)
                    self.dual_cell_model = self.__class__.dual_cell_model(path + [("dual_cell_model", None)], service)

                class macro_model(metaclass=PyMenuMeta):
                    """
                    Enter the heat macro-model menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def heat_exchanger(self, *args, **kwargs):
                        """
                        Enable/disable heat-exchanger model.
                        """
                        return PyMenu(self.service, "/setup/models/heat_exchanger/macro_model/heat_exchanger").execute(*args, **kwargs)
                    def heat_exchanger_model(self, *args, **kwargs):
                        """
                        Define heat-exchanger core model.
                        """
                        return PyMenu(self.service, "/setup/models/heat_exchanger/macro_model/heat_exchanger_model").execute(*args, **kwargs)
                    def heat_exchanger_zone(self, *args, **kwargs):
                        """
                        Define heat-exchanger zone.
                        """
                        return PyMenu(self.service, "/setup/models/heat_exchanger/macro_model/heat_exchanger_zone").execute(*args, **kwargs)
                    def heat_exchanger_group(self, *args, **kwargs):
                        """
                        Define heat-exchanger group.
                        """
                        return PyMenu(self.service, "/setup/models/heat_exchanger/macro_model/heat_exchanger_group").execute(*args, **kwargs)
                    def delete_heat_exchanger_group(self, *args, **kwargs):
                        """
                        Delete heat-exchanger group.
                        """
                        return PyMenu(self.service, "/setup/models/heat_exchanger/macro_model/delete_heat_exchanger_group").execute(*args, **kwargs)
                    def heat_exchanger_report(self, *args, **kwargs):
                        """
                        Report heat-exchanger information.
                        """
                        return PyMenu(self.service, "/setup/models/heat_exchanger/macro_model/heat_exchanger_report").execute(*args, **kwargs)
                    def heat_exchanger_macro_report(self, *args, **kwargs):
                        """
                        Report heat-exchanger information for all the macros.
                        """
                        return PyMenu(self.service, "/setup/models/heat_exchanger/macro_model/heat_exchanger_macro_report").execute(*args, **kwargs)
                    def plot_NTU(self, *args, **kwargs):
                        """
                        Plot NTU vs primary mass flow rate for each auxiliary mass flow rate.
                        """
                        return PyMenu(self.service, "/setup/models/heat_exchanger/macro_model/plot_NTU").execute(*args, **kwargs)
                    def write_NTU(self, *args, **kwargs):
                        """
                        Write NTU vs primary mass flow rate for each auxiliary mass flow rate.
                        """
                        return PyMenu(self.service, "/setup/models/heat_exchanger/macro_model/write_NTU").execute(*args, **kwargs)

                class dual_cell_model(metaclass=PyMenuMeta):
                    """
                    Enter the dual cell model menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def heat_exchanger(self, *args, **kwargs):
                        """
                        Enable/disable the dual cell heat-exchanger model.
                        """
                        return PyMenu(self.service, "/setup/models/heat_exchanger/dual_cell_model/heat_exchanger").execute(*args, **kwargs)
                    def add_heat_exchanger(self, *args, **kwargs):
                        """
                        Add heat-exchanger.
                        """
                        return PyMenu(self.service, "/setup/models/heat_exchanger/dual_cell_model/add_heat_exchanger").execute(*args, **kwargs)
                    def modify_heat_exchanger(self, *args, **kwargs):
                        """
                        Modify heat-exchanger.
                        """
                        return PyMenu(self.service, "/setup/models/heat_exchanger/dual_cell_model/modify_heat_exchanger").execute(*args, **kwargs)
                    def delete_heat_exchanger(self, *args, **kwargs):
                        """
                        Delete heat-exchanger.
                        """
                        return PyMenu(self.service, "/setup/models/heat_exchanger/dual_cell_model/delete_heat_exchanger").execute(*args, **kwargs)
                    def plot_NTU(self, *args, **kwargs):
                        """
                        Plot NTU vs primary mass flow rate for each auxiliary mass flow rate.
                        """
                        return PyMenu(self.service, "/setup/models/heat_exchanger/dual_cell_model/plot_NTU").execute(*args, **kwargs)
                    def write_NTU(self, *args, **kwargs):
                        """
                        Write NTU vs primary mass flow rate for each auxiliary mass flow rate.
                        """
                        return PyMenu(self.service, "/setup/models/heat_exchanger/dual_cell_model/write_NTU").execute(*args, **kwargs)
                    def alternative_formulation(self, *args, **kwargs):
                        """
                        Enable/disable alternative formulation for heat transfer calculations.
                        """
                        return PyMenu(self.service, "/setup/models/heat_exchanger/dual_cell_model/alternative_formulation").execute(*args, **kwargs)

            class electrolysis_setup(metaclass=PyMenuMeta):
                """
                Enter the electrolysis model setup menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.anode_setup = self.__class__.anode_setup(path + [("anode_setup", None)], service)
                    self.cathode_setup = self.__class__.cathode_setup(path + [("cathode_setup", None)], service)
                    self.membrane_setup = self.__class__.membrane_setup(path + [("membrane_setup", None)], service)
                def model_options(self, *args, **kwargs):
                    """
                    Model Options.
                    """
                    return PyMenu(self.service, "/setup/models/electrolysis_setup/model_options").execute(*args, **kwargs)
                def parameters(self, *args, **kwargs):
                    """
                    Model Parameters.
                    """
                    return PyMenu(self.service, "/setup/models/electrolysis_setup/parameters").execute(*args, **kwargs)
                def electrical_tabs_setup(self, *args, **kwargs):
                    """
                    Electrical Tabs Setup.
                    """
                    return PyMenu(self.service, "/setup/models/electrolysis_setup/electrical_tabs_setup").execute(*args, **kwargs)

                class anode_setup(metaclass=PyMenuMeta):
                    """
                    Anode Setup.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def current_collector(self, *args, **kwargs):
                        """
                        Set Current Collector.
                        """
                        return PyMenu(self.service, "/setup/models/electrolysis_setup/anode_setup/current_collector").execute(*args, **kwargs)
                    def flow_channel(self, *args, **kwargs):
                        """
                        Set Flow Channel.
                        """
                        return PyMenu(self.service, "/setup/models/electrolysis_setup/anode_setup/flow_channel").execute(*args, **kwargs)
                    def porous_layer(self, *args, **kwargs):
                        """
                        Set Porous Layer.
                        """
                        return PyMenu(self.service, "/setup/models/electrolysis_setup/anode_setup/porous_layer").execute(*args, **kwargs)
                    def catalyst_layer(self, *args, **kwargs):
                        """
                        Set Catalyst Layer.
                        """
                        return PyMenu(self.service, "/setup/models/electrolysis_setup/anode_setup/catalyst_layer").execute(*args, **kwargs)
                    def electrolyte(self, *args, **kwargs):
                        """
                        Set Electrolyte.
                        """
                        return PyMenu(self.service, "/setup/models/electrolysis_setup/anode_setup/electrolyte").execute(*args, **kwargs)

                class cathode_setup(metaclass=PyMenuMeta):
                    """
                    Cathode Setup.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def current_collector(self, *args, **kwargs):
                        """
                        Set Current Collector.
                        """
                        return PyMenu(self.service, "/setup/models/electrolysis_setup/cathode_setup/current_collector").execute(*args, **kwargs)
                    def flow_channel(self, *args, **kwargs):
                        """
                        Set Flow Channel.
                        """
                        return PyMenu(self.service, "/setup/models/electrolysis_setup/cathode_setup/flow_channel").execute(*args, **kwargs)
                    def porous_layer(self, *args, **kwargs):
                        """
                        Set Porous Layer.
                        """
                        return PyMenu(self.service, "/setup/models/electrolysis_setup/cathode_setup/porous_layer").execute(*args, **kwargs)
                    def catalyst_layer(self, *args, **kwargs):
                        """
                        Set Catalyst Layer.
                        """
                        return PyMenu(self.service, "/setup/models/electrolysis_setup/cathode_setup/catalyst_layer").execute(*args, **kwargs)
                    def electrolyte(self, *args, **kwargs):
                        """
                        Set Electrolyte.
                        """
                        return PyMenu(self.service, "/setup/models/electrolysis_setup/cathode_setup/electrolyte").execute(*args, **kwargs)

                class membrane_setup(metaclass=PyMenuMeta):
                    """
                    Membrane Setup.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def current_collector(self, *args, **kwargs):
                        """
                        Set Current Collector.
                        """
                        return PyMenu(self.service, "/setup/models/electrolysis_setup/membrane_setup/current_collector").execute(*args, **kwargs)
                    def flow_channel(self, *args, **kwargs):
                        """
                        Set Flow Channel.
                        """
                        return PyMenu(self.service, "/setup/models/electrolysis_setup/membrane_setup/flow_channel").execute(*args, **kwargs)
                    def porous_layer(self, *args, **kwargs):
                        """
                        Set Porous Layer.
                        """
                        return PyMenu(self.service, "/setup/models/electrolysis_setup/membrane_setup/porous_layer").execute(*args, **kwargs)
                    def catalyst_layer(self, *args, **kwargs):
                        """
                        Set Catalyst Layer.
                        """
                        return PyMenu(self.service, "/setup/models/electrolysis_setup/membrane_setup/catalyst_layer").execute(*args, **kwargs)
                    def electrolyte(self, *args, **kwargs):
                        """
                        Set Electrolyte.
                        """
                        return PyMenu(self.service, "/setup/models/electrolysis_setup/membrane_setup/electrolyte").execute(*args, **kwargs)

        class named_expressions(metaclass=PyMenuMeta):
            """
            Manage named expressions.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def add(self, *args, **kwargs):
                """
                Add a new object.
                """
                return PyMenu(self.service, "/setup/named_expressions/add").execute(*args, **kwargs)
            def compute(self, *args, **kwargs):
                """
                Compute expression.
                """
                return PyMenu(self.service, "/setup/named_expressions/compute").execute(*args, **kwargs)
            def copy(self, *args, **kwargs):
                """
                Copy expression.
                """
                return PyMenu(self.service, "/setup/named_expressions/copy").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an object.
                """
                return PyMenu(self.service, "/setup/named_expressions/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an object.
                """
                return PyMenu(self.service, "/setup/named_expressions/delete").execute(*args, **kwargs)
            def export_to_tsv(self, *args, **kwargs):
                """
                Export expressions.
                """
                return PyMenu(self.service, "/setup/named_expressions/export_to_tsv").execute(*args, **kwargs)
            def import_from_tsv(self, *args, **kwargs):
                """
                Export expressions.
                """
                return PyMenu(self.service, "/setup/named_expressions/import_from_tsv").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List objects.
                """
                return PyMenu(self.service, "/setup/named_expressions/list").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                List properties of an object.
                """
                return PyMenu(self.service, "/setup/named_expressions/list_properties").execute(*args, **kwargs)

        class operating_conditions(metaclass=PyMenuMeta):
            """
            Enter the define operating conditions menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def gravity(self, *args, **kwargs):
                """
                Set gravitational acceleration.
                """
                return PyMenu(self.service, "/setup/operating_conditions/gravity").execute(*args, **kwargs)
            def gravity_mrf_rotation(self, *args, **kwargs):
                """
                Enable/disable rotation of gravity vector in moving reference frame simulations.
                """
                return PyMenu(self.service, "/setup/operating_conditions/gravity_mrf_rotation").execute(*args, **kwargs)
            def set_state(self, *args, **kwargs):
                """
                Select state for real gas EOS subcritical condition.
                """
                return PyMenu(self.service, "/setup/operating_conditions/set_state").execute(*args, **kwargs)
            def operating_pressure(self, *args, **kwargs):
                """
                Set the operating pressure.
                """
                return PyMenu(self.service, "/setup/operating_conditions/operating_pressure").execute(*args, **kwargs)
            def reference_pressure_location(self, *args, **kwargs):
                """
                Set coordinates of reference pressure.
                """
                return PyMenu(self.service, "/setup/operating_conditions/reference_pressure_location").execute(*args, **kwargs)
            def reference_pressure_method(self, *args, **kwargs):
                """
                Choosing reference pressure type.
                """
                return PyMenu(self.service, "/setup/operating_conditions/reference_pressure_method").execute(*args, **kwargs)
            def used_ref_pressure_location(self, *args, **kwargs):
                """
                See the actual coordinates of reference pressure used.
                """
                return PyMenu(self.service, "/setup/operating_conditions/used_ref_pressure_location").execute(*args, **kwargs)
            def operating_density(self, *args, **kwargs):
                """
                Enable/disable use of a specified operating density.
                """
                return PyMenu(self.service, "/setup/operating_conditions/operating_density").execute(*args, **kwargs)
            def use_inlet_temperature_for_operating_density(self, *args, **kwargs):
                """
                Use Inlet Temperature to calculate Opearating Density.
                """
                return PyMenu(self.service, "/setup/operating_conditions/use_inlet_temperature_for_operating_density").execute(*args, **kwargs)
            def operating_temperature(self, *args, **kwargs):
                """
                Set the operating temperature for Boussinesq.
                """
                return PyMenu(self.service, "/setup/operating_conditions/operating_temperature").execute(*args, **kwargs)

        class overset_interfaces(metaclass=PyMenuMeta):
            """
            Enter the overset-interfaces menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.options = self.__class__.options(path + [("options", None)], service)
                self.cut_control = self.__class__.cut_control(path + [("cut_control", None)], service)
                self.adapt = self.__class__.adapt(path + [("adapt", None)], service)
            def create(self, *args, **kwargs):
                """
                Create an overset interface.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/create").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an overset interface.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/delete").execute(*args, **kwargs)
            def delete_all(self, *args, **kwargs):
                """
                Delete all overset interfaces.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/delete_all").execute(*args, **kwargs)
            def intersect(self, *args, **kwargs):
                """
                Intersect an overset interface.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/intersect").execute(*args, **kwargs)
            def intersect_all(self, *args, **kwargs):
                """
                Intersect all overset interfaces.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/intersect_all").execute(*args, **kwargs)
            def clear(self, *args, **kwargs):
                """
                Clear an overset interface.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/clear").execute(*args, **kwargs)
            def clear_all(self, *args, **kwargs):
                """
                Clear all overset interfaces.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/clear_all").execute(*args, **kwargs)
            def grid_priorities(self, *args, **kwargs):
                """
                Edit grid priorities for an overset interface.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/grid_priorities").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List all overset interfaces.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/list").execute(*args, **kwargs)
            def mark_cells(self, *args, **kwargs):
                """
                Mark overset interface related cell types.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/mark_cells").execute(*args, **kwargs)
            def display_cells(self, *args, **kwargs):
                """
                Display the marked overset cells.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/display_cells").execute(*args, **kwargs)
            def mark_cell_change(self, *args, **kwargs):
                """
                Mark overset interface related cell type change.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/mark_cell_change").execute(*args, **kwargs)
            def set_mark_bounds(self, *args, **kwargs):
                """
                Set bounds (center, radius) for overset cell marking.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/set_mark_bounds").execute(*args, **kwargs)
            def check(self, *args, **kwargs):
                """
                Check all overset interfaces.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/check").execute(*args, **kwargs)
            def debug_hole_cut(self, *args, **kwargs):
                """
                Debugging tool for overset hole cutting.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/debug_hole_cut").execute(*args, **kwargs)
            def fill_dci(self, *args, **kwargs):
                """
                Fill overset domain connectivity information (DCI).
                """
                return PyMenu(self.service, "/setup/overset_interfaces/fill_dci").execute(*args, **kwargs)
            def free_dci(self, *args, **kwargs):
                """
                Free overset domain connectivity information (DCI).
                """
                return PyMenu(self.service, "/setup/overset_interfaces/free_dci").execute(*args, **kwargs)
            def update_from_dci(self, *args, **kwargs):
                """
                Update all overset intrfaces from stored domain connectivity information (DCI).
                """
                return PyMenu(self.service, "/setup/overset_interfaces/update_from_dci").execute(*args, **kwargs)
            def write_dci_to_case(self, *args, **kwargs):
                """
                Save domain connectivity information (DCI) to case file.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/write_dci_to_case").execute(*args, **kwargs)
            def read_dci_from_case(self, *args, **kwargs):
                """
                Read domain connectivity information (DCI) from case file.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/read_dci_from_case").execute(*args, **kwargs)
            def write_dci(self, *args, **kwargs):
                """
                Save domain connectivity information (DCI) to a text file.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/write_dci").execute(*args, **kwargs)
            def write_cell_types(self, *args, **kwargs):
                """
                Write overset cell types into file.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/write_cell_types").execute(*args, **kwargs)
            def find_bounding_cell(self, *args, **kwargs):
                """
                Find bounding cell for given cell or search point.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/find_bounding_cell").execute(*args, **kwargs)
            def find_all_bounding_cells(self, *args, **kwargs):
                """
                Find bounding cells for all cell centroids.
                """
                return PyMenu(self.service, "/setup/overset_interfaces/find_all_bounding_cells").execute(*args, **kwargs)

            class options(metaclass=PyMenuMeta):
                """
                Enter the overset interface options menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def expert(self, *args, **kwargs):
                    """
                    Enable additional overset options and tools.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/options/expert").execute(*args, **kwargs)
                def render_receptor_cells(self, *args, **kwargs):
                    """
                    Set the option to include receptor cells in postprocessing.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/options/render_receptor_cells").execute(*args, **kwargs)
                def partial_cut_faces(self, *args, **kwargs):
                    """
                    Enable enhanced hole cutting where cut faces partially overlap.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/options/partial_cut_faces").execute(*args, **kwargs)
                def auto_create(self, *args, **kwargs):
                    """
                    Enable automatic creation of default overset interface.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/options/auto_create").execute(*args, **kwargs)
                def minimize_overlap(self, *args, **kwargs):
                    """
                    Enable overlap minimization for overset interfaces.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/options/minimize_overlap").execute(*args, **kwargs)
                def overlap_boundaries(self, *args, **kwargs):
                    """
                    Enable overset topologies with overlap boundaries.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/options/overlap_boundaries").execute(*args, **kwargs)
                def mesh_interfaces(self, *args, **kwargs):
                    """
                    Allow mesh interfaces inside overset cell zones.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/options/mesh_interfaces").execute(*args, **kwargs)
                def node_connected_donors(self, *args, **kwargs):
                    """
                    Enable node or face connected donor cells.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/options/node_connected_donors").execute(*args, **kwargs)
                def donor_priority_method(self, *args, **kwargs):
                    """
                    Set method used to evaludate the cell donor priority.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/options/donor_priority_method").execute(*args, **kwargs)
                def solve_island_removal(self, *args, **kwargs):
                    """
                    Set method used to control the removal of isolated patches of solve cells.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/options/solve_island_removal").execute(*args, **kwargs)
                def transient_caching(self, *args, **kwargs):
                    """
                    Set options to control caching of entities in transient overset simulations.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/options/transient_caching").execute(*args, **kwargs)
                def modified_donor_search(self, *args, **kwargs):
                    """
                    Enable modified and more extensive donor search.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/options/modified_donor_search").execute(*args, **kwargs)
                def modified_hole_cutting(self, *args, **kwargs):
                    """
                    Enable modified hole cutting parameters.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/options/modified_hole_cutting").execute(*args, **kwargs)
                def dead_cell_update(self, *args, **kwargs):
                    """
                    Enable dead cell update in moving or dynamic mesh simulations.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/options/dead_cell_update").execute(*args, **kwargs)
                def update_before_case_write(self, *args, **kwargs):
                    """
                    Enable update of overset interfaces before writing case file (CFF format only).
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/options/update_before_case_write").execute(*args, **kwargs)
                def parallel(self, *args, **kwargs):
                    """
                    Set options to control running overset in parallel.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/options/parallel").execute(*args, **kwargs)
                def verbosity(self, *args, **kwargs):
                    """
                    Set overset mesh reporting verbosity.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/options/verbosity").execute(*args, **kwargs)

            class cut_control(metaclass=PyMenuMeta):
                """
                Enter the overset hole cut control menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.cut_seeds = self.__class__.cut_seeds(path + [("cut_seeds", None)], service)
                def add(self, *args, **kwargs):
                    """
                    Add hole cut control for a boundary zone.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/cut_control/add").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete hole cut control for a boundary zone.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/cut_control/delete").execute(*args, **kwargs)
                def delete_all(self, *args, **kwargs):
                    """
                    Delete the hole cut controls for all boundary zones.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/cut_control/delete_all").execute(*args, **kwargs)
                def list(self, *args, **kwargs):
                    """
                    List the defined hole cut controls.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/cut_control/list").execute(*args, **kwargs)

                class cut_seeds(metaclass=PyMenuMeta):
                    """
                    Enter the overset hole cut seed menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def add(self, *args, **kwargs):
                        """
                        Add a hole cut seed.
                        """
                        return PyMenu(self.service, "/setup/overset_interfaces/cut_control/cut_seeds/add").execute(*args, **kwargs)
                    def delete(self, *args, **kwargs):
                        """
                        Delete a hole cut seed.
                        """
                        return PyMenu(self.service, "/setup/overset_interfaces/cut_control/cut_seeds/delete").execute(*args, **kwargs)
                    def delete_all(self, *args, **kwargs):
                        """
                        Delete all hole cut seeds.
                        """
                        return PyMenu(self.service, "/setup/overset_interfaces/cut_control/cut_seeds/delete_all").execute(*args, **kwargs)
                    def list(self, *args, **kwargs):
                        """
                        List the defined hole cut seeds.
                        """
                        return PyMenu(self.service, "/setup/overset_interfaces/cut_control/cut_seeds/list").execute(*args, **kwargs)
                    def cut_seeds_for_all_component_zones(self, *args, **kwargs):
                        """
                        Enable that all component zones get a cut seed.
                        """
                        return PyMenu(self.service, "/setup/overset_interfaces/cut_control/cut_seeds/cut_seeds_for_all_component_zones").execute(*args, **kwargs)

            class adapt(metaclass=PyMenuMeta):
                """
                Enter the overset adaption menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.set = self.__class__.set(path + [("set", None)], service)
                def mark_adaption(self, *args, **kwargs):
                    """
                    Mark cells for overset orphan adaption and donor-receptor size differences.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/adapt/mark_adaption").execute(*args, **kwargs)
                def adapt_mesh(self, *args, **kwargs):
                    """
                    Mark and adapt the mesh to remove orphan cells and large donor-receptor cell size differences.
                    """
                    return PyMenu(self.service, "/setup/overset_interfaces/adapt/adapt_mesh").execute(*args, **kwargs)

                class set(metaclass=PyMenuMeta):
                    """
                    Enter the overset adaption set menu.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def mark_orphans(self, *args, **kwargs):
                        """
                        Enable the option to adapt for orphan reduction.
                        """
                        return PyMenu(self.service, "/setup/overset_interfaces/adapt/set/mark_orphans").execute(*args, **kwargs)
                    def mark_fixed_orphans(self, *args, **kwargs):
                        """
                        Enable the option to adapt for orphans which were removed by accepting neighbor donors.
                        """
                        return PyMenu(self.service, "/setup/overset_interfaces/adapt/set/mark_fixed_orphans").execute(*args, **kwargs)
                    def mark_size(self, *args, **kwargs):
                        """
                        Enable the option to adapt for donor-receptor cell size differences.
                        """
                        return PyMenu(self.service, "/setup/overset_interfaces/adapt/set/mark_size").execute(*args, **kwargs)
                    def mark_gaps(self, *args, **kwargs):
                        """
                        Enable the option to adapt underresolved gaps.
                        """
                        return PyMenu(self.service, "/setup/overset_interfaces/adapt/set/mark_gaps").execute(*args, **kwargs)
                    def mark_coarsening(self, *args, **kwargs):
                        """
                        Enable the option to coarsen the mesh during overset adaption.
                        """
                        return PyMenu(self.service, "/setup/overset_interfaces/adapt/set/mark_coarsening").execute(*args, **kwargs)
                    def anisotropic(self, *args, **kwargs):
                        """
                        Enable the option to use anisotropic adaption in prismatic cells.
                        """
                        return PyMenu(self.service, "/setup/overset_interfaces/adapt/set/anisotropic").execute(*args, **kwargs)
                    def automatic(self, *args, **kwargs):
                        """
                        Enable the option to automatically adapt overset meshes during solution update.
                        """
                        return PyMenu(self.service, "/setup/overset_interfaces/adapt/set/automatic").execute(*args, **kwargs)
                    def length_ratio_max(self, *args, **kwargs):
                        """
                        Set the length scale ratio threshold used to determine which cells are marked for adaption based on donor-receptor cell size differences.
                        """
                        return PyMenu(self.service, "/setup/overset_interfaces/adapt/set/length_ratio_max").execute(*args, **kwargs)
                    def buffer_layers(self, *args, **kwargs):
                        """
                        Set the number of cell layers marked in addition to the cells marked for orphan adaption.
                        """
                        return PyMenu(self.service, "/setup/overset_interfaces/adapt/set/buffer_layers").execute(*args, **kwargs)
                    def adaption_sweeps(self, *args, **kwargs):
                        """
                        Set the number of adaption sweeps per overset adaption.
                        """
                        return PyMenu(self.service, "/setup/overset_interfaces/adapt/set/adaption_sweeps").execute(*args, **kwargs)
                    def maximum_refinement_level(self, *args, **kwargs):
                        """
                        Set the maximum level of refinement in overset adaption.
                        """
                        return PyMenu(self.service, "/setup/overset_interfaces/adapt/set/maximum_refinement_level").execute(*args, **kwargs)

        class reference_frames(metaclass=PyMenuMeta):
            """
            Manage reference frames.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def add(self, *args, **kwargs):
                """
                Add a new object.
                """
                return PyMenu(self.service, "/setup/reference_frames/add").execute(*args, **kwargs)
            def display(self, *args, **kwargs):
                """
                Display Reference Frame.
                """
                return PyMenu(self.service, "/setup/reference_frames/display").execute(*args, **kwargs)
            def display_edit(self, *args, **kwargs):
                """
                Display and edit reference frame from graphics.
                """
                return PyMenu(self.service, "/setup/reference_frames/display_edit").execute(*args, **kwargs)
            def edit(self, *args, **kwargs):
                """
                Edit an object.
                """
                return PyMenu(self.service, "/setup/reference_frames/edit").execute(*args, **kwargs)
            def delete(self, *args, **kwargs):
                """
                Delete an object.
                """
                return PyMenu(self.service, "/setup/reference_frames/delete").execute(*args, **kwargs)
            def hide(self, *args, **kwargs):
                """
                Hide Reference Frame.
                """
                return PyMenu(self.service, "/setup/reference_frames/hide").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List objects.
                """
                return PyMenu(self.service, "/setup/reference_frames/list").execute(*args, **kwargs)
            def list_properties(self, *args, **kwargs):
                """
                List properties of an object.
                """
                return PyMenu(self.service, "/setup/reference_frames/list_properties").execute(*args, **kwargs)

        class reference_values(metaclass=PyMenuMeta):
            """
            Reference value menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.compute = self.__class__.compute(path + [("compute", None)], service)
            def area(self, *args, **kwargs):
                """
                Set reference area for normalization.
                """
                return PyMenu(self.service, "/setup/reference_values/area").execute(*args, **kwargs)
            def depth(self, *args, **kwargs):
                """
                Set reference depth for volume calculation.
                """
                return PyMenu(self.service, "/setup/reference_values/depth").execute(*args, **kwargs)
            def density(self, *args, **kwargs):
                """
                Set reference density for normalization.
                """
                return PyMenu(self.service, "/setup/reference_values/density").execute(*args, **kwargs)
            def enthalpy(self, *args, **kwargs):
                """
                Set reference enthalpy for enthalpy damping and normalization.
                """
                return PyMenu(self.service, "/setup/reference_values/enthalpy").execute(*args, **kwargs)
            def length(self, *args, **kwargs):
                """
                Set reference length for normalization.
                """
                return PyMenu(self.service, "/setup/reference_values/length").execute(*args, **kwargs)
            def pressure(self, *args, **kwargs):
                """
                Set reference pressure for normalization.
                """
                return PyMenu(self.service, "/setup/reference_values/pressure").execute(*args, **kwargs)
            def temperature(self, *args, **kwargs):
                """
                Set reference temperature for normalization.
                """
                return PyMenu(self.service, "/setup/reference_values/temperature").execute(*args, **kwargs)
            def yplus(self, *args, **kwargs):
                """
                Set reference yplus for normalization.
                """
                return PyMenu(self.service, "/setup/reference_values/yplus").execute(*args, **kwargs)
            def velocity(self, *args, **kwargs):
                """
                Set reference velocity for normalization.
                """
                return PyMenu(self.service, "/setup/reference_values/velocity").execute(*args, **kwargs)
            def viscosity(self, *args, **kwargs):
                """
                Set reference viscosity for normalization.
                """
                return PyMenu(self.service, "/setup/reference_values/viscosity").execute(*args, **kwargs)
            def zone(self, *args, **kwargs):
                """
                Set reference zone.
                """
                return PyMenu(self.service, "/setup/reference_values/zone").execute(*args, **kwargs)
            def list(self, *args, **kwargs):
                """
                List current reference values.
                """
                return PyMenu(self.service, "/setup/reference_values/list").execute(*args, **kwargs)

            class compute(metaclass=PyMenuMeta):
                """
                Enter the compute menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def axis(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/axis").execute(*args, **kwargs)
                def degassing(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/degassing").execute(*args, **kwargs)
                def dummy_entry(self, *args, **kwargs):
                    """
                    .
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/dummy_entry").execute(*args, **kwargs)
                def exhaust_fan(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/exhaust_fan").execute(*args, **kwargs)
                def fan(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/fan").execute(*args, **kwargs)
                def fluid(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/fluid").execute(*args, **kwargs)
                def geometry(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/geometry").execute(*args, **kwargs)
                def inlet_vent(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/inlet_vent").execute(*args, **kwargs)
                def intake_fan(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/intake_fan").execute(*args, **kwargs)
                def interface(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/interface").execute(*args, **kwargs)
                def interior(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/interior").execute(*args, **kwargs)
                def mass_flow_inlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/mass_flow_inlet").execute(*args, **kwargs)
                def mass_flow_outlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/mass_flow_outlet").execute(*args, **kwargs)
                def network(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/network").execute(*args, **kwargs)
                def network_end(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/network_end").execute(*args, **kwargs)
                def outflow(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/outflow").execute(*args, **kwargs)
                def outlet_vent(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/outlet_vent").execute(*args, **kwargs)
                def overset(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/overset").execute(*args, **kwargs)
                def periodic(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/periodic").execute(*args, **kwargs)
                def porous_jump(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/porous_jump").execute(*args, **kwargs)
                def pressure_far_field(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/pressure_far_field").execute(*args, **kwargs)
                def pressure_inlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/pressure_inlet").execute(*args, **kwargs)
                def pressure_outlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/pressure_outlet").execute(*args, **kwargs)
                def radiator(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/radiator").execute(*args, **kwargs)
                def rans_les_interface(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/rans_les_interface").execute(*args, **kwargs)
                def recirculation_inlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/recirculation_inlet").execute(*args, **kwargs)
                def recirculation_outlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/recirculation_outlet").execute(*args, **kwargs)
                def shadow(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/shadow").execute(*args, **kwargs)
                def solid(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/solid").execute(*args, **kwargs)
                def symmetry(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/symmetry").execute(*args, **kwargs)
                def velocity_inlet(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/velocity_inlet").execute(*args, **kwargs)
                def wall(self, *args, **kwargs):
                    """
                    Compute reference values from a zone of this type.
                    """
                    return PyMenu(self.service, "/setup/reference_values/compute/wall").execute(*args, **kwargs)

        class turbo_model(metaclass=PyMenuMeta):
            """
            Turbo features menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.turbo_topology = self.__class__.turbo_topology(path + [("turbo_topology", None)], service)
                self.general_turbo_interface_settings = self.__class__.general_turbo_interface_settings(path + [("general_turbo_interface_settings", None)], service)
                self.blade_flutter_harmonics = self.__class__.blade_flutter_harmonics(path + [("blade_flutter_harmonics", None)], service)
            def enable_turbo_model(self, *args, **kwargs):
                """
                Enable/disable turbo model menu.
                """
                return PyMenu(self.service, "/setup/turbo_model/enable_turbo_model").execute(*args, **kwargs)
            def separate_nonoverlapping_interface_boundary(self, *args, **kwargs):
                """
                Split a general turbo interface non-overlapping zone.
                """
                return PyMenu(self.service, "/setup/turbo_model/separate_nonoverlapping_interface_boundary").execute(*args, **kwargs)
            def turbo_create(self, *args, **kwargs):
                """
                Create a general turbo interface.
                """
                return PyMenu(self.service, "/setup/turbo_model/turbo_create").execute(*args, **kwargs)
            def number_of_blades_in_row(self, *args, **kwargs):
                """
                Define the total number of blades in blade flutter row.
                """
                return PyMenu(self.service, "/setup/turbo_model/number_of_blades_in_row").execute(*args, **kwargs)
            def create_turbomachine_description(self, *args, **kwargs):
                """
                Define turbomachine description.
                """
                return PyMenu(self.service, "/setup/turbo_model/create_turbomachine_description").execute(*args, **kwargs)
            def create_phaselag_spectral_content(self, *args, **kwargs):
                """
                Define phaselag related spectral content.
                """
                return PyMenu(self.service, "/setup/turbo_model/create_phaselag_spectral_content").execute(*args, **kwargs)
            def phaselag_extra_settings(self, *args, **kwargs):
                """
                Define phaselag related extra settings.
                """
                return PyMenu(self.service, "/setup/turbo_model/phaselag_extra_settings").execute(*args, **kwargs)
            def create_graphics_spectral_content(self, *args, **kwargs):
                """
                Define post-processing related spectral content.
                """
                return PyMenu(self.service, "/setup/turbo_model/create_graphics_spectral_content").execute(*args, **kwargs)
            def graphics_extra_settings(self, *args, **kwargs):
                """
                Define phaselag related extra settings.
                """
                return PyMenu(self.service, "/setup/turbo_model/graphics_extra_settings").execute(*args, **kwargs)
            def delete_turbomachine_description(self, *args, **kwargs):
                """
                Delete turbomachine description.
                """
                return PyMenu(self.service, "/setup/turbo_model/delete_turbomachine_description").execute(*args, **kwargs)
            def delete_phaselag_spectral_content(self, *args, **kwargs):
                """
                Delete phaselag related spectral content.
                """
                return PyMenu(self.service, "/setup/turbo_model/delete_phaselag_spectral_content").execute(*args, **kwargs)
            def delete_graphics_spectral_content(self, *args, **kwargs):
                """
                Delete post-processing related spectral content.
                """
                return PyMenu(self.service, "/setup/turbo_model/delete_graphics_spectral_content").execute(*args, **kwargs)
            def list_turbomachine_description(self, *args, **kwargs):
                """
                List turbomachine description.
                """
                return PyMenu(self.service, "/setup/turbo_model/list_turbomachine_description").execute(*args, **kwargs)
            def list_graphics_spectral_content(self, *args, **kwargs):
                """
                List post-processing related spectral content.
                """
                return PyMenu(self.service, "/setup/turbo_model/list_graphics_spectral_content").execute(*args, **kwargs)
            def list_phaselag_state(self, *args, **kwargs):
                """
                List all phaselag related case settings.
                """
                return PyMenu(self.service, "/setup/turbo_model/list_phaselag_state").execute(*args, **kwargs)
            def make_phaselag_from_boundaries(self, *args, **kwargs):
                """
                Make interface zones phase lagged.
                """
                return PyMenu(self.service, "/setup/turbo_model/make_phaselag_from_boundaries").execute(*args, **kwargs)
            def make_phaselag_from_periodic(self, *args, **kwargs):
                """
                Convert periodic interface to phase lagged.
                """
                return PyMenu(self.service, "/setup/turbo_model/make_phaselag_from_periodic").execute(*args, **kwargs)

            class turbo_topology(metaclass=PyMenuMeta):
                """
                Define turbo topology.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def define_topology(self, *args, **kwargs):
                    """
                    Define a turbo topology.
                    """
                    return PyMenu(self.service, "/setup/turbo_model/turbo_topology/define_topology").execute(*args, **kwargs)
                def mesh_method(self, *args, **kwargs):
                    """
                    Set turbo structured mesh generation method.
                    """
                    return PyMenu(self.service, "/setup/turbo_model/turbo_topology/mesh_method").execute(*args, **kwargs)
                def search_method(self, *args, **kwargs):
                    """
                    Set search method for a topology.
                    """
                    return PyMenu(self.service, "/setup/turbo_model/turbo_topology/search_method").execute(*args, **kwargs)
                def projection_method(self, *args, **kwargs):
                    """
                    Set 2D projection method.
                    """
                    return PyMenu(self.service, "/setup/turbo_model/turbo_topology/projection_method").execute(*args, **kwargs)
                def delete(self, *args, **kwargs):
                    """
                    Delete a turbo topology.
                    """
                    return PyMenu(self.service, "/setup/turbo_model/turbo_topology/delete").execute(*args, **kwargs)

            class general_turbo_interface_settings(metaclass=PyMenuMeta):
                """
                Set General Turbo Interface options.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                    self.mixing_plane_model_settings = self.__class__.mixing_plane_model_settings(path + [("mixing_plane_model_settings", None)], service)
                    self.pitch_scale_model_settings = self.__class__.pitch_scale_model_settings(path + [("pitch_scale_model_settings", None)], service)
                    self.no_pitch_scale_model_settings = self.__class__.no_pitch_scale_model_settings(path + [("no_pitch_scale_model_settings", None)], service)
                    self.expert = self.__class__.expert(path + [("expert", None)], service)

                class mixing_plane_model_settings(metaclass=PyMenuMeta):
                    """
                    Set the mixing plane model settings.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                        self.number_of_bands = self.__class__.number_of_bands(path + [("number_of_bands", None)], service)
                    def averaging_method(self, *args, **kwargs):
                        """
                        Set the averaging method for the mixing.
                        """
                        return PyMenu(self.service, "/setup/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/averaging_method").execute(*args, **kwargs)
                    def mixing_set_constraint(self, *args, **kwargs):
                        """
                        To set the mixing of primitive or total variable approach.
                        """
                        return PyMenu(self.service, "/setup/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/mixing_set_constraint").execute(*args, **kwargs)
                    def bands_type(self, *args, **kwargs):
                        """
                        To set the mixing plane bands type.
                        """
                        return PyMenu(self.service, "/setup/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/bands_type").execute(*args, **kwargs)
                    def number_of_inner_iterations(self, *args, **kwargs):
                        """
                        To set the number of iteration used for the scaling.
                        """
                        return PyMenu(self.service, "/setup/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/number_of_inner_iterations").execute(*args, **kwargs)
                    def list_mixing_planes(self, *args, **kwargs):
                        """
                        List the settings of mixing planes in the case.
                        """
                        return PyMenu(self.service, "/setup/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/list_mixing_planes").execute(*args, **kwargs)

                    class number_of_bands(metaclass=PyMenuMeta):
                        """
                        Set the maximum number of bands to be used for mixing.
                        """
                        def __init__(self, path, service):
                            self.path = path
                            self.service = service
                        def set_specific_interface(self, *args, **kwargs):
                            """
                            Set number of band to be used for mixing.
                            """
                            return PyMenu(self.service, "/setup/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/number_of_bands/set_specific_interface").execute(*args, **kwargs)
                        def set_all_interfaces(self, *args, **kwargs):
                            """
                            Set number of band to be used for mixing.
                            """
                            return PyMenu(self.service, "/setup/turbo_model/general_turbo_interface_settings/mixing_plane_model_settings/number_of_bands/set_all_interfaces").execute(*args, **kwargs)

                class pitch_scale_model_settings(metaclass=PyMenuMeta):
                    """
                    Set the pitch scale model settings.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def scale_mflux(self, *args, **kwargs):
                        """
                        Scale mass flux to improve the conservation.
                        """
                        return PyMenu(self.service, "/setup/turbo_model/general_turbo_interface_settings/pitch_scale_model_settings/scale_mflux").execute(*args, **kwargs)

                class no_pitch_scale_model_settings(metaclass=PyMenuMeta):
                    """
                    Set the no pitch scale model settings.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def scale_mflux(self, *args, **kwargs):
                        """
                        Scale mass flux to improve the conservation.
                        """
                        return PyMenu(self.service, "/setup/turbo_model/general_turbo_interface_settings/no_pitch_scale_model_settings/scale_mflux").execute(*args, **kwargs)

                class expert(metaclass=PyMenuMeta):
                    """
                    Set the expert parameters for turbo interfaces.
                    """
                    def __init__(self, path, service):
                        self.path = path
                        self.service = service
                    def enforce_flux_scaling(self, *args, **kwargs):
                        """
                        Enforce flux scaling ON/OFF at the turbo interfaces.
                        """
                        return PyMenu(self.service, "/setup/turbo_model/general_turbo_interface_settings/expert/enforce_flux_scaling").execute(*args, **kwargs)
                    def list_settings(self, *args, **kwargs):
                        """
                        List the flux scale settings at the turbo interfaces.
                        """
                        return PyMenu(self.service, "/setup/turbo_model/general_turbo_interface_settings/expert/list_settings").execute(*args, **kwargs)

            class blade_flutter_harmonics(metaclass=PyMenuMeta):
                """
                Enter the blade flutter harmonics menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def enable_harmonic_postprocessing(self, *args, **kwargs):
                    """
                    Calculates/Deletes Postprocessing Fourier coefficients data.
                    """
                    return PyMenu(self.service, "/setup/turbo_model/blade_flutter_harmonics/enable_harmonic_postprocessing").execute(*args, **kwargs)
                def enable_harmonic_exports(self, *args, **kwargs):
                    """
                    Calculates/Deletes flutter harmonic export data.
                    """
                    return PyMenu(self.service, "/setup/turbo_model/blade_flutter_harmonics/enable_harmonic_exports").execute(*args, **kwargs)
                def write_harmonic_exports(self, *args, **kwargs):
                    """
                    Writes harmonic export data.
                    """
                    return PyMenu(self.service, "/setup/turbo_model/blade_flutter_harmonics/write_harmonic_exports").execute(*args, **kwargs)
                def write_aerodamping_vs_nodal_diameter(self, *args, **kwargs):
                    """
                    Reads report definition file and Writes influence coefficient aerodynamic damping values vs nodal diameter.
                    """
                    return PyMenu(self.service, "/setup/turbo_model/blade_flutter_harmonics/write_aerodamping_vs_nodal_diameter").execute(*args, **kwargs)

    class surface(metaclass=PyMenuMeta):
        """
        Enter the data surface manipulation menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
            self.post_processing_volume = self.__class__.post_processing_volume(path + [("post_processing_volume", None)], service)
            self.query = self.__class__.query(path + [("query", None)], service)
        def circle_slice(self, *args, **kwargs):
            """
            Extract a circular slice.
            """
            return PyMenu(self.service, "/surface/circle_slice").execute(*args, **kwargs)
        def delete_surface(self, *args, **kwargs):
            """
            Remove a defined data surface.
            """
            return PyMenu(self.service, "/surface/delete_surface").execute(*args, **kwargs)
        def group_surfaces(self, *args, **kwargs):
            """
            Group a set of surfaces.
            """
            return PyMenu(self.service, "/surface/group_surfaces").execute(*args, **kwargs)
        def ungroup_surface(self, *args, **kwargs):
            """
            Ungroup the surface(if grouped).
            """
            return PyMenu(self.service, "/surface/ungroup_surface").execute(*args, **kwargs)
        def iso_clip(self, *args, **kwargs):
            """
            Clip a data surface (surface, curve, or point) between two iso-values.
            """
            return PyMenu(self.service, "/surface/iso_clip").execute(*args, **kwargs)
        def iso_surface(self, *args, **kwargs):
            """
            Extract an iso-surface (surface, curve, or point) from the curent data field.
            """
            return PyMenu(self.service, "/surface/iso_surface").execute(*args, **kwargs)
        def expression_volume(self, *args, **kwargs):
            """
            Create volume with boolean expression.
            """
            return PyMenu(self.service, "/surface/expression_volume").execute(*args, **kwargs)
        def multiple_iso_surfaces(self, *args, **kwargs):
            """
            Create multiple iso-surfaces from the data field at specified spacing.
            """
            return PyMenu(self.service, "/surface/multiple_iso_surfaces").execute(*args, **kwargs)
        def line_slice(self, *args, **kwargs):
            """
            Extract a linear slice.
            """
            return PyMenu(self.service, "/surface/line_slice").execute(*args, **kwargs)
        def line_surface(self, *args, **kwargs):
            """
            Define a "line" surface by specifying the two endpoint coordinates.
            """
            return PyMenu(self.service, "/surface/line_surface").execute(*args, **kwargs)
        def list_surfaces(self, *args, **kwargs):
            """
            List the number of facets in the defined surfaces.
            """
            return PyMenu(self.service, "/surface/list_surfaces").execute(*args, **kwargs)
        def mouse_line(self, *args, **kwargs):
            """
            Define a line surface using the mouse to select two points.
            """
            return PyMenu(self.service, "/surface/mouse_line").execute(*args, **kwargs)
        def mouse_plane(self, *args, **kwargs):
            """
            Define a plane surface using the mouse to select three points.
            """
            return PyMenu(self.service, "/surface/mouse_plane").execute(*args, **kwargs)
        def mouse_rake(self, *args, **kwargs):
            """
            Define a "rake" surface using the mouse to select the end points.
            """
            return PyMenu(self.service, "/surface/mouse_rake").execute(*args, **kwargs)
        def partition_surface(self, *args, **kwargs):
            """
            Define a data surface on mesh faces on the partition boundary.
            """
            return PyMenu(self.service, "/surface/partition_surface").execute(*args, **kwargs)
        def plane(self, *args, **kwargs):
            """
            Create a plane given 3 points bounded by the domain.
            """
            return PyMenu(self.service, "/surface/plane").execute(*args, **kwargs)
        def plane_surface(self, *args, **kwargs):
            """
            Create a plane from a coordinate plane, point and normal, or three points.
            """
            return PyMenu(self.service, "/surface/plane_surface").execute(*args, **kwargs)
        def multiple_plane_surfaces(self, *args, **kwargs):
            """
            Create multiple plane surfaces at specified spacing.
            """
            return PyMenu(self.service, "/surface/multiple_plane_surfaces").execute(*args, **kwargs)
        def plane_slice(self, *args, **kwargs):
            """
            Extract a planar slice.
            """
            return PyMenu(self.service, "/surface/plane_slice").execute(*args, **kwargs)
        def point_array(self, *args, **kwargs):
            """
            Extract a rectangular array of data points.
            """
            return PyMenu(self.service, "/surface/point_array").execute(*args, **kwargs)
        def point_surface(self, *args, **kwargs):
            """
            Define a "point" surface by specifying the coordinates.
            """
            return PyMenu(self.service, "/surface/point_surface").execute(*args, **kwargs)
        def structural_point_surface(self, *args, **kwargs):
            """
            Define a "structural point" surface by specifying the coordinates.
            """
            return PyMenu(self.service, "/surface/structural_point_surface").execute(*args, **kwargs)
        def quadric_slice(self, *args, **kwargs):
            """
            Extract a quadric slice.
            """
            return PyMenu(self.service, "/surface/quadric_slice").execute(*args, **kwargs)
        def rake_surface(self, *args, **kwargs):
            """
            Define a "rake" surface by specifying the end points.
            """
            return PyMenu(self.service, "/surface/rake_surface").execute(*args, **kwargs)
        def rename_surface(self, *args, **kwargs):
            """
            Rename a defined data surface.
            """
            return PyMenu(self.service, "/surface/rename_surface").execute(*args, **kwargs)
        def sphere_slice(self, *args, **kwargs):
            """
            Extract a spherical slice.
            """
            return PyMenu(self.service, "/surface/sphere_slice").execute(*args, **kwargs)
        def ellipsoid_slice(self, *args, **kwargs):
            """
            Extract a ellipsoid slice.
            """
            return PyMenu(self.service, "/surface/ellipsoid_slice").execute(*args, **kwargs)
        def cone_slice(self, *args, **kwargs):
            """
            Extract a cone slice.
            """
            return PyMenu(self.service, "/surface/cone_slice").execute(*args, **kwargs)
        def surface_cells(self, *args, **kwargs):
            """
            Extract all cells intersected by a data surface.
            """
            return PyMenu(self.service, "/surface/surface_cells").execute(*args, **kwargs)
        def transform_surface(self, *args, **kwargs):
            """
            Transform surface.
            """
            return PyMenu(self.service, "/surface/transform_surface").execute(*args, **kwargs)
        def create_imprint_surface(self, *args, **kwargs):
            """
            Imprint surface.
            """
            return PyMenu(self.service, "/surface/create_imprint_surface").execute(*args, **kwargs)
        def zone_surface(self, *args, **kwargs):
            """
            Define a data surface on a mesh zone.
            """
            return PyMenu(self.service, "/surface/zone_surface").execute(*args, **kwargs)
        def reset_zone_surfaces(self, *args, **kwargs):
            """
            Reset case surface list.
            """
            return PyMenu(self.service, "/surface/reset_zone_surfaces").execute(*args, **kwargs)
        def multiple_zone_surfaces(self, *args, **kwargs):
            """
            Create multiple data surfaces at a time.
            """
            return PyMenu(self.service, "/surface/multiple_zone_surfaces").execute(*args, **kwargs)
        def edit_surface(self, *args, **kwargs):
            """
            Edit a defined data surface.
            """
            return PyMenu(self.service, "/surface/edit_surface").execute(*args, **kwargs)

        class post_processing_volume(metaclass=PyMenuMeta):
            """
            Enter post-processing volume menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def create_from_file(self, *args, **kwargs):
                """
                Read post-processing mesh from file.
                """
                return PyMenu(self.service, "/surface/post_processing_volume/create_from_file").execute(*args, **kwargs)
            def create_octree(self, *args, **kwargs):
                """
                Create post-processing octree mesh based on current case.
                """
                return PyMenu(self.service, "/surface/post_processing_volume/create_octree").execute(*args, **kwargs)

        class query(metaclass=PyMenuMeta):
            """
            Enter surface query menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def delete_query(self, *args, **kwargs):
                """
                Delete saved query.
                """
                return PyMenu(self.service, "/surface/query/delete_query").execute(*args, **kwargs)
            def list_surfaces(self, *args, **kwargs):
                """
                List surfaces.
                """
                return PyMenu(self.service, "/surface/query/list_surfaces").execute(*args, **kwargs)
            def named_surface_list(self, *args, **kwargs):
                """
                Create named list of surfaces.
                """
                return PyMenu(self.service, "/surface/query/named_surface_list").execute(*args, **kwargs)
            def list_named_selection(self, *args, **kwargs):
                """
                List named selection of surface type.
                """
                return PyMenu(self.service, "/surface/query/list_named_selection").execute(*args, **kwargs)
            def list_queries(self, *args, **kwargs):
                """
                List all saved queries.
                """
                return PyMenu(self.service, "/surface/query/list_queries").execute(*args, **kwargs)

    class simulation_reports(metaclass=PyMenuMeta):
        """
        Enter the simulation reports menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
        def list_simulation_reports(self, *args, **kwargs):
            """
            List all report names.
            """
            return PyMenu(self.service, "/simulation_reports/list_simulation_reports").execute(*args, **kwargs)
        def generate_simulation_report(self, *args, **kwargs):
            """
            Generate a new simulation report or regenerate an existing simulation report with the provided name.
            """
            return PyMenu(self.service, "/simulation_reports/generate_simulation_report").execute(*args, **kwargs)
        def view_simulation_report(self, *args, **kwargs):
            """
            View a simulation report that has already been generated. In batch mode this will print the report's URL.
            """
            return PyMenu(self.service, "/simulation_reports/view_simulation_report").execute(*args, **kwargs)
        def export_simulation_report_as_pdf(self, *args, **kwargs):
            """
            Export the provided simulation report as a PDF file.
            """
            return PyMenu(self.service, "/simulation_reports/export_simulation_report_as_pdf").execute(*args, **kwargs)
        def export_simulation_report_as_html(self, *args, **kwargs):
            """
            Export the provided simulation report as HTML.
            """
            return PyMenu(self.service, "/simulation_reports/export_simulation_report_as_html").execute(*args, **kwargs)
        def write_report_names_to_file(self, *args, **kwargs):
            """
            Write the list of currently generated report names to a txt file.
            """
            return PyMenu(self.service, "/simulation_reports/write_report_names_to_file").execute(*args, **kwargs)
        def rename_simulation_report(self, *args, **kwargs):
            """
            Rename a report which has already been generated.
            """
            return PyMenu(self.service, "/simulation_reports/rename_simulation_report").execute(*args, **kwargs)
        def duplicate_simulation_report(self, *args, **kwargs):
            """
            Duplicate a report and all of its settings to a new report.
            """
            return PyMenu(self.service, "/simulation_reports/duplicate_simulation_report").execute(*args, **kwargs)
        def reset_report_to_defaults(self, *args, **kwargs):
            """
            Reset all report settings to default for the provided simulation report.
            """
            return PyMenu(self.service, "/simulation_reports/reset_report_to_defaults").execute(*args, **kwargs)
        def delete_simulation_report(self, *args, **kwargs):
            """
            Delete the provided simulation report.
            """
            return PyMenu(self.service, "/simulation_reports/delete_simulation_report").execute(*args, **kwargs)
        def write_simulation_report_template_file(self, *args, **kwargs):
            """
            Write a JSON template file with this case's Simulation Report settings.
            """
            return PyMenu(self.service, "/simulation_reports/write_simulation_report_template_file").execute(*args, **kwargs)
        def read_simulation_report_template_file(self, *args, **kwargs):
            """
            Read a JSON template file with existing Simulation Report settings.
            """
            return PyMenu(self.service, "/simulation_reports/read_simulation_report_template_file").execute(*args, **kwargs)

    class server(metaclass=PyMenuMeta):
        """
        Enter the server menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
        def start_server(self, *args, **kwargs):
            """
            Start server.
            """
            return PyMenu(self.service, "/server/start_server").execute(*args, **kwargs)
        def start_client(self, *args, **kwargs):
            """
            Start client.
            """
            return PyMenu(self.service, "/server/start_client").execute(*args, **kwargs)
        def print_server_address(self, *args, **kwargs):
            """
            Print server address.
            """
            return PyMenu(self.service, "/server/print_server_address").execute(*args, **kwargs)
        def write_or_reset_server_info(self, *args, **kwargs):
            """
            Write/Reset server info.
            """
            return PyMenu(self.service, "/server/write_or_reset_server_info").execute(*args, **kwargs)
        def print_connected_clients(self, *args, **kwargs):
            """
            Print connected clients.
            """
            return PyMenu(self.service, "/server/print_connected_clients").execute(*args, **kwargs)
        def shutdown_server(self, *args, **kwargs):
            """
            Shutdown server.
            """
            return PyMenu(self.service, "/server/shutdown_server").execute(*args, **kwargs)

    class turbo_post(metaclass=PyMenuMeta):
        """
        Enter the turbo menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
        def compute_report(self, *args, **kwargs):
            """
            Compute the turbo report.
            """
            return PyMenu(self.service, "/turbo_post/compute_report").execute(*args, **kwargs)
        def write_report(self, *args, **kwargs):
            """
            Write the turbo report to file.
            """
            return PyMenu(self.service, "/turbo_post/write_report").execute(*args, **kwargs)
        def avg_contours(self, *args, **kwargs):
            """
            Display average contours.
            """
            return PyMenu(self.service, "/turbo_post/avg_contours").execute(*args, **kwargs)
        def two_d_contours(self, *args, **kwargs):
            """
            Display 2d contours.
            """
            return PyMenu(self.service, "/turbo_post/two_d_contours").execute(*args, **kwargs)
        def xy_plot_avg(self, *args, **kwargs):
            """
            Display average xy plot.
            """
            return PyMenu(self.service, "/turbo_post/xy_plot_avg").execute(*args, **kwargs)
        def current_topology(self, *args, **kwargs):
            """
            Set the current turbo topology for global use.
            """
            return PyMenu(self.service, "/turbo_post/current_topology").execute(*args, **kwargs)

    class views(metaclass=PyMenuMeta):
        """
        Enter the view manipulation menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
            self.camera = self.__class__.camera(path + [("camera", None)], service)
        def auto_scale(self, *args, **kwargs):
            """
            Scale and center the current scene.
            """
            return PyMenu(self.service, "/views/auto_scale").execute(*args, **kwargs)
        def default_view(self, *args, **kwargs):
            """
            Reset view to front and center.
            """
            return PyMenu(self.service, "/views/default_view").execute(*args, **kwargs)
        def delete_view(self, *args, **kwargs):
            """
            Remove a view from the list.
            """
            return PyMenu(self.service, "/views/delete_view").execute(*args, **kwargs)
        def last_view(self, *args, **kwargs):
            """
            Return to the camera position before the last manipulation.
            """
            return PyMenu(self.service, "/views/last_view").execute(*args, **kwargs)
        def next_view(self, *args, **kwargs):
            """
            Return to the camera position after the current position in the stack.
            """
            return PyMenu(self.service, "/views/next_view").execute(*args, **kwargs)
        def list_views(self, *args, **kwargs):
            """
            List predefined and saved views.
            """
            return PyMenu(self.service, "/views/list_views").execute(*args, **kwargs)
        def restore_view(self, *args, **kwargs):
            """
            Use a saved view.
            """
            return PyMenu(self.service, "/views/restore_view").execute(*args, **kwargs)
        def read_views(self, *args, **kwargs):
            """
            Read views from a view file.
            """
            return PyMenu(self.service, "/views/read_views").execute(*args, **kwargs)
        def save_view(self, *args, **kwargs):
            """
            Save the current view to the view list.
            """
            return PyMenu(self.service, "/views/save_view").execute(*args, **kwargs)
        def write_views(self, *args, **kwargs):
            """
            Write selected views to a view file.
            """
            return PyMenu(self.service, "/views/write_views").execute(*args, **kwargs)

        class camera(metaclass=PyMenuMeta):
            """
            Enter the camera menu to modify the current viewing parameters.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def dolly_camera(self, *args, **kwargs):
                """
                Adjust the camera position and target.
                """
                return PyMenu(self.service, "/views/camera/dolly_camera").execute(*args, **kwargs)
            def field(self, *args, **kwargs):
                """
                Set the field of view (width and height).
                """
                return PyMenu(self.service, "/views/camera/field").execute(*args, **kwargs)
            def orbit_camera(self, *args, **kwargs):
                """
                Adjust the camera position without modifying the target.
                """
                return PyMenu(self.service, "/views/camera/orbit_camera").execute(*args, **kwargs)
            def pan_camera(self, *args, **kwargs):
                """
                Adjust the camera target without modifying the position.
                """
                return PyMenu(self.service, "/views/camera/pan_camera").execute(*args, **kwargs)
            def position(self, *args, **kwargs):
                """
                Set the camera position.
                """
                return PyMenu(self.service, "/views/camera/position").execute(*args, **kwargs)
            def projection(self, *args, **kwargs):
                """
                Set the camera projection type.
                """
                return PyMenu(self.service, "/views/camera/projection").execute(*args, **kwargs)
            def roll_camera(self, *args, **kwargs):
                """
                Adjust the camera up-vector.
                """
                return PyMenu(self.service, "/views/camera/roll_camera").execute(*args, **kwargs)
            def target(self, *args, **kwargs):
                """
                Set the point to be the center of the camera view.
                """
                return PyMenu(self.service, "/views/camera/target").execute(*args, **kwargs)
            def up_vector(self, *args, **kwargs):
                """
                Set the camera up-vector.
                """
                return PyMenu(self.service, "/views/camera/up_vector").execute(*args, **kwargs)
            def zoom_camera(self, *args, **kwargs):
                """
                Adjust the camera field of view.
                """
                return PyMenu(self.service, "/views/camera/zoom_camera").execute(*args, **kwargs)

    class parametric_study(metaclass=PyMenuMeta):
        """
        Enter the parametric study menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
            self.design_points = self.__class__.design_points(path + [("design_points", None)], service)
            self.update = self.__class__.update(path + [("update", None)], service)
        def initialize(self, *args, **kwargs):
            """
            Start Parametric Study.
            """
            return PyMenu(self.service, "/parametric_study/initialize").execute(*args, **kwargs)
        def duplicate_study(self, *args, **kwargs):
            """
            Duplicate Parametric Study.
            """
            return PyMenu(self.service, "/parametric_study/duplicate_study").execute(*args, **kwargs)
        def set_as_current_study(self, *args, **kwargs):
            """
            Set As Current Study.
            """
            return PyMenu(self.service, "/parametric_study/set_as_current_study").execute(*args, **kwargs)
        def rename_study(self, *args, **kwargs):
            """
            Rename Study.
            """
            return PyMenu(self.service, "/parametric_study/rename_study").execute(*args, **kwargs)
        def delete_study(self, *args, **kwargs):
            """
            Delete Study.
            """
            return PyMenu(self.service, "/parametric_study/delete_study").execute(*args, **kwargs)
        def list_studies(self, *args, **kwargs):
            """
            List Studies.
            """
            return PyMenu(self.service, "/parametric_study/list_studies").execute(*args, **kwargs)
        def use_base_data(self, *args, **kwargs):
            """
            Use Base Data.
            """
            return PyMenu(self.service, "/parametric_study/use_base_data").execute(*args, **kwargs)
        def export_design_table(self, *args, **kwargs):
            """
            Export Design Point Table.
            """
            return PyMenu(self.service, "/parametric_study/export_design_table").execute(*args, **kwargs)
        def import_design_table(self, *args, **kwargs):
            """
            Import Design Point Table.
            """
            return PyMenu(self.service, "/parametric_study/import_design_table").execute(*args, **kwargs)

        class design_points(metaclass=PyMenuMeta):
            """
            Enter the design points menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def add_design_point(self, *args, **kwargs):
                """
                Add new design point.
                """
                return PyMenu(self.service, "/parametric_study/design_points/add_design_point").execute(*args, **kwargs)
            def get_current_design_point(self, *args, **kwargs):
                """
                Get Name of Current Design Point.
                """
                return PyMenu(self.service, "/parametric_study/design_points/get_current_design_point").execute(*args, **kwargs)
            def load_case_data_for_current_dp(self, *args, **kwargs):
                """
                Loads relevant case/data file for current design point.
                """
                return PyMenu(self.service, "/parametric_study/design_points/load_case_data_for_current_dp").execute(*args, **kwargs)
            def set_as_current(self, *args, **kwargs):
                """
                Set current design point.
                """
                return PyMenu(self.service, "/parametric_study/design_points/set_as_current").execute(*args, **kwargs)
            def get_input_parameters_of_dp(self, *args, **kwargs):
                """
                Get Input Parameter Values of Current Design Point.
                """
                return PyMenu(self.service, "/parametric_study/design_points/get_input_parameters_of_dp").execute(*args, **kwargs)
            def set_input_parameters_of_dp(self, *args, **kwargs):
                """
                Set Input Parameter Values of Design Point.
                """
                return PyMenu(self.service, "/parametric_study/design_points/set_input_parameters_of_dp").execute(*args, **kwargs)
            def get_output_parameters_of_dp(self, *args, **kwargs):
                """
                Get Output Parameter Values of Design Point.
                """
                return PyMenu(self.service, "/parametric_study/design_points/get_output_parameters_of_dp").execute(*args, **kwargs)
            def set_write_data(self, *args, **kwargs):
                """
                Set WriteData option for Design Point.
                """
                return PyMenu(self.service, "/parametric_study/design_points/set_write_data").execute(*args, **kwargs)
            def get_write_data(self, *args, **kwargs):
                """
                Get WriteData option for Design Point.
                """
                return PyMenu(self.service, "/parametric_study/design_points/get_write_data").execute(*args, **kwargs)
            def set_capture_simulation_report_data(self, *args, **kwargs):
                """
                Set Capture Simulation Report Data option for Design Point.
                """
                return PyMenu(self.service, "/parametric_study/design_points/set_capture_simulation_report_data").execute(*args, **kwargs)
            def get_capture_simulation_report_data(self, *args, **kwargs):
                """
                Get Capture Simulation Report Data option for Design Point.
                """
                return PyMenu(self.service, "/parametric_study/design_points/get_capture_simulation_report_data").execute(*args, **kwargs)
            def delete_design_point(self, *args, **kwargs):
                """
                Delete Design Point.
                """
                return PyMenu(self.service, "/parametric_study/design_points/delete_design_point").execute(*args, **kwargs)
            def duplicate_design_point(self, *args, **kwargs):
                """
                Duplicate Design Point.
                """
                return PyMenu(self.service, "/parametric_study/design_points/duplicate_design_point").execute(*args, **kwargs)
            def save_journals(self, *args, **kwargs):
                """
                Save Journals.
                """
                return PyMenu(self.service, "/parametric_study/design_points/save_journals").execute(*args, **kwargs)
            def clear_generated_data(self, *args, **kwargs):
                """
                Clear Generated Data.
                """
                return PyMenu(self.service, "/parametric_study/design_points/clear_generated_data").execute(*args, **kwargs)
            def refresh_status(self, *args, **kwargs):
                """
                Refresh Status.
                """
                return PyMenu(self.service, "/parametric_study/design_points/refresh_status").execute(*args, **kwargs)
            def interrupt_design_point_submitted_concurrently(self, *args, **kwargs):
                """
                Interrupt Design Point.
                """
                return PyMenu(self.service, "/parametric_study/design_points/interrupt_design_point_submitted_concurrently").execute(*args, **kwargs)
            def interrupt_all_design_points_submitted_concurrently(self, *args, **kwargs):
                """
                Interrupt Design Points.
                """
                return PyMenu(self.service, "/parametric_study/design_points/interrupt_all_design_points_submitted_concurrently").execute(*args, **kwargs)

        class update(metaclass=PyMenuMeta):
            """
            Enter the update menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
                self.concurrent_settings = self.__class__.concurrent_settings(path + [("concurrent_settings", None)], service)
            def set_update_method(self, *args, **kwargs):
                """
                Set update method.
                """
                return PyMenu(self.service, "/parametric_study/update/set_update_method").execute(*args, **kwargs)
            def get_update_method(self, *args, **kwargs):
                """
                Get update method.
                """
                return PyMenu(self.service, "/parametric_study/update/get_update_method").execute(*args, **kwargs)
            def update_current(self, *args, **kwargs):
                """
                Update Current Design Point.
                """
                return PyMenu(self.service, "/parametric_study/update/update_current").execute(*args, **kwargs)
            def update_all(self, *args, **kwargs):
                """
                Update All Design Points.
                """
                return PyMenu(self.service, "/parametric_study/update/update_all").execute(*args, **kwargs)
            def update_selected_design_points(self, *args, **kwargs):
                """
                Update Selected Design Points.
                """
                return PyMenu(self.service, "/parametric_study/update/update_selected_design_points").execute(*args, **kwargs)
            def get_number_of_concurrent_dps(self, *args, **kwargs):
                """
                Get Number of Concurrent Design Points.
                """
                return PyMenu(self.service, "/parametric_study/update/get_number_of_concurrent_dps").execute(*args, **kwargs)
            def set_number_of_concurrent_dps(self, *args, **kwargs):
                """
                Set Number of Concurrent Design Points.
                """
                return PyMenu(self.service, "/parametric_study/update/set_number_of_concurrent_dps").execute(*args, **kwargs)
            def get_number_of_cores_per_dp(self, *args, **kwargs):
                """
                Get Number of Cores per Design Point.
                """
                return PyMenu(self.service, "/parametric_study/update/get_number_of_cores_per_dp").execute(*args, **kwargs)
            def set_number_of_cores_per_dp(self, *args, **kwargs):
                """
                Set Number of Cores per Design Point.
                """
                return PyMenu(self.service, "/parametric_study/update/set_number_of_cores_per_dp").execute(*args, **kwargs)

            class concurrent_settings(metaclass=PyMenuMeta):
                """
                Enter the Concurrent Settings menu.
                """
                def __init__(self, path, service):
                    self.path = path
                    self.service = service
                def set_license_type(self, *args, **kwargs):
                    """
                    Set License Type.
                    """
                    return PyMenu(self.service, "/parametric_study/update/concurrent_settings/set_license_type").execute(*args, **kwargs)
                def get_license_type(self, *args, **kwargs):
                    """
                    Get License Type.
                    """
                    return PyMenu(self.service, "/parametric_study/update/concurrent_settings/get_license_type").execute(*args, **kwargs)
                def get_optislang_license_type(self, *args, **kwargs):
                    """
                    Get optiSLang License Type.
                    """
                    return PyMenu(self.service, "/parametric_study/update/concurrent_settings/get_optislang_license_type").execute(*args, **kwargs)
                def set_optislang_license_type(self, *args, **kwargs):
                    """
                    Set optiSLang License Type.
                    """
                    return PyMenu(self.service, "/parametric_study/update/concurrent_settings/set_optislang_license_type").execute(*args, **kwargs)
                def get_optislang_license_count(self, *args, **kwargs):
                    """
                    Get optiSLang License Count.
                    """
                    return PyMenu(self.service, "/parametric_study/update/concurrent_settings/get_optislang_license_count").execute(*args, **kwargs)
                def set_optislang_license_count(self, *args, **kwargs):
                    """
                    Set optiSLang License Count.
                    """
                    return PyMenu(self.service, "/parametric_study/update/concurrent_settings/set_optislang_license_count").execute(*args, **kwargs)

    class turbo_workflow(metaclass=PyMenuMeta):
        """
        Enter the turbo workflow menu.
        """
        def __init__(self, path, service):
            self.path = path
            self.service = service
            self.workflow = self.__class__.workflow(path + [("workflow", None)], service)

        class workflow(metaclass=PyMenuMeta):
            """
            Enter the workflow menu.
            """
            def __init__(self, path, service):
                self.path = path
                self.service = service
            def enable(self, *args, **kwargs):
                """
                Enable the workflow.
                """
                return PyMenu(self.service, "/turbo_workflow/workflow/enable").execute(*args, **kwargs)
            def reset(self, *args, **kwargs):
                """
                Reset the workflow.
                """
                return PyMenu(self.service, "/turbo_workflow/workflow/reset").execute(*args, **kwargs)
            def disable(self, *args, **kwargs):
                """
                Disable the workflow.
                """
                return PyMenu(self.service, "/turbo_workflow/workflow/disable").execute(*args, **kwargs)
